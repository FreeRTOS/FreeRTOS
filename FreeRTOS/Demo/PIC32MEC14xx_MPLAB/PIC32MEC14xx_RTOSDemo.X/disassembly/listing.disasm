Disassembly Listing for PIC32MEC14xx_RTOSDemo
Generated From:
C:/E/Dev/FreeRTOS/WorkingCopy/FreeRTOS/Demo/PIC32MEC14xx_MPLAB/PIC32MEC14xx_RTOSDemo.X/dist/default/debug/PIC32MEC14xx_RTOSDemo.X.debug.elf
15-Jul-2015 17:16:07

---  c:/e/dev/freertos/workingcopy/freertos/source/timers.c  --------------------------------------------
1:                   /*
2:                       FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /* Standard includes. */
71:                  #include <stdlib.h>
72:                  
73:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
74:                  all the API functions to use the MPU wrappers.  That should only be done when
75:                  task.h is included from an application file. */
76:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
77:                  
78:                  #include "FreeRTOS.h"
79:                  #include "task.h"
80:                  #include "queue.h"
81:                  #include "timers.h"
82:                  
83:                  #if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
84:                  	#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.
85:                  #endif
86:                  
87:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
88:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
89:                  header files above, but not in this file, in order to generate the correct
90:                  privileged Vs unprivileged linkage and placement. */
91:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
92:                  
93:                  
94:                  /* This entire source file will be skipped if the application is not configured
95:                  to include software timer functionality.  This #if is closed at the very bottom
96:                  of this file.  If you want to include software timer functionality then ensure
97:                  configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
98:                  #if ( configUSE_TIMERS == 1 )
99:                  
100:                 /* Misc definitions. */
101:                 #define tmrNO_DELAY		( TickType_t ) 0U
102:                 
103:                 /* The definition of the timers themselves. */
104:                 typedef struct tmrTimerControl
105:                 {
106:                 	const char				*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
107:                 	ListItem_t				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
108:                 	TickType_t				xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
109:                 	UBaseType_t				uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. */
110:                 	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
111:                 	TimerCallbackFunction_t	pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
112:                 	#if( configUSE_TRACE_FACILITY == 1 )
113:                 		UBaseType_t			uxTimerNumber;		/*<< An ID assigned by trace tools such as FreeRTOS+Trace */
114:                 	#endif
115:                 } xTIMER;
116:                 
117:                 /* The old xTIMER name is maintained above then typedefed to the new Timer_t
118:                 name below to enable the use of older kernel aware debuggers. */
119:                 typedef xTIMER Timer_t;
120:                 
121:                 /* The definition of messages that can be sent and received on the timer queue.
122:                 Two types of message can be queued - messages that manipulate a software timer,
123:                 and messages that request the execution of a non-timer related callback.  The
124:                 two message types are defined in two separate structures, xTimerParametersType
125:                 and xCallbackParametersType respectively. */
126:                 typedef struct tmrTimerParameters
127:                 {
128:                 	TickType_t			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
129:                 	Timer_t *			pxTimer;			/*<< The timer to which the command will be applied. */
130:                 } TimerParameter_t;
131:                 
132:                 
133:                 typedef struct tmrCallbackParameters
134:                 {
135:                 	PendedFunction_t	pxCallbackFunction;	/* << The callback function to execute. */
136:                 	void *pvParameter1;						/* << The value that will be used as the callback functions first parameter. */
137:                 	uint32_t ulParameter2;					/* << The value that will be used as the callback functions second parameter. */
138:                 } CallbackParameters_t;
139:                 
140:                 /* The structure that contains the two message types, along with an identifier
141:                 that is used to determine which message type is valid. */
142:                 typedef struct tmrTimerQueueMessage
143:                 {
144:                 	BaseType_t			xMessageID;			/*<< The command being sent to the timer service task. */
145:                 	union
146:                 	{
147:                 		TimerParameter_t xTimerParameters;
148:                 
149:                 		/* Don't include xCallbackParameters if it is not going to be used as
150:                 		it makes the structure (and therefore the timer queue) larger. */
151:                 		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
152:                 			CallbackParameters_t xCallbackParameters;
153:                 		#endif /* INCLUDE_xTimerPendFunctionCall */
154:                 	} u;
155:                 } DaemonTaskMessage_t;
156:                 
157:                 /*lint -e956 A manual analysis and inspection has been used to determine which
158:                 static variables must be declared volatile. */
159:                 
160:                 /* The list in which active timers are stored.  Timers are referenced in expire
161:                 time order, with the nearest expiry time at the front of the list.  Only the
162:                 timer service task is allowed to access these lists. */
163:                 PRIVILEGED_DATA static List_t xActiveTimerList1;
164:                 PRIVILEGED_DATA static List_t xActiveTimerList2;
165:                 PRIVILEGED_DATA static List_t *pxCurrentTimerList;
166:                 PRIVILEGED_DATA static List_t *pxOverflowTimerList;
167:                 
168:                 /* A queue that is used to send commands to the timer service task. */
169:                 PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
170:                 
171:                 #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
172:                 
173:                 	PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
174:                 
175:                 #endif
176:                 
177:                 /*lint +e956 */
178:                 
179:                 /*-----------------------------------------------------------*/
180:                 
181:                 /*
182:                  * Initialise the infrastructure used by the timer service task if it has not
183:                  * been initialised already.
184:                  */
185:                 static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
186:                 
187:                 /*
188:                  * The timer service task (daemon).  Timer functionality is controlled by this
189:                  * task.  Other tasks communicate with the timer service task using the
190:                  * xTimerQueue queue.
191:                  */
192:                 static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
193:                 
194:                 /*
195:                  * Called by the timer service task to interpret and process a command it
196:                  * received on the timer queue.
197:                  */
198:                 static void prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
199:                 
200:                 /*
201:                  * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
202:                  * depending on if the expire time causes a timer counter overflow.
203:                  */
204:                 static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
205:                 
206:                 /*
207:                  * An active timer has reached its expire time.  Reload the timer if it is an
208:                  * auto reload timer, then call its callback.
209:                  */
210:                 static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
211:                 
212:                 /*
213:                  * The tick count has overflowed.  Switch the timer lists after ensuring the
214:                  * current timer list does not still reference some timers.
215:                  */
216:                 static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
217:                 
218:                 /*
219:                  * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
220:                  * if a tick count overflow occurred since prvSampleTimeNow() was last called.
221:                  */
222:                 static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
223:                 
224:                 /*
225:                  * If the timer list contains any active timers then return the expire time of
226:                  * the timer that will expire first and set *pxListWasEmpty to false.  If the
227:                  * timer list does not contain any timers then return 0 and set *pxListWasEmpty
228:                  * to pdTRUE.
229:                  */
230:                 static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
231:                 
232:                 /*
233:                  * If a timer has expired, process it.  Otherwise, block the timer service task
234:                  * until either a timer does expire or a command is received.
235:                  */
236:                 static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
237:                 
238:                 /*-----------------------------------------------------------*/
239:                 
240:                 BaseType_t xTimerCreateTimerTask( void )
241:                 {
BFD07A6C      4FE9   ADDIU SP, SP, -48
BFD07A6E      CBEB   SW RA, 44(SP)
BFD07A70      CBCA   SW S8, 40(SP)
BFD07A72      0FDD   MOVE S8, SP
242:                 BaseType_t xReturn = pdFAIL;
BFD07A74  0020F81E   SW ZERO, 32(S8)
243:                 
244:                 	/* This function is called when the scheduler is started if
245:                 	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
246:                 	timer service task has been created/initialised.  If timers have already
247:                 	been created then the initialisation will already have been performed. */
248:                 	prvCheckForValidListAndQueue();
BFD07A78  35F477E8   JALS prvCheckForValidListAndQueue
BFD07A7A  0C0035F4   LHU T7, 3072(S4)
BFD07A7C      0C00   NOP
249:                 
250:                 	if( xTimerQueue != NULL )
BFD07A7E  8068FC5C   LW V0, -32664(GP)
BFD07A82  001540E2   BEQZC V0, 0xBFD07AB0
251:                 	{
252:                 		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
253:                 		{
254:                 			/* Create the timer task, storing its handle in xTimerTaskHandle so
255:                 			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
256:                 			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
257:                 		}
258:                 		#else
259:                 		{
260:                 			/* Create the timer task without storing its handle. */
261:                 			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
BFD07A86      ED02   LI V0, 2
BFD07A88      C844   SW V0, 16(SP)
BFD07A8A      C805   SW ZERO, 20(SP)
BFD07A8C      C806   SW ZERO, 24(SP)
BFD07A8E      C807   SW ZERO, 28(SP)
BFD07A90  BFD141A2   LUI V0, 0xBFD1
BFD07A92  3082BFD1   LDC1 F30, 12418(S1)
BFD07A94  97393082   ADDIU A0, V0, -26823
BFD07A96  41A29739   BEQ T9, T9, 0xBFD0FDDE
BFD07A98  BFD141A2   LUI V0, 0xBFD1
BFD07A9A  30A2BFD1   LDC1 F30, 12450(S1)
BFD07A9C  9AE030A2   ADDIU A1, V0, -25888
BFD07A9E  30C09AE0   SWC1 F23, 12480(ZERO)
BFD07AA0  017C30C0   ADDIU A2, ZERO, 380
BFD07AA4      0CE0   MOVE A3, ZERO
BFD07AA6  0A9A77E8   JALS xTaskGenericCreate
BFD07AA8      0A9A   LBU A1, 10(S1)
BFD07AAA      0C00   NOP
BFD07AAC  0020F85E   SW V0, 32(S8)
262:                 		}
263:                 		#endif
264:                 	}
265:                 	else
266:                 	{
267:                 		mtCOVERAGE_TEST_MARKER();
268:                 	}
269:                 
270:                 	configASSERT( xReturn );
BFD07AB0  0020FC5E   LW V0, 32(S8)
BFD07AB4  000940A2   BNEZC V0, 0xBFD07ACA
BFD07AB8  BFD141A2   LUI V0, 0xBFD1
BFD07ABA  3082BFD1   LDC1 F30, 12418(S1)
BFD07ABC  9AE83082   ADDIU A0, V0, -25880
BFD07ABE  30A09AE8   SWC1 F23, 12448(T0)
BFD07AC0  010E30A0   ADDIU A1, ZERO, 270
BFD07AC4  4B7E77E8   JALS vAssertCalled
BFD07AC6      4B7E   LW K1, 120(SP)
BFD07AC8      0C00   NOP
271:                 	return xReturn;
BFD07ACA  0020FC5E   LW V0, 32(S8)
272:                 }
BFD07ACE      0FBE   MOVE SP, S8
BFD07AD0      4BEB   LW RA, 44(SP)
BFD07AD2      4BCA   LW S8, 40(SP)
BFD07AD4      4C19   ADDIU SP, SP, 48
BFD07AD6      459F   JR16 RA
BFD07AD8      0C00   NOP
273:                 /*-----------------------------------------------------------*/
274:                 
275:                 TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
276:                 {
BFD061D8      4FF1   ADDIU SP, SP, -32
BFD061DA      CBE7   SW RA, 28(SP)
BFD061DC      CBC6   SW S8, 24(SP)
BFD061DE      0FDD   MOVE S8, SP
BFD061E0  0020F89E   SW A0, 32(S8)
BFD061E4  0024F8BE   SW A1, 36(S8)
BFD061E8  0028F8DE   SW A2, 40(S8)
BFD061EC  002CF8FE   SW A3, 44(S8)
277:                 Timer_t *pxNewTimer;
278:                 
279:                 	/* Allocate the timer structure. */
280:                 	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
BFD061F0  0024FC5E   LW V0, 36(S8)
BFD061F4  000440A2   BNEZC V0, 0xBFD06200
281:                 	{
282:                 		pxNewTimer = NULL;
BFD061F8  0010F81E   SW ZERO, 16(S8)
BFD061FC      CC2E   B 0xBFD0625A
BFD061FE      0C00   NOP
283:                 	}
284:                 	else
285:                 	{
286:                 		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
BFD06200      EE28   LI A0, 40
BFD06202  111677E8   JALS pvPortMalloc
BFD06204  0C001116   ADDI T0, S6, 3072
BFD06206      0C00   NOP
BFD06208  0010F85E   SW V0, 16(S8)
287:                 		if( pxNewTimer != NULL )
BFD0620C  0010FC5E   LW V0, 16(S8)
BFD06210  002340E2   BEQZC V0, 0xBFD0625A
288:                 		{
289:                 			/* Ensure the infrastructure used by the timer service task has been
290:                 			created/initialised. */
291:                 			prvCheckForValidListAndQueue();
BFD06214  35F477E8   JALS prvCheckForValidListAndQueue
BFD06216  0C0035F4   LHU T7, 3072(S4)
BFD06218      0C00   NOP
292:                 
293:                 			/* Initialise the timer structure members using the function parameters. */
294:                 			pxNewTimer->pcTimerName = pcTimerName;
BFD0621A  0010FC5E   LW V0, 16(S8)
BFD0621E  0020FC7E   LW V1, 32(S8)
BFD06222      E9A0   SW V1, 0(V0)
295:                 			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
BFD06224  0010FC5E   LW V0, 16(S8)
BFD06228  0024FC7E   LW V1, 36(S8)
BFD0622C      E9A6   SW V1, 24(V0)
296:                 			pxNewTimer->uxAutoReload = uxAutoReload;
BFD0622E  0010FC5E   LW V0, 16(S8)
BFD06232  0028FC7E   LW V1, 40(S8)
BFD06236      E9A7   SW V1, 28(V0)
297:                 			pxNewTimer->pvTimerID = pvTimerID;
BFD06238  0010FC5E   LW V0, 16(S8)
BFD0623C  002CFC7E   LW V1, 44(S8)
BFD06240      E9A8   SW V1, 32(V0)
298:                 			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
BFD06242  0010FC5E   LW V0, 16(S8)
BFD06246  0030FC7E   LW V1, 48(S8)
BFD0624A      E9A9   SW V1, 36(V0)
299:                 			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
BFD0624C  0010FC5E   LW V0, 16(S8)
BFD06250      6D22   ADDIU V0, V0, 4
BFD06252      0C82   MOVE A0, V0
BFD06254  4EE677E8   JALS vListInitialiseItem
BFD06256      4EE6   ADDIU S7, S7, 3
BFD06258      0C00   NOP
300:                 
301:                 			traceTIMER_CREATE( pxNewTimer );
302:                 		}
303:                 		else
304:                 		{
305:                 			traceTIMER_CREATE_FAILED();
306:                 		}
307:                 	}
308:                 
309:                 	/* 0 is not a valid value for xTimerPeriodInTicks. */
310:                 	configASSERT( ( xTimerPeriodInTicks > 0 ) );
BFD0625A  0024FC5E   LW V0, 36(S8)
BFD0625E  000940A2   BNEZC V0, 0xBFD06274
BFD06262  BFD141A2   LUI V0, 0xBFD1
BFD06264  3082BFD1   LDC1 F30, 12418(S1)
BFD06266  9AE83082   ADDIU A0, V0, -25880
BFD06268  30A09AE8   SWC1 F23, 12448(T0)
BFD0626A  013630A0   ADDIU A1, ZERO, 310
BFD0626E  4B7E77E8   JALS vAssertCalled
BFD06270      4B7E   LW K1, 120(SP)
BFD06272      0C00   NOP
311:                 
312:                 	return ( TimerHandle_t ) pxNewTimer;
BFD06274  0010FC5E   LW V0, 16(S8)
313:                 }
BFD06278      0FBE   MOVE SP, S8
BFD0627A      4BE7   LW RA, 28(SP)
BFD0627C      4BC6   LW S8, 24(SP)
BFD0627E      4C11   ADDIU SP, SP, 32
BFD06280      459F   JR16 RA
BFD06282      0C00   NOP
314:                 /*-----------------------------------------------------------*/
315:                 
316:                 BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
317:                 {
BFD05A1C      4FE9   ADDIU SP, SP, -48
BFD05A1E      CBEB   SW RA, 44(SP)
BFD05A20      CBCA   SW S8, 40(SP)
BFD05A22      0FDD   MOVE S8, SP
BFD05A24  0030F89E   SW A0, 48(S8)
BFD05A28  0034F8BE   SW A1, 52(S8)
BFD05A2C  0038F8DE   SW A2, 56(S8)
BFD05A30  003CF8FE   SW A3, 60(S8)
318:                 BaseType_t xReturn = pdFAIL;
BFD05A34  0010F81E   SW ZERO, 16(S8)
319:                 DaemonTaskMessage_t xMessage;
320:                 
321:                 	/* Send a message to the timer service task to perform a particular action
322:                 	on a particular timer definition. */
323:                 	if( xTimerQueue != NULL )
BFD05A38  8068FC5C   LW V0, -32664(GP)
BFD05A3C  004740E2   BEQZC V0, 0xBFD05ACE
324:                 	{
325:                 		/* Send a command to the timer service task to start the xTimer timer. */
326:                 		xMessage.xMessageID = xCommandID;
BFD05A40  0034FC5E   LW V0, 52(S8)
BFD05A44  0014F85E   SW V0, 20(S8)
327:                 		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
BFD05A48  0038FC5E   LW V0, 56(S8)
BFD05A4C  0018F85E   SW V0, 24(S8)
328:                 		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
BFD05A50  0030FC5E   LW V0, 48(S8)
BFD05A54  001CF85E   SW V0, 28(S8)
329:                 
330:                 		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
BFD05A58  0034FC5E   LW V0, 52(S8)
BFD05A5C  00069042   SLTI V0, V0, 6
BFD05A60  002740E2   BEQZC V0, 0xBFD05AB2
331:                 		{
332:                 			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
BFD05A64  4A8E77E8   JALS xTaskGetSchedulerState
BFD05A66      4A8E   LW S4, 56(SP)
BFD05A68      0C00   NOP
BFD05A6A      0C62   MOVE V1, V0
BFD05A6C      ED02   LI V0, 2
BFD05A6E  0011B443   BNE V1, V0, 0xBFD05A94
BFD05A70  0C000011   SLL ZERO, S1, 1
BFD05A72      0C00   NOP
333:                 			{
334:                 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
BFD05A74  8068FC7C   LW V1, -32664(GP)
BFD05A78  0014305E   ADDIU V0, S8, 20
BFD05A7C      0C83   MOVE A0, V1
BFD05A7E      0CA2   MOVE A1, V0
BFD05A80  0040FCDE   LW A2, 64(S8)
BFD05A84      0CE0   MOVE A3, ZERO
BFD05A86  06A277E8   JALS xQueueGenericSend
BFD05A88      06A2   ADDU A1, S1, V0
BFD05A8A      0C00   NOP
BFD05A8C  0010F85E   SW V0, 16(S8)
BFD05A90      CC1E   B 0xBFD05ACE
BFD05A92      0C00   NOP
335:                 			}
336:                 			else
337:                 			{
338:                 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
BFD05A94  8068FC7C   LW V1, -32664(GP)
BFD05A98  0014305E   ADDIU V0, S8, 20
BFD05A9C      0C83   MOVE A0, V1
BFD05A9E      0CA2   MOVE A1, V0
BFD05AA0      0CC0   MOVE A2, ZERO
BFD05AA2      0CE0   MOVE A3, ZERO
BFD05AA4  06A277E8   JALS xQueueGenericSend
BFD05AA6      06A2   ADDU A1, S1, V0
BFD05AA8      0C00   NOP
BFD05AAA  0010F85E   SW V0, 16(S8)
BFD05AAE      CC0F   B 0xBFD05ACE
BFD05AB0      0C00   NOP
339:                 			}
340:                 		}
341:                 		else
342:                 		{
343:                 			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
BFD05AB2  8068FC7C   LW V1, -32664(GP)
BFD05AB6  0014305E   ADDIU V0, S8, 20
BFD05ABA      0C83   MOVE A0, V1
BFD05ABC      0CA2   MOVE A1, V0
BFD05ABE  003CFCDE   LW A2, 60(S8)
BFD05AC2      0CE0   MOVE A3, ZERO
BFD05AC4  11EA77E8   JALS xQueueGenericSendFromISR
BFD05AC6  0C0011EA   ADDI T7, T2, 3072
BFD05AC8      0C00   NOP
BFD05ACA  0010F85E   SW V0, 16(S8)
344:                 		}
345:                 
346:                 		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
347:                 	}
348:                 	else
349:                 	{
350:                 		mtCOVERAGE_TEST_MARKER();
351:                 	}
352:                 
353:                 	return xReturn;
BFD05ACE  0010FC5E   LW V0, 16(S8)
354:                 }
BFD05AD2      0FBE   MOVE SP, S8
BFD05AD4      4BEB   LW RA, 44(SP)
BFD05AD6      4BCA   LW S8, 40(SP)
BFD05AD8      4C19   ADDIU SP, SP, 48
BFD05ADA      459F   JR16 RA
BFD05ADC      0C00   NOP
355:                 /*-----------------------------------------------------------*/
356:                 
357:                 #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
358:                 
359:                 	TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
360:                 	{
361:                 		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
362:                 		started, then xTimerTaskHandle will be NULL. */
363:                 		configASSERT( ( xTimerTaskHandle != NULL ) );
364:                 		return xTimerTaskHandle;
365:                 	}
366:                 
367:                 #endif
368:                 /*-----------------------------------------------------------*/
369:                 
370:                 const char * pcTimerGetTimerName( TimerHandle_t xTimer )
371:                 {
BFD09B04      4FF9   ADDIU SP, SP, -16
BFD09B06      CBC3   SW S8, 12(SP)
BFD09B08      0FDD   MOVE S8, SP
BFD09B0A  0010F89E   SW A0, 16(S8)
372:                 Timer_t *pxTimer = ( Timer_t * ) xTimer;
BFD09B0E  0010FC5E   LW V0, 16(S8)
BFD09B12  0000F85E   SW V0, 0(S8)
373:                 
374:                 	return pxTimer->pcTimerName;
BFD09B16  0000FC5E   LW V0, 0(S8)
BFD09B1A      6920   LW V0, 0(V0)
375:                 }
BFD09B1C      0FBE   MOVE SP, S8
BFD09B1E      4BC3   LW S8, 12(SP)
BFD09B20      4C09   ADDIU SP, SP, 16
BFD09B22      459F   JR16 RA
BFD09B24      0C00   NOP
376:                 /*-----------------------------------------------------------*/
377:                 
378:                 static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
379:                 {
BFD05F24      4FED   ADDIU SP, SP, -40
BFD05F26      CBE9   SW RA, 36(SP)
BFD05F28      CBC8   SW S8, 32(SP)
BFD05F2A      0FDD   MOVE S8, SP
BFD05F2C  0028F89E   SW A0, 40(S8)
BFD05F30  002CF8BE   SW A1, 44(S8)
380:                 BaseType_t xResult;
381:                 Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
BFD05F34  8060FC5C   LW V0, -32672(GP)
BFD05F38      6923   LW V0, 12(V0)
BFD05F3A      6923   LW V0, 12(V0)
BFD05F3C  0018F85E   SW V0, 24(S8)
382:                 
383:                 	/* Remove the timer from the list of active timers.  A check has already
384:                 	been performed to ensure the list is not empty. */
385:                 	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
BFD05F40  0018FC5E   LW V0, 24(S8)
BFD05F44      6D22   ADDIU V0, V0, 4
BFD05F46      0C82   MOVE A0, V0
BFD05F48  00C877E8   JALS uxListRemove
BFD05F4A  0C0000C8   SLL A2, T0, 1
BFD05F4C      0C00   NOP
386:                 	traceTIMER_EXPIRED( pxTimer );
387:                 
388:                 	/* If the timer is an auto reload timer then calculate the next
389:                 	expiry time and re-insert the timer in the list of active timers. */
390:                 	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
BFD05F4E  0018FC5E   LW V0, 24(S8)
BFD05F52      69A7   LW V1, 28(V0)
BFD05F54      ED01   LI V0, 1
BFD05F56  002FB443   BNE V1, V0, 0xBFD05FB8
BFD05F58  0C00002F   SLL AT, T7, 1
BFD05F5A      0C00   NOP
391:                 	{
392:                 		/* The timer is inserted into a list using a time relative to anything
393:                 		other than the current time.  It will therefore be inserted into the
394:                 		correct list relative to the time this task thinks it is now. */
395:                 		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
BFD05F5C  0018FC5E   LW V0, 24(S8)
BFD05F60      69A6   LW V1, 24(V0)
BFD05F62  0028FC5E   LW V0, 40(S8)
BFD05F66      0526   ADDU V0, V1, V0
BFD05F68  0018FC9E   LW A0, 24(S8)
BFD05F6C      0CA2   MOVE A1, V0
BFD05F6E  002CFCDE   LW A2, 44(S8)
BFD05F72  0028FCFE   LW A3, 40(S8)
BFD05F76  2BE477E8   JALS prvInsertTimerInActiveList
BFD05F78      2BE4   LHU A3, 8(A2)
BFD05F7A      0C00   NOP
BFD05F7C      0C62   MOVE V1, V0
BFD05F7E      ED01   LI V0, 1
BFD05F80  001AB443   BNE V1, V0, 0xBFD05FB8
BFD05F82  0C00001A   SLL ZERO, K0, 1
BFD05F84      0C00   NOP
396:                 		{
397:                 			/* The timer expired before it was added to the active timer
398:                 			list.  Reload it now.  */
399:                 			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
BFD05F86      C804   SW ZERO, 16(SP)
BFD05F88  0018FC9E   LW A0, 24(S8)
BFD05F8C      0CA0   MOVE A1, ZERO
BFD05F8E  0028FCDE   LW A2, 40(S8)
BFD05F92      0CE0   MOVE A3, ZERO
BFD05F94  2D0E77E8   JALS xTimerGenericCommand
BFD05F96      2D0E   ANDI V0, S0, 0x8000
BFD05F98      0C00   NOP
BFD05F9A  001CF85E   SW V0, 28(S8)
400:                 			configASSERT( xResult );
BFD05F9E  001CFC5E   LW V0, 28(S8)
BFD05FA2  000940A2   BNEZC V0, 0xBFD05FB8
BFD05FA6  BFD141A2   LUI V0, 0xBFD1
BFD05FA8  3082BFD1   LDC1 F30, 12418(S1)
BFD05FAA  9AE83082   ADDIU A0, V0, -25880
BFD05FAC  30A09AE8   SWC1 F23, 12448(T0)
BFD05FAE  019030A0   ADDIU A1, ZERO, 400
BFD05FB2  4B7E77E8   JALS vAssertCalled
BFD05FB4      4B7E   LW K1, 120(SP)
BFD05FB6      0C00   NOP
401:                 			( void ) xResult;
402:                 		}
403:                 		else
404:                 		{
405:                 			mtCOVERAGE_TEST_MARKER();
406:                 		}
407:                 	}
408:                 	else
409:                 	{
410:                 		mtCOVERAGE_TEST_MARKER();
411:                 	}
412:                 
413:                 	/* Call the timer callback. */
414:                 	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
BFD05FB8  0018FC5E   LW V0, 24(S8)
BFD05FBC      6929   LW V0, 36(V0)
BFD05FBE  0018FC9E   LW A0, 24(S8)
BFD05FC2      45E2   JALRS16 V0
BFD05FC4      0C00   NOP
415:                 }
BFD05FC6      0FBE   MOVE SP, S8
BFD05FC8      4BE9   LW RA, 36(SP)
BFD05FCA      4BC8   LW S8, 32(SP)
BFD05FCC      4C15   ADDIU SP, SP, 40
BFD05FCE      459F   JR16 RA
BFD05FD0      0C00   NOP
416:                 /*-----------------------------------------------------------*/
417:                 
418:                 static void prvTimerTask( void *pvParameters )
419:                 {
BFD09738      4FF1   ADDIU SP, SP, -32
BFD0973A      CBE7   SW RA, 28(SP)
BFD0973C      CBC6   SW S8, 24(SP)
BFD0973E      0FDD   MOVE S8, SP
BFD09740  0020F89E   SW A0, 32(S8)
420:                 TickType_t xNextExpireTime;
421:                 BaseType_t xListWasEmpty;
422:                 
423:                 	/* Just to avoid compiler warnings. */
424:                 	( void ) pvParameters;
425:                 
426:                 	for( ;; )
427:                 	{
428:                 		/* Query the timers list to see if it contains any timers, and if so,
429:                 		obtain the time at which the next timer will expire. */
430:                 		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
BFD09744  0014305E   ADDIU V0, S8, 20
BFD09748      0C82   MOVE A0, V0
BFD0974A  47EE77E8   JALS prvGetNextExpireTime
BFD0974E      0C00   NOP
BFD09750  0010F85E   SW V0, 16(S8)
431:                 
432:                 		/* If a timer has expired, process it.  Otherwise, block this task
433:                 		until either a timer does expire, or a command is received. */
434:                 		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
BFD09754  0014FC5E   LW V0, 20(S8)
BFD09758  0010FC9E   LW A0, 16(S8)
BFD0975C      0CA2   MOVE A1, V0
BFD0975E  2D7077E8   JALS prvProcessTimerOrBlockTask
BFD09760      2D70   ANDI V0, A3, 0x80
BFD09762      0C00   NOP
435:                 
436:                 		/* Empty the command queue. */
437:                 		prvProcessReceivedCommands();
BFD09764  0B9A77E8   JALS prvProcessReceivedCommands
BFD09766      0B9A   LBU A3, 10(S1)
BFD09768      0C00   NOP
438:                 	}
BFD0976A      CFEC   B 0xBFD09744
BFD0976C      0C00   NOP
439:                 }
440:                 /*-----------------------------------------------------------*/
441:                 
442:                 static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
443:                 {
BFD05AE0      4FED   ADDIU SP, SP, -40
BFD05AE2      CBE9   SW RA, 36(SP)
BFD05AE4      CBC8   SW S8, 32(SP)
BFD05AE6      0FDD   MOVE S8, SP
BFD05AE8  0028F89E   SW A0, 40(S8)
BFD05AEC  002CF8BE   SW A1, 44(S8)
444:                 TickType_t xTimeNow;
445:                 BaseType_t xTimerListsWereSwitched;
446:                 
447:                 	vTaskSuspendAll();
BFD05AF0  4EF477E8   JALS vTaskSuspendAll
BFD05AF2      4EF4   ADDIU S7, S7, -6
BFD05AF4      0C00   NOP
448:                 	{
449:                 		/* Obtain the time now to make an assessment as to whether the timer
450:                 		has expired or not.  If obtaining the time causes the lists to switch
451:                 		then don't process this timer as any timers that remained in the list
452:                 		when the lists were switched will have been processed within the
453:                 		prvSampleTimeNow() function. */
454:                 		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
BFD05AF6  0018305E   ADDIU V0, S8, 24
BFD05AFA      0C82   MOVE A0, V0
BFD05AFC  42A877E8   JALS prvSampleTimeNow
BFD05AFE  0C0042A8   BC2T 2, 0xBFD07302
BFD05B00      0C00   NOP
BFD05B02  0010F85E   SW V0, 16(S8)
455:                 		if( xTimerListsWereSwitched == pdFALSE )
BFD05B06  0018FC5E   LW V0, 24(S8)
BFD05B0A  003D40A2   BNEZC V0, 0xBFD05B88
456:                 		{
457:                 			/* The tick count has not overflowed, has the timer expired? */
458:                 			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
BFD05B0E  002CFC5E   LW V0, 44(S8)
BFD05B12  001440A2   BNEZC V0, 0xBFD05B3E
BFD05B16  0028FC7E   LW V1, 40(S8)
BFD05B1A  0010FC5E   LW V0, 16(S8)
BFD05B1E  13900062   SLTU V0, V0, V1
BFD05B20  40A21390   ADDI GP, S0, 16546
BFD05B22  000C40A2   BNEZC V0, 0xBFD05B3E
459:                 			{
460:                 				( void ) xTaskResumeAll();
BFD05B26  158E77E8   JALS xTaskResumeAll
BFD05B28  0C00158E   LBU T4, 3072(T6)
BFD05B2A      0C00   NOP
461:                 				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
BFD05B2C  0028FC9E   LW A0, 40(S8)
BFD05B30  0010FCBE   LW A1, 16(S8)
BFD05B34  2F9277E8   JALS prvProcessExpiredTimer
BFD05B36      2F92   ANDI A3, S1, 0x2
BFD05B38      0C00   NOP
BFD05B3A      CC2C   B 0xBFD05B94
BFD05B3C      0C00   NOP
462:                 			}
463:                 			else
464:                 			{
465:                 				/* The tick count has not overflowed, and the next expire
466:                 				time has not been reached yet.  This task should therefore
467:                 				block to wait for the next expire time or a command to be
468:                 				received - whichever comes first.  The following line cannot
469:                 				be reached unless xNextExpireTime > xTimeNow, except in the
470:                 				case when the current timer list is empty. */
471:                 				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
BFD05B3E  8068FC7C   LW V1, -32664(GP)
BFD05B42  0028FC9E   LW A0, 40(S8)
BFD05B46  0010FC5E   LW V0, 16(S8)
BFD05B4A      0529   SUBU V0, A0, V0
BFD05B4C      0C83   MOVE A0, V1
BFD05B4E      0CA2   MOVE A1, V0
BFD05B50  002CFCDE   LW A2, 44(S8)
BFD05B54  349477E8   JALS vQueueWaitForMessageRestricted
BFD05B56  0C003494   LHU A0, 3072(S4)
BFD05B58      0C00   NOP
472:                 
473:                 				if( xTaskResumeAll() == pdFALSE )
BFD05B5A  158E77E8   JALS xTaskResumeAll
BFD05B5C  0C00158E   LBU T4, 3072(T6)
BFD05B5E      0C00   NOP
BFD05B60  001740A2   BNEZC V0, 0xBFD05B92
474:                 				{
475:                 					/* Yield to wait for either a command to arrive, or the
476:                 					block time to expire.  If a command arrived between the
477:                 					critical section being exited and this yield then the yield
478:                 					will not cause the task to block. */
479:                 					portYIELD_WITHIN_API();
BFD05B64  4E7677E8   JALS ulPortGetCP0Cause
BFD05B66      4E76   ADDIU S3, S3, -5
BFD05B68      0C00   NOP
BFD05B6A  0014F85E   SW V0, 20(S8)
BFD05B6E  0014FC5E   LW V0, 20(S8)
BFD05B72  01005042   ORI V0, V0, 256
BFD05B76  0014F85E   SW V0, 20(S8)
BFD05B7A  0014FC9E   LW A0, 20(S8)
BFD05B7E  4E8677E8   JALS vPortSetCP0Cause
BFD05B80      4E86   ADDIU S4, S4, 3
BFD05B82      0C00   NOP
BFD05B84      CC07   B 0xBFD05B94
BFD05B86      0C00   NOP
BFD05B92      0C00   NOP
480:                 				}
481:                 				else
482:                 				{
483:                 					mtCOVERAGE_TEST_MARKER();
484:                 				}
485:                 			}
486:                 		}
487:                 		else
488:                 		{
489:                 			( void ) xTaskResumeAll();
BFD05B88  158E77E8   JALS xTaskResumeAll
BFD05B8A  0C00158E   LBU T4, 3072(T6)
BFD05B8C      0C00   NOP
BFD05B8E      CC02   B 0xBFD05B94
BFD05B90      0C00   NOP
490:                 		}
491:                 	}
492:                 }
BFD05B94      0FBE   MOVE SP, S8
BFD05B96      4BE9   LW RA, 36(SP)
BFD05B98      4BC8   LW S8, 32(SP)
BFD05B9A      4C15   ADDIU SP, SP, 40
BFD05B9C      459F   JR16 RA
BFD05B9E      0C00   NOP
493:                 /*-----------------------------------------------------------*/
494:                 
495:                 static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
496:                 {
BFD08FDC      4FF9   ADDIU SP, SP, -16
BFD08FDE      CBC3   SW S8, 12(SP)
BFD08FE0      0FDD   MOVE S8, SP
BFD08FE2  0010F89E   SW A0, 16(S8)
497:                 TickType_t xNextExpireTime;
498:                 
499:                 	/* Timers are listed in expiry time order, with the head of the list
500:                 	referencing the task that will expire first.  Obtain the time at which
501:                 	the timer with the nearest expiry time will expire.  If there are no
502:                 	active timers then just set the next expire time to 0.  That will cause
503:                 	this task to unblock when the tick count overflows, at which point the
504:                 	timer lists will be switched and the next expiry time can be
505:                 	re-assessed.  */
506:                 	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
BFD08FE6  8060FC5C   LW V0, -32672(GP)
BFD08FEA      6920   LW V0, 0(V0)
BFD08FEC  0001B062   SLTIU V1, V0, 1
BFD08FF0  0010FC5E   LW V0, 16(S8)
BFD08FF4      E9A0   SW V1, 0(V0)
507:                 	if( *pxListWasEmpty == pdFALSE )
BFD08FF6  0010FC5E   LW V0, 16(S8)
BFD08FFA      6920   LW V0, 0(V0)
BFD08FFC  000840A2   BNEZC V0, 0xBFD09010
508:                 	{
509:                 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
BFD09000  8060FC5C   LW V0, -32672(GP)
BFD09004      6923   LW V0, 12(V0)
BFD09006      6920   LW V0, 0(V0)
BFD09008  0000F85E   SW V0, 0(S8)
BFD0900C      CC03   B 0xBFD09014
BFD0900E      0C00   NOP
510:                 	}
511:                 	else
512:                 	{
513:                 		/* Ensure the task unblocks when the tick count rolls over. */
514:                 		xNextExpireTime = ( TickType_t ) 0U;
BFD09010  0000F81E   SW ZERO, 0(S8)
515:                 	}
516:                 
517:                 	return xNextExpireTime;
BFD09014  0000FC5E   LW V0, 0(S8)
518:                 }
BFD09018      0FBE   MOVE SP, S8
BFD0901A      4BC3   LW S8, 12(SP)
BFD0901C      4C09   ADDIU SP, SP, 16
BFD0901E      459F   JR16 RA
BFD09020      0C00   NOP
519:                 /*-----------------------------------------------------------*/
520:                 
521:                 static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
522:                 {
BFD08550      4FF1   ADDIU SP, SP, -32
BFD08552      CBE7   SW RA, 28(SP)
BFD08554      CBC6   SW S8, 24(SP)
BFD08556      0FDD   MOVE S8, SP
BFD08558  0020F89E   SW A0, 32(S8)
523:                 TickType_t xTimeNow;
524:                 PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
525:                 
526:                 	xTimeNow = xTaskGetTickCount();
BFD0855C  4CCA77E8   JALS xTaskGetTickCount
BFD0855E      4CCA   ADDIU A2, A2, 5
BFD08560      0C00   NOP
BFD08562  0010F85E   SW V0, 16(S8)
527:                 
528:                 	if( xTimeNow < xLastTime )
BFD08566  806CFC5C   LW V0, -32660(GP)
BFD0856A  0010FC7E   LW V1, 16(S8)
BFD0856E  13900043   SLTU V0, V1, V0
BFD08570  40E21390   ADDI GP, S0, 16610
BFD08572  000940E2   BEQZC V0, 0xBFD08588
529:                 	{
530:                 		prvSwitchTimerLists();
BFD08576  1F7877E8   JALS prvSwitchTimerLists
BFD08578  0C001F78   LB K1, 3072(T8)
BFD0857A      0C00   NOP
531:                 		*pxTimerListsWereSwitched = pdTRUE;
BFD0857C  0020FC5E   LW V0, 32(S8)
BFD08580      ED81   LI V1, 1
BFD08582      E9A0   SW V1, 0(V0)
BFD08584      CC04   B 0xBFD0858E
BFD08586      0C00   NOP
532:                 	}
533:                 	else
534:                 	{
535:                 		*pxTimerListsWereSwitched = pdFALSE;
BFD08588  0020FC5E   LW V0, 32(S8)
BFD0858C      E820   SW S0, 0(V0)
536:                 	}
537:                 
538:                 	xLastTime = xTimeNow;
BFD0858E  0010FC5E   LW V0, 16(S8)
BFD08592  806CF85C   SW V0, -32660(GP)
539:                 
540:                 	return xTimeNow;
BFD08596  0010FC5E   LW V0, 16(S8)
541:                 }
BFD0859A      0FBE   MOVE SP, S8
BFD0859C      4BE7   LW RA, 28(SP)
BFD0859E      4BC6   LW S8, 24(SP)
BFD085A0      4C11   ADDIU SP, SP, 32
BFD085A2      459F   JR16 RA
BFD085A4      0C00   NOP
542:                 /*-----------------------------------------------------------*/
543:                 
544:                 static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
545:                 {
BFD057C8      4FF1   ADDIU SP, SP, -32
BFD057CA      CBE7   SW RA, 28(SP)
BFD057CC      CBC6   SW S8, 24(SP)
BFD057CE      0FDD   MOVE S8, SP
BFD057D0  0020F89E   SW A0, 32(S8)
BFD057D4  0024F8BE   SW A1, 36(S8)
BFD057D8  0028F8DE   SW A2, 40(S8)
BFD057DC  002CF8FE   SW A3, 44(S8)
546:                 BaseType_t xProcessTimerNow = pdFALSE;
BFD057E0  0010F81E   SW ZERO, 16(S8)
547:                 
548:                 	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
BFD057E4  0020FC5E   LW V0, 32(S8)
BFD057E8  0024FC7E   LW V1, 36(S8)
BFD057EC      E9A1   SW V1, 4(V0)
549:                 	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
BFD057EE  0020FC5E   LW V0, 32(S8)
BFD057F2  0020FC7E   LW V1, 32(S8)
BFD057F6      E9A4   SW V1, 16(V0)
550:                 
551:                 	if( xNextExpiryTime <= xTimeNow )
BFD057F8  0024FC7E   LW V1, 36(S8)
BFD057FC  0028FC5E   LW V0, 40(S8)
BFD05800  13900062   SLTU V0, V0, V1
BFD05802  40A21390   ADDI GP, S0, 16546
BFD05804  001D40A2   BNEZC V0, 0xBFD05842
552:                 	{
553:                 		/* Has the expiry time elapsed between the command to start/reset a
554:                 		timer was issued, and the time the command was processed? */
555:                 		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
BFD05808  0028FC7E   LW V1, 40(S8)
BFD0580C  002CFC5E   LW V0, 44(S8)
BFD05810      05A7   SUBU V1, V1, V0
BFD05812  0020FC5E   LW V0, 32(S8)
BFD05816      6926   LW V0, 24(V0)
BFD05818  13900043   SLTU V0, V1, V0
BFD0581A  40A21390   ADDI GP, S0, 16546
BFD0581C  000540A2   BNEZC V0, 0xBFD0582A
556:                 		{
557:                 			/* The time between a command being issued and the command being
558:                 			processed actually exceeds the timers period.  */
559:                 			xProcessTimerNow = pdTRUE;
BFD05820      ED01   LI V0, 1
BFD05822  0010F85E   SW V0, 16(S8)
BFD05824  CC2C0010   EXT ZERO, S0, 16, 26
BFD05826      CC2C   B 0xBFD05880
BFD05828      0C00   NOP
560:                 		}
561:                 		else
562:                 		{
563:                 			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
BFD0582A  8064FC7C   LW V1, -32668(GP)
BFD0582E  0020FC5E   LW V0, 32(S8)
BFD05832      6D22   ADDIU V0, V0, 4
BFD05834      0C83   MOVE A0, V1
BFD05836      0CA2   MOVE A1, V0
BFD05838  304077E8   JALS vListInsert
BFD0583A  0C003040   ADDIU V0, ZERO, 3072
BFD0583C      0C00   NOP
BFD0583E      CC20   B 0xBFD05880
BFD05840      0C00   NOP
564:                 		}
565:                 	}
566:                 	else
567:                 	{
568:                 		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
BFD05842  0028FC7E   LW V1, 40(S8)
BFD05846  002CFC5E   LW V0, 44(S8)
BFD0584A  13900043   SLTU V0, V1, V0
BFD0584C  40E21390   ADDI GP, S0, 16610
BFD0584E  000D40E2   BEQZC V0, 0xBFD0586C
BFD05852  0024FC7E   LW V1, 36(S8)
BFD05856  002CFC5E   LW V0, 44(S8)
BFD0585A  13900043   SLTU V0, V1, V0
BFD0585C  40A21390   ADDI GP, S0, 16546
BFD0585E  000540A2   BNEZC V0, 0xBFD0586C
569:                 		{
570:                 			/* If, since the command was issued, the tick count has overflowed
571:                 			but the expiry time has not, then the timer must have already passed
572:                 			its expiry time and should be processed immediately. */
573:                 			xProcessTimerNow = pdTRUE;
BFD05862      ED01   LI V0, 1
BFD05864  0010F85E   SW V0, 16(S8)
BFD05868      CC0B   B 0xBFD05880
BFD0586A      0C00   NOP
574:                 		}
575:                 		else
576:                 		{
577:                 			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
BFD0586C  8060FC7C   LW V1, -32672(GP)
BFD05870  0020FC5E   LW V0, 32(S8)
BFD05874      6D22   ADDIU V0, V0, 4
BFD05876      0C83   MOVE A0, V1
BFD05878      0CA2   MOVE A1, V0
BFD0587A  304077E8   JALS vListInsert
BFD0587C  0C003040   ADDIU V0, ZERO, 3072
BFD0587E      0C00   NOP
578:                 		}
579:                 	}
580:                 
581:                 	return xProcessTimerNow;
BFD05880  0010FC5E   LW V0, 16(S8)
582:                 }
BFD05884      0FBE   MOVE SP, S8
BFD05886      4BE7   LW RA, 28(SP)
BFD05888      4BC6   LW S8, 24(SP)
BFD0588A      4C11   ADDIU SP, SP, 32
BFD0588C      459F   JR16 RA
BFD0588E      0C00   NOP
583:                 /*-----------------------------------------------------------*/
584:                 
585:                 static void	prvProcessReceivedCommands( void )
586:                 {
BFD01734      4FDD   ADDIU SP, SP, -72
BFD01736      CBF1   SW RA, 68(SP)
BFD01738      CBD0   SW S8, 64(SP)
BFD0173A      0FDD   MOVE S8, SP
587:                 DaemonTaskMessage_t xMessage;
588:                 Timer_t *pxTimer;
589:                 BaseType_t xTimerListsWereSwitched, xResult;
590:                 TickType_t xTimeNow;
591:                 
592:                 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
BFD0173C      CCE0   B 0xBFD018FE
BFD0173E      0C00   NOP
BFD018FE  8068FC7C   LW V1, -32664(GP)
BFD01902  0028305E   ADDIU V0, S8, 40
BFD01906      0C83   MOVE A0, V1
BFD01908      0CA2   MOVE A1, V0
BFD0190A      0CC0   MOVE A2, ZERO
BFD0190C      0CE0   MOVE A3, ZERO
BFD0190E  081E77E8   JALS xQueueGenericReceive
BFD01910      081E   LBU S0, 14(S1)
BFD01912      0C00   NOP
BFD01914  FF1440A2   BNEZC V0, 0xBFD01740
BFD01916  0FBEFF14   LW T8, 4030(S4)
593:                 	{
594:                 		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
595:                 		{
596:                 			/* Negative commands are pended function calls rather than timer
597:                 			commands. */
598:                 			if( xMessage.xMessageID < ( BaseType_t ) 0 )
BFD01740  0028FC5E   LW V0, 40(S8)
BFD01744  001F4042   BGEZ V0, 0xBFD01786
BFD01746  0C00001F   SLL ZERO, RA, 1
BFD01748      0C00   NOP
599:                 			{
600:                 				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
BFD0174A  0028305E   ADDIU V0, S8, 40
BFD0174E      6D22   ADDIU V0, V0, 4
BFD01750  0018F85E   SW V0, 24(S8)
601:                 
602:                 				/* The timer uses the xCallbackParameters member to request a
603:                 				callback be executed.  Check the callback is not NULL. */
604:                 				configASSERT( pxCallback );
BFD01754  0018FC5E   LW V0, 24(S8)
BFD01758  000940A2   BNEZC V0, 0xBFD0176E
BFD0175C  BFD141A2   LUI V0, 0xBFD1
BFD0175E  3082BFD1   LDC1 F30, 12418(S1)
BFD01760  9AE83082   ADDIU A0, V0, -25880
BFD01762  30A09AE8   SWC1 F23, 12448(T0)
BFD01764  025C30A0   ADDIU A1, ZERO, 604
BFD01768  4B7E77E8   JALS vAssertCalled
BFD0176A      4B7E   LW K1, 120(SP)
BFD0176C      0C00   NOP
605:                 
606:                 				/* Call the function. */
607:                 				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
BFD0176E  0018FC5E   LW V0, 24(S8)
BFD01772      6920   LW V0, 0(V0)
BFD01774  0018FC7E   LW V1, 24(S8)
BFD01778      6A31   LW A0, 4(V1)
BFD0177A  0018FC7E   LW V1, 24(S8)
BFD0177E      69B2   LW V1, 8(V1)
BFD01780      0CA3   MOVE A1, V1
BFD01782      45E2   JALRS16 V0
BFD01784      0C00   NOP
608:                 			}
609:                 			else
610:                 			{
611:                 				mtCOVERAGE_TEST_MARKER();
612:                 			}
613:                 		}
614:                 		#endif /* INCLUDE_xTimerPendFunctionCall */
615:                 
616:                 		/* Commands that are positive are timer commands rather than pended
617:                 		function calls. */
618:                 		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
BFD01786  0028FC5E   LW V0, 40(S8)
BFD0178A  00B84002   BLTZ V0, 0xBFD018FE
BFD0178C  0C0000B8   SLL A1, T8, 1
BFD0178E      0C00   NOP
619:                 		{
620:                 			/* The messages uses the xTimerParameters member to work on a
621:                 			software timer. */
622:                 			pxTimer = xMessage.u.xTimerParameters.pxTimer;
BFD01790  0030FC5E   LW V0, 48(S8)
BFD01794  001CF85E   SW V0, 28(S8)
623:                 
624:                 			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
BFD01798  001CFC5E   LW V0, 28(S8)
BFD0179C      6925   LW V0, 20(V0)
BFD0179E  000740E2   BEQZC V0, 0xBFD017B0
625:                 			{
626:                 				/* The timer is in a list, remove it. */
627:                 				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
BFD017A2  001CFC5E   LW V0, 28(S8)
BFD017A6      6D22   ADDIU V0, V0, 4
BFD017A8      0C82   MOVE A0, V0
BFD017AA  00C877E8   JALS uxListRemove
BFD017AC  0C0000C8   SLL A2, T0, 1
BFD017AE      0C00   NOP
628:                 			}
629:                 			else
630:                 			{
631:                 				mtCOVERAGE_TEST_MARKER();
632:                 			}
633:                 
634:                 			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
635:                 
636:                 			/* In this case the xTimerListsWereSwitched parameter is not used, but
637:                 			it must be present in the function call.  prvSampleTimeNow() must be
638:                 			called after the message is received from xTimerQueue so there is no
639:                 			possibility of a higher priority task adding a message to the message
640:                 			queue with a time that is ahead of the timer daemon task (because it
641:                 			pre-empted the timer daemon task after the xTimeNow value was set). */
642:                 			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
BFD017B0  0038305E   ADDIU V0, S8, 56
BFD017B4      0C82   MOVE A0, V0
BFD017B6  42A877E8   JALS prvSampleTimeNow
BFD017B8  0C0042A8   BC2T 2, 0xBFD02FBC
BFD017BA      0C00   NOP
BFD017BC  0020F85E   SW V0, 32(S8)
643:                 
644:                 			switch( xMessage.xMessageID )
BFD017C0  0028FC5E   LW V0, 40(S8)
BFD017C4  000AB062   SLTIU V1, V0, 10
BFD017C8  008C40E3   BEQZC V1, 0xBFD018E4
BFD017CC      25A4   SLL V1, V0, 2
BFD017CE  BFD041A2   LUI V0, 0xBFD0
BFD017D0  3042BFD0   LDC1 F30, 12354(S0)
BFD017D2  17DC3042   ADDIU V0, V0, 6108
BFD017D4  052617DC   LBU S8, 1318(GP)
BFD017D6      0526   ADDU V0, V1, V0
BFD017D8      6920   LW V0, 0(V0)
BFD017DA      45A2   JRC V0
BFD017DC  BFD01805   SB ZERO, -16432(A1)
BFD017DE  1805BFD0   LDC1 F30, 6149(S0)
BFD017E0  BFD01805   SB ZERO, -16432(A1)
BFD017E2  1805BFD0   LDC1 F30, 6149(S0)
BFD017E4  BFD01805   SB ZERO, -16432(A1)
BFD017E6  18EBBFD0   LDC1 F30, 6379(S0)
BFD017E8  BFD018EB   SB A3, -16432(T3)
BFD017EA  188DBFD0   LDC1 F30, 6285(S0)
BFD017EC  BFD0188D   SB A0, -16432(T5)
BFD017EE  18D7BFD0   LDC1 F30, 6359(S0)
BFD017F0  BFD018D7   SB A2, -16432(S7)
BFD017F2  1805BFD0   LDC1 F30, 6149(S0)
BFD017F4  BFD01805   SB ZERO, -16432(A1)
BFD017F6  1805BFD0   LDC1 F30, 6149(S0)
BFD017F8  BFD01805   SB ZERO, -16432(A1)
BFD017FA  18EBBFD0   LDC1 F30, 6379(S0)
BFD017FC  BFD018EB   SB A3, -16432(T3)
BFD017FE  188DBFD0   LDC1 F30, 6285(S0)
BFD01800  BFD0188D   SB A0, -16432(T5)
BFD01802  FC7EBFD0   LDC1 F30, -898(S0)
645:                 			{
646:                 				case tmrCOMMAND_START :
647:                 			    case tmrCOMMAND_START_FROM_ISR :
648:                 			    case tmrCOMMAND_RESET :
649:                 			    case tmrCOMMAND_RESET_FROM_ISR :
650:                 				case tmrCOMMAND_START_DONT_TRACE :
651:                 					/* Start or restart a timer. */
652:                 					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
BFD01804  002CFC7E   LW V1, 44(S8)
BFD01808  001CFC5E   LW V0, 28(S8)
BFD0180C      6926   LW V0, 24(V0)
BFD0180E      05A6   ADDU V1, V1, V0
BFD01810  002CFC5E   LW V0, 44(S8)
BFD01814  001CFC9E   LW A0, 28(S8)
BFD01818      0CA3   MOVE A1, V1
BFD0181A  0020FCDE   LW A2, 32(S8)
BFD0181E      0CE2   MOVE A3, V0
BFD01820  2BE477E8   JALS prvInsertTimerInActiveList
BFD01822      2BE4   LHU A3, 8(A2)
BFD01824      0C00   NOP
BFD01826      0C62   MOVE V1, V0
BFD01828      ED01   LI V0, 1
BFD0182A  0061B443   BNE V1, V0, 0xBFD018F0
BFD0182C  0C000061   SLL V1, AT, 1
BFD0182E      0C00   NOP
653:                 					{
654:                 						/* The timer expired before it was added to the active
655:                 						timer list.  Process it now. */
656:                 						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
BFD01830  001CFC5E   LW V0, 28(S8)
BFD01834      6929   LW V0, 36(V0)
BFD01836  001CFC9E   LW A0, 28(S8)
BFD0183A      45E2   JALRS16 V0
BFD0183C      0C00   NOP
657:                 						traceTIMER_EXPIRED( pxTimer );
658:                 
659:                 						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
BFD0183E  001CFC5E   LW V0, 28(S8)
BFD01842      69A7   LW V1, 28(V0)
BFD01844      ED01   LI V0, 1
BFD01846  0056B443   BNE V1, V0, 0xBFD018F6
BFD01848  0C000056   SLL V0, S6, 1
BFD0184A      0C00   NOP
660:                 						{
661:                 							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
BFD0184C  002CFC7E   LW V1, 44(S8)
BFD01850  001CFC5E   LW V0, 28(S8)
BFD01854      6926   LW V0, 24(V0)
BFD01856      0526   ADDU V0, V1, V0
BFD01858      C804   SW ZERO, 16(SP)
BFD0185A  001CFC9E   LW A0, 28(S8)
BFD0185E      0CA0   MOVE A1, ZERO
BFD01860      0CC2   MOVE A2, V0
BFD01862      0CE0   MOVE A3, ZERO
BFD01864  2D0E77E8   JALS xTimerGenericCommand
BFD01866      2D0E   ANDI V0, S0, 0x8000
BFD01868      0C00   NOP
BFD0186A  0024F85E   SW V0, 36(S8)
662:                 							configASSERT( xResult );
BFD0186E  0024FC5E   LW V0, 36(S8)
BFD01872  004340A2   BNEZC V0, 0xBFD018FC
BFD01876  BFD141A2   LUI V0, 0xBFD1
BFD01878  3082BFD1   LDC1 F30, 12418(S1)
BFD0187A  9AE83082   ADDIU A0, V0, -25880
BFD0187C  30A09AE8   SWC1 F23, 12448(T0)
BFD0187E  029630A0   ADDIU A1, ZERO, 662
BFD01882  4B7E77E8   JALS vAssertCalled
BFD01884      4B7E   LW K1, 120(SP)
BFD01886      0C00   NOP
663:                 							( void ) xResult;
664:                 						}
665:                 						else
666:                 						{
667:                 							mtCOVERAGE_TEST_MARKER();
668:                 						}
669:                 					}
670:                 					else
671:                 					{
672:                 						mtCOVERAGE_TEST_MARKER();
673:                 					}
674:                 					break;
BFD01888      CC3A   B 0xBFD018FE
BFD0188A      0C00   NOP
BFD018F0      0C00   NOP
BFD018F2      CC05   B 0xBFD018FE
BFD018F4      0C00   NOP
BFD018F6      0C00   NOP
BFD018F8      CC02   B 0xBFD018FE
BFD018FA      0C00   NOP
BFD018FC      0C00   NOP
675:                 
676:                 				case tmrCOMMAND_STOP :
677:                 				case tmrCOMMAND_STOP_FROM_ISR :
678:                 					/* The timer has already been removed from the active list.
679:                 					There is nothing to do here. */
680:                 					break;
BFD018EA      0C00   NOP
BFD018EC      CC08   B 0xBFD018FE
BFD018EE      0C00   NOP
681:                 
682:                 				case tmrCOMMAND_CHANGE_PERIOD :
683:                 				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
684:                 					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
BFD0188C  002CFC7E   LW V1, 44(S8)
BFD01890  001CFC5E   LW V0, 28(S8)
BFD01894      E9A6   SW V1, 24(V0)
685:                 					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
BFD01896  001CFC5E   LW V0, 28(S8)
BFD0189A      6926   LW V0, 24(V0)
BFD0189C  000940A2   BNEZC V0, 0xBFD018B2
BFD018A0  BFD141A2   LUI V0, 0xBFD1
BFD018A2  3082BFD1   LDC1 F30, 12418(S1)
BFD018A4  9AE83082   ADDIU A0, V0, -25880
BFD018A6  30A09AE8   SWC1 F23, 12448(T0)
BFD018A8  02AD30A0   ADDIU A1, ZERO, 685
BFD018AC  4B7E77E8   JALS vAssertCalled
BFD018AE      4B7E   LW K1, 120(SP)
BFD018B0      0C00   NOP
686:                 
687:                 					/* The new period does not really have a reference, and can be
688:                 					longer or shorter than the old one.  The command time is
689:                 					therefore set to the current time, and as the period cannot be
690:                 					zero the next expiry time can only be in the future, meaning
691:                 					(unlike for the xTimerStart() case above) there is no fail case
692:                 					that needs to be handled here. */
693:                 					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
BFD018B2  001CFC5E   LW V0, 28(S8)
BFD018B6      69A6   LW V1, 24(V0)
BFD018B8  0020FC5E   LW V0, 32(S8)
BFD018BC      0526   ADDU V0, V1, V0
BFD018BE  001CFC9E   LW A0, 28(S8)
BFD018C2      0CA2   MOVE A1, V0
BFD018C4  0020FCDE   LW A2, 32(S8)
BFD018C8  0020FCFE   LW A3, 32(S8)
BFD018CC  2BE477E8   JALS prvInsertTimerInActiveList
BFD018CE      2BE4   LHU A3, 8(A2)
BFD018D0      0C00   NOP
694:                 					break;
BFD018D2      CC15   B 0xBFD018FE
BFD018D4      0C00   NOP
695:                 
696:                 				case tmrCOMMAND_DELETE :
697:                 					/* The timer has already been removed from the active list,
698:                 					just free up the memory. */
699:                 					vPortFree( pxTimer );
BFD018D6  001CFC9E   LW A0, 28(S8)
BFD018DA  2FEA77E8   JALS vPortFree
BFD018DC      2FEA   ANDI A3, A2, 0x20
BFD018DE      0C00   NOP
700:                 					break;
BFD018E0      CC0E   B 0xBFD018FE
BFD018E2      0C00   NOP
701:                 
702:                 				default	:
703:                 					/* Don't expect to get here. */
704:                 					break;
BFD018E4      0C00   NOP
BFD018E6      CC0B   B 0xBFD018FE
BFD018E8      0C00   NOP
705:                 			}
706:                 		}
707:                 	}
708:                 }
BFD01918      0FBE   MOVE SP, S8
BFD0191A      4BF1   LW RA, 68(SP)
BFD0191C      4BD0   LW S8, 64(SP)
BFD0191E      4C25   ADDIU SP, SP, 72
BFD01920      459F   JR16 RA
BFD01922      0C00   NOP
709:                 /*-----------------------------------------------------------*/
710:                 
711:                 static void prvSwitchTimerLists( void )
712:                 {
BFD03EF0      4FE5   ADDIU SP, SP, -56
BFD03EF2      CBED   SW RA, 52(SP)
BFD03EF4      CBCC   SW S8, 48(SP)
BFD03EF6      0FDD   MOVE S8, SP
713:                 TickType_t xNextExpireTime, xReloadTime;
714:                 List_t *pxTemp;
715:                 Timer_t *pxTimer;
716:                 BaseType_t xResult;
717:                 
718:                 	/* The tick count has overflowed.  The timer lists must be switched.
719:                 	If there are any timers still referenced from the current timer list
720:                 	then they must have expired and should be processed before the lists
721:                 	are switched. */
722:                 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
BFD03EF8      CC61   B 0xBFD03FBC
BFD03EFA      0C00   NOP
BFD03FBC  8060FC5C   LW V0, -32672(GP)
BFD03FC0      6920   LW V0, 0(V0)
BFD03FC2  FF9B40A2   BNEZC V0, 0xBFD03EFC
BFD03FC4  FC5CFF9B   LW GP, -932(K1)
723:                 	{
724:                 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
BFD03EFC  8060FC5C   LW V0, -32672(GP)
BFD03F00      6923   LW V0, 12(V0)
BFD03F02      6920   LW V0, 0(V0)
BFD03F04  0018F85E   SW V0, 24(S8)
725:                 
726:                 		/* Remove the timer from the list. */
727:                 		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
BFD03F08  8060FC5C   LW V0, -32672(GP)
BFD03F0C      6923   LW V0, 12(V0)
BFD03F0E      6923   LW V0, 12(V0)
BFD03F10  001CF85E   SW V0, 28(S8)
728:                 		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
BFD03F14  001CFC5E   LW V0, 28(S8)
BFD03F18      6D22   ADDIU V0, V0, 4
BFD03F1A      0C82   MOVE A0, V0
BFD03F1C  00C877E8   JALS uxListRemove
BFD03F1E  0C0000C8   SLL A2, T0, 1
BFD03F20      0C00   NOP
729:                 		traceTIMER_EXPIRED( pxTimer );
730:                 
731:                 		/* Execute its callback, then send a command to restart the timer if
732:                 		it is an auto-reload timer.  It cannot be restarted here as the lists
733:                 		have not yet been switched. */
734:                 		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
BFD03F22  001CFC5E   LW V0, 28(S8)
BFD03F26      6929   LW V0, 36(V0)
BFD03F28  001CFC9E   LW A0, 28(S8)
BFD03F2C      45E2   JALRS16 V0
BFD03F2E      0C00   NOP
735:                 
736:                 		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
BFD03F30  001CFC5E   LW V0, 28(S8)
BFD03F34      69A7   LW V1, 28(V0)
BFD03F36      ED01   LI V0, 1
BFD03F38  0040B443   BNE V1, V0, 0xBFD03FBC
BFD03F3A  0C000040   SLL V0, ZERO, 1
BFD03F3C      0C00   NOP
737:                 		{
738:                 			/* Calculate the reload value, and if the reload value results in
739:                 			the timer going into the same timer list then it has already expired
740:                 			and the timer should be re-inserted into the current list so it is
741:                 			processed again within this loop.  Otherwise a command should be sent
742:                 			to restart the timer to ensure it is only inserted into a list after
743:                 			the lists have been swapped. */
744:                 			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
BFD03F3E  001CFC5E   LW V0, 28(S8)
BFD03F42      69A6   LW V1, 24(V0)
BFD03F44  0018FC5E   LW V0, 24(S8)
BFD03F48      0526   ADDU V0, V1, V0
BFD03F4A  0020F85E   SW V0, 32(S8)
745:                 			if( xReloadTime > xNextExpireTime )
BFD03F4E  0020FC7E   LW V1, 32(S8)
BFD03F52  0018FC5E   LW V0, 24(S8)
BFD03F56  13900062   SLTU V0, V0, V1
BFD03F58  40E21390   ADDI GP, S0, 16610
BFD03F5A  001640E2   BEQZC V0, 0xBFD03F8A
746:                 			{
747:                 				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
BFD03F5E  001CFC5E   LW V0, 28(S8)
BFD03F62  0020FC7E   LW V1, 32(S8)
BFD03F66      E9A1   SW V1, 4(V0)
748:                 				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
BFD03F68  001CFC5E   LW V0, 28(S8)
BFD03F6C  001CFC7E   LW V1, 28(S8)
BFD03F70      E9A4   SW V1, 16(V0)
749:                 				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
BFD03F72  8060FC7C   LW V1, -32672(GP)
BFD03F76  001CFC5E   LW V0, 28(S8)
BFD03F7A      6D22   ADDIU V0, V0, 4
BFD03F7C      0C83   MOVE A0, V1
BFD03F7E      0CA2   MOVE A1, V0
BFD03F80  304077E8   JALS vListInsert
BFD03F82  0C003040   ADDIU V0, ZERO, 3072
BFD03F84      0C00   NOP
BFD03F86      CC1A   B 0xBFD03FBC
BFD03F88      0C00   NOP
750:                 			}
751:                 			else
752:                 			{
753:                 				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
BFD03F8A      C804   SW ZERO, 16(SP)
BFD03F8C  001CFC9E   LW A0, 28(S8)
BFD03F90      0CA0   MOVE A1, ZERO
BFD03F92  0018FCDE   LW A2, 24(S8)
BFD03F96      0CE0   MOVE A3, ZERO
BFD03F98  2D0E77E8   JALS xTimerGenericCommand
BFD03F9A      2D0E   ANDI V0, S0, 0x8000
BFD03F9C      0C00   NOP
BFD03F9E  0024F85E   SW V0, 36(S8)
754:                 				configASSERT( xResult );
BFD03FA2  0024FC5E   LW V0, 36(S8)
BFD03FA6  000940A2   BNEZC V0, 0xBFD03FBC
BFD03FAA  BFD141A2   LUI V0, 0xBFD1
BFD03FAC  3082BFD1   LDC1 F30, 12418(S1)
BFD03FAE  9AE83082   ADDIU A0, V0, -25880
BFD03FB0  30A09AE8   SWC1 F23, 12448(T0)
BFD03FB2  02F230A0   ADDIU A1, ZERO, 754
BFD03FB6  4B7E77E8   JALS vAssertCalled
BFD03FB8      4B7E   LW K1, 120(SP)
BFD03FBA      0C00   NOP
755:                 				( void ) xResult;
756:                 			}
757:                 		}
758:                 		else
759:                 		{
760:                 			mtCOVERAGE_TEST_MARKER();
761:                 		}
762:                 	}
763:                 
764:                 	pxTemp = pxCurrentTimerList;
BFD03FC6  8060FC5C   LW V0, -32672(GP)
BFD03FCA  0028F85E   SW V0, 40(S8)
765:                 	pxCurrentTimerList = pxOverflowTimerList;
BFD03FCE  8064FC5C   LW V0, -32668(GP)
BFD03FD2  8060F85C   SW V0, -32672(GP)
766:                 	pxOverflowTimerList = pxTemp;
BFD03FD6  0028FC5E   LW V0, 40(S8)
BFD03FDA  8064F85C   SW V0, -32668(GP)
767:                 }
BFD03FDE      0FBE   MOVE SP, S8
BFD03FE0      4BED   LW RA, 52(SP)
BFD03FE2      4BCC   LW S8, 48(SP)
BFD03FE4      4C1D   ADDIU SP, SP, 56
BFD03FE6      459F   JR16 RA
BFD03FE8      0C00   NOP
768:                 /*-----------------------------------------------------------*/
769:                 
770:                 static void prvCheckForValidListAndQueue( void )
771:                 {
BFD06BE8      4FF5   ADDIU SP, SP, -24
BFD06BEA      CBE5   SW RA, 20(SP)
BFD06BEC      CBC4   SW S8, 16(SP)
BFD06BEE      0FDD   MOVE S8, SP
772:                 	/* Check that the list from which active timers are referenced, and the
773:                 	queue used to communicate with the timer service, have been
774:                 	initialised. */
775:                 	taskENTER_CRITICAL();
BFD06BF0  33B877E8   JALS vTaskEnterCritical
BFD06BF2  0C0033B8   ADDIU SP, T8, 3072
BFD06BF4      0C00   NOP
776:                 	{
777:                 		if( xTimerQueue == NULL )
BFD06BF6  8068FC5C   LW V0, -32664(GP)
BFD06BFA  002F40A2   BNEZC V0, 0xBFD06C5C
778:                 		{
779:                 			vListInitialise( &xActiveTimerList1 );
BFD06BFE  BFD241A2   LUI V0, 0xBFD2
BFD06C00  3082BFD2   LDC1 F30, 12418(S2)
BFD06C02  B9483082   ADDIU A0, V0, -18104
BFD06C04  77E8B948   SDC1 F10, 30696(T0)
BFD06C06  457077E8   JALS vListInitialise
BFD06C08      4570   SWM16 0x3, 0(SP)
BFD06C0A      0C00   NOP
780:                 			vListInitialise( &xActiveTimerList2 );
BFD06C0C  BFD241A2   LUI V0, 0xBFD2
BFD06C0E  3082BFD2   LDC1 F30, 12418(S2)
BFD06C10  B95C3082   ADDIU A0, V0, -18084
BFD06C12  77E8B95C   SDC1 F10, 30696(GP)
BFD06C14  457077E8   JALS vListInitialise
BFD06C16      4570   SWM16 0x3, 0(SP)
BFD06C18      0C00   NOP
781:                 			pxCurrentTimerList = &xActiveTimerList1;
BFD06C1A  BFD241A2   LUI V0, 0xBFD2
BFD06C1C  3042BFD2   LDC1 F30, 12354(S2)
BFD06C1E  B9483042   ADDIU V0, V0, -18104
BFD06C20  F85CB948   SDC1 F10, -1956(T0)
BFD06C22  8060F85C   SW V0, -32672(GP)
782:                 			pxOverflowTimerList = &xActiveTimerList2;
BFD06C26  BFD241A2   LUI V0, 0xBFD2
BFD06C28  3042BFD2   LDC1 F30, 12354(S2)
BFD06C2A  B95C3042   ADDIU V0, V0, -18084
BFD06C2C  F85CB95C   SDC1 F10, -1956(GP)
BFD06C2E  8064F85C   SW V0, -32668(GP)
783:                 			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
BFD06C32      EE05   LI A0, 5
BFD06C34      EE90   LI A1, 16
BFD06C36      0CC0   MOVE A2, ZERO
BFD06C38  1EFA77E8   JALS xQueueGenericCreate
BFD06C3A  0C001EFA   LB S7, 3072(K0)
BFD06C3C      0C00   NOP
BFD06C3E  8068F85C   SW V0, -32664(GP)
784:                 			configASSERT( xTimerQueue );
BFD06C42  8068FC5C   LW V0, -32664(GP)
BFD06C46  000940A2   BNEZC V0, 0xBFD06C5C
BFD06C4A  BFD141A2   LUI V0, 0xBFD1
BFD06C4C  3082BFD1   LDC1 F30, 12418(S1)
BFD06C4E  9AE83082   ADDIU A0, V0, -25880
BFD06C50  30A09AE8   SWC1 F23, 12448(T0)
BFD06C52  031030A0   ADDIU A1, ZERO, 784
BFD06C56  4B7E77E8   JALS vAssertCalled
BFD06C58      4B7E   LW K1, 120(SP)
BFD06C5A      0C00   NOP
785:                 
786:                 			#if ( configQUEUE_REGISTRY_SIZE > 0 )
787:                 			{
788:                 				if( xTimerQueue != NULL )
789:                 				{
790:                 					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
791:                 				}
792:                 				else
793:                 				{
794:                 					mtCOVERAGE_TEST_MARKER();
795:                 				}
796:                 			}
797:                 			#endif /* configQUEUE_REGISTRY_SIZE */
798:                 		}
799:                 		else
800:                 		{
801:                 			mtCOVERAGE_TEST_MARKER();
802:                 		}
803:                 	}
804:                 	taskEXIT_CRITICAL();
BFD06C5C  40AA77E8   JALS vTaskExitCritical
BFD06C5E  0C0040AA   BNEZC T2, 0xBFD08462
BFD06C60      0C00   NOP
805:                 }
BFD06C62      0FBE   MOVE SP, S8
BFD06C64      4BE5   LW RA, 20(SP)
BFD06C66      4BC4   LW S8, 16(SP)
BFD06C68      4C0D   ADDIU SP, SP, 24
BFD06C6A      459F   JR16 RA
BFD06C6C      0C00   NOP
806:                 /*-----------------------------------------------------------*/
807:                 
808:                 BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
809:                 {
BFD093E0      4FF1   ADDIU SP, SP, -32
BFD093E2      CBE7   SW RA, 28(SP)
BFD093E4      CBC6   SW S8, 24(SP)
BFD093E6      0FDD   MOVE S8, SP
BFD093E8  0020F89E   SW A0, 32(S8)
810:                 BaseType_t xTimerIsInActiveList;
811:                 Timer_t *pxTimer = ( Timer_t * ) xTimer;
BFD093EC  0020FC5E   LW V0, 32(S8)
BFD093F0  0010F85E   SW V0, 16(S8)
812:                 
813:                 	/* Is the timer in the list of active timers? */
814:                 	taskENTER_CRITICAL();
BFD093F4  33B877E8   JALS vTaskEnterCritical
BFD093F6  0C0033B8   ADDIU SP, T8, 3072
BFD093F8      0C00   NOP
815:                 	{
816:                 		/* Checking to see if it is in the NULL list in effect checks to see if
817:                 		it is referenced from either the current or the overflow timer lists in
818:                 		one go, but the logic has to be reversed, hence the '!'. */
819:                 		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
BFD093FA  0010FC5E   LW V0, 16(S8)
BFD093FE      6925   LW V0, 20(V0)
BFD09400  13900040   SLTU V0, ZERO, V0
BFD09402  F85E1390   ADDI GP, S0, -1954
BFD09404  0014F85E   SW V0, 20(S8)
820:                 	}
821:                 	taskEXIT_CRITICAL();
BFD09408  40AA77E8   JALS vTaskExitCritical
BFD0940A  0C0040AA   BNEZC T2, 0xBFD0AC0E
BFD0940C      0C00   NOP
822:                 
823:                 	return xTimerIsInActiveList;
BFD0940E  0014FC5E   LW V0, 20(S8)
824:                 } /*lint !e818 Can't be pointer to const due to the typedef. */
BFD09412      0FBE   MOVE SP, S8
BFD09414      4BE7   LW RA, 28(SP)
BFD09416      4BC6   LW S8, 24(SP)
BFD09418      4C11   ADDIU SP, SP, 32
BFD0941A      459F   JR16 RA
BFD0941C      0C00   NOP
825:                 /*-----------------------------------------------------------*/
826:                 
827:                 void *pvTimerGetTimerID( const TimerHandle_t xTimer )
828:                 {
BFD0875C      4FF1   ADDIU SP, SP, -32
BFD0875E      CBE7   SW RA, 28(SP)
BFD08760      CBC6   SW S8, 24(SP)
BFD08762      0FDD   MOVE S8, SP
BFD08764  0020F89E   SW A0, 32(S8)
829:                 Timer_t * const pxTimer = ( Timer_t * ) xTimer;
BFD08768  0020FC5E   LW V0, 32(S8)
BFD0876C  0010F85E   SW V0, 16(S8)
830:                 void *pvReturn;
831:                 
832:                 	configASSERT( xTimer );
BFD08770  0020FC5E   LW V0, 32(S8)
BFD08774  000940A2   BNEZC V0, 0xBFD0878A
BFD08778  BFD141A2   LUI V0, 0xBFD1
BFD0877A  3082BFD1   LDC1 F30, 12418(S1)
BFD0877C  9AE83082   ADDIU A0, V0, -25880
BFD0877E  30A09AE8   SWC1 F23, 12448(T0)
BFD08780  034030A0   ADDIU A1, ZERO, 832
BFD08784  4B7E77E8   JALS vAssertCalled
BFD08786      4B7E   LW K1, 120(SP)
BFD08788      0C00   NOP
833:                 
834:                 	taskENTER_CRITICAL();
BFD0878A  33B877E8   JALS vTaskEnterCritical
BFD0878C  0C0033B8   ADDIU SP, T8, 3072
BFD0878E      0C00   NOP
835:                 	{
836:                 		pvReturn = pxTimer->pvTimerID;
BFD08790  0010FC5E   LW V0, 16(S8)
BFD08794      6928   LW V0, 32(V0)
BFD08796  0014F85E   SW V0, 20(S8)
837:                 	}
838:                 	taskEXIT_CRITICAL();
BFD0879A  40AA77E8   JALS vTaskExitCritical
BFD0879C  0C0040AA   BNEZC T2, 0xBFD09FA0
BFD0879E      0C00   NOP
839:                 
840:                 	return pvReturn;
BFD087A0  0014FC5E   LW V0, 20(S8)
841:                 }
BFD087A4      0FBE   MOVE SP, S8
BFD087A6      4BE7   LW RA, 28(SP)
BFD087A8      4BC6   LW S8, 24(SP)
BFD087AA      4C11   ADDIU SP, SP, 32
BFD087AC      459F   JR16 RA
BFD087AE      0C00   NOP
842:                 /*-----------------------------------------------------------*/
843:                 
844:                 void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
845:                 {
BFD087B0      4FF1   ADDIU SP, SP, -32
BFD087B2      CBE7   SW RA, 28(SP)
BFD087B4      CBC6   SW S8, 24(SP)
BFD087B6      0FDD   MOVE S8, SP
BFD087B8  0020F89E   SW A0, 32(S8)
BFD087BC  0024F8BE   SW A1, 36(S8)
846:                 Timer_t * const pxTimer = ( Timer_t * ) xTimer;
BFD087C0  0020FC5E   LW V0, 32(S8)
BFD087C4  0010F85E   SW V0, 16(S8)
847:                 
848:                 	configASSERT( xTimer );
BFD087C8  0020FC5E   LW V0, 32(S8)
BFD087CC  000940A2   BNEZC V0, 0xBFD087E2
BFD087D0  BFD141A2   LUI V0, 0xBFD1
BFD087D2  3082BFD1   LDC1 F30, 12418(S1)
BFD087D4  9AE83082   ADDIU A0, V0, -25880
BFD087D6  30A09AE8   SWC1 F23, 12448(T0)
BFD087D8  035030A0   ADDIU A1, ZERO, 848
BFD087DC  4B7E77E8   JALS vAssertCalled
BFD087DE      4B7E   LW K1, 120(SP)
BFD087E0      0C00   NOP
849:                 
850:                 	taskENTER_CRITICAL();
BFD087E2  33B877E8   JALS vTaskEnterCritical
BFD087E4  0C0033B8   ADDIU SP, T8, 3072
BFD087E6      0C00   NOP
851:                 	{
852:                 		pxTimer->pvTimerID = pvNewID;
BFD087E8  0010FC5E   LW V0, 16(S8)
BFD087EC  0024FC7E   LW V1, 36(S8)
BFD087F0      E9A8   SW V1, 32(V0)
853:                 	}
854:                 	taskEXIT_CRITICAL();
BFD087F2  40AA77E8   JALS vTaskExitCritical
BFD087F4  0C0040AA   BNEZC T2, 0xBFD09FF8
BFD087F6      0C00   NOP
855:                 }
BFD087F8      0FBE   MOVE SP, S8
BFD087FA      4BE7   LW RA, 28(SP)
BFD087FC      4BC6   LW S8, 24(SP)
BFD087FE      4C11   ADDIU SP, SP, 32
BFD08800      459F   JR16 RA
BFD08802      0C00   NOP
856:                 /*-----------------------------------------------------------*/
857:                 
858:                 #if( INCLUDE_xTimerPendFunctionCall == 1 )
859:                 
860:                 	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
861:                 	{
BFD07F64      4FE9   ADDIU SP, SP, -48
BFD07F66      CBEB   SW RA, 44(SP)
BFD07F68      CBCA   SW S8, 40(SP)
BFD07F6A      0FDD   MOVE S8, SP
BFD07F6C  0030F89E   SW A0, 48(S8)
BFD07F70  0034F8BE   SW A1, 52(S8)
BFD07F74  0038F8DE   SW A2, 56(S8)
BFD07F78  003CF8FE   SW A3, 60(S8)
BFD07F7A  3040003C   SRL AT, GP, 6
862:                 	DaemonTaskMessage_t xMessage;
863:                 	BaseType_t xReturn;
864:                 
865:                 		/* Complete the message with the function parameters and post it to the
866:                 		daemon task. */
867:                 		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
BFD07F7C  FFFE3040   ADDIU V0, ZERO, -2
BFD07F7E  F85EFFFE   LW RA, -1954(S8)
BFD07F80  0014F85E   SW V0, 20(S8)
868:                 		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
BFD07F84  0030FC5E   LW V0, 48(S8)
BFD07F88  0018F85E   SW V0, 24(S8)
869:                 		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
BFD07F8C  0034FC5E   LW V0, 52(S8)
BFD07F90  001CF85E   SW V0, 28(S8)
870:                 		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
BFD07F94  0038FC5E   LW V0, 56(S8)
BFD07F98  0020F85E   SW V0, 32(S8)
871:                 
872:                 		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
BFD07F9C  8068FC7C   LW V1, -32664(GP)
BFD07FA0  0014305E   ADDIU V0, S8, 20
BFD07FA4      0C83   MOVE A0, V1
BFD07FA6      0CA2   MOVE A1, V0
BFD07FA8  003CFCDE   LW A2, 60(S8)
BFD07FAC      0CE0   MOVE A3, ZERO
BFD07FAE  11EA77E8   JALS xQueueGenericSendFromISR
BFD07FB0  0C0011EA   ADDI T7, T2, 3072
BFD07FB2      0C00   NOP
BFD07FB4  0010F85E   SW V0, 16(S8)
873:                 
874:                 		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
875:                 
876:                 		return xReturn;
BFD07FB8  0010FC5E   LW V0, 16(S8)
877:                 	}
BFD07FBC      0FBE   MOVE SP, S8
BFD07FBE      4BEB   LW RA, 44(SP)
BFD07FC0      4BCA   LW S8, 40(SP)
BFD07FC2      4C19   ADDIU SP, SP, 48
BFD07FC4      459F   JR16 RA
BFD07FC6      0C00   NOP
878:                 
879:                 #endif /* INCLUDE_xTimerPendFunctionCall */
880:                 /*-----------------------------------------------------------*/
881:                 
882:                 #if( INCLUDE_xTimerPendFunctionCall == 1 )
883:                 
884:                 	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
885:                 	{
BFD06D70      4FE9   ADDIU SP, SP, -48
BFD06D72      CBEB   SW RA, 44(SP)
BFD06D74      CBCA   SW S8, 40(SP)
BFD06D76      0FDD   MOVE S8, SP
BFD06D78  0030F89E   SW A0, 48(S8)
BFD06D7C  0034F8BE   SW A1, 52(S8)
BFD06D80  0038F8DE   SW A2, 56(S8)
BFD06D84  003CF8FE   SW A3, 60(S8)
886:                 	DaemonTaskMessage_t xMessage;
887:                 	BaseType_t xReturn;
888:                 
889:                 		/* This function can only be called after a timer has been created or
890:                 		after the scheduler has been started because, until then, the timer
891:                 		queue does not exist. */
892:                 		configASSERT( xTimerQueue );
BFD06D88  8068FC5C   LW V0, -32664(GP)
BFD06D8C  000940A2   BNEZC V0, 0xBFD06DA2
BFD06D90  BFD141A2   LUI V0, 0xBFD1
BFD06D92  3082BFD1   LDC1 F30, 12418(S1)
BFD06D94  9AE83082   ADDIU A0, V0, -25880
BFD06D96  30A09AE8   SWC1 F23, 12448(T0)
BFD06D98  037C30A0   ADDIU A1, ZERO, 892
BFD06D9C  4B7E77E8   JALS vAssertCalled
BFD06D9E      4B7E   LW K1, 120(SP)
BFD06DA0      0C00   NOP
893:                 
894:                 		/* Complete the message with the function parameters and post it to the
895:                 		daemon task. */
896:                 		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
BFD06DA2      ED7F   LI V0, -1
BFD06DA4  0014F85E   SW V0, 20(S8)
897:                 		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
BFD06DA8  0030FC5E   LW V0, 48(S8)
BFD06DAC  0018F85E   SW V0, 24(S8)
898:                 		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
BFD06DB0  0034FC5E   LW V0, 52(S8)
BFD06DB4  001CF85E   SW V0, 28(S8)
899:                 		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
BFD06DB8  0038FC5E   LW V0, 56(S8)
BFD06DBC  0020F85E   SW V0, 32(S8)
900:                 
901:                 		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
BFD06DC0  8068FC7C   LW V1, -32664(GP)
BFD06DC4  0014305E   ADDIU V0, S8, 20
BFD06DC8      0C83   MOVE A0, V1
BFD06DCA      0CA2   MOVE A1, V0
BFD06DCC  003CFCDE   LW A2, 60(S8)
BFD06DD0      0CE0   MOVE A3, ZERO
BFD06DD2  06A277E8   JALS xQueueGenericSend
BFD06DD4      06A2   ADDU A1, S1, V0
BFD06DD6      0C00   NOP
BFD06DD8  0010F85E   SW V0, 16(S8)
902:                 
903:                 		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
904:                 
905:                 		return xReturn;
BFD06DDC  0010FC5E   LW V0, 16(S8)
906:                 	}
BFD06DE0      0FBE   MOVE SP, S8
BFD06DE2      4BEB   LW RA, 44(SP)
BFD06DE4      4BCA   LW S8, 40(SP)
BFD06DE6      4C19   ADDIU SP, SP, 48
BFD06DE8      459F   JR16 RA
BFD06DEA      0C00   NOP
907:                 
908:                 #endif /* INCLUDE_xTimerPendFunctionCall */
909:                 /*-----------------------------------------------------------*/
910:                 
911:                 /* This entire source file will be skipped if the application is not configured
912:                 to include software timer functionality.  If you want to include software timer
913:                 functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
914:                 #endif /* configUSE_TIMERS == 1 */
915:                 
916:                 
917:                 
---  c:/e/dev/freertos/workingcopy/freertos/source/tasks.c  ---------------------------------------------
1:                   /*
2:                       FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /* Standard includes. */
71:                  #include <stdlib.h>
72:                  #include <string.h>
73:                  
74:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
75:                  all the API functions to use the MPU wrappers.  That should only be done when
76:                  task.h is included from an application file. */
77:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
78:                  
79:                  /* FreeRTOS includes. */
80:                  #include "FreeRTOS.h"
81:                  #include "task.h"
82:                  #include "timers.h"
83:                  #include "StackMacros.h"
84:                  
85:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
86:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
87:                  header files above, but not in this file, in order to generate the correct
88:                  privileged Vs unprivileged linkage and placement. */
89:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
90:                  
91:                  /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
92:                  functions but without including stdio.h here. */
93:                  #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
94:                  	/* At the bottom of this file are two optional functions that can be used
95:                  	to generate human readable text from the raw data generated by the
96:                  	uxTaskGetSystemState() function.  Note the formatting functions are provided
97:                  	for convenience only, and are NOT considered part of the kernel. */
98:                  	#include <stdio.h>
99:                  #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
100:                 
101:                 /* Sanity check the configuration. */
102:                 #if( configUSE_TICKLESS_IDLE != 0 )
103:                 	#if( INCLUDE_vTaskSuspend != 1 )
104:                 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
105:                 	#endif /* INCLUDE_vTaskSuspend */
106:                 #endif /* configUSE_TICKLESS_IDLE */
107:                 
108:                 /*
109:                  * Defines the size, in words, of the stack allocated to the idle task.
110:                  */
111:                 #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
112:                 
113:                 #if( configUSE_PREEMPTION == 0 )
114:                 	/* If the cooperative scheduler is being used then a yield should not be
115:                 	performed just because a higher priority task has been woken. */
116:                 	#define taskYIELD_IF_USING_PREEMPTION()
117:                 #else
118:                 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
119:                 #endif
120:                 
121:                 /* Value that can be assigned to the eNotifyState member of the TCB. */
122:                 typedef enum
123:                 {
124:                 	eNotWaitingNotification = 0,
125:                 	eWaitingNotification,
126:                 	eNotified
127:                 } eNotifyValue;
128:                 
129:                 /*
130:                  * Task control block.  A task control block (TCB) is allocated for each task,
131:                  * and stores task state information, including a pointer to the task's context
132:                  * (the task's run time environment, including register values)
133:                  */
134:                 typedef struct tskTaskControlBlock
135:                 {
136:                 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
137:                 
138:                 	#if ( portUSING_MPU_WRAPPERS == 1 )
139:                 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
140:                 		BaseType_t		xUsingStaticallyAllocatedStack; /* Set to pdTRUE if the stack is a statically allocated array, and pdFALSE if the stack is dynamically allocated. */
141:                 	#endif
142:                 
143:                 	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
144:                 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
145:                 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
146:                 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
147:                 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
148:                 
149:                 	#if ( portSTACK_GROWTH > 0 )
150:                 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
151:                 	#endif
152:                 
153:                 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
154:                 		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
155:                 	#endif
156:                 
157:                 	#if ( configUSE_TRACE_FACILITY == 1 )
158:                 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
159:                 		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
160:                 	#endif
161:                 
162:                 	#if ( configUSE_MUTEXES == 1 )
163:                 		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
164:                 		UBaseType_t 	uxMutexesHeld;
165:                 	#endif
166:                 
167:                 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
168:                 		TaskHookFunction_t pxTaskTag;
169:                 	#endif
170:                 
171:                 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
172:                 		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
173:                 	#endif
174:                 
175:                 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
176:                 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
177:                 	#endif
178:                 
179:                 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
180:                 		/* Allocate a Newlib reent structure that is specific to this task.
181:                 		Note Newlib support has been included by popular demand, but is not
182:                 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
183:                 		responsible for resulting newlib operation.  User must be familiar with
184:                 		newlib and must provide system-wide implementations of the necessary
185:                 		stubs. Be warned that (at the time of writing) the current newlib design
186:                 		implements a system-wide malloc() that must be provided with locks. */
187:                 		struct 	_reent xNewLib_reent;
188:                 	#endif
189:                 
190:                 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
191:                 		volatile uint32_t ulNotifiedValue;
192:                 		volatile eNotifyValue eNotifyState;
193:                 	#endif
194:                 
195:                 } tskTCB;
196:                 
197:                 /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
198:                 below to enable the use of older kernel aware debuggers. */
199:                 typedef tskTCB TCB_t;
200:                 
201:                 /*
202:                  * Some kernel aware debuggers require the data the debugger needs access to to
203:                  * be global, rather than file scope.
204:                  */
205:                 #ifdef portREMOVE_STATIC_QUALIFIER
206:                 	#define static
207:                 #endif
208:                 
209:                 /*lint -e956 A manual analysis and inspection has been used to determine which
210:                 static variables must be declared volatile. */
211:                 
212:                 PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
213:                 
214:                 /* Lists for ready and blocked tasks. --------------------*/
215:                 PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
216:                 PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
217:                 PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
218:                 PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
219:                 PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
220:                 PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
221:                 
222:                 #if ( INCLUDE_vTaskDelete == 1 )
223:                 
224:                 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
225:                 	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
226:                 
227:                 #endif
228:                 
229:                 #if ( INCLUDE_vTaskSuspend == 1 )
230:                 
231:                 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
232:                 
233:                 #endif
234:                 
235:                 #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
236:                 
237:                 	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
238:                 
239:                 #endif
240:                 
241:                 /* Other file private variables. --------------------------------*/
242:                 PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
243:                 PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
244:                 PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
245:                 PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
246:                 PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
247:                 PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
248:                 PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
249:                 PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
250:                 PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY; before the scheduler starts. */
251:                 
252:                 /* Context switches are held pending while the scheduler is suspended.  Also,
253:                 interrupts must not manipulate the xGenericListItem of a TCB, or any of the
254:                 lists the xGenericListItem can be referenced from, if the scheduler is suspended.
255:                 If an interrupt needs to unblock a task while the scheduler is suspended then it
256:                 moves the task's event list item into the xPendingReadyList, ready for the
257:                 kernel to move the task from the pending ready list into the real ready list
258:                 when the scheduler is unsuspended.  The pending ready list itself can only be
259:                 accessed from a critical section. */
260:                 PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
261:                 
262:                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
263:                 
264:                 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
265:                 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
266:                 
267:                 #endif
268:                 
269:                 /*lint +e956 */
270:                 
271:                 /* Debugging and trace facilities private variables and macros. ------------*/
272:                 
273:                 /*
274:                  * The value used to fill the stack of a task when the task is created.  This
275:                  * is used purely for checking the high water mark for tasks.
276:                  */
277:                 #define tskSTACK_FILL_BYTE	( 0xa5U )
278:                 
279:                 /*
280:                  * Macros used by vListTask to indicate which state a task is in.
281:                  */
282:                 #define tskBLOCKED_CHAR		( 'B' )
283:                 #define tskREADY_CHAR		( 'R' )
284:                 #define tskDELETED_CHAR		( 'D' )
285:                 #define tskSUSPENDED_CHAR	( 'S' )
286:                 
287:                 /*-----------------------------------------------------------*/
288:                 
289:                 #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
290:                 
291:                 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
292:                 	performed in a generic way that is not optimised to any particular
293:                 	microcontroller architecture. */
294:                 
295:                 	/* uxTopReadyPriority holds the priority of the highest priority ready
296:                 	state task. */
297:                 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
298:                 	{																									\
299:                 		if( ( uxPriority ) > uxTopReadyPriority )														\
300:                 		{																								\
301:                 			uxTopReadyPriority = ( uxPriority );														\
302:                 		}																								\
303:                 	} /* taskRECORD_READY_PRIORITY */
304:                 
305:                 	/*-----------------------------------------------------------*/
306:                 
307:                 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
308:                 	{																									\
309:                 		/* Find the highest priority queue that contains ready tasks. */								\
310:                 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
311:                 		{																								\
312:                 			configASSERT( uxTopReadyPriority );															\
313:                 			--uxTopReadyPriority;																		\
314:                 		}																								\
315:                 																										\
316:                 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
317:                 		the	same priority get an equal share of the processor time. */									\
318:                 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
319:                 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
320:                 
321:                 	/*-----------------------------------------------------------*/
322:                 
323:                 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
324:                 	they are only required when a port optimised method of task selection is
325:                 	being used. */
326:                 	#define taskRESET_READY_PRIORITY( uxPriority )
327:                 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
328:                 
329:                 #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
330:                 
331:                 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
332:                 	performed in a way that is tailored to the particular microcontroller
333:                 	architecture being used. */
334:                 
335:                 	/* A port optimised version is provided.  Call the port defined macros. */
336:                 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
337:                 
338:                 	/*-----------------------------------------------------------*/
339:                 
340:                 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
341:                 	{																								\
342:                 	UBaseType_t uxTopPriority;																		\
343:                 																									\
344:                 		/* Find the highest priority queue that contains ready tasks. */							\
345:                 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
346:                 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
347:                 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
348:                 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
349:                 
350:                 	/*-----------------------------------------------------------*/
351:                 
352:                 	/* A port optimised version is provided, call it only if the TCB being reset
353:                 	is being referenced from a ready list.  If it is referenced from a delayed
354:                 	or suspended list then it won't be in a ready list. */
355:                 	#define taskRESET_READY_PRIORITY( uxPriority )														\
356:                 	{																									\
357:                 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
358:                 		{																								\
359:                 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
360:                 		}																								\
361:                 	}
362:                 
363:                 #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
364:                 
365:                 /*-----------------------------------------------------------*/
366:                 
367:                 /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
368:                 count overflows. */
369:                 #define taskSWITCH_DELAYED_LISTS()																	\
370:                 {																									\
371:                 	List_t *pxTemp;																					\
372:                 																									\
373:                 	/* The delayed tasks list should be empty when the lists are switched. */						\
374:                 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
375:                 																									\
376:                 	pxTemp = pxDelayedTaskList;																		\
377:                 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
378:                 	pxOverflowDelayedTaskList = pxTemp;																\
379:                 	xNumOfOverflows++;																				\
380:                 	prvResetNextTaskUnblockTime();																	\
381:                 }
382:                 
383:                 /*-----------------------------------------------------------*/
384:                 
385:                 /*
386:                  * Place the task represented by pxTCB into the appropriate ready list for
387:                  * the task.  It is inserted at the end of the list.
388:                  */
389:                 #define prvAddTaskToReadyList( pxTCB )																\
390:                 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
391:                 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
392:                 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
393:                 /*-----------------------------------------------------------*/
394:                 
395:                 /*
396:                  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
397:                  * where NULL is used to indicate that the handle of the currently executing
398:                  * task should be used in place of the parameter.  This macro simply checks to
399:                  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
400:                  */
401:                 #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
402:                 
403:                 /* The item value of the event list item is normally used to hold the priority
404:                 of the task to which it belongs (coded to allow it to be held in reverse
405:                 priority order).  However, it is occasionally borrowed for other purposes.  It
406:                 is important its value is not updated due to a task priority change while it is
407:                 being used for another purpose.  The following bit definition is used to inform
408:                 the scheduler that the value should not be changed - in which case it is the
409:                 responsibility of whichever module is using the value to ensure it gets set back
410:                 to its original value when it is released. */
411:                 #if configUSE_16_BIT_TICKS == 1
412:                 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
413:                 #else
414:                 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
415:                 #endif
416:                 
417:                 /* Callback function prototypes. --------------------------*/
418:                 #if configCHECK_FOR_STACK_OVERFLOW > 0
419:                 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
420:                 #endif
421:                 
422:                 #if configUSE_TICK_HOOK > 0
423:                 	extern void vApplicationTickHook( void );
424:                 #endif
425:                 
426:                 /* File private functions. --------------------------------*/
427:                 
428:                 /*
429:                  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
430:                  * into the TCB structure.
431:                  */
432:                 static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
433:                 
434:                 /**
435:                  * Utility task that simply returns pdTRUE if the task referenced by xTask is
436:                  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
437:                  * is in any other state.
438:                  */
439:                 #if ( INCLUDE_vTaskSuspend == 1 )
440:                 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
441:                 #endif /* INCLUDE_vTaskSuspend */
442:                 
443:                 /*
444:                  * Utility to ready all the lists used by the scheduler.  This is called
445:                  * automatically upon the creation of the first task.
446:                  */
447:                 static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
448:                 
449:                 /*
450:                  * The idle task, which as all tasks is implemented as a never ending loop.
451:                  * The idle task is automatically created and added to the ready lists upon
452:                  * creation of the first user task.
453:                  *
454:                  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
455:                  * language extensions.  The equivalent prototype for this function is:
456:                  *
457:                  * void prvIdleTask( void *pvParameters );
458:                  *
459:                  */
460:                 static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
461:                 
462:                 /*
463:                  * Utility to free all memory allocated by the scheduler to hold a TCB,
464:                  * including the stack pointed to by the TCB.
465:                  *
466:                  * This does not free memory allocated by the task itself (i.e. memory
467:                  * allocated by calls to pvPortMalloc from within the tasks application code).
468:                  */
469:                 #if ( INCLUDE_vTaskDelete == 1 )
470:                 
471:                 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
472:                 
473:                 #endif
474:                 
475:                 /*
476:                  * Used only by the idle task.  This checks to see if anything has been placed
477:                  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
478:                  * and its TCB deleted.
479:                  */
480:                 static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
481:                 
482:                 /*
483:                  * The currently executing task is entering the Blocked state.  Add the task to
484:                  * either the current or the overflow delayed task list.
485:                  */
486:                 static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
487:                 
488:                 /*
489:                  * Allocates memory from the heap for a TCB and associated stack.  Checks the
490:                  * allocation was successful.
491:                  */
492:                 static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer ) PRIVILEGED_FUNCTION;
493:                 
494:                 /*
495:                  * Fills an TaskStatus_t structure with information on each task that is
496:                  * referenced from the pxList list (which may be a ready list, a delayed list,
497:                  * a suspended list, etc.).
498:                  *
499:                  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
500:                  * NORMAL APPLICATION CODE.
501:                  */
502:                 #if ( configUSE_TRACE_FACILITY == 1 )
503:                 
504:                 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
505:                 
506:                 #endif
507:                 
508:                 /*
509:                  * When a task is created, the stack of the task is filled with a known value.
510:                  * This function determines the 'high water mark' of the task stack by
511:                  * determining how much of the stack remains at the original preset value.
512:                  */
513:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
514:                 
515:                 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
516:                 
517:                 #endif
518:                 
519:                 /*
520:                  * Return the amount of time, in ticks, that will pass before the kernel will
521:                  * next move a task from the Blocked state to the Running state.
522:                  *
523:                  * This conditional compilation should use inequality to 0, not equality to 1.
524:                  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
525:                  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
526:                  * set to a value other than 1.
527:                  */
528:                 #if ( configUSE_TICKLESS_IDLE != 0 )
529:                 
530:                 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
531:                 
532:                 #endif
533:                 
534:                 /*
535:                  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
536:                  * will exit the Blocked state.
537:                  */
538:                 static void prvResetNextTaskUnblockTime( void );
539:                 
540:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
541:                 
542:                 	/*
543:                 	 * Helper function used to pad task names with spaces when printing out
544:                 	 * human readable tables of task information.
545:                 	 */
546:                 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );
547:                 
548:                 #endif
549:                 /*-----------------------------------------------------------*/
550:                 
551:                 BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
552:                 {
BFD01534      4FE9   ADDIU SP, SP, -48
BFD01536      CBEB   SW RA, 44(SP)
BFD01538      CBCA   SW S8, 40(SP)
BFD0153A      0FDD   MOVE S8, SP
BFD0153C  0030F89E   SW A0, 48(S8)
BFD01540  0034F8BE   SW A1, 52(S8)
BFD01544      0C46   MOVE V0, A2
BFD01546  003CF8FE   SW A3, 60(S8)
BFD0154A  0038385E   SH V0, 56(S8)
553:                 BaseType_t xReturn;
554:                 TCB_t * pxNewTCB;
555:                 StackType_t *pxTopOfStack;
556:                 
557:                 	configASSERT( pxTaskCode );
BFD0154E  0030FC5E   LW V0, 48(S8)
BFD01552  000940A2   BNEZC V0, 0xBFD01568
BFD01556  BFD141A2   LUI V0, 0xBFD1
BFD01558  3082BFD1   LDC1 F30, 12418(S1)
BFD0155A  98103082   ADDIU A0, V0, -26608
BFD0155C  30A09810   SWC1 F0, 12448(S0)
BFD0155E  022D30A0   ADDIU A1, ZERO, 557
BFD01562  4B7E77E8   JALS vAssertCalled
BFD01564      4B7E   LW K1, 120(SP)
BFD01566      0C00   NOP
558:                 	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
BFD01568  0040FC5E   LW V0, 64(S8)
BFD0156C  0005B042   SLTIU V0, V0, 5
BFD01570  000940A2   BNEZC V0, 0xBFD01586
BFD01574  BFD141A2   LUI V0, 0xBFD1
BFD01576  3082BFD1   LDC1 F30, 12418(S1)
BFD01578  98103082   ADDIU A0, V0, -26608
BFD0157A  30A09810   SWC1 F0, 12448(S0)
BFD0157C  022E30A0   ADDIU A1, ZERO, 558
BFD01580  4B7E77E8   JALS vAssertCalled
BFD01582      4B7E   LW K1, 120(SP)
BFD01584      0C00   NOP
559:                 
560:                 	/* Allocate the memory required by the TCB and stack for the new task,
561:                 	checking that the allocation was successful. */
562:                 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
BFD01586  0038345E   LHU V0, 56(S8)
BFD0158A      0C82   MOVE A0, V0
BFD0158C  0048FCBE   LW A1, 72(S8)
BFD01590  319477E8   JALS prvAllocateTCBAndStack
BFD01592  0C003194   ADDIU T4, S4, 3072
BFD01594      0C00   NOP
BFD01596  001CF85E   SW V0, 28(S8)
563:                 
564:                 	if( pxNewTCB != NULL )
BFD0159A  001CFC5E   LW V0, 28(S8)
BFD0159E  009A40E2   BEQZC V0, 0xBFD016D6
565:                 	{
566:                 		#if( portUSING_MPU_WRAPPERS == 1 )
567:                 			/* Should the task be created in privileged mode? */
568:                 			BaseType_t xRunPrivileged;
569:                 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
570:                 			{
571:                 				xRunPrivileged = pdTRUE;
572:                 			}
573:                 			else
574:                 			{
575:                 				xRunPrivileged = pdFALSE;
576:                 			}
577:                 			uxPriority &= ~portPRIVILEGE_BIT;
578:                 
579:                 			if( puxStackBuffer != NULL )
580:                 			{
581:                 				/* The application provided its own stack.  Note this so no
582:                 				attempt is made to delete the stack should that task be
583:                 				deleted. */
584:                 				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
585:                 			}
586:                 			else
587:                 			{
588:                 				/* The stack was allocated dynamically.  Note this so it can be
589:                 				deleted again if the task is deleted. */
590:                 				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
591:                 			}
592:                 		#endif /* portUSING_MPU_WRAPPERS == 1 */
593:                 
594:                 		/* Calculate the top of stack address.  This depends on whether the
595:                 		stack grows from high memory to low (as per the 80x86) or vice versa.
596:                 		portSTACK_GROWTH is used to make the result positive or negative as
597:                 		required by the port. */
598:                 		#if( portSTACK_GROWTH < 0 )
599:                 		{
600:                 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
BFD015A2  001CFC5E   LW V0, 28(S8)
BFD015A4  69AC001C   EXT ZERO, GP, 6, 14
BFD015A6      69AC   LW V1, 48(V0)
BFD015A8  0038345E   LHU V0, 56(S8)
BFD015AC      6D2E   ADDIU V0, V0, -1
BFD015AE      2524   SLL V0, V0, 2
BFD015B0      0526   ADDU V0, V1, V0
BFD015B2  0020F85E   SW V0, 32(S8)
601:                 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
BFD015B6  0020FC7E   LW V1, 32(S8)
BFD015B8  30400020   SRL AT, ZERO, 6
BFD015BA  FFF83040   ADDIU V0, ZERO, -8
BFD015BC  4493FFF8   LW RA, 17555(T8)
BFD015BE      4493   AND16 V0, V1
BFD015C0  0020F85E   SW V0, 32(S8)
602:                 
603:                 			/* Check the alignment of the calculated top of stack is correct. */
604:                 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
BFD015C4  0020FC5E   LW V0, 32(S8)
BFD015C8      2D25   ANDI V0, V0, 0x7
BFD015CA  000940E2   BEQZC V0, 0xBFD015E0
BFD015CE  BFD141A2   LUI V0, 0xBFD1
BFD015D0  3082BFD1   LDC1 F30, 12418(S1)
BFD015D2  98103082   ADDIU A0, V0, -26608
BFD015D4  30A09810   SWC1 F0, 12448(S0)
BFD015D6  025C30A0   ADDIU A1, ZERO, 604
BFD015DA  4B7E77E8   JALS vAssertCalled
BFD015DC      4B7E   LW K1, 120(SP)
BFD015DE      0C00   NOP
605:                 		}
606:                 		#else /* portSTACK_GROWTH */
607:                 		{
608:                 			pxTopOfStack = pxNewTCB->pxStack;
609:                 
610:                 			/* Check the alignment of the stack buffer is correct. */
611:                 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
612:                 
613:                 			/* If we want to use stack checking on architectures that use
614:                 			a positive stack growth direction then we also need to store the
615:                 			other extreme of the stack space. */
616:                 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
617:                 		}
618:                 		#endif /* portSTACK_GROWTH */
619:                 
620:                 		/* Setup the newly allocated TCB with the initial state of the task. */
621:                 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
BFD015E0  0038345E   LHU V0, 56(S8)
BFD015E4      C844   SW V0, 16(SP)
BFD015E6  001CFC9E   LW A0, 28(S8)
BFD015EA  0034FCBE   LW A1, 52(S8)
BFD015EE  0040FCDE   LW A2, 64(S8)
BFD015F2  004CFCFE   LW A3, 76(S8)
BFD015F6  1E7477E8   JALS prvInitialiseTCBVariables
BFD015F8  0C001E74   LB S3, 3072(S4)
BFD015FA      0C00   NOP
622:                 
623:                 		/* Initialize the TCB stack to look as if the task was already running,
624:                 		but had been interrupted by the scheduler.  The return address is set
625:                 		to the start of the task function. Once the stack has been initialised
626:                 		the	top of stack variable is updated. */
627:                 		#if( portUSING_MPU_WRAPPERS == 1 )
628:                 		{
629:                 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
630:                 		}
631:                 		#else /* portUSING_MPU_WRAPPERS */
632:                 		{
633:                 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
BFD015FC  0020FC9E   LW A0, 32(S8)
BFD01600  0030FCBE   LW A1, 48(S8)
BFD01604  003CFCDE   LW A2, 60(S8)
BFD01608  2B1877E8   JALS pxPortInitialiseStack
BFD0160A      2B18   LHU A2, 16(S1)
BFD0160C      0C00   NOP
BFD0160E      0C62   MOVE V1, V0
BFD01610  001CFC5E   LW V0, 28(S8)
BFD01614      E9A0   SW V1, 0(V0)
634:                 		}
635:                 		#endif /* portUSING_MPU_WRAPPERS */
636:                 
637:                 		if( ( void * ) pxCreatedTask != NULL )
BFD01616  0044FC5E   LW V0, 68(S8)
BFD0161A  000540E2   BEQZC V0, 0xBFD01628
638:                 		{
639:                 			/* Pass the TCB out - in an anonymous way.  The calling function/
640:                 			task can use this as a handle to delete the task later if
641:                 			required.*/
642:                 			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
BFD0161E  0044FC5E   LW V0, 68(S8)
BFD01622  001CFC7E   LW V1, 28(S8)
BFD01626      E9A0   SW V1, 0(V0)
643:                 		}
644:                 		else
645:                 		{
646:                 			mtCOVERAGE_TEST_MARKER();
647:                 		}
648:                 
649:                 		/* Ensure interrupts don't access the task lists while they are being
650:                 		updated. */
651:                 		taskENTER_CRITICAL();
BFD01628  33B877E8   JALS vTaskEnterCritical
BFD0162A  0C0033B8   ADDIU SP, T8, 3072
BFD0162C      0C00   NOP
652:                 		{
653:                 			uxCurrentNumberOfTasks++;
BFD0162E  8038FC5C   LW V0, -32712(GP)
BFD01632      6D20   ADDIU V0, V0, 1
BFD01634  8038F85C   SW V0, -32712(GP)
654:                 			if( pxCurrentTCB == NULL )
BFD01638  8030FC5C   LW V0, -32720(GP)
BFD0163C  000F40A2   BNEZC V0, 0xBFD0165E
655:                 			{
656:                 				/* There are no other tasks, or all the other tasks are in
657:                 				the suspended state - make this the current task. */
658:                 				pxCurrentTCB =  pxNewTCB;
BFD01640  001CFC5E   LW V0, 28(S8)
BFD01644  8030F85C   SW V0, -32720(GP)
659:                 
660:                 				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
BFD01648  8038FC7C   LW V1, -32712(GP)
BFD0164C      ED01   LI V0, 1
BFD0164E  0017B443   BNE V1, V0, 0xBFD01680
BFD01650  0C000017   SLL ZERO, S7, 1
BFD01652      0C00   NOP
661:                 				{
662:                 					/* This is the first task to be created so do the preliminary
663:                 					initialisation required.  We will not recover if this call
664:                 					fails, but we will report the failure. */
665:                 					prvInitialiseTaskLists();
BFD01654  309677E8   JALS prvInitialiseTaskLists
BFD01656  0C003096   ADDIU A0, S6, 3072
BFD01658      0C00   NOP
BFD0165A      CC12   B 0xBFD01680
BFD0165C      0C00   NOP
666:                 				}
667:                 				else
668:                 				{
669:                 					mtCOVERAGE_TEST_MARKER();
670:                 				}
671:                 			}
672:                 			else
673:                 			{
674:                 				/* If the scheduler is not already running, make this task the
675:                 				current task if it is the highest priority task to be created
676:                 				so far. */
677:                 				if( xSchedulerRunning == pdFALSE )
BFD0165E  8044FC5C   LW V0, -32700(GP)
BFD01662  000D40A2   BNEZC V0, 0xBFD01680
678:                 				{
679:                 					if( pxCurrentTCB->uxPriority <= uxPriority )
BFD01666  8030FC5C   LW V0, -32720(GP)
BFD0166A      69AB   LW V1, 44(V0)
BFD0166C  0040FC5E   LW V0, 64(S8)
BFD01670  13900062   SLTU V0, V0, V1
BFD01672  40A21390   ADDI GP, S0, 16546
BFD01674  000440A2   BNEZC V0, 0xBFD01680
680:                 					{
681:                 						pxCurrentTCB = pxNewTCB;
BFD01678  001CFC5E   LW V0, 28(S8)
BFD0167C  8030F85C   SW V0, -32720(GP)
682:                 					}
683:                 					else
684:                 					{
685:                 						mtCOVERAGE_TEST_MARKER();
686:                 					}
687:                 				}
688:                 				else
689:                 				{
690:                 					mtCOVERAGE_TEST_MARKER();
691:                 				}
692:                 			}
693:                 
694:                 			uxTaskNumber++;
BFD01680  8054FC5C   LW V0, -32684(GP)
BFD01684      6D20   ADDIU V0, V0, 1
BFD01686  8054F85C   SW V0, -32684(GP)
695:                 
696:                 			#if ( configUSE_TRACE_FACILITY == 1 )
697:                 			{
698:                 				/* Add a counter into the TCB for tracing only. */
699:                 				pxNewTCB->uxTCBNumber = uxTaskNumber;
700:                 			}
701:                 			#endif /* configUSE_TRACE_FACILITY */
702:                 			traceTASK_CREATE( pxNewTCB );
703:                 
704:                 			prvAddTaskToReadyList( pxNewTCB );
BFD0168A  001CFC5E   LW V0, 28(S8)
BFD0168E      692B   LW V0, 44(V0)
BFD01690      ED81   LI V1, 1
BFD01692  18100062   SLLV V1, V0, V1
BFD01694  FC5C1810   SB ZERO, -932(S0)
BFD01696  8040FC5C   LW V0, -32704(GP)
BFD0169A      44D3   OR16 V0, V1
BFD0169C  8040F85C   SW V0, -32704(GP)
BFD016A0  001CFC5E   LW V0, 28(S8)
BFD016A4      692B   LW V0, 44(V0)
BFD016A6      2524   SLL V0, V0, 2
BFD016A8      25A4   SLL V1, V0, 2
BFD016AA      05B4   ADDU V1, V0, V1
BFD016AC  BFD241A2   LUI V0, 0xBFD2
BFD016AE  3042BFD2   LDC1 F30, 12354(S2)
BFD016B0  806C3042   ADDIU V0, V0, -32660
BFD016B4      05A6   ADDU V1, V1, V0
BFD016B6  001CFC5E   LW V0, 28(S8)
BFD016BA      6D22   ADDIU V0, V0, 4
BFD016BC      0C83   MOVE A0, V1
BFD016BE      0CA2   MOVE A1, V0
BFD016C0  3E4A77E8   JALS vListInsertEnd
BFD016C2  0C003E4A   LH S2, 3072(T2)
BFD016C4      0C00   NOP
705:                 
706:                 			xReturn = pdPASS;
BFD016C6      ED01   LI V0, 1
BFD016C8  0018F85E   SW V0, 24(S8)
707:                 			portSETUP_TCB( pxNewTCB );
708:                 		}
709:                 		taskEXIT_CRITICAL();
BFD016CC  40AA77E8   JALS vTaskExitCritical
BFD016CE  0C0040AA   BNEZC T2, 0xBFD02ED2
BFD016D0      0C00   NOP
BFD016D2      CC04   B 0xBFD016DC
BFD016D4      0C00   NOP
710:                 	}
711:                 	else
712:                 	{
713:                 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
BFD016D6      ED7F   LI V0, -1
BFD016D8  0018F85E   SW V0, 24(S8)
714:                 		traceTASK_CREATE_FAILED();
715:                 	}
716:                 
717:                 	if( xReturn == pdPASS )
BFD016DC  0018FC7E   LW V1, 24(S8)
BFD016E0      ED01   LI V0, 1
BFD016E2  001EB443   BNE V1, V0, 0xBFD01722
BFD016E4  0C00001E   SLL ZERO, S8, 1
BFD016E6      0C00   NOP
718:                 	{
719:                 		if( xSchedulerRunning != pdFALSE )
BFD016E8  8044FC5C   LW V0, -32700(GP)
BFD016EC  001940E2   BEQZC V0, 0xBFD01722
720:                 		{
721:                 			/* If the created task is of a higher priority than the current task
722:                 			then it should run now. */
723:                 			if( pxCurrentTCB->uxPriority < uxPriority )
BFD016F0  8030FC5C   LW V0, -32720(GP)
BFD016F4      69AB   LW V1, 44(V0)
BFD016F6  0040FC5E   LW V0, 64(S8)
BFD016FA  13900043   SLTU V0, V1, V0
BFD016FC  40E21390   ADDI GP, S0, 16610
BFD016FE  001040E2   BEQZC V0, 0xBFD01722
724:                 			{
725:                 				taskYIELD_IF_USING_PREEMPTION();
BFD01702  4E5677E8   JALS ulPortGetCP0Cause
BFD01704      4E56   ADDIU S2, S2, -5
BFD01706      0C00   NOP
BFD01708  0024F85E   SW V0, 36(S8)
BFD0170C  0024FC5E   LW V0, 36(S8)
BFD01710  01005042   ORI V0, V0, 256
BFD01714  0024F85E   SW V0, 36(S8)
BFD01718  0024FC9E   LW A0, 36(S8)
BFD0171C  4E6677E8   JALS vPortSetCP0Cause
BFD0171E      4E66   ADDIU S3, S3, 3
BFD01720      0C00   NOP
726:                 			}
727:                 			else
728:                 			{
729:                 				mtCOVERAGE_TEST_MARKER();
730:                 			}
731:                 		}
732:                 		else
733:                 		{
734:                 			mtCOVERAGE_TEST_MARKER();
735:                 		}
736:                 	}
737:                 
738:                 	return xReturn;
BFD01722  0018FC5E   LW V0, 24(S8)
739:                 }
BFD01726      0FBE   MOVE SP, S8
BFD01728      4BEB   LW RA, 44(SP)
BFD0172A      4BCA   LW S8, 40(SP)
BFD0172C      4C19   ADDIU SP, SP, 48
BFD0172E      459F   JR16 RA
BFD01730      0C00   NOP
740:                 /*-----------------------------------------------------------*/
741:                 
742:                 #if ( INCLUDE_vTaskDelete == 1 )
743:                 
744:                 	void vTaskDelete( TaskHandle_t xTaskToDelete )
745:                 	{
BFD033F4      4FF1   ADDIU SP, SP, -32
BFD033F6      CBE7   SW RA, 28(SP)
BFD033F8      CBC6   SW S8, 24(SP)
BFD033FA      0FDD   MOVE S8, SP
BFD033FC  0020F89E   SW A0, 32(S8)
746:                 	TCB_t *pxTCB;
747:                 
748:                 		taskENTER_CRITICAL();
BFD03400  33B877E8   JALS vTaskEnterCritical
BFD03402  0C0033B8   ADDIU SP, T8, 3072
BFD03404      0C00   NOP
749:                 		{
750:                 			/* If null is passed in here then it is the calling task that is
751:                 			being deleted. */
752:                 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
BFD03406  0020FC5E   LW V0, 32(S8)
BFD0340A  000440A2   BNEZC V0, 0xBFD03416
BFD0340E  8030FC5C   LW V0, -32720(GP)
BFD03412      CC03   B 0xBFD0341A
BFD03414      0C00   NOP
BFD03416  0020FC5E   LW V0, 32(S8)
BFD0341A  0010F85E   SW V0, 16(S8)
753:                 
754:                 			/* Remove task from the ready list and place in the	termination list.
755:                 			This will stop the task from be scheduled.  The idle task will check
756:                 			the termination list and free up any memory allocated by the
757:                 			scheduler for the TCB and stack. */
758:                 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD0341E  0010FC5E   LW V0, 16(S8)
BFD03422      6D22   ADDIU V0, V0, 4
BFD03424      0C82   MOVE A0, V0
BFD03426  00C877E8   JALS uxListRemove
BFD03428  0C0000C8   SLL A2, T0, 1
BFD0342A      0C00   NOP
BFD0342C  001A40A2   BNEZC V0, 0xBFD03464
759:                 			{
760:                 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
BFD03430  0010FC5E   LW V0, 16(S8)
BFD03434      692B   LW V0, 44(V0)
BFD03436      2524   SLL V0, V0, 2
BFD03438      25A4   SLL V1, V0, 2
BFD0343A      05B4   ADDU V1, V0, V1
BFD0343C  BFD241A2   LUI V0, 0xBFD2
BFD0343E  3042BFD2   LDC1 F30, 12354(S2)
BFD03440  806C3042   ADDIU V0, V0, -32660
BFD03444      0526   ADDU V0, V1, V0
BFD03446      6920   LW V0, 0(V0)
BFD03448  000C40A2   BNEZC V0, 0xBFD03464
BFD0344C  0010FC5E   LW V0, 16(S8)
BFD03450      692B   LW V0, 44(V0)
BFD03452      ED81   LI V1, 1
BFD03454  10100062   SLLV V0, V0, V1
BFD03456  441A1010   ADDI ZERO, S0, 17434
BFD03458      441A   NOT16 V1, V0
BFD0345A  8040FC5C   LW V0, -32704(GP)
BFD0345E      4493   AND16 V0, V1
BFD03460  8040F85C   SW V0, -32704(GP)
761:                 			}
762:                 			else
763:                 			{
764:                 				mtCOVERAGE_TEST_MARKER();
765:                 			}
766:                 
767:                 			/* Is the task waiting on an event also? */
768:                 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
BFD03464  0010FC5E   LW V0, 16(S8)
BFD03468      692A   LW V0, 40(V0)
BFD0346A  000740E2   BEQZC V0, 0xBFD0347C
769:                 			{
770:                 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
BFD0346E  0010FC5E   LW V0, 16(S8)
BFD03470  6D2C0010   EXT ZERO, S0, 20, 14
BFD03472      6D2C   ADDIU V0, V0, 24
BFD03474      0C82   MOVE A0, V0
BFD03476  00C877E8   JALS uxListRemove
BFD03478  0C0000C8   SLL A2, T0, 1
BFD0347A      0C00   NOP
771:                 			}
772:                 			else
773:                 			{
774:                 				mtCOVERAGE_TEST_MARKER();
775:                 			}
776:                 
777:                 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
BFD0347C  0010FC5E   LW V0, 16(S8)
BFD03480      6D22   ADDIU V0, V0, 4
BFD03482  BFD241A3   LUI V1, 0xBFD2
BFD03484  3083BFD2   LDC1 F30, 12419(S2)
BFD03486  810C3083   ADDIU A0, V1, -32500
BFD0348A      0CA2   MOVE A1, V0
BFD0348C  3E4A77E8   JALS vListInsertEnd
BFD0348E  0C003E4A   LH S2, 3072(T2)
BFD03490      0C00   NOP
778:                 
779:                 			/* Increment the ucTasksDeleted variable so the idle task knows
780:                 			there is a task that has been deleted and that it should therefore
781:                 			check the xTasksWaitingTermination list. */
782:                 			++uxTasksDeleted;
BFD03492  8034FC5C   LW V0, -32716(GP)
BFD03496      6D20   ADDIU V0, V0, 1
BFD03498  8034F85C   SW V0, -32716(GP)
783:                 
784:                 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
785:                 			can detect that the task lists need re-generating. */
786:                 			uxTaskNumber++;
BFD0349C  8054FC5C   LW V0, -32684(GP)
BFD034A0      6D20   ADDIU V0, V0, 1
BFD034A2  8054F85C   SW V0, -32684(GP)
787:                 
788:                 			traceTASK_DELETE( pxTCB );
789:                 		}
790:                 		taskEXIT_CRITICAL();
BFD034A6  40AA77E8   JALS vTaskExitCritical
BFD034A8  0C0040AA   BNEZC T2, 0xBFD04CAC
BFD034AA      0C00   NOP
791:                 
792:                 		/* Force a reschedule if it is the currently running task that has just
793:                 		been deleted. */
794:                 		if( xSchedulerRunning != pdFALSE )
BFD034AC  8044FC5C   LW V0, -32700(GP)
BFD034B0  002F40E2   BEQZC V0, 0xBFD03512
795:                 		{
796:                 			if( pxTCB == pxCurrentTCB )
BFD034B4  8030FC5C   LW V0, -32720(GP)
BFD034B8  0010FC7E   LW V1, 16(S8)
BFD034BC  0020B443   BNE V1, V0, 0xBFD03500
BFD034BE  0C000020   SLL AT, ZERO, 1
BFD034C0      0C00   NOP
797:                 			{
798:                 				configASSERT( uxSchedulerSuspended == 0 );
BFD034C2  805CFC5C   LW V0, -32676(GP)
BFD034C6  000940E2   BEQZC V0, 0xBFD034DC
BFD034CA  BFD141A2   LUI V0, 0xBFD1
BFD034CC  3082BFD1   LDC1 F30, 12418(S1)
BFD034CE  98103082   ADDIU A0, V0, -26608
BFD034D0  30A09810   SWC1 F0, 12448(S0)
BFD034D2  031E30A0   ADDIU A1, ZERO, 798
BFD034D6  4B7E77E8   JALS vAssertCalled
BFD034D8      4B7E   LW K1, 120(SP)
BFD034DA      0C00   NOP
799:                 
800:                 				/* The pre-delete hook is primarily for the Windows simulator,
801:                 				in which Windows specific clean up operations are performed,
802:                 				after which it is not possible to yield away from this task -
803:                 				hence xYieldPending is used to latch that a context switch is
804:                 				required. */
805:                 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
806:                 				portYIELD_WITHIN_API();
BFD034DC  4E5677E8   JALS ulPortGetCP0Cause
BFD034DE      4E56   ADDIU S2, S2, -5
BFD034E0      0C00   NOP
BFD034E2  0014F85E   SW V0, 20(S8)
BFD034E6  0014FC5E   LW V0, 20(S8)
BFD034EA  01005042   ORI V0, V0, 256
BFD034EE  0014F85E   SW V0, 20(S8)
BFD034F2  0014FC9E   LW A0, 20(S8)
BFD034F6  4E6677E8   JALS vPortSetCP0Cause
BFD034F8      4E66   ADDIU S3, S3, 3
BFD034FA      0C00   NOP
BFD034FC      CC0A   B 0xBFD03512
BFD034FE      0C00   NOP
807:                 			}
808:                 			else
809:                 			{
810:                 				/* Reset the next expected unblock time in case it referred to
811:                 				the task that has just been deleted. */
812:                 				taskENTER_CRITICAL();
BFD03500  33B877E8   JALS vTaskEnterCritical
BFD03502  0C0033B8   ADDIU SP, T8, 3072
BFD03504      0C00   NOP
813:                 				{
814:                 					prvResetNextTaskUnblockTime();
BFD03506  47CA77E8   JALS prvResetNextTaskUnblockTime
BFD0350A      0C00   NOP
815:                 				}
816:                 				taskEXIT_CRITICAL();
BFD0350C  40AA77E8   JALS vTaskExitCritical
BFD0350E  0C0040AA   BNEZC T2, 0xBFD04D12
BFD03510      0C00   NOP
817:                 			}
818:                 		}
819:                 	}
BFD03512      0FBE   MOVE SP, S8
BFD03514      4BE7   LW RA, 28(SP)
BFD03516      4BC6   LW S8, 24(SP)
BFD03518      4C11   ADDIU SP, SP, 32
BFD0351A      459F   JR16 RA
BFD0351C      0C00   NOP
820:                 
821:                 #endif /* INCLUDE_vTaskDelete */
822:                 /*-----------------------------------------------------------*/
823:                 
824:                 #if ( INCLUDE_vTaskDelayUntil == 1 )
825:                 
826:                 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
827:                 	{
BFD00008      4FE9   ADDIU SP, SP, -48
BFD0000A      CBEB   SW RA, 44(SP)
BFD0000C      CBCA   SW S8, 40(SP)
BFD0000E      0FDD   MOVE S8, SP
BFD00010  0030F89E   SW A0, 48(S8)
BFD00014  0034F8BE   SW A1, 52(S8)
828:                 	TickType_t xTimeToWake;
829:                 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
BFD00018  0010F81E   SW ZERO, 16(S8)
830:                 
831:                 		configASSERT( pxPreviousWakeTime );
BFD0001C  0030FC5E   LW V0, 48(S8)
BFD00020  000940A2   BNEZC V0, 0xBFD00036
BFD00024  BFD141A2   LUI V0, 0xBFD1
BFD00026  3082BFD1   LDC1 F30, 12418(S1)
BFD00028  98103082   ADDIU A0, V0, -26608
BFD0002A  30A09810   SWC1 F0, 12448(S0)
BFD0002C  033F30A0   ADDIU A1, ZERO, 831
BFD00030  4B7E77E8   JALS vAssertCalled
BFD00032      4B7E   LW K1, 120(SP)
BFD00034      0C00   NOP
832:                 		configASSERT( ( xTimeIncrement > 0U ) );
BFD00036  0034FC5E   LW V0, 52(S8)
BFD0003A  000940A2   BNEZC V0, 0xBFD00050
BFD0003E  BFD141A2   LUI V0, 0xBFD1
BFD00040  3082BFD1   LDC1 F30, 12418(S1)
BFD00042  98103082   ADDIU A0, V0, -26608
BFD00044  30A09810   SWC1 F0, 12448(S0)
BFD00046  034030A0   ADDIU A1, ZERO, 832
BFD0004A  4B7E77E8   JALS vAssertCalled
BFD0004C      4B7E   LW K1, 120(SP)
BFD0004E      0C00   NOP
833:                 		configASSERT( uxSchedulerSuspended == 0 );
BFD00050  805CFC5C   LW V0, -32676(GP)
BFD00054  000940E2   BEQZC V0, 0xBFD0006A
BFD00058  BFD141A2   LUI V0, 0xBFD1
BFD0005A  3082BFD1   LDC1 F30, 12418(S1)
BFD0005C  98103082   ADDIU A0, V0, -26608
BFD0005E  30A09810   SWC1 F0, 12448(S0)
BFD00060  034130A0   ADDIU A1, ZERO, 833
BFD00064  4B7E77E8   JALS vAssertCalled
BFD00066      4B7E   LW K1, 120(SP)
BFD00068      0C00   NOP
834:                 
835:                 		vTaskSuspendAll();
BFD0006A  4EF477E8   JALS vTaskSuspendAll
BFD0006C      4EF4   ADDIU S7, S7, -6
BFD0006E      0C00   NOP
836:                 		{
837:                 			/* Minor optimisation.  The tick count cannot change in this
838:                 			block. */
839:                 			const TickType_t xConstTickCount = xTickCount;
BFD00070  803CFC5C   LW V0, -32708(GP)
BFD00074  0014F85E   SW V0, 20(S8)
840:                 
841:                 			/* Generate the tick time at which the task wants to wake. */
842:                 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
BFD00078  0030FC5E   LW V0, 48(S8)
BFD0007C      69A0   LW V1, 0(V0)
BFD0007E  0034FC5E   LW V0, 52(S8)
BFD00082      0526   ADDU V0, V1, V0
BFD00084  0018F85E   SW V0, 24(S8)
843:                 
844:                 			if( xConstTickCount < *pxPreviousWakeTime )
BFD00088  0030FC5E   LW V0, 48(S8)
BFD0008C      69A0   LW V1, 0(V0)
BFD0008E  0014FC5E   LW V0, 20(S8)
BFD00092  13900062   SLTU V0, V0, V1
BFD00094  40E21390   ADDI GP, S0, 16610
BFD00096  001640E2   BEQZC V0, 0xBFD000C6
845:                 			{
846:                 				/* The tick count has overflowed since this function was
847:                 				lasted called.  In this case the only time we should ever
848:                 				actually delay is if the wake time has also	overflowed,
849:                 				and the wake time is greater than the tick time.  When this
850:                 				is the case it is as if neither time had overflowed. */
851:                 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
BFD0009A  0030FC5E   LW V0, 48(S8)
BFD0009E      69A0   LW V1, 0(V0)
BFD000A0  0018FC5E   LW V0, 24(S8)
BFD000A4  13900062   SLTU V0, V0, V1
BFD000A6  40E21390   ADDI GP, S0, 16610
BFD000A8  002140E2   BEQZC V0, 0xBFD000EE
BFD000AC  0018FC7E   LW V1, 24(S8)
BFD000B0  0014FC5E   LW V0, 20(S8)
BFD000B4  13900062   SLTU V0, V0, V1
BFD000B6  40E21390   ADDI GP, S0, 16610
BFD000B8  001940E2   BEQZC V0, 0xBFD000EE
852:                 				{
853:                 					xShouldDelay = pdTRUE;
BFD000BC      ED01   LI V0, 1
BFD000BE  0010F85E   SW V0, 16(S8)
BFD000C2      CC15   B 0xBFD000EE
BFD000C4      0C00   NOP
854:                 				}
855:                 				else
856:                 				{
857:                 					mtCOVERAGE_TEST_MARKER();
858:                 				}
859:                 			}
860:                 			else
861:                 			{
862:                 				/* The tick time has not overflowed.  In this case we will
863:                 				delay if either the wake time has overflowed, and/or the
864:                 				tick time is less than the wake time. */
865:                 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
BFD000C6  0030FC5E   LW V0, 48(S8)
BFD000CA      69A0   LW V1, 0(V0)
BFD000CC  0018FC5E   LW V0, 24(S8)
BFD000D0  13900062   SLTU V0, V0, V1
BFD000D2  40A21390   ADDI GP, S0, 16546
BFD000D4  000840A2   BNEZC V0, 0xBFD000E8
BFD000D8  0018FC7E   LW V1, 24(S8)
BFD000DC  0014FC5E   LW V0, 20(S8)
BFD000E0  13900062   SLTU V0, V0, V1
BFD000E2  40E21390   ADDI GP, S0, 16610
BFD000E4  000340E2   BEQZC V0, 0xBFD000EE
866:                 				{
867:                 					xShouldDelay = pdTRUE;
BFD000E8      ED01   LI V0, 1
BFD000EA  0010F85E   SW V0, 16(S8)
868:                 				}
869:                 				else
870:                 				{
871:                 					mtCOVERAGE_TEST_MARKER();
872:                 				}
873:                 			}
874:                 
875:                 			/* Update the wake time ready for the next call. */
876:                 			*pxPreviousWakeTime = xTimeToWake;
BFD000EE  0030FC5E   LW V0, 48(S8)
BFD000F2  0018FC7E   LW V1, 24(S8)
BFD000F6      E9A0   SW V1, 0(V0)
877:                 
878:                 			if( xShouldDelay != pdFALSE )
BFD000F8  0010FC5E   LW V0, 16(S8)
BFD000FC  001A40E2   BEQZC V0, 0xBFD00134
879:                 			{
880:                 				traceTASK_DELAY_UNTIL();
881:                 
882:                 				/* Remove the task from the ready list before adding it to the
883:                 				blocked list as the same list item is used for both lists. */
884:                 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD00100  8030FC5C   LW V0, -32720(GP)
BFD00104      6D22   ADDIU V0, V0, 4
BFD00106      0C82   MOVE A0, V0
BFD00108  00C877E8   JALS uxListRemove
BFD0010A  0C0000C8   SLL A2, T0, 1
BFD0010C      0C00   NOP
BFD0010E  000C40A2   BNEZC V0, 0xBFD0012A
885:                 				{
886:                 					/* The current task must be in a ready list, so there is
887:                 					no need to check, and the port reset macro can be called
888:                 					directly. */
889:                 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
BFD00112  8030FC5C   LW V0, -32720(GP)
BFD00116      692B   LW V0, 44(V0)
BFD00118      ED81   LI V1, 1
BFD0011A  10100062   SLLV V0, V0, V1
BFD0011C  441A1010   ADDI ZERO, S0, 17434
BFD0011E      441A   NOT16 V1, V0
BFD00120  8040FC5C   LW V0, -32704(GP)
BFD00124      4493   AND16 V0, V1
BFD00126  8040F85C   SW V0, -32704(GP)
890:                 				}
891:                 				else
892:                 				{
893:                 					mtCOVERAGE_TEST_MARKER();
894:                 				}
895:                 
896:                 				prvAddCurrentTaskToDelayedList( xTimeToWake );
BFD0012A  0018FC9E   LW A0, 24(S8)
BFD0012E  373477E8   JALS prvAddCurrentTaskToDelayedList
BFD00130  0C003734   LHU T9, 3072(S4)
BFD00132      0C00   NOP
897:                 			}
898:                 			else
899:                 			{
900:                 				mtCOVERAGE_TEST_MARKER();
901:                 			}
902:                 		}
903:                 		xAlreadyYielded = xTaskResumeAll();
BFD00134  158E77E8   JALS xTaskResumeAll
BFD00136  0C00158E   LBU T4, 3072(T6)
BFD00138      0C00   NOP
BFD0013A  001CF85E   SW V0, 28(S8)
904:                 
905:                 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
906:                 		have put ourselves to sleep. */
907:                 		if( xAlreadyYielded == pdFALSE )
BFD0013E  001CFC5E   LW V0, 28(S8)
BFD00142  001040A2   BNEZC V0, 0xBFD00166
908:                 		{
909:                 			portYIELD_WITHIN_API();
BFD00146  4E5677E8   JALS ulPortGetCP0Cause
BFD00148      4E56   ADDIU S2, S2, -5
BFD0014A      0C00   NOP
BFD0014C  0020F85E   SW V0, 32(S8)
BFD00150  0020FC5E   LW V0, 32(S8)
BFD00154  01005042   ORI V0, V0, 256
BFD00158  0020F85E   SW V0, 32(S8)
BFD0015C  0020FC9E   LW A0, 32(S8)
BFD00160  4E6677E8   JALS vPortSetCP0Cause
BFD00162      4E66   ADDIU S3, S3, 3
BFD00164      0C00   NOP
910:                 		}
911:                 		else
912:                 		{
913:                 			mtCOVERAGE_TEST_MARKER();
914:                 		}
915:                 	}
BFD00166      0FBE   MOVE SP, S8
BFD00168      4BEB   LW RA, 44(SP)
BFD0016A      4BCA   LW S8, 40(SP)
BFD0016C      4C19   ADDIU SP, SP, 48
BFD0016E      459F   JR16 RA
BFD00170      0C00   NOP
916:                 
917:                 #endif /* INCLUDE_vTaskDelayUntil */
918:                 /*-----------------------------------------------------------*/
919:                 
920:                 #if ( INCLUDE_vTaskDelay == 1 )
921:                 
922:                 	void vTaskDelay( const TickType_t xTicksToDelay )
923:                 	{
BFD05BA0      4FED   ADDIU SP, SP, -40
BFD05BA2      CBE9   SW RA, 36(SP)
BFD05BA4      CBC8   SW S8, 32(SP)
BFD05BA6      0FDD   MOVE S8, SP
BFD05BA8  0028F89E   SW A0, 40(S8)
924:                 	TickType_t xTimeToWake;
925:                 	BaseType_t xAlreadyYielded = pdFALSE;
BFD05BAC  0010F81E   SW ZERO, 16(S8)
926:                 
927:                 
928:                 		/* A delay time of zero just forces a reschedule. */
929:                 		if( xTicksToDelay > ( TickType_t ) 0U )
BFD05BB0  0028FC5E   LW V0, 40(S8)
BFD05BB4  003640E2   BEQZC V0, 0xBFD05C24
930:                 		{
931:                 			configASSERT( uxSchedulerSuspended == 0 );
BFD05BB8  805CFC5C   LW V0, -32676(GP)
BFD05BBC  000940E2   BEQZC V0, 0xBFD05BD2
BFD05BC0  BFD141A2   LUI V0, 0xBFD1
BFD05BC2  3082BFD1   LDC1 F30, 12418(S1)
BFD05BC4  98103082   ADDIU A0, V0, -26608
BFD05BC6  30A09810   SWC1 F0, 12448(S0)
BFD05BC8  03A330A0   ADDIU A1, ZERO, 931
BFD05BCC  4B7E77E8   JALS vAssertCalled
BFD05BCE      4B7E   LW K1, 120(SP)
BFD05BD0      0C00   NOP
932:                 			vTaskSuspendAll();
BFD05BD2  4EF477E8   JALS vTaskSuspendAll
BFD05BD4      4EF4   ADDIU S7, S7, -6
BFD05BD6      0C00   NOP
933:                 			{
934:                 				traceTASK_DELAY();
935:                 
936:                 				/* A task that is removed from the event list while the
937:                 				scheduler is suspended will not get placed in the ready
938:                 				list or removed from the blocked list until the scheduler
939:                 				is resumed.
940:                 
941:                 				This task cannot be in an event list as it is the currently
942:                 				executing task. */
943:                 
944:                 				/* Calculate the time to wake - this may overflow but this is
945:                 				not a problem. */
946:                 				xTimeToWake = xTickCount + xTicksToDelay;
BFD05BD8  803CFC7C   LW V1, -32708(GP)
BFD05BDC  0028FC5E   LW V0, 40(S8)
BFD05BE0      0526   ADDU V0, V1, V0
BFD05BE2  0014F85E   SW V0, 20(S8)
947:                 
948:                 				/* We must remove ourselves from the ready list before adding
949:                 				ourselves to the blocked list as the same list item is used for
950:                 				both lists. */
951:                 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD05BE6  8030FC5C   LW V0, -32720(GP)
BFD05BEA      6D22   ADDIU V0, V0, 4
BFD05BEC      0C82   MOVE A0, V0
BFD05BEE  00C877E8   JALS uxListRemove
BFD05BF0  0C0000C8   SLL A2, T0, 1
BFD05BF2      0C00   NOP
BFD05BF4  000C40A2   BNEZC V0, 0xBFD05C10
952:                 				{
953:                 					/* The current task must be in a ready list, so there is
954:                 					no need to check, and the port reset macro can be called
955:                 					directly. */
956:                 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
BFD05BF8  8030FC5C   LW V0, -32720(GP)
BFD05BFC      692B   LW V0, 44(V0)
BFD05BFE      ED81   LI V1, 1
BFD05C00  10100062   SLLV V0, V0, V1
BFD05C02  441A1010   ADDI ZERO, S0, 17434
BFD05C04      441A   NOT16 V1, V0
BFD05C06  8040FC5C   LW V0, -32704(GP)
BFD05C0A      4493   AND16 V0, V1
BFD05C0C  8040F85C   SW V0, -32704(GP)
957:                 				}
958:                 				else
959:                 				{
960:                 					mtCOVERAGE_TEST_MARKER();
961:                 				}
962:                 				prvAddCurrentTaskToDelayedList( xTimeToWake );
BFD05C10  0014FC9E   LW A0, 20(S8)
BFD05C14  373477E8   JALS prvAddCurrentTaskToDelayedList
BFD05C16  0C003734   LHU T9, 3072(S4)
BFD05C18      0C00   NOP
963:                 			}
964:                 			xAlreadyYielded = xTaskResumeAll();
BFD05C1A  158E77E8   JALS xTaskResumeAll
BFD05C1C  0C00158E   LBU T4, 3072(T6)
BFD05C1E      0C00   NOP
BFD05C20  0010F85E   SW V0, 16(S8)
965:                 		}
966:                 		else
967:                 		{
968:                 			mtCOVERAGE_TEST_MARKER();
969:                 		}
970:                 
971:                 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
972:                 		have put ourselves to sleep. */
973:                 		if( xAlreadyYielded == pdFALSE )
BFD05C24  0010FC5E   LW V0, 16(S8)
BFD05C28  001040A2   BNEZC V0, 0xBFD05C4C
974:                 		{
975:                 			portYIELD_WITHIN_API();
BFD05C2C  4E5677E8   JALS ulPortGetCP0Cause
BFD05C2E      4E56   ADDIU S2, S2, -5
BFD05C30      0C00   NOP
BFD05C32  0018F85E   SW V0, 24(S8)
BFD05C36  0018FC5E   LW V0, 24(S8)
BFD05C3A  01005042   ORI V0, V0, 256
BFD05C3E  0018F85E   SW V0, 24(S8)
BFD05C42  0018FC9E   LW A0, 24(S8)
BFD05C46  4E6677E8   JALS vPortSetCP0Cause
BFD05C48      4E66   ADDIU S3, S3, 3
BFD05C4A      0C00   NOP
976:                 		}
977:                 		else
978:                 		{
979:                 			mtCOVERAGE_TEST_MARKER();
980:                 		}
981:                 	}
BFD05C4C      0FBE   MOVE SP, S8
BFD05C4E      4BE9   LW RA, 36(SP)
BFD05C50      4BC8   LW S8, 32(SP)
BFD05C52      4C15   ADDIU SP, SP, 40
BFD05C54      459F   JR16 RA
BFD05C56      0C00   NOP
982:                 
983:                 #endif /* INCLUDE_vTaskDelay */
984:                 /*-----------------------------------------------------------*/
985:                 
986:                 #if ( INCLUDE_eTaskGetState == 1 )
987:                 
988:                 	eTaskState eTaskGetState( TaskHandle_t xTask )
989:                 	{
BFD04494      4FED   ADDIU SP, SP, -40
BFD04496      CBE9   SW RA, 36(SP)
BFD04498      CBC8   SW S8, 32(SP)
BFD0449A      0FDD   MOVE S8, SP
BFD0449C  0028F89E   SW A0, 40(S8)
990:                 	eTaskState eReturn;
991:                 	List_t *pxStateList;
992:                 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
BFD044A0  0028FC5E   LW V0, 40(S8)
BFD044A4  0014F85E   SW V0, 20(S8)
993:                 
994:                 		configASSERT( pxTCB );
BFD044A8  0014FC5E   LW V0, 20(S8)
BFD044AC  000940A2   BNEZC V0, 0xBFD044C2
BFD044B0  BFD141A2   LUI V0, 0xBFD1
BFD044B2  3082BFD1   LDC1 F30, 12418(S1)
BFD044B4  98103082   ADDIU A0, V0, -26608
BFD044B6  30A09810   SWC1 F0, 12448(S0)
BFD044B8  03E230A0   ADDIU A1, ZERO, 994
BFD044BC  4B7E77E8   JALS vAssertCalled
BFD044BE      4B7E   LW K1, 120(SP)
BFD044C0      0C00   NOP
995:                 
996:                 		if( pxTCB == pxCurrentTCB )
BFD044C2  8030FC5C   LW V0, -32720(GP)
BFD044C6  0014FC7E   LW V1, 20(S8)
BFD044CA  0005B443   BNE V1, V0, 0xBFD044D8
BFD044CC  0C000005   SLL ZERO, A1, 1
BFD044CE      0C00   NOP
997:                 		{
998:                 			/* The task calling this function is querying its own state. */
999:                 			eReturn = eRunning;
BFD044D0  0010F81E   SW ZERO, 16(S8)
BFD044D4      CC48   B 0xBFD04566
BFD044D6      0C00   NOP
1000:                		}
1001:                		else
1002:                		{
1003:                			taskENTER_CRITICAL();
BFD044D8  33B877E8   JALS vTaskEnterCritical
BFD044DA  0C0033B8   ADDIU SP, T8, 3072
BFD044DC      0C00   NOP
1004:                			{
1005:                				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
BFD044DE  0014FC5E   LW V0, 20(S8)
BFD044E2      6925   LW V0, 20(V0)
BFD044E4  0018F85E   SW V0, 24(S8)
1006:                			}
1007:                			taskEXIT_CRITICAL();
BFD044E8  40AA77E8   JALS vTaskExitCritical
BFD044EA  0C0040AA   BNEZC T2, 0xBFD05CEE
BFD044EC      0C00   NOP
1008:                
1009:                			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
BFD044EE  8074FC5C   LW V0, -32652(GP)
BFD044F2  0018FC7E   LW V1, 24(S8)
BFD044F6  00089443   BEQ V1, V0, 0xBFD0450A
BFD044F8  0C000008   SLL ZERO, T0, 1
BFD044FA      0C00   NOP
BFD044FC  8078FC5C   LW V0, -32648(GP)
BFD04500  0018FC7E   LW V1, 24(S8)
BFD04504  0006B443   BNE V1, V0, 0xBFD04514
BFD04506  0C000006   SLL ZERO, A2, 1
BFD04508      0C00   NOP
1010:                			{
1011:                				/* The task being queried is referenced from one of the Blocked
1012:                				lists. */
1013:                				eReturn = eBlocked;
BFD0450A      ED02   LI V0, 2
BFD0450C  0010F85E   SW V0, 16(S8)
BFD04510      CC2A   B 0xBFD04566
BFD04512      0C00   NOP
1014:                			}
1015:                
1016:                			#if ( INCLUDE_vTaskSuspend == 1 )
1017:                				else if( pxStateList == &xSuspendedTaskList )
BFD04514  0018FC7E   LW V1, 24(S8)
BFD04518  BFD241A2   LUI V0, 0xBFD2
BFD0451A  3042BFD2   LDC1 F30, 12354(S2)
BFD0451C  80E43042   ADDIU V0, V0, -32540
BFD04520  0010B443   BNE V1, V0, 0xBFD04544
BFD04522  0C000010   SLL ZERO, S0, 1
BFD04524      0C00   NOP
1018:                				{
1019:                					/* The task being queried is referenced from the suspended
1020:                					list.  Is it genuinely suspended or is it block
1021:                					indefinitely? */
1022:                					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
BFD04526  0014FC5E   LW V0, 20(S8)
BFD0452A      692A   LW V0, 40(V0)
BFD0452C  000540A2   BNEZC V0, 0xBFD0453A
1023:                					{
1024:                						eReturn = eSuspended;
BFD04530      ED03   LI V0, 3
BFD04532  0010F85E   SW V0, 16(S8)
BFD04536      CC17   B 0xBFD04566
BFD04538      0C00   NOP
1025:                					}
1026:                					else
1027:                					{
1028:                						eReturn = eBlocked;
BFD0453A      ED02   LI V0, 2
BFD0453C  0010F85E   SW V0, 16(S8)
BFD04540      CC12   B 0xBFD04566
BFD04542      0C00   NOP
1029:                					}
1030:                				}
1031:                			#endif
1032:                
1033:                			#if ( INCLUDE_vTaskDelete == 1 )
1034:                				else if( pxStateList == &xTasksWaitingTermination )
BFD04544  0018FC7E   LW V1, 24(S8)
BFD04548  BFD241A2   LUI V0, 0xBFD2
BFD0454A  3042BFD2   LDC1 F30, 12354(S2)
BFD0454C  810C3042   ADDIU V0, V0, -32500
BFD04550  0006B443   BNE V1, V0, 0xBFD04560
BFD04552  0C000006   SLL ZERO, A2, 1
BFD04554      0C00   NOP
1035:                				{
1036:                					/* The task being queried is referenced from the deleted
1037:                					tasks list. */
1038:                					eReturn = eDeleted;
BFD04556      ED04   LI V0, 4
BFD04558  0010F85E   SW V0, 16(S8)
BFD0455C      CC04   B 0xBFD04566
BFD0455E      0C00   NOP
1039:                				}
1040:                			#endif
1041:                
1042:                			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1043:                			{
1044:                				/* If the task is not in any other state, it must be in the
1045:                				Ready (including pending ready) state. */
1046:                				eReturn = eReady;
BFD04560      ED01   LI V0, 1
BFD04562  0010F85E   SW V0, 16(S8)
1047:                			}
1048:                		}
1049:                
1050:                		return eReturn;
BFD04566  0010FC5E   LW V0, 16(S8)
1051:                	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
BFD0456A      0FBE   MOVE SP, S8
BFD0456C      4BE9   LW RA, 36(SP)
BFD0456E      4BC8   LW S8, 32(SP)
BFD04570      4C15   ADDIU SP, SP, 40
BFD04572      459F   JR16 RA
BFD04574      0C00   NOP
1052:                
1053:                #endif /* INCLUDE_eTaskGetState */
1054:                /*-----------------------------------------------------------*/
1055:                
1056:                #if ( INCLUDE_uxTaskPriorityGet == 1 )
1057:                
1058:                	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1059:                	{
BFD08B78      4FF1   ADDIU SP, SP, -32
BFD08B7A      CBE7   SW RA, 28(SP)
BFD08B7C      CBC6   SW S8, 24(SP)
BFD08B7E      0FDD   MOVE S8, SP
BFD08B80  0020F89E   SW A0, 32(S8)
1060:                	TCB_t *pxTCB;
1061:                	UBaseType_t uxReturn;
1062:                
1063:                		taskENTER_CRITICAL();
BFD08B84  33B877E8   JALS vTaskEnterCritical
BFD08B86  0C0033B8   ADDIU SP, T8, 3072
BFD08B88      0C00   NOP
1064:                		{
1065:                			/* If null is passed in here then we are changing the
1066:                			priority of the calling function. */
1067:                			pxTCB = prvGetTCBFromHandle( xTask );
BFD08B8A  0020FC5E   LW V0, 32(S8)
BFD08B8E  000440A2   BNEZC V0, 0xBFD08B9A
BFD08B92  8030FC5C   LW V0, -32720(GP)
BFD08B96      CC03   B 0xBFD08B9E
BFD08B98      0C00   NOP
BFD08B9A  0020FC5E   LW V0, 32(S8)
BFD08B9E  0010F85E   SW V0, 16(S8)
1068:                			uxReturn = pxTCB->uxPriority;
BFD08BA2  0010FC5E   LW V0, 16(S8)
BFD08BA6      692B   LW V0, 44(V0)
BFD08BA8  0014F85E   SW V0, 20(S8)
1069:                		}
1070:                		taskEXIT_CRITICAL();
BFD08BAC  40AA77E8   JALS vTaskExitCritical
BFD08BAE  0C0040AA   BNEZC T2, 0xBFD0A3B2
BFD08BB0      0C00   NOP
1071:                
1072:                		return uxReturn;
BFD08BB2  0014FC5E   LW V0, 20(S8)
1073:                	}
BFD08BB6      0FBE   MOVE SP, S8
BFD08BB8      4BE7   LW RA, 28(SP)
BFD08BBA      4BC6   LW S8, 24(SP)
BFD08BBC      4C11   ADDIU SP, SP, 32
BFD08BBE      459F   JR16 RA
BFD08BC0      0C00   NOP
1074:                
1075:                #endif /* INCLUDE_uxTaskPriorityGet */
1076:                /*-----------------------------------------------------------*/
1077:                
1078:                #if ( INCLUDE_uxTaskPriorityGet == 1 )
1079:                
1080:                	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1081:                	{
BFD08708      4FED   ADDIU SP, SP, -40
BFD0870A      CBE9   SW RA, 36(SP)
BFD0870C      CBC8   SW S8, 32(SP)
BFD0870E      0FDD   MOVE S8, SP
BFD08710  0028F89E   SW A0, 40(S8)
1082:                	TCB_t *pxTCB;
1083:                	UBaseType_t uxReturn, uxSavedInterruptState;
1084:                
1085:                		/* RTOS ports that support interrupt nesting have the concept of a
1086:                		maximum	system call (or maximum API call) interrupt priority.
1087:                		Interrupts that are	above the maximum system call priority are keep
1088:                		permanently enabled, even when the RTOS kernel is in a critical section,
1089:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1090:                		is defined in FreeRTOSConfig.h then
1091:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1092:                		failure if a FreeRTOS API function is called from an interrupt that has
1093:                		been assigned a priority above the configured maximum system call
1094:                		priority.  Only FreeRTOS functions that end in FromISR can be called
1095:                		from interrupts	that have been assigned a priority at or (logically)
1096:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
1097:                		separate interrupt safe API to ensure interrupt entry is as fast and as
1098:                		simple as possible.  More information (albeit Cortex-M specific) is
1099:                		provided on the following link:
1100:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1101:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1102:                
1103:                		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
BFD08714  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD08718      0C00   NOP
BFD0871A  0010F85E   SW V0, 16(S8)
1104:                		{
1105:                			/* If null is passed in here then it is the priority of the calling
1106:                			task that is being queried. */
1107:                			pxTCB = prvGetTCBFromHandle( xTask );
BFD0871E  0028FC5E   LW V0, 40(S8)
BFD08722  000440A2   BNEZC V0, 0xBFD0872E
BFD08726  8030FC5C   LW V0, -32720(GP)
BFD0872A      CC03   B 0xBFD08732
BFD0872C      0C00   NOP
BFD0872E  0028FC5E   LW V0, 40(S8)
BFD08732  0014F85E   SW V0, 20(S8)
1108:                			uxReturn = pxTCB->uxPriority;
BFD08736  0014FC5E   LW V0, 20(S8)
BFD0873A      692B   LW V0, 44(V0)
BFD0873C  0018F85E   SW V0, 24(S8)
1109:                		}
1110:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
BFD08740  0010FC9E   LW A0, 16(S8)
BFD08744  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD08746      4D5E   ADDIU T2, T2, -1
BFD08748      0C00   NOP
1111:                
1112:                		return uxReturn;
BFD0874A  0018FC5E   LW V0, 24(S8)
1113:                	}
BFD0874E      0FBE   MOVE SP, S8
BFD08750      4BE9   LW RA, 36(SP)
BFD08752      4BC8   LW S8, 32(SP)
BFD08754      4C15   ADDIU SP, SP, 40
BFD08756      459F   JR16 RA
BFD08758      0C00   NOP
1114:                
1115:                #endif /* INCLUDE_uxTaskPriorityGet */
1116:                /*-----------------------------------------------------------*/
1117:                
1118:                #if ( INCLUDE_vTaskPrioritySet == 1 )
1119:                
1120:                	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1121:                	{
BFD01924      4FE9   ADDIU SP, SP, -48
BFD01926      CBEB   SW RA, 44(SP)
BFD01928      CBCA   SW S8, 40(SP)
BFD0192A      0FDD   MOVE S8, SP
BFD0192C  0030F89E   SW A0, 48(S8)
BFD01930  0034F8BE   SW A1, 52(S8)
1122:                	TCB_t *pxTCB;
1123:                	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1124:                	BaseType_t xYieldRequired = pdFALSE;
BFD01934  0010F81E   SW ZERO, 16(S8)
1125:                
1126:                		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
BFD01938  0034FC5E   LW V0, 52(S8)
BFD0193C  0005B042   SLTIU V0, V0, 5
BFD01940  000940A2   BNEZC V0, 0xBFD01956
BFD01944  BFD141A2   LUI V0, 0xBFD1
BFD01946  3082BFD1   LDC1 F30, 12418(S1)
BFD01948  98103082   ADDIU A0, V0, -26608
BFD0194A  30A09810   SWC1 F0, 12448(S0)
BFD0194C  046630A0   ADDIU A1, ZERO, 1126
BFD0194E      0466   ADDU S0, V1, A2
BFD01950  4B7E77E8   JALS vAssertCalled
BFD01952      4B7E   LW K1, 120(SP)
BFD01954      0C00   NOP
1127:                
1128:                		/* Ensure the new priority is valid. */
1129:                		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
BFD01956  0034FC5E   LW V0, 52(S8)
BFD0195A  0005B042   SLTIU V0, V0, 5
BFD0195E  000340A2   BNEZC V0, 0xBFD01968
1130:                		{
1131:                			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
BFD01962      ED04   LI V0, 4
BFD01964  0034F85E   SW V0, 52(S8)
1132:                		}
1133:                		else
1134:                		{
1135:                			mtCOVERAGE_TEST_MARKER();
1136:                		}
1137:                
1138:                		taskENTER_CRITICAL();
BFD01968  33B877E8   JALS vTaskEnterCritical
BFD0196A  0C0033B8   ADDIU SP, T8, 3072
BFD0196C      0C00   NOP
1139:                		{
1140:                			/* If null is passed in here then it is the priority of the calling
1141:                			task that is being changed. */
1142:                			pxTCB = prvGetTCBFromHandle( xTask );
BFD0196E  0030FC5E   LW V0, 48(S8)
BFD01972  000440A2   BNEZC V0, 0xBFD0197E
BFD01976  8030FC5C   LW V0, -32720(GP)
BFD0197A      CC03   B 0xBFD01982
BFD0197C      0C00   NOP
BFD0197E  0030FC5E   LW V0, 48(S8)
BFD01982  0014F85E   SW V0, 20(S8)
1143:                
1144:                			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1145:                
1146:                			#if ( configUSE_MUTEXES == 1 )
1147:                			{
1148:                				uxCurrentBasePriority = pxTCB->uxBasePriority;
BFD01986  0014FC5E   LW V0, 20(S8)
BFD0198A  0040FC42   LW V0, 64(V0)
BFD0198E  0018F85E   SW V0, 24(S8)
1149:                			}
1150:                			#else
1151:                			{
1152:                				uxCurrentBasePriority = pxTCB->uxPriority;
1153:                			}
1154:                			#endif
1155:                
1156:                			if( uxCurrentBasePriority != uxNewPriority )
BFD01992  0018FC7E   LW V1, 24(S8)
BFD01996  0034FC5E   LW V0, 52(S8)
BFD0199A  00AD9443   BEQ V1, V0, 0xBFD01AF8
BFD0199C  0C0000AD   SLL A1, T5, 1
BFD0199E      0C00   NOP
1157:                			{
1158:                				/* The priority change may have readied a task of higher
1159:                				priority than the calling task. */
1160:                				if( uxNewPriority > uxCurrentBasePriority )
BFD019A0  0034FC7E   LW V1, 52(S8)
BFD019A4  0018FC5E   LW V0, 24(S8)
BFD019A8  13900062   SLTU V0, V0, V1
BFD019AA  40E21390   ADDI GP, S0, 16610
BFD019AC  001540E2   BEQZC V0, 0xBFD019DA
1161:                				{
1162:                					if( pxTCB != pxCurrentTCB )
BFD019B0  8030FC5C   LW V0, -32720(GP)
BFD019B4  0014FC7E   LW V1, 20(S8)
BFD019B8  00199443   BEQ V1, V0, 0xBFD019EE
BFD019BA  0C000019   SLL ZERO, T9, 1
BFD019BC      0C00   NOP
1163:                					{
1164:                						/* The priority of a task other than the currently
1165:                						running task is being raised.  Is the priority being
1166:                						raised above that of the running task? */
1167:                						if( uxNewPriority >= pxCurrentTCB->uxPriority )
BFD019BE  8030FC5C   LW V0, -32720(GP)
BFD019C2      69AB   LW V1, 44(V0)
BFD019C4  0034FC5E   LW V0, 52(S8)
BFD019C8  13900062   SLTU V0, V0, V1
BFD019CA  40A21390   ADDI GP, S0, 16546
BFD019CC  000F40A2   BNEZC V0, 0xBFD019EE
1168:                						{
1169:                							xYieldRequired = pdTRUE;
BFD019D0      ED01   LI V0, 1
BFD019D2  0010F85E   SW V0, 16(S8)
BFD019D6      CC0B   B 0xBFD019EE
BFD019D8      0C00   NOP
1170:                						}
1171:                						else
1172:                						{
1173:                							mtCOVERAGE_TEST_MARKER();
1174:                						}
1175:                					}
1176:                					else
1177:                					{
1178:                						/* The priority of the running task is being raised,
1179:                						but the running task must already be the highest
1180:                						priority task able to run so no yield is required. */
1181:                					}
1182:                				}
1183:                				else if( pxTCB == pxCurrentTCB )
BFD019DA  8030FC5C   LW V0, -32720(GP)
BFD019DE  0014FC7E   LW V1, 20(S8)
BFD019E2  0004B443   BNE V1, V0, 0xBFD019EE
BFD019E4  0C000004   SLL ZERO, A0, 1
BFD019E6      0C00   NOP
1184:                				{
1185:                					/* Setting the priority of the running task down means
1186:                					there may now be another task of higher priority that
1187:                					is ready to execute. */
1188:                					xYieldRequired = pdTRUE;
BFD019E8      ED01   LI V0, 1
BFD019EA  0010F85E   SW V0, 16(S8)
1189:                				}
1190:                				else
1191:                				{
1192:                					/* Setting the priority of any other task down does not
1193:                					require a yield as the running task must be above the
1194:                					new priority of the task being modified. */
1195:                				}
1196:                
1197:                				/* Remember the ready list the task might be referenced from
1198:                				before its uxPriority member is changed so the
1199:                				taskRESET_READY_PRIORITY() macro can function correctly. */
1200:                				uxPriorityUsedOnEntry = pxTCB->uxPriority;
BFD019EE  0014FC5E   LW V0, 20(S8)
BFD019F2      692B   LW V0, 44(V0)
BFD019F4  001CF85E   SW V0, 28(S8)
1201:                
1202:                				#if ( configUSE_MUTEXES == 1 )
1203:                				{
1204:                					/* Only change the priority being used if the task is not
1205:                					currently using an inherited priority. */
1206:                					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
BFD019F8  0014FC5E   LW V0, 20(S8)
BFD019FC  0040FC62   LW V1, 64(V0)
BFD01A00  0014FC5E   LW V0, 20(S8)
BFD01A04      692B   LW V0, 44(V0)
BFD01A06  0006B443   BNE V1, V0, 0xBFD01A16
BFD01A08  0C000006   SLL ZERO, A2, 1
BFD01A0A      0C00   NOP
1207:                					{
1208:                						pxTCB->uxPriority = uxNewPriority;
BFD01A0C  0014FC5E   LW V0, 20(S8)
BFD01A10  0034FC7E   LW V1, 52(S8)
BFD01A14      E9AB   SW V1, 44(V0)
1209:                					}
1210:                					else
1211:                					{
1212:                						mtCOVERAGE_TEST_MARKER();
1213:                					}
1214:                
1215:                					/* The base priority gets set whatever. */
1216:                					pxTCB->uxBasePriority = uxNewPriority;
BFD01A16  0014FC5E   LW V0, 20(S8)
BFD01A1A  0034FC7E   LW V1, 52(S8)
BFD01A1E  0040F862   SW V1, 64(V0)
1217:                				}
1218:                				#else
1219:                				{
1220:                					pxTCB->uxPriority = uxNewPriority;
1221:                				}
1222:                				#endif
1223:                
1224:                				/* Only reset the event list item value if the value is not
1225:                				being used for anything else. */
1226:                				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
BFD01A22  0014FC5E   LW V0, 20(S8)
BFD01A26      6926   LW V0, 24(V0)
BFD01A28  00084002   BLTZ V0, 0xBFD01A3C
BFD01A2A  0C000008   SLL ZERO, T0, 1
BFD01A2C      0C00   NOP
1227:                				{
1228:                					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
BFD01A2E      ED85   LI V1, 5
BFD01A30  0034FC5E   LW V0, 52(S8)
BFD01A34      05A7   SUBU V1, V1, V0
BFD01A36  0014FC5E   LW V0, 20(S8)
BFD01A3A      E9A6   SW V1, 24(V0)
1229:                				}
1230:                				else
1231:                				{
1232:                					mtCOVERAGE_TEST_MARKER();
1233:                				}
1234:                
1235:                				/* If the task is in the blocked or suspended list we need do
1236:                				nothing more than change it's priority variable. However, if
1237:                				the task is in a ready list it needs to be removed and placed
1238:                				in the list appropriate to its new priority. */
1239:                				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
BFD01A3C  0014FC5E   LW V0, 20(S8)
BFD01A3E  69A50014   LWX T5, 0(S4)
BFD01A40      69A5   LW V1, 20(V0)
BFD01A42  001CFC5E   LW V0, 28(S8)
BFD01A46      2524   SLL V0, V0, 2
BFD01A48      2624   SLL A0, V0, 2
BFD01A4A      0644   ADDU A0, V0, A0
BFD01A4C  BFD241A2   LUI V0, 0xBFD2
BFD01A4E  3042BFD2   LDC1 F30, 12354(S2)
BFD01A50  806C3042   ADDIU V0, V0, -32660
BFD01A54      0528   ADDU V0, A0, V0
BFD01A56  0004B443   BNE V1, V0, 0xBFD01A62
BFD01A58  0C000004   SLL ZERO, A0, 1
BFD01A5A      0C00   NOP
BFD01A5C      ED01   LI V0, 1
BFD01A5E      CC02   B 0xBFD01A64
BFD01A60      0C00   NOP
BFD01A62      0C40   MOVE V0, ZERO
BFD01A64  003240E2   BEQZC V0, 0xBFD01ACC
1240:                				{
1241:                					/* The task is currently in its ready list - remove before adding
1242:                					it to it's new ready list.  As we are in a critical section we
1243:                					can do this even if the scheduler is suspended. */
1244:                					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD01A68  0014FC5E   LW V0, 20(S8)
BFD01A6C      6D22   ADDIU V0, V0, 4
BFD01A6E      0C82   MOVE A0, V0
BFD01A70  00C877E8   JALS uxListRemove
BFD01A72  0C0000C8   SLL A2, T0, 1
BFD01A74      0C00   NOP
BFD01A76  000B40A2   BNEZC V0, 0xBFD01A90
1245:                					{
1246:                						/* It is known that the task is in its ready list so
1247:                						there is no need to check again and the port level
1248:                						reset macro can be called directly. */
1249:                						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
BFD01A7A  001CFC5E   LW V0, 28(S8)
BFD01A7E      ED81   LI V1, 1
BFD01A80  10100062   SLLV V0, V0, V1
BFD01A82  441A1010   ADDI ZERO, S0, 17434
BFD01A84      441A   NOT16 V1, V0
BFD01A86  8040FC5C   LW V0, -32704(GP)
BFD01A8A      4493   AND16 V0, V1
BFD01A8C  8040F85C   SW V0, -32704(GP)
1250:                					}
1251:                					else
1252:                					{
1253:                						mtCOVERAGE_TEST_MARKER();
1254:                					}
1255:                					prvAddTaskToReadyList( pxTCB );
BFD01A90  0014FC5E   LW V0, 20(S8)
BFD01A94      692B   LW V0, 44(V0)
BFD01A96      ED81   LI V1, 1
BFD01A98  18100062   SLLV V1, V0, V1
BFD01A9A  FC5C1810   SB ZERO, -932(S0)
BFD01A9C  8040FC5C   LW V0, -32704(GP)
BFD01AA0      44D3   OR16 V0, V1
BFD01AA2  8040F85C   SW V0, -32704(GP)
BFD01AA6  0014FC5E   LW V0, 20(S8)
BFD01AAA      692B   LW V0, 44(V0)
BFD01AAC      2524   SLL V0, V0, 2
BFD01AAE      25A4   SLL V1, V0, 2
BFD01AB0      05B4   ADDU V1, V0, V1
BFD01AB2  BFD241A2   LUI V0, 0xBFD2
BFD01AB4  3042BFD2   LDC1 F30, 12354(S2)
BFD01AB6  806C3042   ADDIU V0, V0, -32660
BFD01ABA      05A6   ADDU V1, V1, V0
BFD01ABC  0014FC5E   LW V0, 20(S8)
BFD01AC0      6D22   ADDIU V0, V0, 4
BFD01AC2      0C83   MOVE A0, V1
BFD01AC4      0CA2   MOVE A1, V0
BFD01AC6  3E4A77E8   JALS vListInsertEnd
BFD01AC8  0C003E4A   LH S2, 3072(T2)
BFD01ACA      0C00   NOP
1256:                				}
1257:                				else
1258:                				{
1259:                					mtCOVERAGE_TEST_MARKER();
1260:                				}
1261:                
1262:                				if( xYieldRequired == pdTRUE )
BFD01ACC  0010FC7E   LW V1, 16(S8)
BFD01AD0      ED01   LI V0, 1
BFD01AD2  0011B443   BNE V1, V0, 0xBFD01AF8
BFD01AD4  0C000011   SLL ZERO, S1, 1
BFD01AD6      0C00   NOP
1263:                				{
1264:                					taskYIELD_IF_USING_PREEMPTION();
BFD01AD8  4E5677E8   JALS ulPortGetCP0Cause
BFD01ADA      4E56   ADDIU S2, S2, -5
BFD01ADC      0C00   NOP
BFD01ADE  0020F85E   SW V0, 32(S8)
BFD01AE2  0020FC5E   LW V0, 32(S8)
BFD01AE6  01005042   ORI V0, V0, 256
BFD01AEA  0020F85E   SW V0, 32(S8)
BFD01AEE  0020FC9E   LW A0, 32(S8)
BFD01AF2  4E6677E8   JALS vPortSetCP0Cause
BFD01AF4      4E66   ADDIU S3, S3, 3
BFD01AF6      0C00   NOP
1265:                				}
1266:                				else
1267:                				{
1268:                					mtCOVERAGE_TEST_MARKER();
1269:                				}
1270:                
1271:                				/* Remove compiler warning about unused variables when the port
1272:                				optimised task selection is not being used. */
1273:                				( void ) uxPriorityUsedOnEntry;
1274:                			}
1275:                		}
1276:                		taskEXIT_CRITICAL();
BFD01AF8  40AA77E8   JALS vTaskExitCritical
BFD01AFA  0C0040AA   BNEZC T2, 0xBFD032FE
BFD01AFC      0C00   NOP
1277:                	}
BFD01AFE      0FBE   MOVE SP, S8
BFD01B00      4BEB   LW RA, 44(SP)
BFD01B02      4BCA   LW S8, 40(SP)
BFD01B04      4C19   ADDIU SP, SP, 48
BFD01B06      459F   JR16 RA
BFD01B08      0C00   NOP
1278:                
1279:                #endif /* INCLUDE_vTaskPrioritySet */
1280:                /*-----------------------------------------------------------*/
1281:                
1282:                #if ( INCLUDE_vTaskSuspend == 1 )
1283:                
1284:                	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1285:                	{
BFD0304C      4FF1   ADDIU SP, SP, -32
BFD0304E      CBE7   SW RA, 28(SP)
BFD03050      CBC6   SW S8, 24(SP)
BFD03052      0FDD   MOVE S8, SP
BFD03054  0020F89E   SW A0, 32(S8)
1286:                	TCB_t *pxTCB;
1287:                
1288:                		taskENTER_CRITICAL();
BFD03058  33B877E8   JALS vTaskEnterCritical
BFD0305A  0C0033B8   ADDIU SP, T8, 3072
BFD0305C      0C00   NOP
1289:                		{
1290:                			/* If null is passed in here then it is the running task that is
1291:                			being suspended. */
1292:                			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
BFD0305E  0020FC5E   LW V0, 32(S8)
BFD03062  000440A2   BNEZC V0, 0xBFD0306E
BFD03066  8030FC5C   LW V0, -32720(GP)
BFD0306A      CC03   B 0xBFD03072
BFD0306C      0C00   NOP
BFD0306E  0020FC5E   LW V0, 32(S8)
BFD03072  0010F85E   SW V0, 16(S8)
1293:                
1294:                			traceTASK_SUSPEND( pxTCB );
1295:                
1296:                			/* Remove task from the ready/delayed list and place in the
1297:                			suspended list. */
1298:                			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD03076  0010FC5E   LW V0, 16(S8)
BFD0307A      6D22   ADDIU V0, V0, 4
BFD0307C      0C82   MOVE A0, V0
BFD0307E  00C877E8   JALS uxListRemove
BFD03080  0C0000C8   SLL A2, T0, 1
BFD03082      0C00   NOP
BFD03084  001A40A2   BNEZC V0, 0xBFD030BC
1299:                			{
1300:                				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
BFD03088  0010FC5E   LW V0, 16(S8)
BFD0308C      692B   LW V0, 44(V0)
BFD0308E      2524   SLL V0, V0, 2
BFD03090      25A4   SLL V1, V0, 2
BFD03092      05B4   ADDU V1, V0, V1
BFD03094  BFD241A2   LUI V0, 0xBFD2
BFD03096  3042BFD2   LDC1 F30, 12354(S2)
BFD03098  806C3042   ADDIU V0, V0, -32660
BFD0309C      0526   ADDU V0, V1, V0
BFD0309E      6920   LW V0, 0(V0)
BFD030A0  000C40A2   BNEZC V0, 0xBFD030BC
BFD030A4  0010FC5E   LW V0, 16(S8)
BFD030A8      692B   LW V0, 44(V0)
BFD030AA      ED81   LI V1, 1
BFD030AC  10100062   SLLV V0, V0, V1
BFD030AE  441A1010   ADDI ZERO, S0, 17434
BFD030B0      441A   NOT16 V1, V0
BFD030B2  8040FC5C   LW V0, -32704(GP)
BFD030B6      4493   AND16 V0, V1
BFD030B8  8040F85C   SW V0, -32704(GP)
1301:                			}
1302:                			else
1303:                			{
1304:                				mtCOVERAGE_TEST_MARKER();
1305:                			}
1306:                
1307:                			/* Is the task waiting on an event also? */
1308:                			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
BFD030BC  0010FC5E   LW V0, 16(S8)
BFD030C0      692A   LW V0, 40(V0)
BFD030C2  000740E2   BEQZC V0, 0xBFD030D4
1309:                			{
1310:                				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
BFD030C6  0010FC5E   LW V0, 16(S8)
BFD030C8  6D2C0010   EXT ZERO, S0, 20, 14
BFD030CA      6D2C   ADDIU V0, V0, 24
BFD030CC      0C82   MOVE A0, V0
BFD030CE  00C877E8   JALS uxListRemove
BFD030D0  0C0000C8   SLL A2, T0, 1
BFD030D2      0C00   NOP
1311:                			}
1312:                			else
1313:                			{
1314:                				mtCOVERAGE_TEST_MARKER();
1315:                			}
1316:                
1317:                			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
BFD030D4  0010FC5E   LW V0, 16(S8)
BFD030D8      6D22   ADDIU V0, V0, 4
BFD030DA  BFD241A3   LUI V1, 0xBFD2
BFD030DC  3083BFD2   LDC1 F30, 12419(S2)
BFD030DE  80E43083   ADDIU A0, V1, -32540
BFD030E2      0CA2   MOVE A1, V0
BFD030E4  3E4A77E8   JALS vListInsertEnd
BFD030E6  0C003E4A   LH S2, 3072(T2)
BFD030E8      0C00   NOP
1318:                		}
1319:                		taskEXIT_CRITICAL();
BFD030EA  40AA77E8   JALS vTaskExitCritical
BFD030EC  0C0040AA   BNEZC T2, 0xBFD048F0
BFD030EE      0C00   NOP
1320:                
1321:                		if( pxTCB == pxCurrentTCB )
BFD030F0  8030FC5C   LW V0, -32720(GP)
BFD030F4  0010FC7E   LW V1, 16(S8)
BFD030F8  0036B443   BNE V1, V0, 0xBFD03168
BFD030FA  0C000036   SLL AT, S6, 1
BFD030FC      0C00   NOP
1322:                		{
1323:                			if( xSchedulerRunning != pdFALSE )
BFD030FE  8044FC5C   LW V0, -32700(GP)
BFD03102  001F40E2   BEQZC V0, 0xBFD03144
1324:                			{
1325:                				/* The current task has just been suspended. */
1326:                				configASSERT( uxSchedulerSuspended == 0 );
BFD03106  805CFC5C   LW V0, -32676(GP)
BFD0310A  000940E2   BEQZC V0, 0xBFD03120
BFD0310E  BFD141A2   LUI V0, 0xBFD1
BFD03110  3082BFD1   LDC1 F30, 12418(S1)
BFD03112  98103082   ADDIU A0, V0, -26608
BFD03114  30A09810   SWC1 F0, 12448(S0)
BFD03116  052E30A0   ADDIU A1, ZERO, 1326
BFD03118      052E   ADDU V0, A3, V0
BFD0311A  4B7E77E8   JALS vAssertCalled
BFD0311C      4B7E   LW K1, 120(SP)
BFD0311E      0C00   NOP
1327:                				portYIELD_WITHIN_API();
BFD03120  4E5677E8   JALS ulPortGetCP0Cause
BFD03122      4E56   ADDIU S2, S2, -5
BFD03124      0C00   NOP
BFD03126  0014F85E   SW V0, 20(S8)
BFD0312A  0014FC5E   LW V0, 20(S8)
BFD0312E  01005042   ORI V0, V0, 256
BFD03132  0014F85E   SW V0, 20(S8)
BFD03136  0014FC9E   LW A0, 20(S8)
BFD0313A  4E6677E8   JALS vPortSetCP0Cause
BFD0313C      4E66   ADDIU S3, S3, 3
BFD0313E      0C00   NOP
BFD03140      CC20   B 0xBFD03182
BFD03142      0C00   NOP
1328:                			}
1329:                			else
1330:                			{
1331:                				/* The scheduler is not running, but the task that was pointed
1332:                				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1333:                				must be adjusted to point to a different task. */
1334:                				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
BFD03144  BFD241A2   LUI V0, 0xBFD2
BFD03146  FC62BFD2   LDC1 F30, -926(S2)
BFD03148  80E4FC62   LW V1, -32540(V0)
BFD0314C  8038FC5C   LW V0, -32712(GP)
BFD03150  0005B443   BNE V1, V0, 0xBFD0315E
BFD03152  0C000005   SLL ZERO, A1, 1
BFD03154      0C00   NOP
1335:                				{
1336:                					/* No other tasks are ready, so set pxCurrentTCB back to
1337:                					NULL so when the next task is created pxCurrentTCB will
1338:                					be set to point to it no matter what its relative priority
1339:                					is. */
1340:                					pxCurrentTCB = NULL;
BFD03156  8030F81C   SW ZERO, -32720(GP)
BFD0315A      CC13   B 0xBFD03182
BFD0315C      0C00   NOP
1341:                				}
1342:                				else
1343:                				{
1344:                					vTaskSwitchContext();
BFD0315E  16DE77E8   JALS vTaskSwitchContext
BFD03160  0C0016DE   LBU S6, 3072(S8)
BFD03162      0C00   NOP
BFD03164      CC0E   B 0xBFD03182
BFD03166      0C00   NOP
1345:                				}
1346:                			}
1347:                		}
1348:                		else
1349:                		{
1350:                			if( xSchedulerRunning != pdFALSE )
BFD03168  8044FC5C   LW V0, -32700(GP)
BFD0316C  000940E2   BEQZC V0, 0xBFD03182
1351:                			{
1352:                				/* A task other than the currently running task was suspended,
1353:                				reset the next expected unblock time in case it referred to the
1354:                				task that is now in the Suspended state. */
1355:                				taskENTER_CRITICAL();
BFD03170  33B877E8   JALS vTaskEnterCritical
BFD03172  0C0033B8   ADDIU SP, T8, 3072
BFD03174      0C00   NOP
1356:                				{
1357:                					prvResetNextTaskUnblockTime();
BFD03176  47CA77E8   JALS prvResetNextTaskUnblockTime
BFD0317A      0C00   NOP
1358:                				}
1359:                				taskEXIT_CRITICAL();
BFD0317C  40AA77E8   JALS vTaskExitCritical
BFD0317E  0C0040AA   BNEZC T2, 0xBFD04982
BFD03180      0C00   NOP
1360:                			}
1361:                			else
1362:                			{
1363:                				mtCOVERAGE_TEST_MARKER();
1364:                			}
1365:                		}
1366:                	}
BFD03182      0FBE   MOVE SP, S8
BFD03184      4BE7   LW RA, 28(SP)
BFD03186      4BC6   LW S8, 24(SP)
BFD03188      4C11   ADDIU SP, SP, 32
BFD0318A      459F   JR16 RA
BFD0318C      0C00   NOP
1367:                
1368:                #endif /* INCLUDE_vTaskSuspend */
1369:                /*-----------------------------------------------------------*/
1370:                
1371:                #if ( INCLUDE_vTaskSuspend == 1 )
1372:                
1373:                	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1374:                	{
BFD066DC      4FF1   ADDIU SP, SP, -32
BFD066DE      CBE7   SW RA, 28(SP)
BFD066E0      CBC6   SW S8, 24(SP)
BFD066E2      0FDD   MOVE S8, SP
BFD066E4  0020F89E   SW A0, 32(S8)
1375:                	BaseType_t xReturn = pdFALSE;
BFD066E8  0010F81E   SW ZERO, 16(S8)
1376:                	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
BFD066EC  0020FC5E   LW V0, 32(S8)
BFD066F0  0014F85E   SW V0, 20(S8)
1377:                
1378:                		/* Accesses xPendingReadyList so must be called from a critical
1379:                		section. */
1380:                
1381:                		/* It does not make sense to check if the calling task is suspended. */
1382:                		configASSERT( xTask );
BFD066F4  0020FC5E   LW V0, 32(S8)
BFD066F8  000940A2   BNEZC V0, 0xBFD0670E
BFD066FC  BFD141A2   LUI V0, 0xBFD1
BFD066FE  3082BFD1   LDC1 F30, 12418(S1)
BFD06700  98103082   ADDIU A0, V0, -26608
BFD06702  30A09810   SWC1 F0, 12448(S0)
BFD06704  056630A0   ADDIU A1, ZERO, 1382
BFD06706      0566   ADDU V0, V1, A2
BFD06708  4B7E77E8   JALS vAssertCalled
BFD0670A      4B7E   LW K1, 120(SP)
BFD0670C      0C00   NOP
1383:                
1384:                		/* Is the task being resumed actually in the suspended list? */
1385:                		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
BFD0670E  0014FC5E   LW V0, 20(S8)
BFD06710  69A50014   LWX T5, 0(S4)
BFD06712      69A5   LW V1, 20(V0)
BFD06714  BFD241A2   LUI V0, 0xBFD2
BFD06716  3042BFD2   LDC1 F30, 12354(S2)
BFD06718  80E43042   ADDIU V0, V0, -32540
BFD0671C  0004B443   BNE V1, V0, 0xBFD06728
BFD0671E  0C000004   SLL ZERO, A0, 1
BFD06720      0C00   NOP
BFD06722      ED01   LI V0, 1
BFD06724      CC02   B 0xBFD0672A
BFD06726      0C00   NOP
BFD06728      0C40   MOVE V0, ZERO
BFD0672A  001840E2   BEQZC V0, 0xBFD0675E
1386:                		{
1387:                			/* Has the task already been resumed from within an ISR? */
1388:                			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
BFD0672E  0014FC5E   LW V0, 20(S8)
BFD06732      69AA   LW V1, 40(V0)
BFD06734  BFD241A2   LUI V0, 0xBFD2
BFD06736  3042BFD2   LDC1 F30, 12354(S2)
BFD06738  80D03042   ADDIU V0, V0, -32560
BFD0673C  000F9443   BEQ V1, V0, 0xBFD0675E
BFD0673E  0C00000F   SLL ZERO, T7, 1
BFD06740      0C00   NOP
1389:                			{
1390:                				/* Is it in the suspended list because it is in the	Suspended
1391:                				state, or because is is blocked with no timeout? */
1392:                				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
BFD06742  0014FC5E   LW V0, 20(S8)
BFD06746      692A   LW V0, 40(V0)
BFD06748  000340A2   BNEZC V0, 0xBFD06752
BFD0674C      ED01   LI V0, 1
BFD0674E      CC02   B 0xBFD06754
BFD06750      0C00   NOP
BFD06752      0C40   MOVE V0, ZERO
BFD06754  000340E2   BEQZC V0, 0xBFD0675E
1393:                				{
1394:                					xReturn = pdTRUE;
BFD06758      ED01   LI V0, 1
BFD0675A  0010F85E   SW V0, 16(S8)
1395:                				}
1396:                				else
1397:                				{
1398:                					mtCOVERAGE_TEST_MARKER();
1399:                				}
1400:                			}
1401:                			else
1402:                			{
1403:                				mtCOVERAGE_TEST_MARKER();
1404:                			}
1405:                		}
1406:                		else
1407:                		{
1408:                			mtCOVERAGE_TEST_MARKER();
1409:                		}
1410:                
1411:                		return xReturn;
BFD0675E  0010FC5E   LW V0, 16(S8)
1412:                	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
BFD06762      0FBE   MOVE SP, S8
BFD06764      4BE7   LW RA, 28(SP)
BFD06766      4BC6   LW S8, 24(SP)
BFD06768      4C11   ADDIU SP, SP, 32
BFD0676A      459F   JR16 RA
BFD0676C      0C00   NOP
1413:                
1414:                #endif /* INCLUDE_vTaskSuspend */
1415:                /*-----------------------------------------------------------*/
1416:                
1417:                #if ( INCLUDE_vTaskSuspend == 1 )
1418:                
1419:                	void vTaskResume( TaskHandle_t xTaskToResume )
1420:                	{
BFD040E4      4FF1   ADDIU SP, SP, -32
BFD040E6      CBE7   SW RA, 28(SP)
BFD040E8      CBC6   SW S8, 24(SP)
BFD040EA      0FDD   MOVE S8, SP
BFD040EC  0020F89E   SW A0, 32(S8)
1421:                	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
BFD040F0  0020FC5E   LW V0, 32(S8)
BFD040F4  0010F85E   SW V0, 16(S8)
1422:                
1423:                		/* It does not make sense to resume the calling task. */
1424:                		configASSERT( xTaskToResume );
BFD040F8  0020FC5E   LW V0, 32(S8)
BFD040FC  000940A2   BNEZC V0, 0xBFD04112
BFD04100  BFD141A2   LUI V0, 0xBFD1
BFD04102  3082BFD1   LDC1 F30, 12418(S1)
BFD04104  98103082   ADDIU A0, V0, -26608
BFD04106  30A09810   SWC1 F0, 12448(S0)
BFD04108  059030A0   ADDIU A1, ZERO, 1424
BFD0410A      0590   ADDU V1, S0, S1
BFD0410C  4B7E77E8   JALS vAssertCalled
BFD0410E      4B7E   LW K1, 120(SP)
BFD04110      0C00   NOP
1425:                
1426:                		/* The parameter cannot be NULL as it is impossible to resume the
1427:                		currently executing task. */
1428:                		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
BFD04112  0010FC5E   LW V0, 16(S8)
BFD04116  005640E2   BEQZC V0, 0xBFD041C6
BFD0411A  8030FC5C   LW V0, -32720(GP)
BFD0411E  0010FC7E   LW V1, 16(S8)
BFD04122  00509443   BEQ V1, V0, 0xBFD041C6
BFD04124  0C000050   SLL V0, S0, 1
BFD04126      0C00   NOP
1429:                		{
1430:                			taskENTER_CRITICAL();
BFD04128  33B877E8   JALS vTaskEnterCritical
BFD0412A  0C0033B8   ADDIU SP, T8, 3072
BFD0412C      0C00   NOP
1431:                			{
1432:                				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
BFD0412E  0010FC9E   LW A0, 16(S8)
BFD04132  336E77E8   JALS prvTaskIsTaskSuspended
BFD04134  0C00336E   ADDIU K1, T6, 3072
BFD04136      0C00   NOP
BFD04138      0C62   MOVE V1, V0
BFD0413A      ED01   LI V0, 1
BFD0413C  0040B443   BNE V1, V0, 0xBFD041C0
BFD0413E  0C000040   SLL V0, ZERO, 1
BFD04140      0C00   NOP
1433:                				{
1434:                					traceTASK_RESUME( pxTCB );
1435:                
1436:                					/* As we are in a critical section we can access the ready
1437:                					lists even if the scheduler is suspended. */
1438:                					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
BFD04142  0010FC5E   LW V0, 16(S8)
BFD04146      6D22   ADDIU V0, V0, 4
BFD04148      0C82   MOVE A0, V0
BFD0414A  00C877E8   JALS uxListRemove
BFD0414C  0C0000C8   SLL A2, T0, 1
BFD0414E      0C00   NOP
1439:                					prvAddTaskToReadyList( pxTCB );
BFD04150  0010FC5E   LW V0, 16(S8)
BFD04154      692B   LW V0, 44(V0)
BFD04156      ED81   LI V1, 1
BFD04158  18100062   SLLV V1, V0, V1
BFD0415A  FC5C1810   SB ZERO, -932(S0)
BFD0415C  8040FC5C   LW V0, -32704(GP)
BFD04160      44D3   OR16 V0, V1
BFD04162  8040F85C   SW V0, -32704(GP)
BFD04166  0010FC5E   LW V0, 16(S8)
BFD0416A      692B   LW V0, 44(V0)
BFD0416C      2524   SLL V0, V0, 2
BFD0416E      25A4   SLL V1, V0, 2
BFD04170      05B4   ADDU V1, V0, V1
BFD04172  BFD241A2   LUI V0, 0xBFD2
BFD04174  3042BFD2   LDC1 F30, 12354(S2)
BFD04176  806C3042   ADDIU V0, V0, -32660
BFD0417A      05A6   ADDU V1, V1, V0
BFD0417C  0010FC5E   LW V0, 16(S8)
BFD04180      6D22   ADDIU V0, V0, 4
BFD04182      0C83   MOVE A0, V1
BFD04184      0CA2   MOVE A1, V0
BFD04186  3E4A77E8   JALS vListInsertEnd
BFD04188  0C003E4A   LH S2, 3072(T2)
BFD0418A      0C00   NOP
1440:                
1441:                					/* We may have just resumed a higher priority task. */
1442:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
BFD0418C  0010FC5E   LW V0, 16(S8)
BFD04190      69AB   LW V1, 44(V0)
BFD04192  8030FC5C   LW V0, -32720(GP)
BFD04196      692B   LW V0, 44(V0)
BFD04198  13900043   SLTU V0, V1, V0
BFD0419A  40A21390   ADDI GP, S0, 16546
BFD0419C  001040A2   BNEZC V0, 0xBFD041C0
1443:                					{
1444:                						/* This yield may not cause the task just resumed to run,
1445:                						but will leave the lists in the correct state for the
1446:                						next yield. */
1447:                						taskYIELD_IF_USING_PREEMPTION();
BFD041A0  4E5677E8   JALS ulPortGetCP0Cause
BFD041A2      4E56   ADDIU S2, S2, -5
BFD041A4      0C00   NOP
BFD041A6  0014F85E   SW V0, 20(S8)
BFD041AA  0014FC5E   LW V0, 20(S8)
BFD041AE  01005042   ORI V0, V0, 256
BFD041B2  0014F85E   SW V0, 20(S8)
BFD041B6  0014FC9E   LW A0, 20(S8)
BFD041BA  4E6677E8   JALS vPortSetCP0Cause
BFD041BC      4E66   ADDIU S3, S3, 3
BFD041BE      0C00   NOP
1448:                					}
1449:                					else
1450:                					{
1451:                						mtCOVERAGE_TEST_MARKER();
1452:                					}
1453:                				}
1454:                				else
1455:                				{
1456:                					mtCOVERAGE_TEST_MARKER();
1457:                				}
1458:                			}
1459:                			taskEXIT_CRITICAL();
BFD041C0  40AA77E8   JALS vTaskExitCritical
BFD041C2  0C0040AA   BNEZC T2, 0xBFD059C6
BFD041C4      0C00   NOP
1460:                		}
1461:                		else
1462:                		{
1463:                			mtCOVERAGE_TEST_MARKER();
1464:                		}
1465:                	}
BFD041C6      0FBE   MOVE SP, S8
BFD041C8      4BE7   LW RA, 28(SP)
BFD041CA      4BC6   LW S8, 24(SP)
BFD041CC      4C11   ADDIU SP, SP, 32
BFD041CE      459F   JR16 RA
BFD041D0      0C00   NOP
1466:                
1467:                #endif /* INCLUDE_vTaskSuspend */
1468:                
1469:                /*-----------------------------------------------------------*/
1470:                
1471:                #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1472:                
1473:                	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1474:                	{
BFD041D4      4FED   ADDIU SP, SP, -40
BFD041D6      CBE9   SW RA, 36(SP)
BFD041D8      CBC8   SW S8, 32(SP)
BFD041DA      0FDD   MOVE S8, SP
BFD041DC  0028F89E   SW A0, 40(S8)
1475:                	BaseType_t xYieldRequired = pdFALSE;
BFD041E0  0010F81E   SW ZERO, 16(S8)
1476:                	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
BFD041E4  0028FC5E   LW V0, 40(S8)
BFD041E8  0014F85E   SW V0, 20(S8)
1477:                	UBaseType_t uxSavedInterruptStatus;
1478:                
1479:                		configASSERT( xTaskToResume );
BFD041EC  0028FC5E   LW V0, 40(S8)
BFD041F0  000940A2   BNEZC V0, 0xBFD04206
BFD041F4  BFD141A2   LUI V0, 0xBFD1
BFD041F6  3082BFD1   LDC1 F30, 12418(S1)
BFD041F8  98103082   ADDIU A0, V0, -26608
BFD041FA  30A09810   SWC1 F0, 12448(S0)
BFD041FC  05C730A0   ADDIU A1, ZERO, 1479
BFD041FE      05C7   SUBU V1, V1, A0
BFD04200  4B7E77E8   JALS vAssertCalled
BFD04202      4B7E   LW K1, 120(SP)
BFD04204      0C00   NOP
1480:                
1481:                		/* RTOS ports that support interrupt nesting have the concept of a
1482:                		maximum	system call (or maximum API call) interrupt priority.
1483:                		Interrupts that are	above the maximum system call priority are keep
1484:                		permanently enabled, even when the RTOS kernel is in a critical section,
1485:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1486:                		is defined in FreeRTOSConfig.h then
1487:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1488:                		failure if a FreeRTOS API function is called from an interrupt that has
1489:                		been assigned a priority above the configured maximum system call
1490:                		priority.  Only FreeRTOS functions that end in FromISR can be called
1491:                		from interrupts	that have been assigned a priority at or (logically)
1492:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
1493:                		separate interrupt safe API to ensure interrupt entry is as fast and as
1494:                		simple as possible.  More information (albeit Cortex-M specific) is
1495:                		provided on the following link:
1496:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1497:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1498:                
1499:                		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
BFD04206  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD0420A      0C00   NOP
BFD0420C  0018F85E   SW V0, 24(S8)
1500:                		{
1501:                			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
BFD04210  0014FC9E   LW A0, 20(S8)
BFD04214  336E77E8   JALS prvTaskIsTaskSuspended
BFD04216  0C00336E   ADDIU K1, T6, 3072
BFD04218      0C00   NOP
BFD0421A      0C62   MOVE V1, V0
BFD0421C      ED01   LI V0, 1
BFD0421E  0044B443   BNE V1, V0, 0xBFD042AA
BFD04220  0C000044   SLL V0, A0, 1
BFD04222      0C00   NOP
1502:                			{
1503:                				traceTASK_RESUME_FROM_ISR( pxTCB );
1504:                
1505:                				/* Check the ready lists can be accessed. */
1506:                				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
BFD04224  805CFC5C   LW V0, -32676(GP)
BFD04228  003440A2   BNEZC V0, 0xBFD04294
1507:                				{
1508:                					/* Ready lists can be accessed so move the task from the
1509:                					suspended list to the ready list directly. */
1510:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
BFD0422C  0014FC5E   LW V0, 20(S8)
BFD04230      69AB   LW V1, 44(V0)
BFD04232  8030FC5C   LW V0, -32720(GP)
BFD04236      692B   LW V0, 44(V0)
BFD04238  13900043   SLTU V0, V1, V0
BFD0423A  40A21390   ADDI GP, S0, 16546
BFD0423C  000340A2   BNEZC V0, 0xBFD04246
1511:                					{
1512:                						xYieldRequired = pdTRUE;
BFD04240      ED01   LI V0, 1
BFD04242  0010F85E   SW V0, 16(S8)
1513:                					}
1514:                					else
1515:                					{
1516:                						mtCOVERAGE_TEST_MARKER();
1517:                					}
1518:                
1519:                					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
BFD04246  0014FC5E   LW V0, 20(S8)
BFD0424A      6D22   ADDIU V0, V0, 4
BFD0424C      0C82   MOVE A0, V0
BFD0424E  00C877E8   JALS uxListRemove
BFD04250  0C0000C8   SLL A2, T0, 1
BFD04252      0C00   NOP
1520:                					prvAddTaskToReadyList( pxTCB );
BFD04254  0014FC5E   LW V0, 20(S8)
BFD04258      692B   LW V0, 44(V0)
BFD0425A      ED81   LI V1, 1
BFD0425C  18100062   SLLV V1, V0, V1
BFD0425E  FC5C1810   SB ZERO, -932(S0)
BFD04260  8040FC5C   LW V0, -32704(GP)
BFD04264      44D3   OR16 V0, V1
BFD04266  8040F85C   SW V0, -32704(GP)
BFD0426A  0014FC5E   LW V0, 20(S8)
BFD0426E      692B   LW V0, 44(V0)
BFD04270      2524   SLL V0, V0, 2
BFD04272      25A4   SLL V1, V0, 2
BFD04274      05B4   ADDU V1, V0, V1
BFD04276  BFD241A2   LUI V0, 0xBFD2
BFD04278  3042BFD2   LDC1 F30, 12354(S2)
BFD0427A  806C3042   ADDIU V0, V0, -32660
BFD0427E      05A6   ADDU V1, V1, V0
BFD04280  0014FC5E   LW V0, 20(S8)
BFD04284      6D22   ADDIU V0, V0, 4
BFD04286      0C83   MOVE A0, V1
BFD04288      0CA2   MOVE A1, V0
BFD0428A  3E4A77E8   JALS vListInsertEnd
BFD0428C  0C003E4A   LH S2, 3072(T2)
BFD0428E      0C00   NOP
BFD04290      CC0C   B 0xBFD042AA
BFD04292      0C00   NOP
1521:                				}
1522:                				else
1523:                				{
1524:                					/* The delayed or ready lists cannot be accessed so the task
1525:                					is held in the pending ready list until the scheduler is
1526:                					unsuspended. */
1527:                					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
BFD04294  0014FC5E   LW V0, 20(S8)
BFD04296  6D2C0014   EXT ZERO, S4, 20, 14
BFD04298      6D2C   ADDIU V0, V0, 24
BFD0429A  BFD241A3   LUI V1, 0xBFD2
BFD0429C  3083BFD2   LDC1 F30, 12419(S2)
BFD0429E  80D03083   ADDIU A0, V1, -32560
BFD042A2      0CA2   MOVE A1, V0
BFD042A4  3E4A77E8   JALS vListInsertEnd
BFD042A6  0C003E4A   LH S2, 3072(T2)
BFD042A8      0C00   NOP
1528:                				}
1529:                			}
1530:                			else
1531:                			{
1532:                				mtCOVERAGE_TEST_MARKER();
1533:                			}
1534:                		}
1535:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
BFD042AA  0018FC9E   LW A0, 24(S8)
BFD042AE  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD042B0      4D5E   ADDIU T2, T2, -1
BFD042B2      0C00   NOP
1536:                
1537:                		return xYieldRequired;
BFD042B4  0010FC5E   LW V0, 16(S8)
1538:                	}
BFD042B8      0FBE   MOVE SP, S8
BFD042BA      4BE9   LW RA, 36(SP)
BFD042BC      4BC8   LW S8, 32(SP)
BFD042BE      4C15   ADDIU SP, SP, 40
BFD042C0      459F   JR16 RA
BFD042C2      0C00   NOP
1539:                
1540:                #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1541:                /*-----------------------------------------------------------*/
1542:                
1543:                void vTaskStartScheduler( void )
1544:                {
BFD04AC0      4FE9   ADDIU SP, SP, -48
BFD04AC2      CBEB   SW RA, 44(SP)
BFD04AC4      CBCA   SW S8, 40(SP)
BFD04AC6      0FDD   MOVE S8, SP
1545:                BaseType_t xReturn;
1546:                
1547:                	/* Add the idle task at the lowest priority. */
1548:                	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1549:                	{
1550:                		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1551:                		be returned by the xTaskGetIdleTaskHandle() function. */
1552:                		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1553:                	}
1554:                	#else
1555:                	{
1556:                		/* Create the idle task without storing its handle. */
1557:                		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
BFD04AC8      C804   SW ZERO, 16(SP)
BFD04ACA      C805   SW ZERO, 20(SP)
BFD04ACC      C806   SW ZERO, 24(SP)
BFD04ACE      C807   SW ZERO, 28(SP)
BFD04AD0  BFD141A2   LUI V0, 0xBFD1
BFD04AD2  3082BFD1   LDC1 F30, 12418(S1)
BFD04AD4  8BC53082   ADDIU A0, V0, -29755
BFD04AD6      8BC5   SB A3, 5(A0)
BFD04AD8  BFD141A2   LUI V0, 0xBFD1
BFD04ADA  30A2BFD1   LDC1 F30, 12450(S1)
BFD04ADC  982830A2   ADDIU A1, V0, -26584
BFD04ADE  30C09828   SWC1 F1, 12480(T0)
BFD04AE0  00BE30C0   ADDIU A2, ZERO, 190
BFD04AE4      0CE0   MOVE A3, ZERO
BFD04AE6  0A9A77E8   JALS xTaskGenericCreate
BFD04AE8      0A9A   LBU A1, 10(S1)
BFD04AEA      0C00   NOP
BFD04AEC  0020F85E   SW V0, 32(S8)
1558:                	}
1559:                	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1560:                
1561:                	#if ( configUSE_TIMERS == 1 )
1562:                	{
1563:                		if( xReturn == pdPASS )
BFD04AF0  0020FC7E   LW V1, 32(S8)
BFD04AF4      ED01   LI V0, 1
BFD04AF6  0006B443   BNE V1, V0, 0xBFD04B06
BFD04AF8  0C000006   SLL ZERO, A2, 1
BFD04AFA      0C00   NOP
1564:                		{
1565:                			xReturn = xTimerCreateTimerTask();
BFD04AFC  3D3677E8   JALS xTimerCreateTimerTask
BFD04AFE  0C003D36   LH T1, 3072(S6)
BFD04B00      0C00   NOP
BFD04B02  0020F85E   SW V0, 32(S8)
1566:                		}
1567:                		else
1568:                		{
1569:                			mtCOVERAGE_TEST_MARKER();
1570:                		}
1571:                	}
1572:                	#endif /* configUSE_TIMERS */
1573:                
1574:                	if( xReturn == pdPASS )
BFD04B06  0020FC7E   LW V1, 32(S8)
BFD04B0A      ED01   LI V0, 1
BFD04B0C  0031B443   BNE V1, V0, 0xBFD04B72
BFD04B0E  0C000031   SLL AT, S1, 1
BFD04B10      0C00   NOP
1575:                	{
1576:                		/* Interrupts are turned off here, to ensure a tick does not occur
1577:                		before or during the call to xPortStartScheduler().  The stacks of
1578:                		the created tasks contain a status word with interrupts switched on
1579:                		so interrupts will automatically get re-enabled when the first task
1580:                		starts to run. */
1581:                		portDISABLE_INTERRUPTS();
BFD04B12  4E3677E8   JALS ulPortGetCP0Status
BFD04B14      4E36   ADDIU S1, S1, -5
BFD04B16      0C00   NOP
BFD04B18  0024F85E   SW V0, 36(S8)
BFD04B1C  0024FC7E   LW V1, 36(S8)
BFD04B20  000141A2   LUI V0, 0x1
BFD04B24  FC005042   ORI V0, V0, -1024
BFD04B26  4493FC00   LW ZERO, 17555(ZERO)
BFD04B28      4493   AND16 V0, V1
BFD04B2A  50400042   SRL V0, V0, 10
BFD04B2C  B0425040   ORI V0, ZERO, -20414
BFD04B2E  0003B042   SLTIU V0, V0, 3
BFD04B32  001140E2   BEQZC V0, 0xBFD04B58
BFD04B36  0024FC7E   LW V1, 36(S8)
BFD04B3A  FFFE41A2   LUI V0, 0xFFFE
BFD04B3C  5042FFFE   LW RA, 20546(S8)
BFD04B3E  03FF5042   ORI V0, V0, 1023
BFD04B42      4493   AND16 V0, V1
BFD04B44  0024F85E   SW V0, 36(S8)
BFD04B48  0024FC5E   LW V0, 36(S8)
BFD04B4C  0C005042   ORI V0, V0, 3072
BFD04B4E      0C00   NOP
BFD04B50      0C82   MOVE A0, V0
BFD04B52  4E4677E8   JALS vPortSetCP0Status
BFD04B54      4E46   ADDIU S2, S2, 3
BFD04B56      0C00   NOP
1582:                
1583:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1584:                		{
1585:                			/* Switch Newlib's _impure_ptr variable to point to the _reent
1586:                			structure specific to the task that will run first. */
1587:                			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1588:                		}
1589:                		#endif /* configUSE_NEWLIB_REENTRANT */
1590:                
1591:                		xNextTaskUnblockTime = portMAX_DELAY;
BFD04B58      ED7F   LI V0, -1
BFD04B5A  8058F85C   SW V0, -32680(GP)
1592:                		xSchedulerRunning = pdTRUE;
BFD04B5E      ED01   LI V0, 1
BFD04B60  8044F85C   SW V0, -32700(GP)
1593:                		xTickCount = ( TickType_t ) 0U;
BFD04B64  803CF81C   SW ZERO, -32708(GP)
1594:                
1595:                		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1596:                		macro must be defined to configure the timer/counter used to generate
1597:                		the run time counter time base. */
1598:                		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1599:                
1600:                		/* Setting up the timer tick is hardware specific and thus in the
1601:                		portable interface. */
1602:                		if( xPortStartScheduler() != pdFALSE )
BFD04B68  344C77E8   JALS xPortStartScheduler
BFD04B6A  0C00344C   LHU V0, 3072(T4)
BFD04B6C      0C00   NOP
BFD04B6E      CC0E   B 0xBFD04B8C
BFD04B70      0C00   NOP
1603:                		{
1604:                			/* Should not reach here as if the scheduler is running the
1605:                			function will not return. */
1606:                		}
1607:                		else
1608:                		{
1609:                			/* Should only reach here if a task calls xTaskEndScheduler(). */
1610:                		}
1611:                	}
1612:                	else
1613:                	{
1614:                		/* This line will only be reached if the kernel could not be started,
1615:                		because there was not enough FreeRTOS heap to create the idle task
1616:                		or the timer task. */
1617:                		configASSERT( xReturn );
BFD04B72  0020FC5E   LW V0, 32(S8)
BFD04B76  000940A2   BNEZC V0, 0xBFD04B8C
BFD04B7A  BFD141A2   LUI V0, 0xBFD1
BFD04B7C  3082BFD1   LDC1 F30, 12418(S1)
BFD04B7E  98103082   ADDIU A0, V0, -26608
BFD04B80  30A09810   SWC1 F0, 12448(S0)
BFD04B82  065130A0   ADDIU A1, ZERO, 1617
BFD04B84      0651   SUBU A0, S0, A1
BFD04B86  4B7E77E8   JALS vAssertCalled
BFD04B88      4B7E   LW K1, 120(SP)
BFD04B8A      0C00   NOP
1618:                	}
1619:                }
BFD04B8C      0FBE   MOVE SP, S8
BFD04B8E      4BEB   LW RA, 44(SP)
BFD04B90      4BCA   LW S8, 40(SP)
BFD04B92      4C19   ADDIU SP, SP, 48
BFD04B94      459F   JR16 RA
BFD04B96      0C00   NOP
1620:                /*-----------------------------------------------------------*/
1621:                
1622:                void vTaskEndScheduler( void )
1623:                {
BFD07F00      4FF1   ADDIU SP, SP, -32
BFD07F02      CBE7   SW RA, 28(SP)
BFD07F04      CBC6   SW S8, 24(SP)
BFD07F06      0FDD   MOVE S8, SP
1624:                	/* Stop the scheduler interrupts and call the portable scheduler end
1625:                	routine so the original ISRs can be restored if necessary.  The port
1626:                	layer must ensure interrupts enable	bit is left in the correct state. */
1627:                	portDISABLE_INTERRUPTS();
BFD07F08  4E3677E8   JALS ulPortGetCP0Status
BFD07F0A      4E36   ADDIU S1, S1, -5
BFD07F0C      0C00   NOP
BFD07F0E  0010F85E   SW V0, 16(S8)
BFD07F12  0010FC7E   LW V1, 16(S8)
BFD07F16  000141A2   LUI V0, 0x1
BFD07F1A  FC005042   ORI V0, V0, -1024
BFD07F1C  4493FC00   LW ZERO, 17555(ZERO)
BFD07F1E      4493   AND16 V0, V1
BFD07F20  50400042   SRL V0, V0, 10
BFD07F22  B0425040   ORI V0, ZERO, -20414
BFD07F24  0003B042   SLTIU V0, V0, 3
BFD07F28  001140E2   BEQZC V0, 0xBFD07F4E
BFD07F2C  0010FC7E   LW V1, 16(S8)
BFD07F30  FFFE41A2   LUI V0, 0xFFFE
BFD07F32  5042FFFE   LW RA, 20546(S8)
BFD07F34  03FF5042   ORI V0, V0, 1023
BFD07F38      4493   AND16 V0, V1
BFD07F3A  0010F85E   SW V0, 16(S8)
BFD07F3E  0010FC5E   LW V0, 16(S8)
BFD07F42  0C005042   ORI V0, V0, 3072
BFD07F44      0C00   NOP
BFD07F46      0C82   MOVE A0, V0
BFD07F48  4E4677E8   JALS vPortSetCP0Status
BFD07F4A      4E46   ADDIU S2, S2, 3
BFD07F4C      0C00   NOP
1628:                	xSchedulerRunning = pdFALSE;
BFD07F4E  8044F81C   SW ZERO, -32700(GP)
1629:                	vPortEndScheduler();
BFD07F52  4BD477E8   JALS vPortEndScheduler
BFD07F54      4BD4   LW S8, 80(SP)
BFD07F56      0C00   NOP
1630:                }
BFD07F58      0FBE   MOVE SP, S8
BFD07F5A      4BE7   LW RA, 28(SP)
BFD07F5C      4BC6   LW S8, 24(SP)
BFD07F5E      4C11   ADDIU SP, SP, 32
BFD07F60      459F   JR16 RA
BFD07F62      0C00   NOP
1631:                /*----------------------------------------------------------*/
1632:                
1633:                void vTaskSuspendAll( void )
1634:                {
BFD09DE8      4FB0   ADDIU SP, SP, -8
BFD09DEA      CBC1   SW S8, 4(SP)
BFD09DEC      0FDD   MOVE S8, SP
1635:                	/* A critical section is not required as the variable is of type
1636:                	BaseType_t.  Please read Richard Barry's reply in the following link to a
1637:                	post in the FreeRTOS support forum before reporting this as a bug! -
1638:                	http://goo.gl/wu4acr */
1639:                	++uxSchedulerSuspended;
BFD09DEE  805CFC5C   LW V0, -32676(GP)
BFD09DF2      6D20   ADDIU V0, V0, 1
BFD09DF4  805CF85C   SW V0, -32676(GP)
1640:                }
BFD09DF8      0FBE   MOVE SP, S8
BFD09DFA      4BC1   LW S8, 4(SP)
BFD09DFC      4C05   ADDIU SP, SP, 8
BFD09DFE      459F   JR16 RA
BFD09E00      0C00   NOP
1641:                /*----------------------------------------------------------*/
1642:                
1643:                #if ( configUSE_TICKLESS_IDLE != 0 )
1644:                
1645:                	static TickType_t prvGetExpectedIdleTime( void )
1646:                	{
1647:                	TickType_t xReturn;
1648:                
1649:                		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1650:                		{
1651:                			xReturn = 0;
1652:                		}
1653:                		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1654:                		{
1655:                			/* There are other idle priority tasks in the ready state.  If
1656:                			time slicing is used then the very next tick interrupt must be
1657:                			processed. */
1658:                			xReturn = 0;
1659:                		}
1660:                		else
1661:                		{
1662:                			xReturn = xNextTaskUnblockTime - xTickCount;
1663:                		}
1664:                
1665:                		return xReturn;
1666:                	}
1667:                
1668:                #endif /* configUSE_TICKLESS_IDLE */
1669:                /*----------------------------------------------------------*/
1670:                
1671:                BaseType_t xTaskResumeAll( void )
1672:                {
BFD02B1C      4FED   ADDIU SP, SP, -40
BFD02B1E      CBE9   SW RA, 36(SP)
BFD02B20      CBC8   SW S8, 32(SP)
BFD02B22      0FDD   MOVE S8, SP
1673:                TCB_t *pxTCB;
1674:                BaseType_t xAlreadyYielded = pdFALSE;
BFD02B24  0010F81E   SW ZERO, 16(S8)
1675:                
1676:                	/* If uxSchedulerSuspended is zero then this function does not match a
1677:                	previous call to vTaskSuspendAll(). */
1678:                	configASSERT( uxSchedulerSuspended );
BFD02B28  805CFC5C   LW V0, -32676(GP)
BFD02B2C  000940A2   BNEZC V0, 0xBFD02B42
BFD02B30  BFD141A2   LUI V0, 0xBFD1
BFD02B32  3082BFD1   LDC1 F30, 12418(S1)
BFD02B34  98103082   ADDIU A0, V0, -26608
BFD02B36  30A09810   SWC1 F0, 12448(S0)
BFD02B38  068E30A0   ADDIU A1, ZERO, 1678
BFD02B3A      068E   ADDU A1, A3, S0
BFD02B3C  4B7E77E8   JALS vAssertCalled
BFD02B3E      4B7E   LW K1, 120(SP)
BFD02B40      0C00   NOP
1679:                
1680:                	/* It is possible that an ISR caused a task to be removed from an event
1681:                	list while the scheduler was suspended.  If this was the case then the
1682:                	removed task will have been added to the xPendingReadyList.  Once the
1683:                	scheduler has been resumed it is safe to move all the pending ready
1684:                	tasks from this list into their appropriate ready list. */
1685:                	taskENTER_CRITICAL();
BFD02B42  33B877E8   JALS vTaskEnterCritical
BFD02B44  0C0033B8   ADDIU SP, T8, 3072
BFD02B46      0C00   NOP
1686:                	{
1687:                		--uxSchedulerSuspended;
BFD02B48  805CFC5C   LW V0, -32676(GP)
BFD02B4C      6D2E   ADDIU V0, V0, -1
BFD02B4E  805CF85C   SW V0, -32676(GP)
1688:                
1689:                		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
BFD02B52  805CFC5C   LW V0, -32676(GP)
BFD02B56  007D40A2   BNEZC V0, 0xBFD02C54
1690:                		{
1691:                			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
BFD02B5A  8038FC5C   LW V0, -32712(GP)
BFD02B5E  007940E2   BEQZC V0, 0xBFD02C54
1692:                			{
1693:                				/* Move any readied tasks from the pending list into the
1694:                				appropriate ready list. */
1695:                				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
BFD02B62      CC42   B 0xBFD02BE8
BFD02B64      0C00   NOP
BFD02BE8  BFD241A2   LUI V0, 0xBFD2
BFD02BEA  FC42BFD2   LDC1 F30, -958(S2)
BFD02BEC  80D0FC42   LW V0, -32560(V0)
BFD02BF0  FFB940A2   BNEZC V0, 0xBFD02B66
BFD02BF2  FC5CFFB9   LW SP, -932(T9)
1696:                				{
1697:                					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
BFD02B66  BFD241A2   LUI V0, 0xBFD2
BFD02B68  3042BFD2   LDC1 F30, 12354(S2)
BFD02B6A  80D03042   ADDIU V0, V0, -32560
BFD02B6E      6923   LW V0, 12(V0)
BFD02B70      6923   LW V0, 12(V0)
BFD02B72  0014F85E   SW V0, 20(S8)
1698:                					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
BFD02B76  0014FC5E   LW V0, 20(S8)
BFD02B78  6D2C0014   EXT ZERO, S4, 20, 14
BFD02B7A      6D2C   ADDIU V0, V0, 24
BFD02B7C      0C82   MOVE A0, V0
BFD02B7E  00C877E8   JALS uxListRemove
BFD02B80  0C0000C8   SLL A2, T0, 1
BFD02B82      0C00   NOP
1699:                					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
BFD02B84  0014FC5E   LW V0, 20(S8)
BFD02B88      6D22   ADDIU V0, V0, 4
BFD02B8A      0C82   MOVE A0, V0
BFD02B8C  00C877E8   JALS uxListRemove
BFD02B8E  0C0000C8   SLL A2, T0, 1
BFD02B90      0C00   NOP
1700:                					prvAddTaskToReadyList( pxTCB );
BFD02B92  0014FC5E   LW V0, 20(S8)
BFD02B96      692B   LW V0, 44(V0)
BFD02B98      ED81   LI V1, 1
BFD02B9A  18100062   SLLV V1, V0, V1
BFD02B9C  FC5C1810   SB ZERO, -932(S0)
BFD02B9E  8040FC5C   LW V0, -32704(GP)
BFD02BA2      44D3   OR16 V0, V1
BFD02BA4  8040F85C   SW V0, -32704(GP)
BFD02BA8  0014FC5E   LW V0, 20(S8)
BFD02BAC      692B   LW V0, 44(V0)
BFD02BAE      2524   SLL V0, V0, 2
BFD02BB0      25A4   SLL V1, V0, 2
BFD02BB2      05B4   ADDU V1, V0, V1
BFD02BB4  BFD241A2   LUI V0, 0xBFD2
BFD02BB6  3042BFD2   LDC1 F30, 12354(S2)
BFD02BB8  806C3042   ADDIU V0, V0, -32660
BFD02BBC      05A6   ADDU V1, V1, V0
BFD02BBE  0014FC5E   LW V0, 20(S8)
BFD02BC2      6D22   ADDIU V0, V0, 4
BFD02BC4      0C83   MOVE A0, V1
BFD02BC6      0CA2   MOVE A1, V0
BFD02BC8  3E4A77E8   JALS vListInsertEnd
BFD02BCA  0C003E4A   LH S2, 3072(T2)
BFD02BCC      0C00   NOP
1701:                
1702:                					/* If the moved task has a priority higher than the current
1703:                					task then a yield must be performed. */
1704:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
BFD02BCE  0014FC5E   LW V0, 20(S8)
BFD02BD2      69AB   LW V1, 44(V0)
BFD02BD4  8030FC5C   LW V0, -32720(GP)
BFD02BD8      692B   LW V0, 44(V0)
BFD02BDA  13900043   SLTU V0, V1, V0
BFD02BDC  40A21390   ADDI GP, S0, 16546
BFD02BDE  000340A2   BNEZC V0, 0xBFD02BE8
1705:                					{
1706:                						xYieldPending = pdTRUE;
BFD02BE2      ED01   LI V0, 1
BFD02BE4  804CF85C   SW V0, -32692(GP)
1707:                					}
1708:                					else
1709:                					{
1710:                						mtCOVERAGE_TEST_MARKER();
1711:                					}
1712:                				}
1713:                
1714:                				/* If any ticks occurred while the scheduler was suspended then
1715:                				they should be processed now.  This ensures the tick count does
1716:                				not	slip, and that any delayed tasks are resumed at the correct
1717:                				time. */
1718:                				if( uxPendedTicks > ( UBaseType_t ) 0U )
BFD02BF4  8048FC5C   LW V0, -32696(GP)
BFD02BF8  001340E2   BEQZC V0, 0xBFD02C22
1719:                				{
1720:                					while( uxPendedTicks > ( UBaseType_t ) 0U )
BFD02BFC      CC0E   B 0xBFD02C1A
BFD02BFE      0C00   NOP
BFD02C1A  8048FC5C   LW V0, -32696(GP)
BFD02C1E  FFEF40A2   BNEZC V0, 0xBFD02C00
BFD02C20  FC7CFFEF   LW RA, -900(T7)
1721:                					{
1722:                						if( xTaskIncrementTick() != pdFALSE )
BFD02C00  104077E8   JALS xTaskIncrementTick
BFD02C02  0C001040   ADDI V0, ZERO, 3072
BFD02C04      0C00   NOP
BFD02C06  000340E2   BEQZC V0, 0xBFD02C10
1723:                						{
1724:                							xYieldPending = pdTRUE;
BFD02C0A      ED01   LI V0, 1
BFD02C0C  804CF85C   SW V0, -32692(GP)
1725:                						}
1726:                						else
1727:                						{
1728:                							mtCOVERAGE_TEST_MARKER();
1729:                						}
1730:                						--uxPendedTicks;
BFD02C10  8048FC5C   LW V0, -32696(GP)
BFD02C14      6D2E   ADDIU V0, V0, -1
BFD02C16  8048F85C   SW V0, -32696(GP)
1731:                					}
1732:                				}
1733:                				else
1734:                				{
1735:                					mtCOVERAGE_TEST_MARKER();
1736:                				}
1737:                
1738:                				if( xYieldPending == pdTRUE )
BFD02C22  804CFC7C   LW V1, -32692(GP)
BFD02C26      ED01   LI V0, 1
BFD02C28  0014B443   BNE V1, V0, 0xBFD02C54
BFD02C2A  0C000014   SLL ZERO, S4, 1
BFD02C2C      0C00   NOP
1739:                				{
1740:                					#if( configUSE_PREEMPTION != 0 )
1741:                					{
1742:                						xAlreadyYielded = pdTRUE;
BFD02C2E      ED01   LI V0, 1
BFD02C30  0010F85E   SW V0, 16(S8)
1743:                					}
1744:                					#endif
1745:                					taskYIELD_IF_USING_PREEMPTION();
BFD02C34  4E5677E8   JALS ulPortGetCP0Cause
BFD02C36      4E56   ADDIU S2, S2, -5
BFD02C38      0C00   NOP
BFD02C3A  0018F85E   SW V0, 24(S8)
BFD02C3E  0018FC5E   LW V0, 24(S8)
BFD02C42  01005042   ORI V0, V0, 256
BFD02C46  0018F85E   SW V0, 24(S8)
BFD02C4A  0018FC9E   LW A0, 24(S8)
BFD02C4E  4E6677E8   JALS vPortSetCP0Cause
BFD02C50      4E66   ADDIU S3, S3, 3
BFD02C52      0C00   NOP
1746:                				}
1747:                				else
1748:                				{
1749:                					mtCOVERAGE_TEST_MARKER();
1750:                				}
1751:                			}
1752:                		}
1753:                		else
1754:                		{
1755:                			mtCOVERAGE_TEST_MARKER();
1756:                		}
1757:                	}
1758:                	taskEXIT_CRITICAL();
BFD02C54  40AA77E8   JALS vTaskExitCritical
BFD02C56  0C0040AA   BNEZC T2, 0xBFD0445A
BFD02C58      0C00   NOP
1759:                
1760:                	return xAlreadyYielded;
BFD02C5A  0010FC5E   LW V0, 16(S8)
1761:                }
BFD02C5E      0FBE   MOVE SP, S8
BFD02C60      4BE9   LW RA, 36(SP)
BFD02C62      4BC8   LW S8, 32(SP)
BFD02C64      4C15   ADDIU SP, SP, 40
BFD02C66      459F   JR16 RA
BFD02C68      0C00   NOP
1762:                /*-----------------------------------------------------------*/
1763:                
1764:                TickType_t xTaskGetTickCount( void )
1765:                {
BFD09994      4FF1   ADDIU SP, SP, -32
BFD09996      CBE7   SW RA, 28(SP)
BFD09998      CBC6   SW S8, 24(SP)
BFD0999A      0FDD   MOVE S8, SP
1766:                TickType_t xTicks;
1767:                
1768:                	/* Critical section required if running on a 16 bit processor. */
1769:                	portTICK_TYPE_ENTER_CRITICAL();
BFD0999C  33B877E8   JALS vTaskEnterCritical
BFD0999E  0C0033B8   ADDIU SP, T8, 3072
BFD099A0      0C00   NOP
1770:                	{
1771:                		xTicks = xTickCount;
BFD099A2  803CFC5C   LW V0, -32708(GP)
BFD099A6  0010F85E   SW V0, 16(S8)
1772:                	}
1773:                	portTICK_TYPE_EXIT_CRITICAL();
BFD099AA  40AA77E8   JALS vTaskExitCritical
BFD099AC  0C0040AA   BNEZC T2, 0xBFD0B1B0
BFD099AE      0C00   NOP
1774:                
1775:                	return xTicks;
BFD099B0  0010FC5E   LW V0, 16(S8)
1776:                }
BFD099B4      0FBE   MOVE SP, S8
BFD099B6      4BE7   LW RA, 28(SP)
BFD099B8      4BC6   LW S8, 24(SP)
BFD099BA      4C11   ADDIU SP, SP, 32
BFD099BC      459F   JR16 RA
BFD099BE      0C00   NOP
1777:                /*-----------------------------------------------------------*/
1778:                
1779:                TickType_t xTaskGetTickCountFromISR( void )
1780:                {
BFD09844      4FF1   ADDIU SP, SP, -32
BFD09846      CBE7   SW RA, 28(SP)
BFD09848      CBC6   SW S8, 24(SP)
BFD0984A      0FDD   MOVE S8, SP
1781:                TickType_t xReturn;
1782:                UBaseType_t uxSavedInterruptStatus;
1783:                
1784:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1785:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1786:                	above the maximum system call priority are kept permanently enabled, even
1787:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1788:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1789:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1790:                	failure if a FreeRTOS API function is called from an interrupt that has been
1791:                	assigned a priority above the configured maximum system call priority.
1792:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1793:                	that have been assigned a priority at or (logically) below the maximum
1794:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1795:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1796:                	More information (albeit Cortex-M specific) is provided on the following
1797:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1798:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1799:                
1800:                	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
BFD0984C  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD09850      0C00   NOP
BFD09852  0010F85E   SW V0, 16(S8)
1801:                	{
1802:                		xReturn = xTickCount;
BFD09856  803CFC5C   LW V0, -32708(GP)
BFD0985A  0014F85E   SW V0, 20(S8)
1803:                	}
1804:                	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
BFD0985E  0010FC9E   LW A0, 16(S8)
BFD09862  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD09864      4D5E   ADDIU T2, T2, -1
BFD09866      0C00   NOP
1805:                
1806:                	return xReturn;
BFD09868  0014FC5E   LW V0, 20(S8)
1807:                }
BFD0986C      0FBE   MOVE SP, S8
BFD0986E      4BE7   LW RA, 28(SP)
BFD09870      4BC6   LW S8, 24(SP)
BFD09872      4C11   ADDIU SP, SP, 32
BFD09874      459F   JR16 RA
BFD09876      0C00   NOP
1808:                /*-----------------------------------------------------------*/
1809:                
1810:                UBaseType_t uxTaskGetNumberOfTasks( void )
1811:                {
BFD09E98      4FB0   ADDIU SP, SP, -8
BFD09E9A      CBC1   SW S8, 4(SP)
BFD09E9C      0FDD   MOVE S8, SP
1812:                	/* A critical section is not required because the variables are of type
1813:                	BaseType_t. */
1814:                	return uxCurrentNumberOfTasks;
BFD09E9E  8038FC5C   LW V0, -32712(GP)
1815:                }
BFD09EA2      0FBE   MOVE SP, S8
BFD09EA4      4BC1   LW S8, 4(SP)
BFD09EA6      4C05   ADDIU SP, SP, 8
BFD09EA8      459F   JR16 RA
BFD09EAA      0C00   NOP
1816:                /*-----------------------------------------------------------*/
1817:                
1818:                #if ( INCLUDE_pcTaskGetTaskName == 1 )
1819:                
1820:                	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
1821:                	{
1822:                	TCB_t *pxTCB;
1823:                
1824:                		/* If null is passed in here then the name of the calling task is being queried. */
1825:                		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1826:                		configASSERT( pxTCB );
1827:                		return &( pxTCB->pcTaskName[ 0 ] );
1828:                	}
1829:                
1830:                #endif /* INCLUDE_pcTaskGetTaskName */
1831:                /*-----------------------------------------------------------*/
1832:                
1833:                #if ( configUSE_TRACE_FACILITY == 1 )
1834:                
1835:                	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
1836:                	{
1837:                	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1838:                
1839:                		vTaskSuspendAll();
1840:                		{
1841:                			/* Is there a space in the array for each task in the system? */
1842:                			if( uxArraySize >= uxCurrentNumberOfTasks )
1843:                			{
1844:                				/* Fill in an TaskStatus_t structure with information on each
1845:                				task in the Ready state. */
1846:                				do
1847:                				{
1848:                					uxQueue--;
1849:                					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
1850:                
1851:                				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1852:                
1853:                				/* Fill in an TaskStatus_t structure with information on each
1854:                				task in the Blocked state. */
1855:                				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
1856:                				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
1857:                
1858:                				#if( INCLUDE_vTaskDelete == 1 )
1859:                				{
1860:                					/* Fill in an TaskStatus_t structure with information on
1861:                					each task that has been deleted but not yet cleaned up. */
1862:                					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
1863:                				}
1864:                				#endif
1865:                
1866:                				#if ( INCLUDE_vTaskSuspend == 1 )
1867:                				{
1868:                					/* Fill in an TaskStatus_t structure with information on
1869:                					each task in the Suspended state. */
1870:                					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
1871:                				}
1872:                				#endif
1873:                
1874:                				#if ( configGENERATE_RUN_TIME_STATS == 1)
1875:                				{
1876:                					if( pulTotalRunTime != NULL )
1877:                					{
1878:                						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1879:                							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1880:                						#else
1881:                							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1882:                						#endif
1883:                					}
1884:                				}
1885:                				#else
1886:                				{
1887:                					if( pulTotalRunTime != NULL )
1888:                					{
1889:                						*pulTotalRunTime = 0;
1890:                					}
1891:                				}
1892:                				#endif
1893:                			}
1894:                			else
1895:                			{
1896:                				mtCOVERAGE_TEST_MARKER();
1897:                			}
1898:                		}
1899:                		( void ) xTaskResumeAll();
1900:                
1901:                		return uxTask;
1902:                	}
1903:                
1904:                #endif /* configUSE_TRACE_FACILITY */
1905:                /*----------------------------------------------------------*/
1906:                
1907:                #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1908:                
1909:                	TaskHandle_t xTaskGetIdleTaskHandle( void )
1910:                	{
1911:                		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1912:                		started, then xIdleTaskHandle will be NULL. */
1913:                		configASSERT( ( xIdleTaskHandle != NULL ) );
1914:                		return xIdleTaskHandle;
1915:                	}
1916:                
1917:                #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1918:                /*----------------------------------------------------------*/
1919:                
1920:                /* This conditional compilation should use inequality to 0, not equality to 1.
1921:                This is to ensure vTaskStepTick() is available when user defined low power mode
1922:                implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1923:                1. */
1924:                #if ( configUSE_TICKLESS_IDLE != 0 )
1925:                
1926:                	void vTaskStepTick( const TickType_t xTicksToJump )
1927:                	{
1928:                		/* Correct the tick count value after a period during which the tick
1929:                		was suppressed.  Note this does *not* call the tick hook function for
1930:                		each stepped tick. */
1931:                		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1932:                		xTickCount += xTicksToJump;
1933:                		traceINCREASE_TICK_COUNT( xTicksToJump );
1934:                	}
1935:                
1936:                #endif /* configUSE_TICKLESS_IDLE */
1937:                /*----------------------------------------------------------*/
1938:                
1939:                BaseType_t xTaskIncrementTick( void )
1940:                {
BFD02080      4FE9   ADDIU SP, SP, -48
BFD02082      CBEB   SW RA, 44(SP)
BFD02084      CBCA   SW S8, 40(SP)
BFD02086      0FDD   MOVE S8, SP
1941:                TCB_t * pxTCB;
1942:                TickType_t xItemValue;
1943:                BaseType_t xSwitchRequired = pdFALSE;
BFD02088  0010F81E   SW ZERO, 16(S8)
1944:                
1945:                	/* Called by the portable layer each time a tick interrupt occurs.
1946:                	Increments the tick then checks to see if the new tick value will cause any
1947:                	tasks to be unblocked. */
1948:                	traceTASK_INCREMENT_TICK( xTickCount );
1949:                	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
BFD0208C  805CFC5C   LW V0, -32676(GP)
BFD02090  00B840A2   BNEZC V0, 0xBFD02204
1950:                	{
1951:                		/* Increment the RTOS tick, switching the delayed and overflowed
1952:                		delayed lists if it wraps to 0. */
1953:                		++xTickCount;
BFD02094  803CFC5C   LW V0, -32708(GP)
BFD02098      6D20   ADDIU V0, V0, 1
BFD0209A  803CF85C   SW V0, -32708(GP)
1954:                
1955:                		{
1956:                			/* Minor optimisation.  The tick count cannot change in this
1957:                			block. */
1958:                			const TickType_t xConstTickCount = xTickCount;
BFD0209E  803CFC5C   LW V0, -32708(GP)
BFD020A2  0014F85E   SW V0, 20(S8)
1959:                
1960:                			if( xConstTickCount == ( TickType_t ) 0U )
BFD020A6  0014FC5E   LW V0, 20(S8)
BFD020AA  002240A2   BNEZC V0, 0xBFD020F2
1961:                			{
1962:                				taskSWITCH_DELAYED_LISTS();
BFD020AE  8074FC5C   LW V0, -32652(GP)
BFD020B2      6920   LW V0, 0(V0)
BFD020B4  000940E2   BEQZC V0, 0xBFD020CA
BFD020B8  BFD141A2   LUI V0, 0xBFD1
BFD020BA  3082BFD1   LDC1 F30, 12418(S1)
BFD020BC  98103082   ADDIU A0, V0, -26608
BFD020BE  30A09810   SWC1 F0, 12448(S0)
BFD020C0  07AA30A0   ADDIU A1, ZERO, 1962
BFD020C2      07AA   ADDU A3, A1, V0
BFD020C4  4B7E77E8   JALS vAssertCalled
BFD020C6      4B7E   LW K1, 120(SP)
BFD020C8      0C00   NOP
BFD020CA  8074FC5C   LW V0, -32652(GP)
BFD020CE  0018F85E   SW V0, 24(S8)
BFD020D2  8078FC5C   LW V0, -32648(GP)
BFD020D6  8074F85C   SW V0, -32652(GP)
BFD020DA  0018FC5E   LW V0, 24(S8)
BFD020DE  8078F85C   SW V0, -32648(GP)
BFD020E2  8050FC5C   LW V0, -32688(GP)
BFD020E6      6D20   ADDIU V0, V0, 1
BFD020E8  8050F85C   SW V0, -32688(GP)
BFD020EC  47CA77E8   JALS prvResetNextTaskUnblockTime
BFD020F0      0C00   NOP
1963:                			}
1964:                			else
1965:                			{
1966:                				mtCOVERAGE_TEST_MARKER();
1967:                			}
1968:                
1969:                			/* See if this tick has made a timeout expire.  Tasks are stored in
1970:                			the	queue in the order of their wake time - meaning once one task
1971:                			has been found whose block time has not expired there is no need to
1972:                			look any further down the list. */
1973:                			if( xConstTickCount >= xNextTaskUnblockTime )
BFD020F2  8058FC5C   LW V0, -32680(GP)
BFD020F6  0014FC7E   LW V1, 20(S8)
BFD020FA  13900043   SLTU V0, V1, V0
BFD020FC  40A21390   ADDI GP, S0, 16546
BFD020FE  006C40A2   BNEZC V0, 0xBFD021DA
BFD02102      CC02   B 0xBFD02108
BFD02104      0C00   NOP
1974:                			{
1975:                				for( ;; )
1976:                				{
1977:                					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
BFD02108  8074FC5C   LW V0, -32652(GP)
BFD0210C      6920   LW V0, 0(V0)
BFD0210E  000340A2   BNEZC V0, 0xBFD02118
BFD02112      ED01   LI V0, 1
BFD02114      CC02   B 0xBFD0211A
BFD02116      0C00   NOP
BFD02118      0C40   MOVE V0, ZERO
BFD0211A  000540E2   BEQZC V0, 0xBFD02128
1978:                					{
1979:                						/* The delayed list is empty.  Set xNextTaskUnblockTime
1980:                						to the maximum possible value so it is extremely
1981:                						unlikely that the
1982:                						if( xTickCount >= xNextTaskUnblockTime ) test will pass
1983:                						next time through. */
1984:                						xNextTaskUnblockTime = portMAX_DELAY;
BFD0211E      ED7F   LI V0, -1
BFD02120  8058F85C   SW V0, -32680(GP)
1985:                						break;
BFD02124      CC5A   B 0xBFD021DA
BFD02126      0C00   NOP
1986:                					}
1987:                					else
1988:                					{
1989:                						/* The delayed list is not empty, get the value of the
1990:                						item at the head of the delayed list.  This is the time
1991:                						at which the task at the head of the delayed list must
1992:                						be removed from the Blocked state. */
1993:                						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
BFD02128  8074FC5C   LW V0, -32652(GP)
BFD0212C      6923   LW V0, 12(V0)
BFD0212E      6923   LW V0, 12(V0)
BFD02130  001CF85E   SW V0, 28(S8)
1994:                						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
BFD02134  001CFC5E   LW V0, 28(S8)
BFD02138      6921   LW V0, 4(V0)
BFD0213A  0020F85E   SW V0, 32(S8)
1995:                
1996:                						if( xConstTickCount < xItemValue )
BFD0213E  0014FC7E   LW V1, 20(S8)
BFD02142  0020FC5E   LW V0, 32(S8)
BFD02146  13900043   SLTU V0, V1, V0
BFD02148  40E21390   ADDI GP, S0, 16610
BFD0214A  000640E2   BEQZC V0, 0xBFD0215A
1997:                						{
1998:                							/* It is not time to unblock this item yet, but the
1999:                							item value is the time at which the task at the head
2000:                							of the blocked list must be removed from the Blocked
2001:                							state -	so record the item value in
2002:                							xNextTaskUnblockTime. */
2003:                							xNextTaskUnblockTime = xItemValue;
BFD0214E  0020FC5E   LW V0, 32(S8)
BFD02152  8058F85C   SW V0, -32680(GP)
2004:                							break;
BFD02156      CC41   B 0xBFD021DA
BFD02158      0C00   NOP
2005:                						}
2006:                						else
2007:                						{
2008:                							mtCOVERAGE_TEST_MARKER();
2009:                						}
2010:                
2011:                						/* It is time to remove the item from the Blocked state. */
2012:                						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
BFD0215A  001CFC5E   LW V0, 28(S8)
BFD0215E      6D22   ADDIU V0, V0, 4
BFD02160      0C82   MOVE A0, V0
BFD02162  00C877E8   JALS uxListRemove
BFD02164  0C0000C8   SLL A2, T0, 1
BFD02166      0C00   NOP
2013:                
2014:                						/* Is the task waiting on an event also?  If so remove
2015:                						it from the event list. */
2016:                						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
BFD02168  001CFC5E   LW V0, 28(S8)
BFD0216C      692A   LW V0, 40(V0)
BFD0216E  000740E2   BEQZC V0, 0xBFD02180
2017:                						{
2018:                							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
BFD02172  001CFC5E   LW V0, 28(S8)
BFD02174  6D2C001C   EXT ZERO, GP, 20, 14
BFD02176      6D2C   ADDIU V0, V0, 24
BFD02178      0C82   MOVE A0, V0
BFD0217A  00C877E8   JALS uxListRemove
BFD0217C  0C0000C8   SLL A2, T0, 1
BFD0217E      0C00   NOP
2019:                						}
2020:                						else
2021:                						{
2022:                							mtCOVERAGE_TEST_MARKER();
2023:                						}
2024:                
2025:                						/* Place the unblocked task into the appropriate ready
2026:                						list. */
2027:                						prvAddTaskToReadyList( pxTCB );
BFD02180  001CFC5E   LW V0, 28(S8)
BFD02184      692B   LW V0, 44(V0)
BFD02186      ED81   LI V1, 1
BFD02188  18100062   SLLV V1, V0, V1
BFD0218A  FC5C1810   SB ZERO, -932(S0)
BFD0218C  8040FC5C   LW V0, -32704(GP)
BFD02190      44D3   OR16 V0, V1
BFD02192  8040F85C   SW V0, -32704(GP)
BFD02196  001CFC5E   LW V0, 28(S8)
BFD0219A      692B   LW V0, 44(V0)
BFD0219C      2524   SLL V0, V0, 2
BFD0219E      25A4   SLL V1, V0, 2
BFD021A0      05B4   ADDU V1, V0, V1
BFD021A2  BFD241A2   LUI V0, 0xBFD2
BFD021A4  3042BFD2   LDC1 F30, 12354(S2)
BFD021A6  806C3042   ADDIU V0, V0, -32660
BFD021AA      05A6   ADDU V1, V1, V0
BFD021AC  001CFC5E   LW V0, 28(S8)
BFD021B0      6D22   ADDIU V0, V0, 4
BFD021B2      0C83   MOVE A0, V1
BFD021B4      0CA2   MOVE A1, V0
BFD021B6  3E4A77E8   JALS vListInsertEnd
BFD021B8  0C003E4A   LH S2, 3072(T2)
BFD021BA      0C00   NOP
2028:                
2029:                						/* A task being unblocked cannot cause an immediate
2030:                						context switch if preemption is turned off. */
2031:                						#if (  configUSE_PREEMPTION == 1 )
2032:                						{
2033:                							/* Preemption is on, but a context switch should
2034:                							only be performed if the unblocked task has a
2035:                							priority that is equal to or higher than the
2036:                							currently executing task. */
2037:                							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
BFD021BC  001CFC5E   LW V0, 28(S8)
BFD021C0      69AB   LW V1, 44(V0)
BFD021C2  8030FC5C   LW V0, -32720(GP)
BFD021C6      692B   LW V0, 44(V0)
BFD021C8  13900043   SLTU V0, V1, V0
BFD021CA  40A21390   ADDI GP, S0, 16546
BFD021CC  FF9B40A2   BNEZC V0, 0xBFD02106
BFD021CE  ED01FF9B   LW GP, -4863(K1)
2038:                							{
2039:                								xSwitchRequired = pdTRUE;
BFD021D0      ED01   LI V0, 1
BFD021D2  0010F85E   SW V0, 16(S8)
2040:                							}
2041:                							else
2042:                							{
2043:                								mtCOVERAGE_TEST_MARKER();
2044:                							}
2045:                						}
2046:                						#endif /* configUSE_PREEMPTION */
2047:                					}
2048:                				}
BFD02106      0C00   NOP
BFD021D6      CF98   B 0xBFD02108
BFD021D8      0C00   NOP
2049:                			}
2050:                		}
2051:                
2052:                		/* Tasks of equal priority to the currently running task will share
2053:                		processing time (time slice) if preemption is on, and the application
2054:                		writer has not explicitly turned time slicing off. */
2055:                		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2056:                		{
2057:                			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
BFD021DA  8030FC5C   LW V0, -32720(GP)
BFD021DE      692B   LW V0, 44(V0)
BFD021E0      2524   SLL V0, V0, 2
BFD021E2      25A4   SLL V1, V0, 2
BFD021E4      05B4   ADDU V1, V0, V1
BFD021E6  BFD241A2   LUI V0, 0xBFD2
BFD021E8  3042BFD2   LDC1 F30, 12354(S2)
BFD021EA  806C3042   ADDIU V0, V0, -32660
BFD021EE      0526   ADDU V0, V1, V0
BFD021F0      6920   LW V0, 0(V0)
BFD021F2  0002B042   SLTIU V0, V0, 2
BFD021F6  000A40A2   BNEZC V0, 0xBFD0220E
2058:                			{
2059:                				xSwitchRequired = pdTRUE;
BFD021FA      ED01   LI V0, 1
BFD021FC  0010F85E   SW V0, 16(S8)
BFD02200      CC06   B 0xBFD0220E
BFD02202      0C00   NOP
2060:                			}
2061:                			else
2062:                			{
2063:                				mtCOVERAGE_TEST_MARKER();
2064:                			}
2065:                		}
2066:                		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2067:                
2068:                		#if ( configUSE_TICK_HOOK == 1 )
2069:                		{
2070:                			/* Guard against the tick hook being called when the pended tick
2071:                			count is being unwound (when the scheduler is being unlocked). */
2072:                			if( uxPendedTicks == ( UBaseType_t ) 0U )
2073:                			{
2074:                				vApplicationTickHook();
2075:                			}
2076:                			else
2077:                			{
2078:                				mtCOVERAGE_TEST_MARKER();
2079:                			}
2080:                		}
2081:                		#endif /* configUSE_TICK_HOOK */
2082:                	}
2083:                	else
2084:                	{
2085:                		++uxPendedTicks;
BFD02204  8048FC5C   LW V0, -32696(GP)
BFD02208      6D20   ADDIU V0, V0, 1
BFD0220A  8048F85C   SW V0, -32696(GP)
2086:                
2087:                		/* The tick hook gets called at regular intervals, even if the
2088:                		scheduler is locked. */
2089:                		#if ( configUSE_TICK_HOOK == 1 )
2090:                		{
2091:                			vApplicationTickHook();
2092:                		}
2093:                		#endif
2094:                	}
2095:                
2096:                	#if ( configUSE_PREEMPTION == 1 )
2097:                	{
2098:                		if( xYieldPending != pdFALSE )
BFD0220E  804CFC5C   LW V0, -32692(GP)
BFD02212  000340E2   BEQZC V0, 0xBFD0221C
2099:                		{
2100:                			xSwitchRequired = pdTRUE;
BFD02216      ED01   LI V0, 1
BFD02218  0010F85E   SW V0, 16(S8)
2101:                		}
2102:                		else
2103:                		{
2104:                			mtCOVERAGE_TEST_MARKER();
2105:                		}
2106:                	}
2107:                	#endif /* configUSE_PREEMPTION */
2108:                
2109:                	return xSwitchRequired;
BFD0221C  0010FC5E   LW V0, 16(S8)
2110:                }
BFD02220      0FBE   MOVE SP, S8
BFD02222      4BEB   LW RA, 44(SP)
BFD02224      4BCA   LW S8, 40(SP)
BFD02226      4C19   ADDIU SP, SP, 48
BFD02228      459F   JR16 RA
BFD0222A      0C00   NOP
2111:                /*-----------------------------------------------------------*/
2112:                
2113:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2114:                
2115:                	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2116:                	{
2117:                	TCB_t *xTCB;
2118:                
2119:                		/* If xTask is NULL then it is the task hook of the calling task that is
2120:                		getting set. */
2121:                		if( xTask == NULL )
2122:                		{
2123:                			xTCB = ( TCB_t * ) pxCurrentTCB;
2124:                		}
2125:                		else
2126:                		{
2127:                			xTCB = ( TCB_t * ) xTask;
2128:                		}
2129:                
2130:                		/* Save the hook function in the TCB.  A critical section is required as
2131:                		the value can be accessed from an interrupt. */
2132:                		taskENTER_CRITICAL();
2133:                			xTCB->pxTaskTag = pxHookFunction;
2134:                		taskEXIT_CRITICAL();
2135:                	}
2136:                
2137:                #endif /* configUSE_APPLICATION_TASK_TAG */
2138:                /*-----------------------------------------------------------*/
2139:                
2140:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2141:                
2142:                	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2143:                	{
2144:                	TCB_t *xTCB;
2145:                	TaskHookFunction_t xReturn;
2146:                
2147:                		/* If xTask is NULL then we are setting our own task hook. */
2148:                		if( xTask == NULL )
2149:                		{
2150:                			xTCB = ( TCB_t * ) pxCurrentTCB;
2151:                		}
2152:                		else
2153:                		{
2154:                			xTCB = ( TCB_t * ) xTask;
2155:                		}
2156:                
2157:                		/* Save the hook function in the TCB.  A critical section is required as
2158:                		the value can be accessed from an interrupt. */
2159:                		taskENTER_CRITICAL();
2160:                		{
2161:                			xReturn = xTCB->pxTaskTag;
2162:                		}
2163:                		taskEXIT_CRITICAL();
2164:                
2165:                		return xReturn;
2166:                	}
2167:                
2168:                #endif /* configUSE_APPLICATION_TASK_TAG */
2169:                /*-----------------------------------------------------------*/
2170:                
2171:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2172:                
2173:                	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2174:                	{
2175:                	TCB_t *xTCB;
2176:                	BaseType_t xReturn;
2177:                
2178:                		/* If xTask is NULL then we are calling our own task hook. */
2179:                		if( xTask == NULL )
2180:                		{
2181:                			xTCB = ( TCB_t * ) pxCurrentTCB;
2182:                		}
2183:                		else
2184:                		{
2185:                			xTCB = ( TCB_t * ) xTask;
2186:                		}
2187:                
2188:                		if( xTCB->pxTaskTag != NULL )
2189:                		{
2190:                			xReturn = xTCB->pxTaskTag( pvParameter );
2191:                		}
2192:                		else
2193:                		{
2194:                			xReturn = pdFAIL;
2195:                		}
2196:                
2197:                		return xReturn;
2198:                	}
2199:                
2200:                #endif /* configUSE_APPLICATION_TASK_TAG */
2201:                /*-----------------------------------------------------------*/
2202:                
2203:                void vTaskSwitchContext( void )
2204:                {
BFD02DBC      4FE5   ADDIU SP, SP, -56
BFD02DBE      CBED   SW RA, 52(SP)
BFD02DC0      CBCC   SW S8, 48(SP)
BFD02DC2      0FDD   MOVE S8, SP
2205:                	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
BFD02DC4  805CFC5C   LW V0, -32676(GP)
BFD02DC8  000540E2   BEQZC V0, 0xBFD02DD6
2206:                	{
2207:                		/* The scheduler is currently suspended - do not allow a context
2208:                		switch. */
2209:                		xYieldPending = pdTRUE;
BFD02DCC      ED01   LI V0, 1
BFD02DCE  804CF85C   SW V0, -32692(GP)
BFD02DD2      CC91   B 0xBFD02EF6
BFD02DD4      0C00   NOP
2210:                	}
2211:                	else
2212:                	{
2213:                		xYieldPending = pdFALSE;
BFD02DD6  804CF81C   SW ZERO, -32692(GP)
2214:                		traceTASK_SWITCHED_OUT();
2215:                
2216:                		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2217:                		{
2218:                				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2219:                					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2220:                				#else
2221:                					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2222:                				#endif
2223:                
2224:                				/* Add the amount of time the task has been running to the
2225:                				accumulated	time so far.  The time the task started running was
2226:                				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2227:                				protection here	so count values are only valid until the timer
2228:                				overflows.  The guard against negative values is to protect
2229:                				against suspect run time stat counter implementations - which
2230:                				are provided by the application, not the kernel. */
2231:                				if( ulTotalRunTime > ulTaskSwitchedInTime )
2232:                				{
2233:                					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2234:                				}
2235:                				else
2236:                				{
2237:                					mtCOVERAGE_TEST_MARKER();
2238:                				}
2239:                				ulTaskSwitchedInTime = ulTotalRunTime;
2240:                		}
2241:                		#endif /* configGENERATE_RUN_TIME_STATS */
2242:                
2243:                		/* Check for stack overflow, if configured. */
2244:                		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
BFD02DDA  8030FC5C   LW V0, -32720(GP)
BFD02DDE      69A0   LW V1, 0(V0)
BFD02DE0  8030FC5C   LW V0, -32720(GP)
BFD02DE4      692C   LW V0, 48(V0)
BFD02DE6  13900062   SLTU V0, V0, V1
BFD02DE8  40A21390   ADDI GP, S0, 16546
BFD02DEA  000B40A2   BNEZC V0, 0xBFD02E04
BFD02DEE  8030FC7C   LW V1, -32720(GP)
BFD02DF2  8030FC5C   LW V0, -32720(GP)
BFD02DF6  00343042   ADDIU V0, V0, 52
BFD02DFA      0C83   MOVE A0, V1
BFD02DFC      0CA2   MOVE A1, V0
BFD02DFE  422277E8   JALS vApplicationStackOverflowHook
BFD02E00  0C004222   BLTZALS V0, 0xBFD04604
BFD02E02      0C00   NOP
2245:                		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
BFD02E04  BFD141A2   LUI V0, 0xBFD1
BFD02E06  FCC2BFD1   LDC1 F30, -830(S1)
BFD02E08  9830FCC2   LW A2, -26576(V0)
BFD02E0A  30629830   SWC1 F1, 12386(S0)
BFD02E0C  98303062   ADDIU V1, V0, -26576
BFD02E0E  6AB19830   SWC1 F1, 27313(S0)
BFD02E10      6AB1   LW A1, 4(V1)
BFD02E12  98303062   ADDIU V1, V0, -26576
BFD02E14  6A329830   SWC1 F1, 27186(S0)
BFD02E16      6A32   LW A0, 8(V1)
BFD02E18  98303062   ADDIU V1, V0, -26576
BFD02E1A  69B39830   SWC1 F1, 27059(S0)
BFD02E1C      69B3   LW V1, 12(V1)
BFD02E1E  98303042   ADDIU V0, V0, -26576
BFD02E20  69249830   SWC1 F1, 26916(S0)
BFD02E22      6924   LW V0, 16(V0)
BFD02E24  0018F8DE   SW A2, 24(S8)
BFD02E28  001CF8BE   SW A1, 28(S8)
BFD02E2C  0020F89E   SW A0, 32(S8)
BFD02E30  0024F87E   SW V1, 36(S8)
BFD02E34  0028F85E   SW V0, 40(S8)
BFD02E38  8030FC5C   LW V0, -32720(GP)
BFD02E3C      69AC   LW V1, 48(V0)
BFD02E3E  0018305E   ADDIU V0, S8, 24
BFD02E42      0C83   MOVE A0, V1
BFD02E44      0CA2   MOVE A1, V0
BFD02E46      EF14   LI A2, 20
BFD02E48  3DA677E8   JALS 0xBFD07B4C
BFD02E4A  0C003DA6   LH T5, 3072(A2)
BFD02E4C      0C00   NOP
BFD02E4E  000B40E2   BEQZC V0, 0xBFD02E68
BFD02E52  8030FC7C   LW V1, -32720(GP)
BFD02E56  8030FC5C   LW V0, -32720(GP)
BFD02E5A  00343042   ADDIU V0, V0, 52
BFD02E5E      0C83   MOVE A0, V1
BFD02E60      0CA2   MOVE A1, V0
BFD02E62  422277E8   JALS vApplicationStackOverflowHook
BFD02E64  0C004222   BLTZALS V0, 0xBFD04668
BFD02E66      0C00   NOP
2246:                
2247:                		/* Select a new task to run using either the generic C or port
2248:                		optimised asm code. */
2249:                		taskSELECT_HIGHEST_PRIORITY_TASK();
BFD02E68  8040FC5C   LW V0, -32704(GP)
BFD02E6C  5B3C0042   CLZ V0, V0
BFD02E70      ED9F   LI V1, 31
BFD02E72      0527   SUBU V0, V1, V0
BFD02E74  0010F85E   SW V0, 16(S8)
BFD02E78  0010FC5E   LW V0, 16(S8)
BFD02E7C      2524   SLL V0, V0, 2
BFD02E7E      25A4   SLL V1, V0, 2
BFD02E80      05B4   ADDU V1, V0, V1
BFD02E82  BFD241A2   LUI V0, 0xBFD2
BFD02E84  3042BFD2   LDC1 F30, 12354(S2)
BFD02E86  806C3042   ADDIU V0, V0, -32660
BFD02E8A      0526   ADDU V0, V1, V0
BFD02E8C      6920   LW V0, 0(V0)
BFD02E8E  000940A2   BNEZC V0, 0xBFD02EA4
BFD02E92  BFD141A2   LUI V0, 0xBFD1
BFD02E94  3082BFD1   LDC1 F30, 12418(S1)
BFD02E96  98103082   ADDIU A0, V0, -26608
BFD02E98  30A09810   SWC1 F0, 12448(S0)
BFD02E9A  08C930A0   ADDIU A1, ZERO, 2249
BFD02E9C      08C9   LBU S1, 9(A0)
BFD02E9E  4B7E77E8   JALS vAssertCalled
BFD02EA0      4B7E   LW K1, 120(SP)
BFD02EA2      0C00   NOP
BFD02EA4  0010FC5E   LW V0, 16(S8)
BFD02EA8      2524   SLL V0, V0, 2
BFD02EAA      25A4   SLL V1, V0, 2
BFD02EAC      05B4   ADDU V1, V0, V1
BFD02EAE  BFD241A2   LUI V0, 0xBFD2
BFD02EB0  3042BFD2   LDC1 F30, 12354(S2)
BFD02EB2  806C3042   ADDIU V0, V0, -32660
BFD02EB6      0526   ADDU V0, V1, V0
BFD02EB8  0014F85E   SW V0, 20(S8)
BFD02EBC  0014FC5E   LW V0, 20(S8)
BFD02EC0      6921   LW V0, 4(V0)
BFD02EC2      69A1   LW V1, 4(V0)
BFD02EC4  0014FC5E   LW V0, 20(S8)
BFD02EC8      E9A1   SW V1, 4(V0)
BFD02ECA  0014FC5E   LW V0, 20(S8)
BFD02ECE      69A1   LW V1, 4(V0)
BFD02ED0  0014FC5E   LW V0, 20(S8)
BFD02ED4      6D24   ADDIU V0, V0, 8
BFD02ED6  0008B443   BNE V1, V0, 0xBFD02EEA
BFD02ED8  0C000008   SLL ZERO, T0, 1
BFD02EDA      0C00   NOP
BFD02EDC  0014FC5E   LW V0, 20(S8)
BFD02EE0      6921   LW V0, 4(V0)
BFD02EE2      69A1   LW V1, 4(V0)
BFD02EE4  0014FC5E   LW V0, 20(S8)
BFD02EE8      E9A1   SW V1, 4(V0)
BFD02EEA  0014FC5E   LW V0, 20(S8)
BFD02EEE      6921   LW V0, 4(V0)
BFD02EF0      6923   LW V0, 12(V0)
BFD02EF2  8030F85C   SW V0, -32720(GP)
2250:                		traceTASK_SWITCHED_IN();
2251:                
2252:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2253:                		{
2254:                			/* Switch Newlib's _impure_ptr variable to point to the _reent
2255:                			structure specific to this task. */
2256:                			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2257:                		}
2258:                		#endif /* configUSE_NEWLIB_REENTRANT */
2259:                	}
2260:                }
BFD02EF6      0FBE   MOVE SP, S8
BFD02EF8      4BED   LW RA, 52(SP)
BFD02EFA      4BCC   LW S8, 48(SP)
BFD02EFC      4C1D   ADDIU SP, SP, 56
BFD02EFE      459F   JR16 RA
BFD02F00      0C00   NOP
2261:                /*-----------------------------------------------------------*/
2262:                
2263:                void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2264:                {
BFD05E74      4FF1   ADDIU SP, SP, -32
BFD05E76      CBE7   SW RA, 28(SP)
BFD05E78      CBC6   SW S8, 24(SP)
BFD05E7A      0FDD   MOVE S8, SP
BFD05E7C  0020F89E   SW A0, 32(S8)
BFD05E80  0024F8BE   SW A1, 36(S8)
2265:                TickType_t xTimeToWake;
2266:                
2267:                	configASSERT( pxEventList );
BFD05E84  0020FC5E   LW V0, 32(S8)
BFD05E88  000940A2   BNEZC V0, 0xBFD05E9E
BFD05E8C  BFD141A2   LUI V0, 0xBFD1
BFD05E8E  3082BFD1   LDC1 F30, 12418(S1)
BFD05E90  98103082   ADDIU A0, V0, -26608
BFD05E92  30A09810   SWC1 F0, 12448(S0)
BFD05E94  08DB30A0   ADDIU A1, ZERO, 2267
BFD05E96      08DB   LBU S1, 11(A1)
BFD05E98  4B7E77E8   JALS vAssertCalled
BFD05E9A      4B7E   LW K1, 120(SP)
BFD05E9C      0C00   NOP
2268:                
2269:                	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2270:                	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2271:                
2272:                	/* Place the event list item of the TCB in the appropriate event list.
2273:                	This is placed in the list in priority order so the highest priority task
2274:                	is the first to be woken by the event.  The queue that contains the event
2275:                	list is locked, preventing simultaneous access from interrupts. */
2276:                	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
BFD05E9E  8030FC5C   LW V0, -32720(GP)
BFD05EA2      6D2C   ADDIU V0, V0, 24
BFD05EA4  0020FC9E   LW A0, 32(S8)
BFD05EA8      0CA2   MOVE A1, V0
BFD05EAA  304077E8   JALS vListInsert
BFD05EAC  0C003040   ADDIU V0, ZERO, 3072
BFD05EAE      0C00   NOP
2277:                
2278:                	/* The task must be removed from from the ready list before it is added to
2279:                	the blocked list as the same list item is used for both lists.  Exclusive
2280:                	access to the ready lists guaranteed because the scheduler is locked. */
2281:                	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD05EB0  8030FC5C   LW V0, -32720(GP)
BFD05EB4      6D22   ADDIU V0, V0, 4
BFD05EB6      0C82   MOVE A0, V0
BFD05EB8  00C877E8   JALS uxListRemove
BFD05EBA  0C0000C8   SLL A2, T0, 1
BFD05EBC      0C00   NOP
BFD05EBE  000C40A2   BNEZC V0, 0xBFD05EDA
2282:                	{
2283:                		/* The current task must be in a ready list, so there is no need to
2284:                		check, and the port reset macro can be called directly. */
2285:                		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
BFD05EC2  8030FC5C   LW V0, -32720(GP)
BFD05EC6      692B   LW V0, 44(V0)
BFD05EC8      ED81   LI V1, 1
BFD05ECA  10100062   SLLV V0, V0, V1
BFD05ECC  441A1010   ADDI ZERO, S0, 17434
BFD05ECE      441A   NOT16 V1, V0
BFD05ED0  8040FC5C   LW V0, -32704(GP)
BFD05ED4      4493   AND16 V0, V1
BFD05ED6  8040F85C   SW V0, -32704(GP)
2286:                	}
2287:                	else
2288:                	{
2289:                		mtCOVERAGE_TEST_MARKER();
2290:                	}
2291:                
2292:                	#if ( INCLUDE_vTaskSuspend == 1 )
2293:                	{
2294:                		if( xTicksToWait == portMAX_DELAY )
BFD05EDA  0024FC7E   LW V1, 36(S8)
BFD05EDE      ED7F   LI V0, -1
BFD05EE0  000EB443   BNE V1, V0, 0xBFD05F00
BFD05EE2  0C00000E   SLL ZERO, T6, 1
BFD05EE4      0C00   NOP
2295:                		{
2296:                			/* Add the task to the suspended task list instead of a delayed task
2297:                			list to ensure the task is not woken by a timing event.  It will
2298:                			block indefinitely. */
2299:                			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
BFD05EE6  8030FC5C   LW V0, -32720(GP)
BFD05EEA      6D22   ADDIU V0, V0, 4
BFD05EEC  BFD241A3   LUI V1, 0xBFD2
BFD05EEE  3083BFD2   LDC1 F30, 12419(S2)
BFD05EF0  80E43083   ADDIU A0, V1, -32540
BFD05EF4      0CA2   MOVE A1, V0
BFD05EF6  3E4A77E8   JALS vListInsertEnd
BFD05EF8  0C003E4A   LH S2, 3072(T2)
BFD05EFA      0C00   NOP
BFD05EFC      CC0D   B 0xBFD05F18
BFD05EFE      0C00   NOP
2300:                		}
2301:                		else
2302:                		{
2303:                			/* Calculate the time at which the task should be woken if the event
2304:                			does not occur.  This may overflow but this doesn't matter, the
2305:                			scheduler will handle it. */
2306:                			xTimeToWake = xTickCount + xTicksToWait;
BFD05F00  803CFC7C   LW V1, -32708(GP)
BFD05F04  0024FC5E   LW V0, 36(S8)
BFD05F08      0526   ADDU V0, V1, V0
BFD05F0A  0010F85E   SW V0, 16(S8)
2307:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
BFD05F0E  0010FC9E   LW A0, 16(S8)
BFD05F12  373477E8   JALS prvAddCurrentTaskToDelayedList
BFD05F14  0C003734   LHU T9, 3072(S4)
BFD05F16      0C00   NOP
2308:                		}
2309:                	}
2310:                	#else /* INCLUDE_vTaskSuspend */
2311:                	{
2312:                			/* Calculate the time at which the task should be woken if the event does
2313:                			not occur.  This may overflow but this doesn't matter, the scheduler
2314:                			will handle it. */
2315:                			xTimeToWake = xTickCount + xTicksToWait;
2316:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
2317:                	}
2318:                	#endif /* INCLUDE_vTaskSuspend */
2319:                }
BFD05F18      0FBE   MOVE SP, S8
BFD05F1A      4BE7   LW RA, 28(SP)
BFD05F1C      4BC6   LW S8, 24(SP)
BFD05F1E      4C11   ADDIU SP, SP, 32
BFD05F20      459F   JR16 RA
BFD05F22      0C00   NOP
2320:                /*-----------------------------------------------------------*/
2321:                
2322:                void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
2323:                {
BFD04904      4FF1   ADDIU SP, SP, -32
BFD04906      CBE7   SW RA, 28(SP)
BFD04908      CBC6   SW S8, 24(SP)
BFD0490A      0FDD   MOVE S8, SP
BFD0490C  0020F89E   SW A0, 32(S8)
BFD04910  0024F8BE   SW A1, 36(S8)
BFD04914  0028F8DE   SW A2, 40(S8)
2324:                TickType_t xTimeToWake;
2325:                
2326:                	configASSERT( pxEventList );
BFD04918  0020FC5E   LW V0, 32(S8)
BFD0491C  000940A2   BNEZC V0, 0xBFD04932
BFD04920  BFD141A2   LUI V0, 0xBFD1
BFD04922  3082BFD1   LDC1 F30, 12418(S1)
BFD04924  98103082   ADDIU A0, V0, -26608
BFD04926  30A09810   SWC1 F0, 12448(S0)
BFD04928  091630A0   ADDIU A1, ZERO, 2326
BFD0492A      0916   LBU V0, 6(S1)
BFD0492C  4B7E77E8   JALS vAssertCalled
BFD0492E      4B7E   LW K1, 120(SP)
BFD04930      0C00   NOP
2327:                
2328:                	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2329:                	the event groups implementation. */
2330:                	configASSERT( uxSchedulerSuspended != 0 );
BFD04932  805CFC5C   LW V0, -32676(GP)
BFD04936  000940A2   BNEZC V0, 0xBFD0494C
BFD0493A  BFD141A2   LUI V0, 0xBFD1
BFD0493C  3082BFD1   LDC1 F30, 12418(S1)
BFD0493E  98103082   ADDIU A0, V0, -26608
BFD04940  30A09810   SWC1 F0, 12448(S0)
BFD04942  091A30A0   ADDIU A1, ZERO, 2330
BFD04944      091A   LBU V0, 10(S1)
BFD04946  4B7E77E8   JALS vAssertCalled
BFD04948      4B7E   LW K1, 120(SP)
BFD0494A      0C00   NOP
2331:                
2332:                	/* Store the item value in the event list item.  It is safe to access the
2333:                	event list item here as interrupts won't access the event list item of a
2334:                	task that is not in the Blocked state. */
2335:                	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
BFD0494C  8030FC5C   LW V0, -32720(GP)
BFD04950  0024FC9E   LW A0, 36(S8)
BFD04954  800041A3   LUI V1, 0x8000
BFD04958      44DC   OR16 V1, A0
BFD0495A      E9A6   SW V1, 24(V0)
2336:                
2337:                	/* Place the event list item of the TCB at the end of the appropriate event
2338:                	list.  It is safe to access the event list here because it is part of an
2339:                	event group implementation - and interrupts don't access event groups
2340:                	directly (instead they access them indirectly by pending function calls to
2341:                	the task level). */
2342:                	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
BFD0495C  8030FC5C   LW V0, -32720(GP)
BFD04960      6D2C   ADDIU V0, V0, 24
BFD04962  0020FC9E   LW A0, 32(S8)
BFD04966      0CA2   MOVE A1, V0
BFD04968  3E4A77E8   JALS vListInsertEnd
BFD0496A  0C003E4A   LH S2, 3072(T2)
BFD0496C      0C00   NOP
2343:                
2344:                	/* The task must be removed from the ready list before it is added to the
2345:                	blocked list.  Exclusive access can be assured to the ready list as the
2346:                	scheduler is locked. */
2347:                	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD0496E  8030FC5C   LW V0, -32720(GP)
BFD04972      6D22   ADDIU V0, V0, 4
BFD04974      0C82   MOVE A0, V0
BFD04976  00C877E8   JALS uxListRemove
BFD04978  0C0000C8   SLL A2, T0, 1
BFD0497A      0C00   NOP
BFD0497C  000C40A2   BNEZC V0, 0xBFD04998
2348:                	{
2349:                		/* The current task must be in a ready list, so there is no need to
2350:                		check, and the port reset macro can be called directly. */
2351:                		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
BFD04980  8030FC5C   LW V0, -32720(GP)
BFD04984      692B   LW V0, 44(V0)
BFD04986      ED81   LI V1, 1
BFD04988  10100062   SLLV V0, V0, V1
BFD0498A  441A1010   ADDI ZERO, S0, 17434
BFD0498C      441A   NOT16 V1, V0
BFD0498E  8040FC5C   LW V0, -32704(GP)
BFD04992      4493   AND16 V0, V1
BFD04994  8040F85C   SW V0, -32704(GP)
2352:                	}
2353:                	else
2354:                	{
2355:                		mtCOVERAGE_TEST_MARKER();
2356:                	}
2357:                
2358:                	#if ( INCLUDE_vTaskSuspend == 1 )
2359:                	{
2360:                		if( xTicksToWait == portMAX_DELAY )
BFD04998  0028FC7E   LW V1, 40(S8)
BFD0499C      ED7F   LI V0, -1
BFD0499E  000EB443   BNE V1, V0, 0xBFD049BE
BFD049A0  0C00000E   SLL ZERO, T6, 1
BFD049A2      0C00   NOP
2361:                		{
2362:                			/* Add the task to the suspended task list instead of a delayed task
2363:                			list to ensure it is not woken by a timing event.  It will block
2364:                			indefinitely. */
2365:                			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
BFD049A4  8030FC5C   LW V0, -32720(GP)
BFD049A8      6D22   ADDIU V0, V0, 4
BFD049AA  BFD241A3   LUI V1, 0xBFD2
BFD049AC  3083BFD2   LDC1 F30, 12419(S2)
BFD049AE  80E43083   ADDIU A0, V1, -32540
BFD049B2      0CA2   MOVE A1, V0
BFD049B4  3E4A77E8   JALS vListInsertEnd
BFD049B6  0C003E4A   LH S2, 3072(T2)
BFD049B8      0C00   NOP
BFD049BA      CC0D   B 0xBFD049D6
BFD049BC      0C00   NOP
2366:                		}
2367:                		else
2368:                		{
2369:                			/* Calculate the time at which the task should be woken if the event
2370:                			does not occur.  This may overflow but this doesn't matter, the
2371:                			kernel will manage it correctly. */
2372:                			xTimeToWake = xTickCount + xTicksToWait;
BFD049BE  803CFC7C   LW V1, -32708(GP)
BFD049C2  0028FC5E   LW V0, 40(S8)
BFD049C6      0526   ADDU V0, V1, V0
BFD049C8  0010F85E   SW V0, 16(S8)
2373:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
BFD049CC  0010FC9E   LW A0, 16(S8)
BFD049D0  373477E8   JALS prvAddCurrentTaskToDelayedList
BFD049D2  0C003734   LHU T9, 3072(S4)
BFD049D4      0C00   NOP
2374:                		}
2375:                	}
2376:                	#else /* INCLUDE_vTaskSuspend */
2377:                	{
2378:                			/* Calculate the time at which the task should be woken if the event does
2379:                			not occur.  This may overflow but this doesn't matter, the kernel
2380:                			will manage it correctly. */
2381:                			xTimeToWake = xTickCount + xTicksToWait;
2382:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
2383:                	}
2384:                	#endif /* INCLUDE_vTaskSuspend */
2385:                }
BFD049D6      0FBE   MOVE SP, S8
BFD049D8      4BE7   LW RA, 28(SP)
BFD049DA      4BC6   LW S8, 24(SP)
BFD049DC      4C11   ADDIU SP, SP, 32
BFD049DE      459F   JR16 RA
BFD049E0      0C00   NOP
2386:                /*-----------------------------------------------------------*/
2387:                
2388:                #if configUSE_TIMERS == 1
2389:                
2390:                	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2391:                	{
BFD05C58      4FF1   ADDIU SP, SP, -32
BFD05C5A      CBE7   SW RA, 28(SP)
BFD05C5C      CBC6   SW S8, 24(SP)
BFD05C5E      0FDD   MOVE S8, SP
BFD05C60  0020F89E   SW A0, 32(S8)
BFD05C64  0024F8BE   SW A1, 36(S8)
BFD05C68  0028F8DE   SW A2, 40(S8)
2392:                	TickType_t xTimeToWake;
2393:                
2394:                		configASSERT( pxEventList );
BFD05C6C  0020FC5E   LW V0, 32(S8)
BFD05C70  000940A2   BNEZC V0, 0xBFD05C86
BFD05C74  BFD141A2   LUI V0, 0xBFD1
BFD05C76  3082BFD1   LDC1 F30, 12418(S1)
BFD05C78  98103082   ADDIU A0, V0, -26608
BFD05C7A  30A09810   SWC1 F0, 12448(S0)
BFD05C7C  095A30A0   ADDIU A1, ZERO, 2394
BFD05C7E      095A   LBU V0, 10(A1)
BFD05C80  4B7E77E8   JALS vAssertCalled
BFD05C82      4B7E   LW K1, 120(SP)
BFD05C84      0C00   NOP
2395:                
2396:                		/* This function should not be called by application code hence the
2397:                		'Restricted' in its name.  It is not part of the public API.  It is
2398:                		designed for use by kernel code, and has special calling requirements -
2399:                		it should be called with the scheduler suspended. */
2400:                
2401:                
2402:                		/* Place the event list item of the TCB in the appropriate event list.
2403:                		In this case it is assume that this is the only task that is going to
2404:                		be waiting on this event list, so the faster vListInsertEnd() function
2405:                		can be used in place of vListInsert. */
2406:                		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
BFD05C86  8030FC5C   LW V0, -32720(GP)
BFD05C8A      6D2C   ADDIU V0, V0, 24
BFD05C8C  0020FC9E   LW A0, 32(S8)
BFD05C90      0CA2   MOVE A1, V0
BFD05C92  3E4A77E8   JALS vListInsertEnd
BFD05C94  0C003E4A   LH S2, 3072(T2)
BFD05C96      0C00   NOP
2407:                
2408:                		/* We must remove this task from the ready list before adding it to the
2409:                		blocked list as the same list item is used for both lists.  This
2410:                		function is called with the scheduler locked so interrupts will not
2411:                		access the lists at the same time. */
2412:                		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD05C98  8030FC5C   LW V0, -32720(GP)
BFD05C9C      6D22   ADDIU V0, V0, 4
BFD05C9E      0C82   MOVE A0, V0
BFD05CA0  00C877E8   JALS uxListRemove
BFD05CA2  0C0000C8   SLL A2, T0, 1
BFD05CA4      0C00   NOP
BFD05CA6  000C40A2   BNEZC V0, 0xBFD05CC2
2413:                		{
2414:                			/* The current task must be in a ready list, so there is no need to
2415:                			check, and the port reset macro can be called directly. */
2416:                			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
BFD05CAA  8030FC5C   LW V0, -32720(GP)
BFD05CAE      692B   LW V0, 44(V0)
BFD05CB0      ED81   LI V1, 1
BFD05CB2  10100062   SLLV V0, V0, V1
BFD05CB4  441A1010   ADDI ZERO, S0, 17434
BFD05CB6      441A   NOT16 V1, V0
BFD05CB8  8040FC5C   LW V0, -32704(GP)
BFD05CBC      4493   AND16 V0, V1
BFD05CBE  8040F85C   SW V0, -32704(GP)
2417:                		}
2418:                		else
2419:                		{
2420:                			mtCOVERAGE_TEST_MARKER();
2421:                		}
2422:                
2423:                		/* If vTaskSuspend() is available then the suspended task list is also
2424:                		available and a task that is blocking indefinitely can enter the
2425:                		suspended state (it is not really suspended as it will re-enter the
2426:                		Ready state when the event it is waiting indefinitely for occurs).
2427:                		Blocking indefinitely is useful when using tickless idle mode as when
2428:                		all tasks are blocked indefinitely all timers can be turned off. */
2429:                		#if( INCLUDE_vTaskSuspend == 1 )
2430:                		{
2431:                			if( xWaitIndefinitely == pdTRUE )
BFD05CC2  0028FC7E   LW V1, 40(S8)
BFD05CC6      ED01   LI V0, 1
BFD05CC8  000EB443   BNE V1, V0, 0xBFD05CE8
BFD05CCA  0C00000E   SLL ZERO, T6, 1
BFD05CCC      0C00   NOP
2432:                			{
2433:                				/* Add the task to the suspended task list instead of a delayed
2434:                				task list to ensure the task is not woken by a timing event.  It
2435:                				will block indefinitely. */
2436:                				vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
BFD05CCE  8030FC5C   LW V0, -32720(GP)
BFD05CD2      6D22   ADDIU V0, V0, 4
BFD05CD4  BFD241A3   LUI V1, 0xBFD2
BFD05CD6  3083BFD2   LDC1 F30, 12419(S2)
BFD05CD8  80E43083   ADDIU A0, V1, -32540
BFD05CDC      0CA2   MOVE A1, V0
BFD05CDE  3E4A77E8   JALS vListInsertEnd
BFD05CE0  0C003E4A   LH S2, 3072(T2)
BFD05CE2      0C00   NOP
BFD05CE4      CC0D   B 0xBFD05D00
BFD05CE6      0C00   NOP
2437:                			}
2438:                			else
2439:                			{
2440:                				/* Calculate the time at which the task should be woken if the
2441:                				event does not occur.  This may overflow but this doesn't
2442:                				matter. */
2443:                				xTimeToWake = xTickCount + xTicksToWait;
BFD05CE8  803CFC7C   LW V1, -32708(GP)
BFD05CEC  0024FC5E   LW V0, 36(S8)
BFD05CF0      0526   ADDU V0, V1, V0
BFD05CF2  0010F85E   SW V0, 16(S8)
2444:                				traceTASK_DELAY_UNTIL();
2445:                				prvAddCurrentTaskToDelayedList( xTimeToWake );
BFD05CF6  0010FC9E   LW A0, 16(S8)
BFD05CFA  373477E8   JALS prvAddCurrentTaskToDelayedList
BFD05CFC  0C003734   LHU T9, 3072(S4)
BFD05CFE      0C00   NOP
2446:                			}
2447:                		}
2448:                		#else
2449:                		{
2450:                			/* Calculate the time at which the task should be woken if the event
2451:                			does not occur.  This may overflow but this doesn't matter. */
2452:                			xTimeToWake = xTickCount + xTicksToWait;
2453:                			traceTASK_DELAY_UNTIL();
2454:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
2455:                
2456:                			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
2457:                			defined. */
2458:                			( void ) xWaitIndefinitely;
2459:                		}
2460:                		#endif
2461:                	}
BFD05D00      0FBE   MOVE SP, S8
BFD05D02      4BE7   LW RA, 28(SP)
BFD05D04      4BC6   LW S8, 24(SP)
BFD05D06      4C11   ADDIU SP, SP, 32
BFD05D08      459F   JR16 RA
BFD05D0A      0C00   NOP
2462:                
2463:                #endif /* configUSE_TIMERS */
2464:                /*-----------------------------------------------------------*/
2465:                
2466:                BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2467:                {
BFD04578      4FF1   ADDIU SP, SP, -32
BFD0457A      CBE7   SW RA, 28(SP)
BFD0457C      CBC6   SW S8, 24(SP)
BFD0457E      0FDD   MOVE S8, SP
BFD04580  0020F89E   SW A0, 32(S8)
2468:                TCB_t *pxUnblockedTCB;
2469:                BaseType_t xReturn;
2470:                
2471:                	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2472:                	called from a critical section within an ISR. */
2473:                
2474:                	/* The event list is sorted in priority order, so the first in the list can
2475:                	be removed as it is known to be the highest priority.  Remove the TCB from
2476:                	the delayed list, and add it to the ready list.
2477:                
2478:                	If an event is for a queue that is locked then this function will never
2479:                	get called - the lock count on the queue will get modified instead.  This
2480:                	means exclusive access to the event list is guaranteed here.
2481:                
2482:                	This function assumes that a check has already been made to ensure that
2483:                	pxEventList is not empty. */
2484:                	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
BFD04584  0020FC5E   LW V0, 32(S8)
BFD04588      6923   LW V0, 12(V0)
BFD0458A      6923   LW V0, 12(V0)
BFD0458C  0014F85E   SW V0, 20(S8)
2485:                	configASSERT( pxUnblockedTCB );
BFD04590  0014FC5E   LW V0, 20(S8)
BFD04594  000940A2   BNEZC V0, 0xBFD045AA
BFD04598  BFD141A2   LUI V0, 0xBFD1
BFD0459A  3082BFD1   LDC1 F30, 12418(S1)
BFD0459C  98103082   ADDIU A0, V0, -26608
BFD0459E  30A09810   SWC1 F0, 12448(S0)
BFD045A0  09B530A0   ADDIU A1, ZERO, 2485
BFD045A2      09B5   LBU V1, 5(V1)
BFD045A4  4B7E77E8   JALS vAssertCalled
BFD045A6      4B7E   LW K1, 120(SP)
BFD045A8      0C00   NOP
2486:                	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
BFD045AA  0014FC5E   LW V0, 20(S8)
BFD045AC  6D2C0014   EXT ZERO, S4, 20, 14
BFD045AE      6D2C   ADDIU V0, V0, 24
BFD045B0      0C82   MOVE A0, V0
BFD045B2  00C877E8   JALS uxListRemove
BFD045B4  0C0000C8   SLL A2, T0, 1
BFD045B6      0C00   NOP
2487:                
2488:                	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
BFD045B8  805CFC5C   LW V0, -32676(GP)
BFD045BC  002740A2   BNEZC V0, 0xBFD0460E
2489:                	{
2490:                		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
BFD045C0  0014FC5E   LW V0, 20(S8)
BFD045C4      6D22   ADDIU V0, V0, 4
BFD045C6      0C82   MOVE A0, V0
BFD045C8  00C877E8   JALS uxListRemove
BFD045CA  0C0000C8   SLL A2, T0, 1
BFD045CC      0C00   NOP
2491:                		prvAddTaskToReadyList( pxUnblockedTCB );
BFD045CE  0014FC5E   LW V0, 20(S8)
BFD045D2      692B   LW V0, 44(V0)
BFD045D4      ED81   LI V1, 1
BFD045D6  18100062   SLLV V1, V0, V1
BFD045D8  FC5C1810   SB ZERO, -932(S0)
BFD045DA  8040FC5C   LW V0, -32704(GP)
BFD045DE      44D3   OR16 V0, V1
BFD045E0  8040F85C   SW V0, -32704(GP)
BFD045E4  0014FC5E   LW V0, 20(S8)
BFD045E8      692B   LW V0, 44(V0)
BFD045EA      2524   SLL V0, V0, 2
BFD045EC      25A4   SLL V1, V0, 2
BFD045EE      05B4   ADDU V1, V0, V1
BFD045F0  BFD241A2   LUI V0, 0xBFD2
BFD045F2  3042BFD2   LDC1 F30, 12354(S2)
BFD045F4  806C3042   ADDIU V0, V0, -32660
BFD045F8      05A6   ADDU V1, V1, V0
BFD045FA  0014FC5E   LW V0, 20(S8)
BFD045FE      6D22   ADDIU V0, V0, 4
BFD04600      0C83   MOVE A0, V1
BFD04602      0CA2   MOVE A1, V0
BFD04604  3E4A77E8   JALS vListInsertEnd
BFD04606  0C003E4A   LH S2, 3072(T2)
BFD04608      0C00   NOP
BFD0460A      CC0C   B 0xBFD04624
BFD0460C      0C00   NOP
2492:                	}
2493:                	else
2494:                	{
2495:                		/* The delayed and ready lists cannot be accessed, so hold this task
2496:                		pending until the scheduler is resumed. */
2497:                		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
BFD0460E  0014FC5E   LW V0, 20(S8)
BFD04610  6D2C0014   EXT ZERO, S4, 20, 14
BFD04612      6D2C   ADDIU V0, V0, 24
BFD04614  BFD241A3   LUI V1, 0xBFD2
BFD04616  3083BFD2   LDC1 F30, 12419(S2)
BFD04618  80D03083   ADDIU A0, V1, -32560
BFD0461C      0CA2   MOVE A1, V0
BFD0461E  3E4A77E8   JALS vListInsertEnd
BFD04620  0C003E4A   LH S2, 3072(T2)
BFD04622      0C00   NOP
2498:                	}
2499:                
2500:                	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
BFD04624  0014FC5E   LW V0, 20(S8)
BFD04628      69AB   LW V1, 44(V0)
BFD0462A  8030FC5C   LW V0, -32720(GP)
BFD0462E      692B   LW V0, 44(V0)
BFD04630  13900062   SLTU V0, V0, V1
BFD04632  40E21390   ADDI GP, S0, 16610
BFD04634  000840E2   BEQZC V0, 0xBFD04648
2501:                	{
2502:                		/* Return true if the task removed from the event list has a higher
2503:                		priority than the calling task.  This allows the calling task to know if
2504:                		it should force a context switch now. */
2505:                		xReturn = pdTRUE;
BFD04638      ED01   LI V0, 1
BFD0463A  0010F85E   SW V0, 16(S8)
2506:                
2507:                		/* Mark that a yield is pending in case the user is not using the
2508:                		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2509:                		xYieldPending = pdTRUE;
BFD0463E      ED01   LI V0, 1
BFD04640  804CF85C   SW V0, -32692(GP)
BFD04644      CC03   B 0xBFD0464C
BFD04646      0C00   NOP
2510:                	}
2511:                	else
2512:                	{
2513:                		xReturn = pdFALSE;
BFD04648  0010F81E   SW ZERO, 16(S8)
2514:                	}
2515:                
2516:                	#if( configUSE_TICKLESS_IDLE != 0 )
2517:                	{
2518:                		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2519:                		might be set to the blocked task's time out time.  If the task is
2520:                		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2521:                		normally left unchanged, because it is automatically reset to a new
2522:                		value when the tick count equals xNextTaskUnblockTime.  However if
2523:                		tickless idling is used it might be more important to enter sleep mode
2524:                		at the earliest possible time - so reset xNextTaskUnblockTime here to
2525:                		ensure it is updated at the earliest possible time. */
2526:                		prvResetNextTaskUnblockTime();
2527:                	}
2528:                	#endif
2529:                
2530:                	return xReturn;
BFD0464C  0010FC5E   LW V0, 16(S8)
2531:                }
BFD04650      0FBE   MOVE SP, S8
BFD04652      4BE7   LW RA, 28(SP)
BFD04654      4BC6   LW S8, 24(SP)
BFD04656      4C11   ADDIU SP, SP, 32
BFD04658      459F   JR16 RA
BFD0465A      0C00   NOP
2532:                /*-----------------------------------------------------------*/
2533:                
2534:                BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
2535:                {
BFD042C4      4FF1   ADDIU SP, SP, -32
BFD042C6      CBE7   SW RA, 28(SP)
BFD042C8      CBC6   SW S8, 24(SP)
BFD042CA      0FDD   MOVE S8, SP
BFD042CC  0020F89E   SW A0, 32(S8)
BFD042D0  0024F8BE   SW A1, 36(S8)
2536:                TCB_t *pxUnblockedTCB;
2537:                BaseType_t xReturn;
2538:                
2539:                	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2540:                	the event flags implementation. */
2541:                	configASSERT( uxSchedulerSuspended != pdFALSE );
BFD042D4  805CFC5C   LW V0, -32676(GP)
BFD042D8  000940A2   BNEZC V0, 0xBFD042EE
BFD042DC  BFD141A2   LUI V0, 0xBFD1
BFD042DE  3082BFD1   LDC1 F30, 12418(S1)
BFD042E0  98103082   ADDIU A0, V0, -26608
BFD042E2  30A09810   SWC1 F0, 12448(S0)
BFD042E4  09ED30A0   ADDIU A1, ZERO, 2541
BFD042E6      09ED   LBU V1, 13(A2)
BFD042E8  4B7E77E8   JALS vAssertCalled
BFD042EA      4B7E   LW K1, 120(SP)
BFD042EC      0C00   NOP
2542:                
2543:                	/* Store the new item value in the event list. */
2544:                	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
BFD042EE  0024FC7E   LW V1, 36(S8)
BFD042F2  800041A2   LUI V0, 0x8000
BFD042F6      44DA   OR16 V1, V0
BFD042F8  0020FC5E   LW V0, 32(S8)
BFD042FC      E9A0   SW V1, 0(V0)
2545:                
2546:                	/* Remove the event list form the event flag.  Interrupts do not access
2547:                	event flags. */
2548:                	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
BFD042FE  0020FC5E   LW V0, 32(S8)
BFD04302      6923   LW V0, 12(V0)
BFD04304  0014F85E   SW V0, 20(S8)
2549:                	configASSERT( pxUnblockedTCB );
BFD04308  0014FC5E   LW V0, 20(S8)
BFD0430C  000940A2   BNEZC V0, 0xBFD04322
BFD04310  BFD141A2   LUI V0, 0xBFD1
BFD04312  3082BFD1   LDC1 F30, 12418(S1)
BFD04314  98103082   ADDIU A0, V0, -26608
BFD04316  30A09810   SWC1 F0, 12448(S0)
BFD04318  09F530A0   ADDIU A1, ZERO, 2549
BFD0431A      09F5   LBU V1, 5(A3)
BFD0431C  4B7E77E8   JALS vAssertCalled
BFD0431E      4B7E   LW K1, 120(SP)
BFD04320      0C00   NOP
2550:                	( void ) uxListRemove( pxEventListItem );
BFD04322  0020FC9E   LW A0, 32(S8)
BFD04326  00C877E8   JALS uxListRemove
BFD04328  0C0000C8   SLL A2, T0, 1
BFD0432A      0C00   NOP
2551:                
2552:                	/* Remove the task from the delayed list and add it to the ready list.  The
2553:                	scheduler is suspended so interrupts will not be accessing the ready
2554:                	lists. */
2555:                	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
BFD0432C  0014FC5E   LW V0, 20(S8)
BFD04330      6D22   ADDIU V0, V0, 4
BFD04332      0C82   MOVE A0, V0
BFD04334  00C877E8   JALS uxListRemove
BFD04336  0C0000C8   SLL A2, T0, 1
BFD04338      0C00   NOP
2556:                	prvAddTaskToReadyList( pxUnblockedTCB );
BFD0433A  0014FC5E   LW V0, 20(S8)
BFD0433E      692B   LW V0, 44(V0)
BFD04340      ED81   LI V1, 1
BFD04342  18100062   SLLV V1, V0, V1
BFD04344  FC5C1810   SB ZERO, -932(S0)
BFD04346  8040FC5C   LW V0, -32704(GP)
BFD0434A      44D3   OR16 V0, V1
BFD0434C  8040F85C   SW V0, -32704(GP)
BFD04350  0014FC5E   LW V0, 20(S8)
BFD04354      692B   LW V0, 44(V0)
BFD04356      2524   SLL V0, V0, 2
BFD04358      25A4   SLL V1, V0, 2
BFD0435A      05B4   ADDU V1, V0, V1
BFD0435C  BFD241A2   LUI V0, 0xBFD2
BFD0435E  3042BFD2   LDC1 F30, 12354(S2)
BFD04360  806C3042   ADDIU V0, V0, -32660
BFD04364      05A6   ADDU V1, V1, V0
BFD04366  0014FC5E   LW V0, 20(S8)
BFD0436A      6D22   ADDIU V0, V0, 4
BFD0436C      0C83   MOVE A0, V1
BFD0436E      0CA2   MOVE A1, V0
BFD04370  3E4A77E8   JALS vListInsertEnd
BFD04372  0C003E4A   LH S2, 3072(T2)
BFD04374      0C00   NOP
2557:                
2558:                	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
BFD04376  0014FC5E   LW V0, 20(S8)
BFD0437A      69AB   LW V1, 44(V0)
BFD0437C  8030FC5C   LW V0, -32720(GP)
BFD04380      692B   LW V0, 44(V0)
BFD04382  13900062   SLTU V0, V0, V1
BFD04384  40E21390   ADDI GP, S0, 16610
BFD04386  000840E2   BEQZC V0, 0xBFD0439A
2559:                	{
2560:                		/* Return true if the task removed from the event list has
2561:                		a higher priority than the calling task.  This allows
2562:                		the calling task to know if it should force a context
2563:                		switch now. */
2564:                		xReturn = pdTRUE;
BFD0438A      ED01   LI V0, 1
BFD0438C  0010F85E   SW V0, 16(S8)
2565:                
2566:                		/* Mark that a yield is pending in case the user is not using the
2567:                		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2568:                		xYieldPending = pdTRUE;
BFD04390      ED01   LI V0, 1
BFD04392  804CF85C   SW V0, -32692(GP)
BFD04396      CC03   B 0xBFD0439E
BFD04398      0C00   NOP
2569:                	}
2570:                	else
2571:                	{
2572:                		xReturn = pdFALSE;
BFD0439A  0010F81E   SW ZERO, 16(S8)
2573:                	}
2574:                
2575:                	return xReturn;
BFD0439E  0010FC5E   LW V0, 16(S8)
2576:                }
BFD043A2      0FBE   MOVE SP, S8
BFD043A4      4BE7   LW RA, 28(SP)
BFD043A6      4BC6   LW S8, 24(SP)
BFD043A8      4C11   ADDIU SP, SP, 32
BFD043AA      459F   JR16 RA
BFD043AC      0C00   NOP
2577:                /*-----------------------------------------------------------*/
2578:                
2579:                void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2580:                {
BFD08F4C      4FF5   ADDIU SP, SP, -24
BFD08F4E      CBE5   SW RA, 20(SP)
BFD08F50      CBC4   SW S8, 16(SP)
BFD08F52      0FDD   MOVE S8, SP
BFD08F54  0018F89E   SW A0, 24(S8)
2581:                	configASSERT( pxTimeOut );
BFD08F58  0018FC5E   LW V0, 24(S8)
BFD08F5C  000940A2   BNEZC V0, 0xBFD08F72
BFD08F60  BFD141A2   LUI V0, 0xBFD1
BFD08F62  3082BFD1   LDC1 F30, 12418(S1)
BFD08F64  98103082   ADDIU A0, V0, -26608
BFD08F66  30A09810   SWC1 F0, 12448(S0)
BFD08F68  0A1530A0   ADDIU A1, ZERO, 2581
BFD08F6A      0A15   LBU A0, 5(S1)
BFD08F6C  4B7E77E8   JALS vAssertCalled
BFD08F6E      4B7E   LW K1, 120(SP)
BFD08F70      0C00   NOP
2582:                	pxTimeOut->xOverflowCount = xNumOfOverflows;
BFD08F72  8050FC7C   LW V1, -32688(GP)
BFD08F76  0018FC5E   LW V0, 24(S8)
BFD08F7A      E9A0   SW V1, 0(V0)
2583:                	pxTimeOut->xTimeOnEntering = xTickCount;
BFD08F7C  803CFC7C   LW V1, -32708(GP)
BFD08F80  0018FC5E   LW V0, 24(S8)
BFD08F84      E9A1   SW V1, 4(V0)
2584:                }
BFD08F86      0FBE   MOVE SP, S8
BFD08F88      4BE5   LW RA, 20(SP)
BFD08F8A      4BC4   LW S8, 16(SP)
BFD08F8C      4C0D   ADDIU SP, SP, 24
BFD08F8E      459F   JR16 RA
BFD08F90      0C00   NOP
2585:                /*-----------------------------------------------------------*/
2586:                
2587:                BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2588:                {
BFD03FEC      4FF1   ADDIU SP, SP, -32
BFD03FEE      CBE7   SW RA, 28(SP)
BFD03FF0      CBC6   SW S8, 24(SP)
BFD03FF2      0FDD   MOVE S8, SP
BFD03FF4  0020F89E   SW A0, 32(S8)
BFD03FF8  0024F8BE   SW A1, 36(S8)
2589:                BaseType_t xReturn;
2590:                
2591:                	configASSERT( pxTimeOut );
BFD03FFC  0020FC5E   LW V0, 32(S8)
BFD04000  000940A2   BNEZC V0, 0xBFD04016
BFD04004  BFD141A2   LUI V0, 0xBFD1
BFD04006  3082BFD1   LDC1 F30, 12418(S1)
BFD04008  98103082   ADDIU A0, V0, -26608
BFD0400A  30A09810   SWC1 F0, 12448(S0)
BFD0400C  0A1F30A0   ADDIU A1, ZERO, 2591
BFD0400E      0A1F   LBU A0, -1(S1)
BFD04010  4B7E77E8   JALS vAssertCalled
BFD04012      4B7E   LW K1, 120(SP)
BFD04014      0C00   NOP
2592:                	configASSERT( pxTicksToWait );
BFD04016  0024FC5E   LW V0, 36(S8)
BFD0401A  000940A2   BNEZC V0, 0xBFD04030
BFD0401E  BFD141A2   LUI V0, 0xBFD1
BFD04020  3082BFD1   LDC1 F30, 12418(S1)
BFD04022  98103082   ADDIU A0, V0, -26608
BFD04024  30A09810   SWC1 F0, 12448(S0)
BFD04026  0A2030A0   ADDIU A1, ZERO, 2592
BFD04028      0A20   LBU A0, 0(V0)
BFD0402A  4B7E77E8   JALS vAssertCalled
BFD0402C      4B7E   LW K1, 120(SP)
BFD0402E      0C00   NOP
2593:                
2594:                	taskENTER_CRITICAL();
BFD04030  33B877E8   JALS vTaskEnterCritical
BFD04032  0C0033B8   ADDIU SP, T8, 3072
BFD04034      0C00   NOP
2595:                	{
2596:                		/* Minor optimisation.  The tick count cannot change in this block. */
2597:                		const TickType_t xConstTickCount = xTickCount;
BFD04036  803CFC5C   LW V0, -32708(GP)
BFD0403A  0014F85E   SW V0, 20(S8)
2598:                
2599:                		#if ( INCLUDE_vTaskSuspend == 1 )
2600:                			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2601:                			the maximum block time then the task should block indefinitely, and
2602:                			therefore never time out. */
2603:                			if( *pxTicksToWait == portMAX_DELAY )
BFD0403E  0024FC5E   LW V0, 36(S8)
BFD04042      69A0   LW V1, 0(V0)
BFD04044      ED7F   LI V0, -1
BFD04046  0005B443   BNE V1, V0, 0xBFD04054
BFD04048  0C000005   SLL ZERO, A1, 1
BFD0404A      0C00   NOP
2604:                			{
2605:                				xReturn = pdFALSE;
BFD0404C  0010F81E   SW ZERO, 16(S8)
BFD0404E  CC3D0010   REPL.PH T9, 0x10
BFD04050      CC3D   B 0xBFD040CC
BFD04052      0C00   NOP
2606:                			}
2607:                			else /* We are not blocking indefinitely, perform the checks below. */
2608:                		#endif
2609:                
2610:                		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
BFD04054  0020FC5E   LW V0, 32(S8)
BFD04058      69A0   LW V1, 0(V0)
BFD0405A  8050FC5C   LW V0, -32688(GP)
BFD0405E  000F9443   BEQ V1, V0, 0xBFD04080
BFD04060  0C00000F   SLL ZERO, T7, 1
BFD04062      0C00   NOP
BFD04064  0020FC5E   LW V0, 32(S8)
BFD04068      69A1   LW V1, 4(V0)
BFD0406A  0014FC5E   LW V0, 20(S8)
BFD0406E  13900062   SLTU V0, V0, V1
BFD04070  40A21390   ADDI GP, S0, 16546
BFD04072  000540A2   BNEZC V0, 0xBFD04080
2611:                		{
2612:                			/* The tick count is greater than the time at which vTaskSetTimeout()
2613:                			was called, but has also overflowed since vTaskSetTimeOut() was called.
2614:                			It must have wrapped all the way around and gone past us again. This
2615:                			passed since vTaskSetTimeout() was called. */
2616:                			xReturn = pdTRUE;
BFD04076      ED01   LI V0, 1
BFD04078  0010F85E   SW V0, 16(S8)
BFD0407C      CC27   B 0xBFD040CC
BFD0407E      0C00   NOP
2617:                		}
2618:                		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
BFD04080  0020FC5E   LW V0, 32(S8)
BFD04084      6921   LW V0, 4(V0)
BFD04086  0014FC7E   LW V1, 20(S8)
BFD0408A      05A7   SUBU V1, V1, V0
BFD0408C  0024FC5E   LW V0, 36(S8)
BFD04090      6920   LW V0, 0(V0)
BFD04092  13900043   SLTU V0, V1, V0
BFD04094  40E21390   ADDI GP, S0, 16610
BFD04096  001640E2   BEQZC V0, 0xBFD040C6
2619:                		{
2620:                			/* Not a genuine timeout. Adjust parameters for time remaining. */
2621:                			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
BFD0409A  0024FC5E   LW V0, 36(S8)
BFD0409E      69A0   LW V1, 0(V0)
BFD040A0  0020FC5E   LW V0, 32(S8)
BFD040A4      6A21   LW A0, 4(V0)
BFD040A6  0014FC5E   LW V0, 20(S8)
BFD040AA      0529   SUBU V0, A0, V0
BFD040AC      05A6   ADDU V1, V1, V0
BFD040AE  0024FC5E   LW V0, 36(S8)
BFD040B2      E9A0   SW V1, 0(V0)
2622:                			vTaskSetTimeOutState( pxTimeOut );
BFD040B4  0020FC9E   LW A0, 32(S8)
BFD040B8  47A677E8   JALS vTaskSetTimeOutState
BFD040BC      0C00   NOP
2623:                			xReturn = pdFALSE;
BFD040BE  0010F81E   SW ZERO, 16(S8)
BFD040C2      CC04   B 0xBFD040CC
BFD040C4      0C00   NOP
2624:                		}
2625:                		else
2626:                		{
2627:                			xReturn = pdTRUE;
BFD040C6      ED01   LI V0, 1
BFD040C8  0010F85E   SW V0, 16(S8)
2628:                		}
2629:                	}
2630:                	taskEXIT_CRITICAL();
BFD040CC  40AA77E8   JALS vTaskExitCritical
BFD040CE  0C0040AA   BNEZC T2, 0xBFD058D2
BFD040D0      0C00   NOP
2631:                
2632:                	return xReturn;
BFD040D2  0010FC5E   LW V0, 16(S8)
2633:                }
BFD040D6      0FBE   MOVE SP, S8
BFD040D8      4BE7   LW RA, 28(SP)
BFD040DA      4BC6   LW S8, 24(SP)
BFD040DC      4C11   ADDIU SP, SP, 32
BFD040DE      459F   JR16 RA
BFD040E0      0C00   NOP
2634:                /*-----------------------------------------------------------*/
2635:                
2636:                void vTaskMissedYield( void )
2637:                {
BFD09E54      4FB0   ADDIU SP, SP, -8
BFD09E56      CBC1   SW S8, 4(SP)
BFD09E58      0FDD   MOVE S8, SP
2638:                	xYieldPending = pdTRUE;
BFD09E5A      ED01   LI V0, 1
BFD09E5C  804CF85C   SW V0, -32692(GP)
2639:                }
BFD09E60      0FBE   MOVE SP, S8
BFD09E62      4BC1   LW S8, 4(SP)
BFD09E64      4C05   ADDIU SP, SP, 8
BFD09E66      459F   JR16 RA
BFD09E68      0C00   NOP
2640:                /*-----------------------------------------------------------*/
2641:                
2642:                #if ( configUSE_TRACE_FACILITY == 1 )
2643:                
2644:                	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2645:                	{
2646:                	UBaseType_t uxReturn;
2647:                	TCB_t *pxTCB;
2648:                
2649:                		if( xTask != NULL )
2650:                		{
2651:                			pxTCB = ( TCB_t * ) xTask;
2652:                			uxReturn = pxTCB->uxTaskNumber;
2653:                		}
2654:                		else
2655:                		{
2656:                			uxReturn = 0U;
2657:                		}
2658:                
2659:                		return uxReturn;
2660:                	}
2661:                
2662:                #endif /* configUSE_TRACE_FACILITY */
2663:                /*-----------------------------------------------------------*/
2664:                
2665:                #if ( configUSE_TRACE_FACILITY == 1 )
2666:                
2667:                	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2668:                	{
2669:                	TCB_t *pxTCB;
2670:                
2671:                		if( xTask != NULL )
2672:                		{
2673:                			pxTCB = ( TCB_t * ) xTask;
2674:                			pxTCB->uxTaskNumber = uxHandle;
2675:                		}
2676:                	}
2677:                
2678:                #endif /* configUSE_TRACE_FACILITY */
2679:                
2680:                /*
2681:                 * -----------------------------------------------------------
2682:                 * The Idle task.
2683:                 * ----------------------------------------------------------
2684:                 *
2685:                 * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2686:                 * language extensions.  The equivalent prototype for this function is:
2687:                 *
2688:                 * void prvIdleTask( void *pvParameters );
2689:                 *
2690:                 */
2691:                static portTASK_FUNCTION( prvIdleTask, pvParameters )
2692:                {
BFD08BC4      4FF1   ADDIU SP, SP, -32
BFD08BC6      CBE7   SW RA, 28(SP)
BFD08BC8      CBC6   SW S8, 24(SP)
BFD08BCA      0FDD   MOVE S8, SP
BFD08BCC  0020F89E   SW A0, 32(S8)
BFD08BD0      CC02   B 0xBFD08BD6
BFD08BD2      0C00   NOP
2693:                	/* Stop warnings. */
2694:                	( void ) pvParameters;
2695:                
2696:                	for( ;; )
2697:                	{
2698:                		/* See if any tasks have been deleted. */
2699:                		prvCheckTasksWaitingTermination();
BFD08BD6  35AE77E8   JALS prvCheckTasksWaitingTermination
BFD08BD8  0C0035AE   LHU T5, 3072(T6)
BFD08BDA      0C00   NOP
2700:                
2701:                		#if ( configUSE_PREEMPTION == 0 )
2702:                		{
2703:                			/* If we are not using preemption we keep forcing a task switch to
2704:                			see if any other task has become available.  If we are using
2705:                			preemption we don't need to do this as any task becoming available
2706:                			will automatically get the processor anyway. */
2707:                			taskYIELD();
2708:                		}
2709:                		#endif /* configUSE_PREEMPTION */
2710:                
2711:                		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2712:                		{
2713:                			/* When using preemption tasks of equal priority will be
2714:                			timesliced.  If a task that is sharing the idle priority is ready
2715:                			to run then the idle task should yield before the end of the
2716:                			timeslice.
2717:                
2718:                			A critical region is not required here as we are just reading from
2719:                			the list, and an occasional incorrect value will not matter.  If
2720:                			the ready list at the idle priority contains more than one task
2721:                			then a task other than the idle task is ready to execute. */
2722:                			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
BFD08BDC  BFD241A2   LUI V0, 0xBFD2
BFD08BDE  FC42BFD2   LDC1 F30, -958(S2)
BFD08BE0  806CFC42   LW V0, -32660(V0)
BFD08BE4  0002B042   SLTIU V0, V0, 2
BFD08BE8  FFF440A2   BNEZC V0, 0xBFD08BD4
BFD08BEA  77E8FFF4   LW RA, 30696(S4)
2723:                			{
2724:                				taskYIELD();
BFD08BEC  4E5677E8   JALS ulPortGetCP0Cause
BFD08BEE      4E56   ADDIU S2, S2, -5
BFD08BF0      0C00   NOP
BFD08BF2  0010F85E   SW V0, 16(S8)
BFD08BF6  0010FC5E   LW V0, 16(S8)
BFD08BFA  01005042   ORI V0, V0, 256
BFD08BFE  0010F85E   SW V0, 16(S8)
BFD08C02  0010FC9E   LW A0, 16(S8)
BFD08C06  4E6677E8   JALS vPortSetCP0Cause
BFD08C08      4E66   ADDIU S3, S3, 3
BFD08C0A      0C00   NOP
2725:                			}
2726:                			else
2727:                			{
2728:                				mtCOVERAGE_TEST_MARKER();
2729:                			}
2730:                		}
2731:                		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2732:                
2733:                		#if ( configUSE_IDLE_HOOK == 1 )
2734:                		{
2735:                			extern void vApplicationIdleHook( void );
2736:                
2737:                			/* Call the user defined function from within the idle task.  This
2738:                			allows the application designer to add background functionality
2739:                			without the overhead of a separate task.
2740:                			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2741:                			CALL A FUNCTION THAT MIGHT BLOCK. */
2742:                			vApplicationIdleHook();
2743:                		}
2744:                		#endif /* configUSE_IDLE_HOOK */
2745:                
2746:                		/* This conditional compilation should use inequality to 0, not equality
2747:                		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2748:                		user defined low power mode	implementations require
2749:                		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2750:                		#if ( configUSE_TICKLESS_IDLE != 0 )
2751:                		{
2752:                		TickType_t xExpectedIdleTime;
2753:                
2754:                			/* It is not desirable to suspend then resume the scheduler on
2755:                			each iteration of the idle task.  Therefore, a preliminary
2756:                			test of the expected idle time is performed without the
2757:                			scheduler suspended.  The result here is not necessarily
2758:                			valid. */
2759:                			xExpectedIdleTime = prvGetExpectedIdleTime();
2760:                
2761:                			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2762:                			{
2763:                				vTaskSuspendAll();
2764:                				{
2765:                					/* Now the scheduler is suspended, the expected idle
2766:                					time can be sampled again, and this time its value can
2767:                					be used. */
2768:                					configASSERT( xNextTaskUnblockTime >= xTickCount );
2769:                					xExpectedIdleTime = prvGetExpectedIdleTime();
2770:                
2771:                					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2772:                					{
2773:                						traceLOW_POWER_IDLE_BEGIN();
2774:                						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2775:                						traceLOW_POWER_IDLE_END();
2776:                					}
2777:                					else
2778:                					{
2779:                						mtCOVERAGE_TEST_MARKER();
2780:                					}
2781:                				}
2782:                				( void ) xTaskResumeAll();
2783:                			}
2784:                			else
2785:                			{
2786:                				mtCOVERAGE_TEST_MARKER();
2787:                			}
2788:                		}
2789:                		#endif /* configUSE_TICKLESS_IDLE */
2790:                	}
BFD08BD4      0C00   NOP
BFD08C0C      CFE4   B 0xBFD08BD6
BFD08C0E      0C00   NOP
2791:                }
2792:                /*-----------------------------------------------------------*/
2793:                
2794:                #if( configUSE_TICKLESS_IDLE != 0 )
2795:                
2796:                	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2797:                	{
2798:                	/* The idle task exists in addition to the application tasks. */
2799:                	const UBaseType_t uxNonApplicationTasks = 1;
2800:                	eSleepModeStatus eReturn = eStandardSleep;
2801:                
2802:                		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2803:                		{
2804:                			/* A task was made ready while the scheduler was suspended. */
2805:                			eReturn = eAbortSleep;
2806:                		}
2807:                		else if( xYieldPending != pdFALSE )
2808:                		{
2809:                			/* A yield was pended while the scheduler was suspended. */
2810:                			eReturn = eAbortSleep;
2811:                		}
2812:                		else
2813:                		{
2814:                			/* If all the tasks are in the suspended list (which might mean they
2815:                			have an infinite block time rather than actually being suspended)
2816:                			then it is safe to turn all clocks off and just wait for external
2817:                			interrupts. */
2818:                			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
2819:                			{
2820:                				eReturn = eNoTasksWaitingTimeout;
2821:                			}
2822:                			else
2823:                			{
2824:                				mtCOVERAGE_TEST_MARKER();
2825:                			}
2826:                		}
2827:                
2828:                		return eReturn;
2829:                	}
2830:                
2831:                #endif /* configUSE_TICKLESS_IDLE */
2832:                /*-----------------------------------------------------------*/
2833:                
2834:                static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2835:                {
BFD03CE8      4FED   ADDIU SP, SP, -40
BFD03CEA      CBE9   SW RA, 36(SP)
BFD03CEC      CBC8   SW S8, 32(SP)
BFD03CEE      0FDD   MOVE S8, SP
BFD03CF0  0028F89E   SW A0, 40(S8)
BFD03CF4  002CF8BE   SW A1, 44(S8)
BFD03CF8  0030F8DE   SW A2, 48(S8)
BFD03CFC  0034F8FE   SW A3, 52(S8)
BFD03D00  0038FC5E   LW V0, 56(S8)
BFD03D04  0018385E   SH V0, 24(S8)
2836:                UBaseType_t x;
2837:                
2838:                	/* Store the task name in the TCB. */
2839:                	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
BFD03D08  0010F81E   SW ZERO, 16(S8)
BFD03D0A  CC1D0010   SHILO null, 16
BFD03D0C      CC1D   B 0xBFD03D48
BFD03D0E      0C00   NOP
BFD03D3E  0010FC5E   LW V0, 16(S8)
BFD03D42      6D20   ADDIU V0, V0, 1
BFD03D44  0010F85E   SW V0, 16(S8)
BFD03D48  0010FC5E   LW V0, 16(S8)
BFD03D4C  0008B042   SLTIU V0, V0, 8
BFD03D50  FFDE40A2   BNEZC V0, 0xBFD03D10
BFD03D52  CC02FFDE   LW S8, -13310(S8)
BFD03D54      CC02   B 0xBFD03D5A
BFD03D56      0C00   NOP
2840:                	{
2841:                		pxTCB->pcTaskName[ x ] = pcName[ x ];
BFD03D10  002CFC7E   LW V1, 44(S8)
BFD03D14  0010FC5E   LW V0, 16(S8)
BFD03D18      0526   ADDU V0, V1, V0
BFD03D1A  00001C62   LB V1, 0(V0)
BFD03D1E  0028FC9E   LW A0, 40(S8)
BFD03D22  0010FC5E   LW V0, 16(S8)
BFD03D26      0528   ADDU V0, A0, V0
BFD03D28  00341862   SB V1, 52(V0)
2842:                
2843:                		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2844:                		configMAX_TASK_NAME_LEN characters just in case the memory after the
2845:                		string is not accessible (extremely unlikely). */
2846:                		if( pcName[ x ] == 0x00 )
BFD03D2C  002CFC7E   LW V1, 44(S8)
BFD03D30  0010FC5E   LW V0, 16(S8)
BFD03D34      0526   ADDU V0, V1, V0
BFD03D36  00001C42   LB V0, 0(V0)
BFD03D3A  000D40E2   BEQZC V0, 0xBFD03D58
2847:                		{
2848:                			break;
BFD03D58      0C00   NOP
2849:                		}
2850:                		else
2851:                		{
2852:                			mtCOVERAGE_TEST_MARKER();
2853:                		}
2854:                	}
2855:                
2856:                	/* Ensure the name string is terminated in the case that the string length
2857:                	was greater or equal to configMAX_TASK_NAME_LEN. */
2858:                	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
BFD03D5A  0028FC5E   LW V0, 40(S8)
BFD03D5E  003B1802   SB ZERO, 59(V0)
2859:                
2860:                	/* This is used as an array index so must ensure it's not too large.  First
2861:                	remove the privilege bit if one is present. */
2862:                	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
BFD03D62  0030FC5E   LW V0, 48(S8)
BFD03D66  0005B042   SLTIU V0, V0, 5
BFD03D6A  000340A2   BNEZC V0, 0xBFD03D74
2863:                	{
2864:                		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
BFD03D6E      ED04   LI V0, 4
BFD03D70  0030F85E   SW V0, 48(S8)
2865:                	}
2866:                	else
2867:                	{
2868:                		mtCOVERAGE_TEST_MARKER();
2869:                	}
2870:                
2871:                	pxTCB->uxPriority = uxPriority;
BFD03D74  0028FC5E   LW V0, 40(S8)
BFD03D78  0030FC7E   LW V1, 48(S8)
BFD03D7C      E9AB   SW V1, 44(V0)
2872:                	#if ( configUSE_MUTEXES == 1 )
2873:                	{
2874:                		pxTCB->uxBasePriority = uxPriority;
BFD03D7E  0028FC5E   LW V0, 40(S8)
BFD03D82  0030FC7E   LW V1, 48(S8)
BFD03D86  0040F862   SW V1, 64(V0)
2875:                		pxTCB->uxMutexesHeld = 0;
BFD03D8A  0028FC5E   LW V0, 40(S8)
BFD03D8E  0044F802   SW ZERO, 68(V0)
2876:                	}
2877:                	#endif /* configUSE_MUTEXES */
2878:                
2879:                	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
BFD03D92  0028FC5E   LW V0, 40(S8)
BFD03D96      6D22   ADDIU V0, V0, 4
BFD03D98      0C82   MOVE A0, V0
BFD03D9A  4EE677E8   JALS vListInitialiseItem
BFD03D9C      4EE6   ADDIU S7, S7, 3
BFD03D9E      0C00   NOP
2880:                	vListInitialiseItem( &( pxTCB->xEventListItem ) );
BFD03DA0  0028FC5E   LW V0, 40(S8)
BFD03DA2  6D2C0028   EXT AT, T0, 20, 14
BFD03DA4      6D2C   ADDIU V0, V0, 24
BFD03DA6      0C82   MOVE A0, V0
BFD03DA8  4EE677E8   JALS vListInitialiseItem
BFD03DAA      4EE6   ADDIU S7, S7, 3
BFD03DAC      0C00   NOP
2881:                
2882:                	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2883:                	back to	the containing TCB from a generic item in a list. */
2884:                	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
BFD03DAE  0028FC5E   LW V0, 40(S8)
BFD03DB2  0028FC7E   LW V1, 40(S8)
BFD03DB6      E9A4   SW V1, 16(V0)
2885:                
2886:                	/* Event lists are always in priority order. */
2887:                	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
BFD03DB8      ED85   LI V1, 5
BFD03DBA  0030FC5E   LW V0, 48(S8)
BFD03DBE      05A7   SUBU V1, V1, V0
BFD03DC0  0028FC5E   LW V0, 40(S8)
BFD03DC4      E9A6   SW V1, 24(V0)
2888:                	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
BFD03DC6  0028FC5E   LW V0, 40(S8)
BFD03DCA  0028FC7E   LW V1, 40(S8)
BFD03DCE      E9A9   SW V1, 36(V0)
2889:                
2890:                	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2891:                	{
2892:                		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
BFD03DD0  0028FC5E   LW V0, 40(S8)
BFD03DD4      E82F   SW S0, 60(V0)
2893:                	}
2894:                	#endif /* portCRITICAL_NESTING_IN_TCB */
2895:                
2896:                	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2897:                	{
2898:                		pxTCB->pxTaskTag = NULL;
2899:                	}
2900:                	#endif /* configUSE_APPLICATION_TASK_TAG */
2901:                
2902:                	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2903:                	{
2904:                		pxTCB->ulRunTimeCounter = 0UL;
2905:                	}
2906:                	#endif /* configGENERATE_RUN_TIME_STATS */
2907:                
2908:                	#if ( portUSING_MPU_WRAPPERS == 1 )
2909:                	{
2910:                		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2911:                	}
2912:                	#else /* portUSING_MPU_WRAPPERS */
2913:                	{
2914:                		( void ) xRegions;
2915:                		( void ) usStackDepth;
2916:                	}
2917:                	#endif /* portUSING_MPU_WRAPPERS */
2918:                
2919:                	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2920:                	{
2921:                		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
2922:                		{
2923:                			pxTCB->pvThreadLocalStoragePointers[ x ] = NULL;
2924:                		}
2925:                	}
2926:                	#endif
2927:                
2928:                	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
2929:                	{
2930:                		pxTCB->ulNotifiedValue = 0;
BFD03DD6  0028FC5E   LW V0, 40(S8)
BFD03DDA  0048F802   SW ZERO, 72(V0)
2931:                		pxTCB->eNotifyState = eNotWaitingNotification;
BFD03DDE  0028FC5E   LW V0, 40(S8)
BFD03DE2  004CF802   SW ZERO, 76(V0)
2932:                	}
2933:                	#endif
2934:                
2935:                	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2936:                	{
2937:                		/* Initialise this task's Newlib reent structure. */
2938:                		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2939:                	}
2940:                	#endif /* configUSE_NEWLIB_REENTRANT */
2941:                }
BFD03DE6      0FBE   MOVE SP, S8
BFD03DE8      4BE9   LW RA, 36(SP)
BFD03DEA      4BC8   LW S8, 32(SP)
BFD03DEC      4C15   ADDIU SP, SP, 40
BFD03DEE      459F   JR16 RA
BFD03DF0      0C00   NOP
2942:                /*-----------------------------------------------------------*/
2943:                
2944:                #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2945:                
2946:                	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
2947:                	{
2948:                	TCB_t *pxTCB;
2949:                
2950:                		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2951:                		{
2952:                			pxTCB = prvGetTCBFromHandle( xTaskToSet );
2953:                			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
2954:                		}
2955:                	}
2956:                
2957:                #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2958:                /*-----------------------------------------------------------*/
2959:                
2960:                #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2961:                
2962:                	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
2963:                	{
2964:                	void *pvReturn = NULL;
2965:                	TCB_t *pxTCB;
2966:                
2967:                		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2968:                		{
2969:                			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2970:                			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
2971:                		}
2972:                		else
2973:                		{
2974:                			pvReturn = NULL;
2975:                		}
2976:                
2977:                		return pvReturn;
2978:                	}
2979:                
2980:                #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2981:                /*-----------------------------------------------------------*/
2982:                
2983:                #if ( portUSING_MPU_WRAPPERS == 1 )
2984:                
2985:                	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2986:                	{
2987:                	TCB_t *pxTCB;
2988:                
2989:                		/* If null is passed in here then we are modifying the MPU settings of
2990:                		the calling task. */
2991:                		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2992:                
2993:                        vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2994:                	}
2995:                
2996:                #endif /* portUSING_MPU_WRAPPERS */
2997:                /*-----------------------------------------------------------*/
2998:                
2999:                static void prvInitialiseTaskLists( void )
3000:                {
BFD0612C      4FF1   ADDIU SP, SP, -32
BFD0612E      CBE7   SW RA, 28(SP)
BFD06130      CBC6   SW S8, 24(SP)
BFD06132      0FDD   MOVE S8, SP
3001:                UBaseType_t uxPriority;
3002:                
3003:                	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
BFD06134  0010F81E   SW ZERO, 16(S8)
BFD06138      CC14   B 0xBFD06162
BFD0613A      0C00   NOP
BFD06158  0010FC5E   LW V0, 16(S8)
BFD0615C      6D20   ADDIU V0, V0, 1
BFD0615E  0010F85E   SW V0, 16(S8)
BFD06162  0010FC5E   LW V0, 16(S8)
BFD06166  0005B042   SLTIU V0, V0, 5
BFD0616A  FFE740A2   BNEZC V0, 0xBFD0613C
BFD0616C  41A2FFE7   LW RA, 16802(A3)
3004:                	{
3005:                		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
BFD0613C  0010FC5E   LW V0, 16(S8)
BFD06140      2524   SLL V0, V0, 2
BFD06142      25A4   SLL V1, V0, 2
BFD06144      05B4   ADDU V1, V0, V1
BFD06146  BFD241A2   LUI V0, 0xBFD2
BFD06148  3042BFD2   LDC1 F30, 12354(S2)
BFD0614A  806C3042   ADDIU V0, V0, -32660
BFD0614E      0526   ADDU V0, V1, V0
BFD06150      0C82   MOVE A0, V0
BFD06152  457077E8   JALS vListInitialise
BFD06154      4570   SWM16 0x3, 0(SP)
BFD06156      0C00   NOP
3006:                	}
3007:                
3008:                	vListInitialise( &xDelayedTaskList1 );
BFD0616E  BFD241A2   LUI V0, 0xBFD2
BFD06170  3082BFD2   LDC1 F30, 12418(S2)
BFD06172  80F83082   ADDIU A0, V0, -32520
BFD06176  457077E8   JALS vListInitialise
BFD06178      4570   SWM16 0x3, 0(SP)
BFD0617A      0C00   NOP
3009:                	vListInitialise( &xDelayedTaskList2 );
BFD0617C  BFD241A2   LUI V0, 0xBFD2
BFD0617E  3082BFD2   LDC1 F30, 12418(S2)
BFD06180  81203082   ADDIU A0, V0, -32480
BFD06184  457077E8   JALS vListInitialise
BFD06186      4570   SWM16 0x3, 0(SP)
BFD06188      0C00   NOP
3010:                	vListInitialise( &xPendingReadyList );
BFD0618A  BFD241A2   LUI V0, 0xBFD2
BFD0618C  3082BFD2   LDC1 F30, 12418(S2)
BFD0618E  80D03082   ADDIU A0, V0, -32560
BFD06192  457077E8   JALS vListInitialise
BFD06194      4570   SWM16 0x3, 0(SP)
BFD06196      0C00   NOP
3011:                
3012:                	#if ( INCLUDE_vTaskDelete == 1 )
3013:                	{
3014:                		vListInitialise( &xTasksWaitingTermination );
BFD06198  BFD241A2   LUI V0, 0xBFD2
BFD0619A  3082BFD2   LDC1 F30, 12418(S2)
BFD0619C  810C3082   ADDIU A0, V0, -32500
BFD061A0  457077E8   JALS vListInitialise
BFD061A2      4570   SWM16 0x3, 0(SP)
BFD061A4      0C00   NOP
3015:                	}
3016:                	#endif /* INCLUDE_vTaskDelete */
3017:                
3018:                	#if ( INCLUDE_vTaskSuspend == 1 )
3019:                	{
3020:                		vListInitialise( &xSuspendedTaskList );
BFD061A6  BFD241A2   LUI V0, 0xBFD2
BFD061A8  3082BFD2   LDC1 F30, 12418(S2)
BFD061AA  80E43082   ADDIU A0, V0, -32540
BFD061AE  457077E8   JALS vListInitialise
BFD061B0      4570   SWM16 0x3, 0(SP)
BFD061B2      0C00   NOP
3021:                	}
3022:                	#endif /* INCLUDE_vTaskSuspend */
3023:                
3024:                	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3025:                	using list2. */
3026:                	pxDelayedTaskList = &xDelayedTaskList1;
BFD061B4  BFD241A2   LUI V0, 0xBFD2
BFD061B6  3042BFD2   LDC1 F30, 12354(S2)
BFD061B8  80F83042   ADDIU V0, V0, -32520
BFD061BC  8074F85C   SW V0, -32652(GP)
3027:                	pxOverflowDelayedTaskList = &xDelayedTaskList2;
BFD061C0  BFD241A2   LUI V0, 0xBFD2
BFD061C2  3042BFD2   LDC1 F30, 12354(S2)
BFD061C4  81203042   ADDIU V0, V0, -32480
BFD061C8  8078F85C   SW V0, -32648(GP)
3028:                }
BFD061CC      0FBE   MOVE SP, S8
BFD061CE      4BE7   LW RA, 28(SP)
BFD061D0      4BC6   LW S8, 24(SP)
BFD061D2      4C11   ADDIU SP, SP, 32
BFD061D4      459F   JR16 RA
BFD061D6      0C00   NOP
3029:                /*-----------------------------------------------------------*/
3030:                
3031:                static void prvCheckTasksWaitingTermination( void )
3032:                {
BFD06B5C      4FF1   ADDIU SP, SP, -32
BFD06B5E      CBE7   SW RA, 28(SP)
BFD06B60      CBC6   SW S8, 24(SP)
BFD06B62      0FDD   MOVE S8, SP
3033:                	#if ( INCLUDE_vTaskDelete == 1 )
3034:                	{
3035:                		BaseType_t xListIsEmpty;
3036:                
3037:                		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3038:                		too often in the idle task. */
3039:                		while( uxTasksDeleted > ( UBaseType_t ) 0U )
BFD06B64      CC37   B 0xBFD06BD4
BFD06B66      0C00   NOP
BFD06BD4  8034FC5C   LW V0, -32716(GP)
BFD06BD8  FFC640A2   BNEZC V0, 0xBFD06B68
BFD06BDA  0FBEFFC6   LW S8, 4030(A2)
3040:                		{
3041:                			vTaskSuspendAll();
BFD06B68  4EF477E8   JALS vTaskSuspendAll
BFD06B6A      4EF4   ADDIU S7, S7, -6
BFD06B6C      0C00   NOP
3042:                			{
3043:                				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
BFD06B6E  BFD241A2   LUI V0, 0xBFD2
BFD06B70  FC42BFD2   LDC1 F30, -958(S2)
BFD06B72  810CFC42   LW V0, -32500(V0)
BFD06B76  0001B042   SLTIU V0, V0, 1
BFD06B7A  0010F85E   SW V0, 16(S8)
3044:                			}
3045:                			( void ) xTaskResumeAll();
BFD06B7E  158E77E8   JALS xTaskResumeAll
BFD06B80  0C00158E   LBU T4, 3072(T6)
BFD06B82      0C00   NOP
3046:                
3047:                			if( xListIsEmpty == pdFALSE )
BFD06B84  0010FC5E   LW V0, 16(S8)
BFD06B88  002440A2   BNEZC V0, 0xBFD06BD4
3048:                			{
3049:                				TCB_t *pxTCB;
3050:                
3051:                				taskENTER_CRITICAL();
BFD06B8C  33B877E8   JALS vTaskEnterCritical
BFD06B8E  0C0033B8   ADDIU SP, T8, 3072
BFD06B90      0C00   NOP
3052:                				{
3053:                					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
BFD06B92  BFD241A2   LUI V0, 0xBFD2
BFD06B94  3042BFD2   LDC1 F30, 12354(S2)
BFD06B96  810C3042   ADDIU V0, V0, -32500
BFD06B9A      6923   LW V0, 12(V0)
BFD06B9C      6923   LW V0, 12(V0)
BFD06B9E  0014F85E   SW V0, 20(S8)
3054:                					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
BFD06BA2  0014FC5E   LW V0, 20(S8)
BFD06BA6      6D22   ADDIU V0, V0, 4
BFD06BA8      0C82   MOVE A0, V0
BFD06BAA  00C877E8   JALS uxListRemove
BFD06BAC  0C0000C8   SLL A2, T0, 1
BFD06BAE      0C00   NOP
3055:                					--uxCurrentNumberOfTasks;
BFD06BB0  8038FC5C   LW V0, -32712(GP)
BFD06BB4      6D2E   ADDIU V0, V0, -1
BFD06BB6  8038F85C   SW V0, -32712(GP)
3056:                					--uxTasksDeleted;
BFD06BBA  8034FC5C   LW V0, -32716(GP)
BFD06BBE      6D2E   ADDIU V0, V0, -1
BFD06BC0  8034F85C   SW V0, -32716(GP)
3057:                				}
3058:                				taskEXIT_CRITICAL();
BFD06BC4  40AA77E8   JALS vTaskExitCritical
BFD06BC6  0C0040AA   BNEZC T2, 0xBFD083CA
BFD06BC8      0C00   NOP
3059:                
3060:                				prvDeleteTCB( pxTCB );
BFD06BCA  0014FC9E   LW A0, 20(S8)
BFD06BCE  4C6E77E8   JALS prvDeleteTCB
BFD06BD0      4C6E   ADDIU V1, V1, 7
BFD06BD2      0C00   NOP
3061:                			}
3062:                			else
3063:                			{
3064:                				mtCOVERAGE_TEST_MARKER();
3065:                			}
3066:                		}
3067:                	}
3068:                	#endif /* vTaskDelete */
3069:                }
BFD06BDC      0FBE   MOVE SP, S8
BFD06BDE      4BE7   LW RA, 28(SP)
BFD06BE0      4BC6   LW S8, 24(SP)
BFD06BE2      4C11   ADDIU SP, SP, 32
BFD06BE4      459F   JR16 RA
BFD06BE6      0C00   NOP
3070:                /*-----------------------------------------------------------*/
3071:                
3072:                static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
3073:                {
BFD06E68      4FF5   ADDIU SP, SP, -24
BFD06E6A      CBE5   SW RA, 20(SP)
BFD06E6C      CBC4   SW S8, 16(SP)
BFD06E6E      0FDD   MOVE S8, SP
BFD06E70  0018F89E   SW A0, 24(S8)
3074:                	/* The list item will be inserted in wake time order. */
3075:                	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
BFD06E74  8030FC5C   LW V0, -32720(GP)
BFD06E78  0018FC7E   LW V1, 24(S8)
BFD06E7C      E9A1   SW V1, 4(V0)
3076:                
3077:                	if( xTimeToWake < xTickCount )
BFD06E7E  803CFC5C   LW V0, -32708(GP)
BFD06E82  0018FC7E   LW V1, 24(S8)
BFD06E86  13900043   SLTU V0, V1, V0
BFD06E88  40E21390   ADDI GP, S0, 16610
BFD06E8A  000C40E2   BEQZC V0, 0xBFD06EA6
3078:                	{
3079:                		/* Wake time has overflowed.  Place this item in the overflow list. */
3080:                		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
BFD06E8E  8078FC7C   LW V1, -32648(GP)
BFD06E92  8030FC5C   LW V0, -32720(GP)
BFD06E96      6D22   ADDIU V0, V0, 4
BFD06E98      0C83   MOVE A0, V1
BFD06E9A      0CA2   MOVE A1, V0
BFD06E9C  304077E8   JALS vListInsert
BFD06E9E  0C003040   ADDIU V0, ZERO, 3072
BFD06EA0      0C00   NOP
BFD06EA2      CC17   B 0xBFD06ED2
BFD06EA4      0C00   NOP
3081:                	}
3082:                	else
3083:                	{
3084:                		/* The wake time has not overflowed, so the current block list is used. */
3085:                		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
BFD06EA6  8074FC7C   LW V1, -32652(GP)
BFD06EAA  8030FC5C   LW V0, -32720(GP)
BFD06EAE      6D22   ADDIU V0, V0, 4
BFD06EB0      0C83   MOVE A0, V1
BFD06EB2      0CA2   MOVE A1, V0
BFD06EB4  304077E8   JALS vListInsert
BFD06EB6  0C003040   ADDIU V0, ZERO, 3072
BFD06EB8      0C00   NOP
3086:                
3087:                		/* If the task entering the blocked state was placed at the head of the
3088:                		list of blocked tasks then xNextTaskUnblockTime needs to be updated
3089:                		too. */
3090:                		if( xTimeToWake < xNextTaskUnblockTime )
BFD06EBA  8058FC5C   LW V0, -32680(GP)
BFD06EBE  0018FC7E   LW V1, 24(S8)
BFD06EC2  13900043   SLTU V0, V1, V0
BFD06EC4  40E21390   ADDI GP, S0, 16610
BFD06EC6  000440E2   BEQZC V0, 0xBFD06ED2
3091:                		{
3092:                			xNextTaskUnblockTime = xTimeToWake;
BFD06ECA  0018FC5E   LW V0, 24(S8)
BFD06ECE  8058F85C   SW V0, -32680(GP)
3093:                		}
3094:                		else
3095:                		{
3096:                			mtCOVERAGE_TEST_MARKER();
3097:                		}
3098:                	}
3099:                }
BFD06ED2      0FBE   MOVE SP, S8
BFD06ED4      4BE5   LW RA, 20(SP)
BFD06ED6      4BC4   LW S8, 16(SP)
BFD06ED8      4C0D   ADDIU SP, SP, 24
BFD06EDA      459F   JR16 RA
BFD06EDC      0C00   NOP
3100:                /*-----------------------------------------------------------*/
3101:                
3102:                static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
3103:                {
BFD06328      4FF1   ADDIU SP, SP, -32
BFD0632A      CBE7   SW RA, 28(SP)
BFD0632C      CBC6   SW S8, 24(SP)
BFD0632E      0FDD   MOVE S8, SP
BFD06330      0C44   MOVE V0, A0
BFD06332  0024F8BE   SW A1, 36(S8)
BFD06336  0020385E   SH V0, 32(S8)
3104:                TCB_t *pxNewTCB;
3105:                
3106:                	/* If the stack grows down then allocate the stack then the TCB so the stack
3107:                	does not grow into the TCB.  Likewise if the stack grows up then allocate
3108:                	the TCB then the stack. */
3109:                	#if( portSTACK_GROWTH > 0 )
3110:                	{
3111:                		/* Allocate space for the TCB.  Where the memory comes from depends on
3112:                		the implementation of the port malloc function. */
3113:                		pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
3114:                
3115:                		if( pxNewTCB != NULL )
3116:                		{
3117:                			/* Allocate space for the stack used by the task being created.
3118:                			The base of the stack memory stored in the TCB so the task can
3119:                			be deleted later if required. */
3120:                			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
3121:                
3122:                			if( pxNewTCB->pxStack == NULL )
3123:                			{
3124:                				/* Could not allocate the stack.  Delete the allocated TCB. */
3125:                				vPortFree( pxNewTCB );
3126:                				pxNewTCB = NULL;
3127:                			}
3128:                		}
3129:                	}
3130:                	#else /* portSTACK_GROWTH */
3131:                	{
3132:                	StackType_t *pxStack;
3133:                
3134:                		/* Allocate space for the stack used by the task being created. */
3135:                		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
BFD0633A  0024FC5E   LW V0, 36(S8)
BFD0633E  000940A2   BNEZC V0, 0xBFD06354
BFD06342  0020345E   LHU V0, 32(S8)
BFD06346      2524   SLL V0, V0, 2
BFD06348      0C82   MOVE A0, V0
BFD0634A  111677E8   JALS pvPortMalloc
BFD0634C  0C001116   ADDI T0, S6, 3072
BFD0634E      0C00   NOP
BFD06350      CC03   B 0xBFD06358
BFD06352      0C00   NOP
BFD06354  0024FC5E   LW V0, 36(S8)
BFD06358  0014F85E   SW V0, 20(S8)
3136:                
3137:                		if( pxStack != NULL )
BFD0635C  0014FC5E   LW V0, 20(S8)
BFD06360  001840E2   BEQZC V0, 0xBFD06394
BFD06362  EE500018   AND SP, T8, ZERO
3138:                		{
3139:                			/* Allocate space for the TCB.  Where the memory comes from depends
3140:                			on the implementation of the port malloc function. */
3141:                			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
BFD06364      EE50   LI A0, 80
BFD06366  111677E8   JALS pvPortMalloc
BFD06368  0C001116   ADDI T0, S6, 3072
BFD0636A      0C00   NOP
BFD0636C  0010F85E   SW V0, 16(S8)
3142:                
3143:                			if( pxNewTCB != NULL )
BFD06370  0010FC5E   LW V0, 16(S8)
BFD06374  000740E2   BEQZC V0, 0xBFD06386
3144:                			{
3145:                				/* Store the stack location in the TCB. */
3146:                				pxNewTCB->pxStack = pxStack;
BFD06378  0010FC5E   LW V0, 16(S8)
BFD0637C  0014FC7E   LW V1, 20(S8)
BFD0637E  E9AC0014   EXT ZERO, S4, 6, 30
BFD06380      E9AC   SW V1, 48(V0)
BFD06382      CC0A   B 0xBFD06398
BFD06384      0C00   NOP
3147:                			}
3148:                			else
3149:                			{
3150:                				/* The stack cannot be used as the TCB was not created.  Free it
3151:                				again. */
3152:                				vPortFree( pxStack );
BFD06386  0014FC9E   LW A0, 20(S8)
BFD0638A  2FEA77E8   JALS vPortFree
BFD0638C      2FEA   ANDI A3, A2, 0x20
BFD0638E      0C00   NOP
BFD06390      CC03   B 0xBFD06398
BFD06392      0C00   NOP
3153:                			}
3154:                		}
3155:                		else
3156:                		{
3157:                			pxNewTCB = NULL;
BFD06394  0010F81E   SW ZERO, 16(S8)
3158:                		}
3159:                	}
3160:                	#endif /* portSTACK_GROWTH */
3161:                
3162:                	if( pxNewTCB != NULL )
BFD06398  0010FC5E   LW V0, 16(S8)
BFD0639C  000D40E2   BEQZC V0, 0xBFD063BA
3163:                	{
3164:                		/* Avoid dependency on memset() if it is not required. */
3165:                		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3166:                		{
3167:                			/* Just to help debugging. */
3168:                			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
BFD063A0  0010FC5E   LW V0, 16(S8)
BFD063A2  69AC0010   EXT ZERO, S0, 6, 14
BFD063A4      69AC   LW V1, 48(V0)
BFD063A6  0020345E   LHU V0, 32(S8)
BFD063AA      2524   SLL V0, V0, 2
BFD063AC      0C83   MOVE A0, V1
BFD063AE  00A530A0   ADDIU A1, ZERO, 165
BFD063B2      0CC2   MOVE A2, V0
BFD063B4  36F677E8   JALS 0xBFD06DEC
BFD063B6  0C0036F6   LHU S7, 3072(S6)
BFD063B8      0C00   NOP
3169:                		}
3170:                		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
3171:                	}
3172:                
3173:                	return pxNewTCB;
BFD063BA  0010FC5E   LW V0, 16(S8)
3174:                }
BFD063BE      0FBE   MOVE SP, S8
BFD063C0      4BE7   LW RA, 28(SP)
BFD063C2      4BC6   LW S8, 24(SP)
BFD063C4      4C11   ADDIU SP, SP, 32
BFD063C6      459F   JR16 RA
BFD063C8      0C00   NOP
3175:                /*-----------------------------------------------------------*/
3176:                
3177:                #if ( configUSE_TRACE_FACILITY == 1 )
3178:                
3179:                	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
3180:                	{
3181:                	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3182:                	UBaseType_t uxTask = 0;
3183:                
3184:                		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3185:                		{
3186:                			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3187:                
3188:                			/* Populate an TaskStatus_t structure within the
3189:                			pxTaskStatusArray array for each task that is referenced from
3190:                			pxList.  See the definition of TaskStatus_t in task.h for the
3191:                			meaning of each TaskStatus_t structure member. */
3192:                			do
3193:                			{
3194:                				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3195:                
3196:                				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
3197:                				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
3198:                				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
3199:                				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
3200:                				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
3201:                
3202:                				#if ( INCLUDE_vTaskSuspend == 1 )
3203:                				{
3204:                					/* If the task is in the suspended list then there is a chance
3205:                					it is actually just blocked indefinitely - so really it should
3206:                					be reported as being in the Blocked state. */
3207:                					if( eState == eSuspended )
3208:                					{
3209:                						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
3210:                						{
3211:                							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
3212:                						}
3213:                					}
3214:                				}
3215:                				#endif /* INCLUDE_vTaskSuspend */
3216:                
3217:                				#if ( configUSE_MUTEXES == 1 )
3218:                				{
3219:                					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
3220:                				}
3221:                				#else
3222:                				{
3223:                					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
3224:                				}
3225:                				#endif
3226:                
3227:                				#if ( configGENERATE_RUN_TIME_STATS == 1 )
3228:                				{
3229:                					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
3230:                				}
3231:                				#else
3232:                				{
3233:                					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
3234:                				}
3235:                				#endif
3236:                
3237:                				#if ( portSTACK_GROWTH > 0 )
3238:                				{
3239:                					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
3240:                				}
3241:                				#else
3242:                				{
3243:                					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
3244:                				}
3245:                				#endif
3246:                
3247:                				uxTask++;
3248:                
3249:                			} while( pxNextTCB != pxFirstTCB );
3250:                		}
3251:                		else
3252:                		{
3253:                			mtCOVERAGE_TEST_MARKER();
3254:                		}
3255:                
3256:                		return uxTask;
3257:                	}
3258:                
3259:                #endif /* configUSE_TRACE_FACILITY */
3260:                /*-----------------------------------------------------------*/
3261:                
3262:                #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3263:                
3264:                	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3265:                	{
BFD089A4      4FF9   ADDIU SP, SP, -16
BFD089A6      CBC3   SW S8, 12(SP)
BFD089A8      0FDD   MOVE S8, SP
BFD089AA  0010F89E   SW A0, 16(S8)
3266:                	uint32_t ulCount = 0U;
BFD089AE  0000F81E   SW ZERO, 0(S8)
3267:                
3268:                		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
BFD089B2      CC0B   B 0xBFD089CA
BFD089B4      0C00   NOP
BFD089CA  0010FC5E   LW V0, 16(S8)
BFD089CE      09A0   LBU V1, 0(V0)
BFD089D0  00A53040   ADDIU V0, ZERO, 165
BFD089D4  FFEF9443   BEQ V1, V0, 0xBFD089B6
BFD089D6  0C00FFEF   LW RA, 3072(T7)
BFD089D8      0C00   NOP
3269:                		{
3270:                			pucStackByte -= portSTACK_GROWTH;
BFD089B6  0010FC5E   LW V0, 16(S8)
BFD089BA      6D20   ADDIU V0, V0, 1
BFD089BC  0010F85E   SW V0, 16(S8)
3271:                			ulCount++;
BFD089C0  0000FC5E   LW V0, 0(S8)
BFD089C4      6D20   ADDIU V0, V0, 1
BFD089C6  0000F85E   SW V0, 0(S8)
3272:                		}
3273:                
3274:                		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
BFD089DA  0000FC5E   LW V0, 0(S8)
BFD089DE      2525   SRL V0, V0, 2
BFD089E0  0000F85E   SW V0, 0(S8)
3275:                
3276:                		return ( uint16_t ) ulCount;
BFD089E4  0000FC5E   LW V0, 0(S8)
BFD089E8      2D2F   ANDI V0, V0, 0xFFFF
3277:                	}
BFD089EA      0FBE   MOVE SP, S8
BFD089EC      4BC3   LW S8, 12(SP)
BFD089EE      4C09   ADDIU SP, SP, 16
BFD089F0      459F   JR16 RA
BFD089F2      0C00   NOP
3278:                
3279:                #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3280:                /*-----------------------------------------------------------*/
3281:                
3282:                #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3283:                
3284:                	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3285:                	{
BFD08C10      4FED   ADDIU SP, SP, -40
BFD08C12      CBE9   SW RA, 36(SP)
BFD08C14      CBC8   SW S8, 32(SP)
BFD08C16      0FDD   MOVE S8, SP
BFD08C18  0028F89E   SW A0, 40(S8)
3286:                	TCB_t *pxTCB;
3287:                	uint8_t *pucEndOfStack;
3288:                	UBaseType_t uxReturn;
3289:                
3290:                		pxTCB = prvGetTCBFromHandle( xTask );
BFD08C1C  0028FC5E   LW V0, 40(S8)
BFD08C20  000440A2   BNEZC V0, 0xBFD08C2C
BFD08C24  8030FC5C   LW V0, -32720(GP)
BFD08C28      CC03   B 0xBFD08C30
BFD08C2A      0C00   NOP
BFD08C2C  0028FC5E   LW V0, 40(S8)
BFD08C30  0010F85E   SW V0, 16(S8)
3291:                
3292:                		#if portSTACK_GROWTH < 0
3293:                		{
3294:                			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
BFD08C34  0010FC5E   LW V0, 16(S8)
BFD08C36  692C0010   EXT ZERO, S0, 4, 14
BFD08C38      692C   LW V0, 48(V0)
BFD08C3A  0014F85E   SW V0, 20(S8)
3295:                		}
3296:                		#else
3297:                		{
3298:                			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3299:                		}
3300:                		#endif
3301:                
3302:                		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
BFD08C3E  0014FC9E   LW A0, 20(S8)
BFD08C42  44D277E8   JALS prvTaskCheckFreeStackSpace
BFD08C44      44D2   OR16 V0, V0
BFD08C46      0C00   NOP
BFD08C48  0018F85E   SW V0, 24(S8)
3303:                
3304:                		return uxReturn;
BFD08C4C  0018FC5E   LW V0, 24(S8)
3305:                	}
BFD08C50      0FBE   MOVE SP, S8
BFD08C52      4BE9   LW RA, 36(SP)
BFD08C54      4BC8   LW S8, 32(SP)
BFD08C56      4C15   ADDIU SP, SP, 40
BFD08C58      459F   JR16 RA
BFD08C5A      0C00   NOP
3306:                
3307:                #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3308:                /*-----------------------------------------------------------*/
3309:                
3310:                #if ( INCLUDE_vTaskDelete == 1 )
3311:                
3312:                	static void prvDeleteTCB( TCB_t *pxTCB )
3313:                	{
BFD098DC      4FF5   ADDIU SP, SP, -24
BFD098DE      CBE5   SW RA, 20(SP)
BFD098E0      CBC4   SW S8, 16(SP)
BFD098E2      0FDD   MOVE S8, SP
BFD098E4  0018F89E   SW A0, 24(S8)
3314:                		/* This call is required specifically for the TriCore port.  It must be
3315:                		above the vPortFree() calls.  The call is also used by ports/demos that
3316:                		want to allocate and clean RAM statically. */
3317:                		portCLEAN_UP_TCB( pxTCB );
3318:                
3319:                		/* Free up the memory allocated by the scheduler for the task.  It is up
3320:                		to the task to free any memory allocated at the application level. */
3321:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3322:                		{
3323:                			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3324:                		}
3325:                		#endif /* configUSE_NEWLIB_REENTRANT */
3326:                
3327:                		#if( portUSING_MPU_WRAPPERS == 1 )
3328:                		{
3329:                			/* Only free the stack if it was allocated dynamically in the first
3330:                			place. */
3331:                			if( pxTCB->xUsingStaticallyAllocatedStack == pdFALSE )
3332:                			{
3333:                				vPortFreeAligned( pxTCB->pxStack );
3334:                			}
3335:                		}
3336:                		#else
3337:                		{
3338:                			vPortFreeAligned( pxTCB->pxStack );
BFD098E8  0018FC5E   LW V0, 24(S8)
BFD098EA  692C0018   EXT ZERO, T8, 4, 14
BFD098EC      692C   LW V0, 48(V0)
BFD098EE      0C82   MOVE A0, V0
BFD098F0  2FEA77E8   JALS vPortFree
BFD098F2      2FEA   ANDI A3, A2, 0x20
BFD098F4      0C00   NOP
3339:                		}
3340:                		#endif
3341:                
3342:                		vPortFree( pxTCB );
BFD098F6  0018FC9E   LW A0, 24(S8)
BFD098FA  2FEA77E8   JALS vPortFree
BFD098FC      2FEA   ANDI A3, A2, 0x20
BFD098FE      0C00   NOP
3343:                	}
BFD09900      0FBE   MOVE SP, S8
BFD09902      4BE5   LW RA, 20(SP)
BFD09904      4BC4   LW S8, 16(SP)
BFD09906      4C0D   ADDIU SP, SP, 24
BFD09908      459F   JR16 RA
BFD0990A      0C00   NOP
3344:                
3345:                #endif /* INCLUDE_vTaskDelete */
3346:                /*-----------------------------------------------------------*/
3347:                
3348:                static void prvResetNextTaskUnblockTime( void )
3349:                {
BFD08F94      4FF9   ADDIU SP, SP, -16
BFD08F96      CBC3   SW S8, 12(SP)
BFD08F98      0FDD   MOVE S8, SP
3350:                TCB_t *pxTCB;
3351:                
3352:                	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
BFD08F9A  8074FC5C   LW V0, -32652(GP)
BFD08F9E      6920   LW V0, 0(V0)
BFD08FA0  000340A2   BNEZC V0, 0xBFD08FAA
BFD08FA4      ED01   LI V0, 1
BFD08FA6      CC02   B 0xBFD08FAC
BFD08FA8      0C00   NOP
BFD08FAA      0C40   MOVE V0, ZERO
BFD08FAC  000540E2   BEQZC V0, 0xBFD08FBA
3353:                	{
3354:                		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3355:                		the maximum possible value so it is	extremely unlikely that the
3356:                		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3357:                		there is an item in the delayed list. */
3358:                		xNextTaskUnblockTime = portMAX_DELAY;
BFD08FB0      ED7F   LI V0, -1
BFD08FB2  8058F85C   SW V0, -32680(GP)
BFD08FB6      CC0C   B 0xBFD08FD0
BFD08FB8      0C00   NOP
3359:                	}
3360:                	else
3361:                	{
3362:                		/* The new current delayed list is not empty, get the value of
3363:                		the item at the head of the delayed list.  This is the time at
3364:                		which the task at the head of the delayed list should be removed
3365:                		from the Blocked state. */
3366:                		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
BFD08FBA  8074FC5C   LW V0, -32652(GP)
BFD08FBE      6923   LW V0, 12(V0)
BFD08FC0      6923   LW V0, 12(V0)
BFD08FC2  0000F85E   SW V0, 0(S8)
3367:                		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
BFD08FC6  0000FC5E   LW V0, 0(S8)
BFD08FCA      6921   LW V0, 4(V0)
BFD08FCC  8058F85C   SW V0, -32680(GP)
3368:                	}
3369:                }
BFD08FD0      0FBE   MOVE SP, S8
BFD08FD2      4BC3   LW S8, 12(SP)
BFD08FD4      4C09   ADDIU SP, SP, 16
BFD08FD6      459F   JR16 RA
BFD08FD8      0C00   NOP
3370:                /*-----------------------------------------------------------*/
3371:                
3372:                #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3373:                
3374:                	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3375:                	{
BFD09E04      4FF9   ADDIU SP, SP, -16
BFD09E06      CBC3   SW S8, 12(SP)
BFD09E08      0FDD   MOVE S8, SP
3376:                	TaskHandle_t xReturn;
3377:                
3378:                		/* A critical section is not required as this is not called from
3379:                		an interrupt and the current TCB will always be the same for any
3380:                		individual execution thread. */
3381:                		xReturn = pxCurrentTCB;
BFD09E0A  8030FC5C   LW V0, -32720(GP)
BFD09E0E  0000F85E   SW V0, 0(S8)
3382:                
3383:                		return xReturn;
BFD09E12  0000FC5E   LW V0, 0(S8)
3384:                	}
BFD09E16      0FBE   MOVE SP, S8
BFD09E18      4BC3   LW S8, 12(SP)
BFD09E1A      4C09   ADDIU SP, SP, 16
BFD09E1C      459F   JR16 RA
BFD09E1E      0C00   NOP
3385:                
3386:                #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3387:                /*-----------------------------------------------------------*/
3388:                
3389:                #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3390:                
3391:                	BaseType_t xTaskGetSchedulerState( void )
3392:                	{
BFD0951C      4FF9   ADDIU SP, SP, -16
BFD0951E      CBC3   SW S8, 12(SP)
BFD09520      0FDD   MOVE S8, SP
3393:                	BaseType_t xReturn;
3394:                
3395:                		if( xSchedulerRunning == pdFALSE )
BFD09522  8044FC5C   LW V0, -32700(GP)
BFD09526  000540A2   BNEZC V0, 0xBFD09534
3396:                		{
3397:                			xReturn = taskSCHEDULER_NOT_STARTED;
BFD0952A      ED01   LI V0, 1
BFD0952C  0000F85E   SW V0, 0(S8)
BFD0952E  CC0C0000   INS ZERO, ZERO, 16, 10
BFD09530      CC0C   B 0xBFD0954A
BFD09532      0C00   NOP
3398:                		}
3399:                		else
3400:                		{
3401:                			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
BFD09534  805CFC5C   LW V0, -32676(GP)
BFD09538  000540A2   BNEZC V0, 0xBFD09546
3402:                			{
3403:                				xReturn = taskSCHEDULER_RUNNING;
BFD0953C      ED02   LI V0, 2
BFD0953E  0000F85E   SW V0, 0(S8)
BFD09542      CC03   B 0xBFD0954A
BFD09544      0C00   NOP
3404:                			}
3405:                			else
3406:                			{
3407:                				xReturn = taskSCHEDULER_SUSPENDED;
BFD09546  0000F81E   SW ZERO, 0(S8)
3408:                			}
3409:                		}
3410:                
3411:                		return xReturn;
BFD0954A  0000FC5E   LW V0, 0(S8)
3412:                	}
BFD0954E      0FBE   MOVE SP, S8
BFD09550      4BC3   LW S8, 12(SP)
BFD09552      4C09   ADDIU SP, SP, 16
BFD09554      459F   JR16 RA
BFD09556      0C00   NOP
3413:                
3414:                #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3415:                /*-----------------------------------------------------------*/
3416:                
3417:                #if ( configUSE_MUTEXES == 1 )
3418:                
3419:                	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3420:                	{
BFD03520      4FF1   ADDIU SP, SP, -32
BFD03522      CBE7   SW RA, 28(SP)
BFD03524      CBC6   SW S8, 24(SP)
BFD03526      0FDD   MOVE S8, SP
BFD03528  0020F89E   SW A0, 32(S8)
3421:                	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
BFD0352C  0020FC5E   LW V0, 32(S8)
BFD03530  0010F85E   SW V0, 16(S8)
3422:                
3423:                		/* If the mutex was given back by an interrupt while the queue was
3424:                		locked then the mutex holder might now be NULL. */
3425:                		if( pxMutexHolder != NULL )
BFD03534  0020FC5E   LW V0, 32(S8)
BFD03538  007E40E2   BEQZC V0, 0xBFD03638
3426:                		{
3427:                			/* If the holder of the mutex has a priority below the priority of
3428:                			the task attempting to obtain the mutex then it will temporarily
3429:                			inherit the priority of the task attempting to obtain the mutex. */
3430:                			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
BFD0353C  0010FC5E   LW V0, 16(S8)
BFD03540      69AB   LW V1, 44(V0)
BFD03542  8030FC5C   LW V0, -32720(GP)
BFD03546      692B   LW V0, 44(V0)
BFD03548  13900043   SLTU V0, V1, V0
BFD0354A  40E21390   ADDI GP, S0, 16610
BFD0354C  007440E2   BEQZC V0, 0xBFD03638
3431:                			{
3432:                				/* Adjust the mutex holder state to account for its new
3433:                				priority.  Only reset the event list item value if the value is
3434:                				not	being used for anything else. */
3435:                				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
BFD03550  0010FC5E   LW V0, 16(S8)
BFD03554      6926   LW V0, 24(V0)
BFD03556  00094002   BLTZ V0, 0xBFD0356C
BFD03558  0C000009   SLL ZERO, T1, 1
BFD0355A      0C00   NOP
3436:                				{
3437:                					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
BFD0355C  8030FC5C   LW V0, -32720(GP)
BFD03560      692B   LW V0, 44(V0)
BFD03562      ED85   LI V1, 5
BFD03564      05A7   SUBU V1, V1, V0
BFD03566  0010FC5E   LW V0, 16(S8)
BFD0356A      E9A6   SW V1, 24(V0)
3438:                				}
3439:                				else
3440:                				{
3441:                					mtCOVERAGE_TEST_MARKER();
3442:                				}
3443:                
3444:                				/* If the task being modified is in the ready state it will need
3445:                				to be moved into a new list. */
3446:                				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
BFD0356C  0010FC5E   LW V0, 16(S8)
BFD0356E  69A50010   LWX T5, 0(S0)
BFD03570      69A5   LW V1, 20(V0)
BFD03572  0010FC5E   LW V0, 16(S8)
BFD03576      692B   LW V0, 44(V0)
BFD03578      2524   SLL V0, V0, 2
BFD0357A      2624   SLL A0, V0, 2
BFD0357C      0644   ADDU A0, V0, A0
BFD0357E  BFD241A2   LUI V0, 0xBFD2
BFD03580  3042BFD2   LDC1 F30, 12354(S2)
BFD03582  806C3042   ADDIU V0, V0, -32660
BFD03586      0528   ADDU V0, A0, V0
BFD03588  0004B443   BNE V1, V0, 0xBFD03594
BFD0358A  0C000004   SLL ZERO, A0, 1
BFD0358C      0C00   NOP
BFD0358E      ED01   LI V0, 1
BFD03590      CC02   B 0xBFD03596
BFD03592      0C00   NOP
BFD03594      0C40   MOVE V0, ZERO
BFD03596  004940E2   BEQZC V0, 0xBFD0362C
3447:                				{
3448:                					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD0359A  0010FC5E   LW V0, 16(S8)
BFD0359E      6D22   ADDIU V0, V0, 4
BFD035A0      0C82   MOVE A0, V0
BFD035A2  00C877E8   JALS uxListRemove
BFD035A4  0C0000C8   SLL A2, T0, 1
BFD035A6      0C00   NOP
BFD035A8  001A40A2   BNEZC V0, 0xBFD035E0
3449:                					{
3450:                						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
BFD035AC  0010FC5E   LW V0, 16(S8)
BFD035B0      692B   LW V0, 44(V0)
BFD035B2      2524   SLL V0, V0, 2
BFD035B4      25A4   SLL V1, V0, 2
BFD035B6      05B4   ADDU V1, V0, V1
BFD035B8  BFD241A2   LUI V0, 0xBFD2
BFD035BA  3042BFD2   LDC1 F30, 12354(S2)
BFD035BC  806C3042   ADDIU V0, V0, -32660
BFD035C0      0526   ADDU V0, V1, V0
BFD035C2      6920   LW V0, 0(V0)
BFD035C4  000C40A2   BNEZC V0, 0xBFD035E0
BFD035C8  0010FC5E   LW V0, 16(S8)
BFD035CC      692B   LW V0, 44(V0)
BFD035CE      ED81   LI V1, 1
BFD035D0  10100062   SLLV V0, V0, V1
BFD035D2  441A1010   ADDI ZERO, S0, 17434
BFD035D4      441A   NOT16 V1, V0
BFD035D6  8040FC5C   LW V0, -32704(GP)
BFD035DA      4493   AND16 V0, V1
BFD035DC  8040F85C   SW V0, -32704(GP)
3451:                					}
3452:                					else
3453:                					{
3454:                						mtCOVERAGE_TEST_MARKER();
3455:                					}
3456:                
3457:                					/* Inherit the priority before being moved into the new list. */
3458:                					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
BFD035E0  8030FC5C   LW V0, -32720(GP)
BFD035E4      69AB   LW V1, 44(V0)
BFD035E6  0010FC5E   LW V0, 16(S8)
BFD035EA      E9AB   SW V1, 44(V0)
3459:                					prvAddTaskToReadyList( pxTCB );
BFD035EC  0010FC5E   LW V0, 16(S8)
BFD035F0      692B   LW V0, 44(V0)
BFD035F2      ED81   LI V1, 1
BFD035F4  18100062   SLLV V1, V0, V1
BFD035F6  FC5C1810   SB ZERO, -932(S0)
BFD035F8  8040FC5C   LW V0, -32704(GP)
BFD035FC      44D3   OR16 V0, V1
BFD035FE  8040F85C   SW V0, -32704(GP)
BFD03602  0010FC5E   LW V0, 16(S8)
BFD03606      692B   LW V0, 44(V0)
BFD03608      2524   SLL V0, V0, 2
BFD0360A      25A4   SLL V1, V0, 2
BFD0360C      05B4   ADDU V1, V0, V1
BFD0360E  BFD241A2   LUI V0, 0xBFD2
BFD03610  3042BFD2   LDC1 F30, 12354(S2)
BFD03612  806C3042   ADDIU V0, V0, -32660
BFD03616      05A6   ADDU V1, V1, V0
BFD03618  0010FC5E   LW V0, 16(S8)
BFD0361C      6D22   ADDIU V0, V0, 4
BFD0361E      0C83   MOVE A0, V1
BFD03620      0CA2   MOVE A1, V0
BFD03622  3E4A77E8   JALS vListInsertEnd
BFD03624  0C003E4A   LH S2, 3072(T2)
BFD03626      0C00   NOP
BFD03628      CC07   B 0xBFD03638
BFD0362A      0C00   NOP
3460:                				}
3461:                				else
3462:                				{
3463:                					/* Just inherit the priority. */
3464:                					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
BFD0362C  8030FC5C   LW V0, -32720(GP)
BFD03630      69AB   LW V1, 44(V0)
BFD03632  0010FC5E   LW V0, 16(S8)
BFD03636      E9AB   SW V1, 44(V0)
3465:                				}
3466:                
3467:                				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3468:                			}
3469:                			else
3470:                			{
3471:                				mtCOVERAGE_TEST_MARKER();
3472:                			}
3473:                		}
3474:                		else
3475:                		{
3476:                			mtCOVERAGE_TEST_MARKER();
3477:                		}
3478:                	}
BFD03638      0FBE   MOVE SP, S8
BFD0363A      4BE7   LW RA, 28(SP)
BFD0363C      4BC6   LW S8, 24(SP)
BFD0363E      4C11   ADDIU SP, SP, 32
BFD03640      459F   JR16 RA
BFD03642      0C00   NOP
3479:                
3480:                #endif /* configUSE_MUTEXES */
3481:                /*-----------------------------------------------------------*/
3482:                
3483:                #if ( configUSE_MUTEXES == 1 )
3484:                
3485:                	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3486:                	{
BFD02F04      4FF1   ADDIU SP, SP, -32
BFD02F06      CBE7   SW RA, 28(SP)
BFD02F08      CBC6   SW S8, 24(SP)
BFD02F0A      0FDD   MOVE S8, SP
BFD02F0C  0020F89E   SW A0, 32(S8)
3487:                	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
BFD02F10  0020FC5E   LW V0, 32(S8)
BFD02F14  0014F85E   SW V0, 20(S8)
3488:                	BaseType_t xReturn = pdFALSE;
BFD02F18  0010F81E   SW ZERO, 16(S8)
3489:                
3490:                		if( pxMutexHolder != NULL )
BFD02F1C  0020FC5E   LW V0, 32(S8)
BFD02F20  008B40E2   BEQZC V0, 0xBFD0303A
3491:                		{
3492:                			/* A task can only have an inherited priority if it holds the mutex.
3493:                			If the mutex is held by a task then it cannot be given from an
3494:                			interrupt, and if a mutex is given by the holding task then it must
3495:                			be the running state task. */
3496:                			configASSERT( pxTCB == pxCurrentTCB );
BFD02F24  8030FC5C   LW V0, -32720(GP)
BFD02F28  0014FC7E   LW V1, 20(S8)
BFD02F2C  000A9443   BEQ V1, V0, 0xBFD02F44
BFD02F2E  0C00000A   SLL ZERO, T2, 1
BFD02F30      0C00   NOP
BFD02F32  BFD141A2   LUI V0, 0xBFD1
BFD02F34  3082BFD1   LDC1 F30, 12418(S1)
BFD02F36  98103082   ADDIU A0, V0, -26608
BFD02F38  30A09810   SWC1 F0, 12448(S0)
BFD02F3A  0DA830A0   ADDIU A1, ZERO, 3496
BFD02F3C      0DA8   MOVE T5, T0
BFD02F3E  4B7E77E8   JALS vAssertCalled
BFD02F40      4B7E   LW K1, 120(SP)
BFD02F42      0C00   NOP
3497:                
3498:                			configASSERT( pxTCB->uxMutexesHeld );
BFD02F44  0014FC5E   LW V0, 20(S8)
BFD02F48  0044FC42   LW V0, 68(V0)
BFD02F4C  000940A2   BNEZC V0, 0xBFD02F62
BFD02F50  BFD141A2   LUI V0, 0xBFD1
BFD02F52  3082BFD1   LDC1 F30, 12418(S1)
BFD02F54  98103082   ADDIU A0, V0, -26608
BFD02F56  30A09810   SWC1 F0, 12448(S0)
BFD02F58  0DAA30A0   ADDIU A1, ZERO, 3498
BFD02F5A      0DAA   MOVE T5, T2
BFD02F5C  4B7E77E8   JALS vAssertCalled
BFD02F5E      4B7E   LW K1, 120(SP)
BFD02F60      0C00   NOP
3499:                			( pxTCB->uxMutexesHeld )--;
BFD02F62  0014FC5E   LW V0, 20(S8)
BFD02F66  0044FC42   LW V0, 68(V0)
BFD02F6A      6DAE   ADDIU V1, V0, -1
BFD02F6C  0014FC5E   LW V0, 20(S8)
BFD02F70  0044F862   SW V1, 68(V0)
3500:                
3501:                			/* Has the holder of the mutex inherited the priority of another
3502:                			task? */
3503:                			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
BFD02F74  0014FC5E   LW V0, 20(S8)
BFD02F78      69AB   LW V1, 44(V0)
BFD02F7A  0014FC5E   LW V0, 20(S8)
BFD02F7E  0040FC42   LW V0, 64(V0)
BFD02F82  005A9443   BEQ V1, V0, 0xBFD0303A
BFD02F84  0C00005A   SLL V0, K0, 1
BFD02F86      0C00   NOP
3504:                			{
3505:                				/* Only disinherit if no other mutexes are held. */
3506:                				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
BFD02F88  0014FC5E   LW V0, 20(S8)
BFD02F8C  0044FC42   LW V0, 68(V0)
BFD02F90  005340A2   BNEZC V0, 0xBFD0303A
3507:                				{
3508:                					/* A task can only have an inherited priority if it holds
3509:                					the mutex.  If the mutex is held by a task then it cannot be
3510:                					given from an interrupt, and if a mutex is given by the
3511:                					holding	task then it must be the running state task.  Remove
3512:                					the	holding task from the ready	list. */
3513:                					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD02F94  0014FC5E   LW V0, 20(S8)
BFD02F98      6D22   ADDIU V0, V0, 4
BFD02F9A      0C82   MOVE A0, V0
BFD02F9C  00C877E8   JALS uxListRemove
BFD02F9E  0C0000C8   SLL A2, T0, 1
BFD02FA0      0C00   NOP
BFD02FA2  001A40A2   BNEZC V0, 0xBFD02FDA
3514:                					{
3515:                						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
BFD02FA6  0014FC5E   LW V0, 20(S8)
BFD02FAA      692B   LW V0, 44(V0)
BFD02FAC      2524   SLL V0, V0, 2
BFD02FAE      25A4   SLL V1, V0, 2
BFD02FB0      05B4   ADDU V1, V0, V1
BFD02FB2  BFD241A2   LUI V0, 0xBFD2
BFD02FB4  3042BFD2   LDC1 F30, 12354(S2)
BFD02FB6  806C3042   ADDIU V0, V0, -32660
BFD02FBA      0526   ADDU V0, V1, V0
BFD02FBC      6920   LW V0, 0(V0)
BFD02FBE  000C40A2   BNEZC V0, 0xBFD02FDA
BFD02FC2  0014FC5E   LW V0, 20(S8)
BFD02FC6      692B   LW V0, 44(V0)
BFD02FC8      ED81   LI V1, 1
BFD02FCA  10100062   SLLV V0, V0, V1
BFD02FCC  441A1010   ADDI ZERO, S0, 17434
BFD02FCE      441A   NOT16 V1, V0
BFD02FD0  8040FC5C   LW V0, -32704(GP)
BFD02FD4      4493   AND16 V0, V1
BFD02FD6  8040F85C   SW V0, -32704(GP)
3516:                					}
3517:                					else
3518:                					{
3519:                						mtCOVERAGE_TEST_MARKER();
3520:                					}
3521:                
3522:                					/* Disinherit the priority before adding the task into the
3523:                					new	ready list. */
3524:                					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3525:                					pxTCB->uxPriority = pxTCB->uxBasePriority;
BFD02FDA  0014FC5E   LW V0, 20(S8)
BFD02FDE  0040FC62   LW V1, 64(V0)
BFD02FE2  0014FC5E   LW V0, 20(S8)
BFD02FE6      E9AB   SW V1, 44(V0)
3526:                
3527:                					/* Reset the event list item value.  It cannot be in use for
3528:                					any other purpose if this task is running, and it must be
3529:                					running to give back the mutex. */
3530:                					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
BFD02FE8  0014FC5E   LW V0, 20(S8)
BFD02FEC      692B   LW V0, 44(V0)
BFD02FEE      ED85   LI V1, 5
BFD02FF0      05A7   SUBU V1, V1, V0
BFD02FF2  0014FC5E   LW V0, 20(S8)
BFD02FF6      E9A6   SW V1, 24(V0)
3531:                					prvAddTaskToReadyList( pxTCB );
BFD02FF8  0014FC5E   LW V0, 20(S8)
BFD02FFC      692B   LW V0, 44(V0)
BFD02FFE      ED81   LI V1, 1
BFD03000  18100062   SLLV V1, V0, V1
BFD03002  FC5C1810   SB ZERO, -932(S0)
BFD03004  8040FC5C   LW V0, -32704(GP)
BFD03008      44D3   OR16 V0, V1
BFD0300A  8040F85C   SW V0, -32704(GP)
BFD0300E  0014FC5E   LW V0, 20(S8)
BFD03012      692B   LW V0, 44(V0)
BFD03014      2524   SLL V0, V0, 2
BFD03016      25A4   SLL V1, V0, 2
BFD03018      05B4   ADDU V1, V0, V1
BFD0301A  BFD241A2   LUI V0, 0xBFD2
BFD0301C  3042BFD2   LDC1 F30, 12354(S2)
BFD0301E  806C3042   ADDIU V0, V0, -32660
BFD03022      05A6   ADDU V1, V1, V0
BFD03024  0014FC5E   LW V0, 20(S8)
BFD03028      6D22   ADDIU V0, V0, 4
BFD0302A      0C83   MOVE A0, V1
BFD0302C      0CA2   MOVE A1, V0
BFD0302E  3E4A77E8   JALS vListInsertEnd
BFD03030  0C003E4A   LH S2, 3072(T2)
BFD03032      0C00   NOP
3532:                
3533:                					/* Return true to indicate that a context switch is required.
3534:                					This is only actually required in the corner case whereby
3535:                					multiple mutexes were held and the mutexes were given back
3536:                					in an order different to that in which they were taken.
3537:                					If a context switch did not occur when the first mutex was
3538:                					returned, even if a task was waiting on it, then a context
3539:                					switch should occur when the last mutex is returned whether
3540:                					a task is waiting on it or not. */
3541:                					xReturn = pdTRUE;
BFD03034      ED01   LI V0, 1
BFD03036  0010F85E   SW V0, 16(S8)
3542:                				}
3543:                				else
3544:                				{
3545:                					mtCOVERAGE_TEST_MARKER();
3546:                				}
3547:                			}
3548:                			else
3549:                			{
3550:                				mtCOVERAGE_TEST_MARKER();
3551:                			}
3552:                		}
3553:                		else
3554:                		{
3555:                			mtCOVERAGE_TEST_MARKER();
3556:                		}
3557:                
3558:                		return xReturn;
BFD0303A  0010FC5E   LW V0, 16(S8)
3559:                	}
BFD0303E      0FBE   MOVE SP, S8
BFD03040      4BE7   LW RA, 28(SP)
BFD03042      4BC6   LW S8, 24(SP)
BFD03044      4C11   ADDIU SP, SP, 32
BFD03046      459F   JR16 RA
BFD03048      0C00   NOP
3560:                
3561:                #endif /* configUSE_MUTEXES */
3562:                /*-----------------------------------------------------------*/
3563:                
3564:                #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3565:                
3566:                	void vTaskEnterCritical( void )
3567:                	{
BFD06770      4FF1   ADDIU SP, SP, -32
BFD06772      CBE7   SW RA, 28(SP)
BFD06774      CBC6   SW S8, 24(SP)
BFD06776      0FDD   MOVE S8, SP
3568:                		portDISABLE_INTERRUPTS();
BFD06778  4E3677E8   JALS ulPortGetCP0Status
BFD0677A      4E36   ADDIU S1, S1, -5
BFD0677C      0C00   NOP
BFD0677E  0010F85E   SW V0, 16(S8)
BFD06782  0010FC7E   LW V1, 16(S8)
BFD06786  000141A2   LUI V0, 0x1
BFD0678A  FC005042   ORI V0, V0, -1024
BFD0678C  4493FC00   LW ZERO, 17555(ZERO)
BFD0678E      4493   AND16 V0, V1
BFD06790  50400042   SRL V0, V0, 10
BFD06792  B0425040   ORI V0, ZERO, -20414
BFD06794  0003B042   SLTIU V0, V0, 3
BFD06798  001140E2   BEQZC V0, 0xBFD067BE
BFD0679C  0010FC7E   LW V1, 16(S8)
BFD067A0  FFFE41A2   LUI V0, 0xFFFE
BFD067A2  5042FFFE   LW RA, 20546(S8)
BFD067A4  03FF5042   ORI V0, V0, 1023
BFD067A8      4493   AND16 V0, V1
BFD067AA  0010F85E   SW V0, 16(S8)
BFD067AE  0010FC5E   LW V0, 16(S8)
BFD067B2  0C005042   ORI V0, V0, 3072
BFD067B4      0C00   NOP
BFD067B6      0C82   MOVE A0, V0
BFD067B8  4E4677E8   JALS vPortSetCP0Status
BFD067BA      4E46   ADDIU S2, S2, 3
BFD067BC      0C00   NOP
3569:                
3570:                		if( xSchedulerRunning != pdFALSE )
BFD067BE  8044FC5C   LW V0, -32700(GP)
BFD067C2  001940E2   BEQZC V0, 0xBFD067F8
3571:                		{
3572:                			( pxCurrentTCB->uxCriticalNesting )++;
BFD067C6  8030FC5C   LW V0, -32720(GP)
BFD067CA      69AF   LW V1, 60(V0)
BFD067CC      6DB0   ADDIU V1, V1, 1
BFD067CE      E9AF   SW V1, 60(V0)
3573:                
3574:                			/* This is not the interrupt safe version of the enter critical
3575:                			function so	assert() if it is being called from an interrupt
3576:                			context.  Only API functions that end in "FromISR" can be used in an
3577:                			interrupt.  Only assert if the critical nesting count is 1 to
3578:                			protect against recursive calls if the assert function also uses a
3579:                			critical section. */
3580:                			if( pxCurrentTCB->uxCriticalNesting == 1 )
BFD067D0  8030FC5C   LW V0, -32720(GP)
BFD067D4      69AF   LW V1, 60(V0)
BFD067D6      ED01   LI V0, 1
BFD067D8  000EB443   BNE V1, V0, 0xBFD067F8
BFD067DA  0C00000E   SLL ZERO, T6, 1
BFD067DC      0C00   NOP
3581:                			{
3582:                				portASSERT_IF_IN_ISR();
BFD067DE  8014FC5C   LW V0, -32748(GP)
BFD067E2  000940E2   BEQZC V0, 0xBFD067F8
BFD067E6  BFD141A2   LUI V0, 0xBFD1
BFD067E8  3082BFD1   LDC1 F30, 12418(S1)
BFD067EA  98103082   ADDIU A0, V0, -26608
BFD067EC  30A09810   SWC1 F0, 12448(S0)
BFD067EE  0DFE30A0   ADDIU A1, ZERO, 3582
BFD067F0      0DFE   MOVE T7, S8
BFD067F2  4B7E77E8   JALS vAssertCalled
BFD067F4      4B7E   LW K1, 120(SP)
BFD067F6      0C00   NOP
3583:                			}
3584:                
3585:                		}
3586:                		else
3587:                		{
3588:                			mtCOVERAGE_TEST_MARKER();
3589:                		}
3590:                	}
BFD067F8      0FBE   MOVE SP, S8
BFD067FA      4BE7   LW RA, 28(SP)
BFD067FC      4BC6   LW S8, 24(SP)
BFD067FE      4C11   ADDIU SP, SP, 32
BFD06800      459F   JR16 RA
BFD06802      0C00   NOP
3591:                
3592:                #endif /* portCRITICAL_NESTING_IN_TCB */
3593:                /*-----------------------------------------------------------*/
3594:                
3595:                #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3596:                
3597:                	void vTaskExitCritical( void )
3598:                	{
BFD08154      4FF1   ADDIU SP, SP, -32
BFD08156      CBE7   SW RA, 28(SP)
BFD08158      CBC6   SW S8, 24(SP)
BFD0815A      0FDD   MOVE S8, SP
3599:                		if( xSchedulerRunning != pdFALSE )
BFD0815C  8044FC5C   LW V0, -32700(GP)
BFD08160  002240E2   BEQZC V0, 0xBFD081A8
3600:                		{
3601:                			if( pxCurrentTCB->uxCriticalNesting > 0U )
BFD08164  8030FC5C   LW V0, -32720(GP)
BFD08168      692F   LW V0, 60(V0)
BFD0816A  001D40E2   BEQZC V0, 0xBFD081A8
3602:                			{
3603:                				( pxCurrentTCB->uxCriticalNesting )--;
BFD0816E  8030FC5C   LW V0, -32720(GP)
BFD08172      69AF   LW V1, 60(V0)
BFD08174      6DBE   ADDIU V1, V1, -1
BFD08176      E9AF   SW V1, 60(V0)
3604:                
3605:                				if( pxCurrentTCB->uxCriticalNesting == 0U )
BFD08178  8030FC5C   LW V0, -32720(GP)
BFD0817C      692F   LW V0, 60(V0)
BFD0817E  001340A2   BNEZC V0, 0xBFD081A8
3606:                				{
3607:                					portENABLE_INTERRUPTS();
BFD08182  4E3677E8   JALS ulPortGetCP0Status
BFD08184      4E36   ADDIU S1, S1, -5
BFD08186      0C00   NOP
BFD08188  0010F85E   SW V0, 16(S8)
BFD0818C  0010FC7E   LW V1, 16(S8)
BFD08190  FFFE41A2   LUI V0, 0xFFFE
BFD08192  5042FFFE   LW RA, 20546(S8)
BFD08194  03FF5042   ORI V0, V0, 1023
BFD08198      4493   AND16 V0, V1
BFD0819A  0010F85E   SW V0, 16(S8)
BFD0819E  0010FC9E   LW A0, 16(S8)
BFD081A2  4E4677E8   JALS vPortSetCP0Status
BFD081A4      4E46   ADDIU S2, S2, 3
BFD081A6      0C00   NOP
3608:                				}
3609:                				else
3610:                				{
3611:                					mtCOVERAGE_TEST_MARKER();
3612:                				}
3613:                			}
3614:                			else
3615:                			{
3616:                				mtCOVERAGE_TEST_MARKER();
3617:                			}
3618:                		}
3619:                		else
3620:                		{
3621:                			mtCOVERAGE_TEST_MARKER();
3622:                		}
3623:                	}
BFD081A8      0FBE   MOVE SP, S8
BFD081AA      4BE7   LW RA, 28(SP)
BFD081AC      4BC6   LW S8, 24(SP)
BFD081AE      4C11   ADDIU SP, SP, 32
BFD081B0      459F   JR16 RA
BFD081B2      0C00   NOP
3624:                
3625:                #endif /* portCRITICAL_NESTING_IN_TCB */
3626:                /*-----------------------------------------------------------*/
3627:                
3628:                #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3629:                
3630:                	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3631:                	{
3632:                	BaseType_t x;
3633:                
3634:                		/* Start by copying the entire string. */
3635:                		strcpy( pcBuffer, pcTaskName );
3636:                
3637:                		/* Pad the end of the string with spaces to ensure columns line up when
3638:                		printed out. */
3639:                		for( x = strlen( pcBuffer ); x < ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3640:                		{
3641:                			pcBuffer[ x ] = ' ';
3642:                		}
3643:                
3644:                		/* Terminate. */
3645:                		pcBuffer[ x ] = 0x00;
3646:                
3647:                		/* Return the new end of string. */
3648:                		return &( pcBuffer[ x ] );
3649:                	}
3650:                
3651:                #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3652:                /*-----------------------------------------------------------*/
3653:                
3654:                #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3655:                
3656:                	void vTaskList( char * pcWriteBuffer )
3657:                	{
3658:                	TaskStatus_t *pxTaskStatusArray;
3659:                	volatile UBaseType_t uxArraySize, x;
3660:                	char cStatus;
3661:                
3662:                		/*
3663:                		 * PLEASE NOTE:
3664:                		 *
3665:                		 * This function is provided for convenience only, and is used by many
3666:                		 * of the demo applications.  Do not consider it to be part of the
3667:                		 * scheduler.
3668:                		 *
3669:                		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3670:                		 * uxTaskGetSystemState() output into a human readable table that
3671:                		 * displays task names, states and stack usage.
3672:                		 *
3673:                		 * vTaskList() has a dependency on the sprintf() C library function that
3674:                		 * might bloat the code size, use a lot of stack, and provide different
3675:                		 * results on different platforms.  An alternative, tiny, third party,
3676:                		 * and limited functionality implementation of sprintf() is provided in
3677:                		 * many of the FreeRTOS/Demo sub-directories in a file called
3678:                		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3679:                		 * snprintf() implementation!).
3680:                		 *
3681:                		 * It is recommended that production systems call uxTaskGetSystemState()
3682:                		 * directly to get access to raw stats data, rather than indirectly
3683:                		 * through a call to vTaskList().
3684:                		 */
3685:                
3686:                
3687:                		/* Make sure the write buffer does not contain a string. */
3688:                		*pcWriteBuffer = 0x00;
3689:                
3690:                		/* Take a snapshot of the number of tasks in case it changes while this
3691:                		function is executing. */
3692:                		uxArraySize = uxCurrentNumberOfTasks;
3693:                
3694:                		/* Allocate an array index for each task. */
3695:                		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3696:                
3697:                		if( pxTaskStatusArray != NULL )
3698:                		{
3699:                			/* Generate the (binary) data. */
3700:                			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3701:                
3702:                			/* Create a human readable table from the binary data. */
3703:                			for( x = 0; x < uxArraySize; x++ )
3704:                			{
3705:                				switch( pxTaskStatusArray[ x ].eCurrentState )
3706:                				{
3707:                					case eReady:		cStatus = tskREADY_CHAR;
3708:                										break;
3709:                
3710:                					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3711:                										break;
3712:                
3713:                					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
3714:                										break;
3715:                
3716:                					case eDeleted:		cStatus = tskDELETED_CHAR;
3717:                										break;
3718:                
3719:                					default:			/* Should not get here, but it is included
3720:                										to prevent static checking errors. */
3721:                										cStatus = 0x00;
3722:                										break;
3723:                				}
3724:                
3725:                				/* Write the task name to the string, padding with spaces so it
3726:                				can be printed in tabular form more easily. */
3727:                				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3728:                
3729:                				/* Write the rest of the string. */
3730:                				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
3731:                				pcWriteBuffer += strlen( pcWriteBuffer );
3732:                			}
3733:                
3734:                			/* Free the array again. */
3735:                			vPortFree( pxTaskStatusArray );
3736:                		}
3737:                		else
3738:                		{
3739:                			mtCOVERAGE_TEST_MARKER();
3740:                		}
3741:                	}
3742:                
3743:                #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
3744:                /*----------------------------------------------------------*/
3745:                
3746:                #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3747:                
3748:                	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3749:                	{
3750:                	TaskStatus_t *pxTaskStatusArray;
3751:                	volatile UBaseType_t uxArraySize, x;
3752:                	uint32_t ulTotalTime, ulStatsAsPercentage;
3753:                
3754:                		#if( configUSE_TRACE_FACILITY != 1 )
3755:                		{
3756:                			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
3757:                		}
3758:                		#endif
3759:                
3760:                		/*
3761:                		 * PLEASE NOTE:
3762:                		 *
3763:                		 * This function is provided for convenience only, and is used by many
3764:                		 * of the demo applications.  Do not consider it to be part of the
3765:                		 * scheduler.
3766:                		 *
3767:                		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3768:                		 * of the uxTaskGetSystemState() output into a human readable table that
3769:                		 * displays the amount of time each task has spent in the Running state
3770:                		 * in both absolute and percentage terms.
3771:                		 *
3772:                		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3773:                		 * function that might bloat the code size, use a lot of stack, and
3774:                		 * provide different results on different platforms.  An alternative,
3775:                		 * tiny, third party, and limited functionality implementation of
3776:                		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3777:                		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3778:                		 * a full snprintf() implementation!).
3779:                		 *
3780:                		 * It is recommended that production systems call uxTaskGetSystemState()
3781:                		 * directly to get access to raw stats data, rather than indirectly
3782:                		 * through a call to vTaskGetRunTimeStats().
3783:                		 */
3784:                
3785:                		/* Make sure the write buffer does not contain a string. */
3786:                		*pcWriteBuffer = 0x00;
3787:                
3788:                		/* Take a snapshot of the number of tasks in case it changes while this
3789:                		function is executing. */
3790:                		uxArraySize = uxCurrentNumberOfTasks;
3791:                
3792:                		/* Allocate an array index for each task. */
3793:                		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3794:                
3795:                		if( pxTaskStatusArray != NULL )
3796:                		{
3797:                			/* Generate the (binary) data. */
3798:                			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
3799:                
3800:                			/* For percentage calculations. */
3801:                			ulTotalTime /= 100UL;
3802:                
3803:                			/* Avoid divide by zero errors. */
3804:                			if( ulTotalTime > 0 )
3805:                			{
3806:                				/* Create a human readable table from the binary data. */
3807:                				for( x = 0; x < uxArraySize; x++ )
3808:                				{
3809:                					/* What percentage of the total run time has the task used?
3810:                					This will always be rounded down to the nearest integer.
3811:                					ulTotalRunTimeDiv100 has already been divided by 100. */
3812:                					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3813:                
3814:                					/* Write the task name to the string, padding with
3815:                					spaces so it can be printed in tabular form more
3816:                					easily. */
3817:                					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3818:                
3819:                					if( ulStatsAsPercentage > 0UL )
3820:                					{
3821:                						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3822:                						{
3823:                							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
3824:                						}
3825:                						#else
3826:                						{
3827:                							/* sizeof( int ) == sizeof( long ) so a smaller
3828:                							printf() library can be used. */
3829:                							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
3830:                						}
3831:                						#endif
3832:                					}
3833:                					else
3834:                					{
3835:                						/* If the percentage is zero here then the task has
3836:                						consumed less than 1% of the total run time. */
3837:                						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3838:                						{
3839:                							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
3840:                						}
3841:                						#else
3842:                						{
3843:                							/* sizeof( int ) == sizeof( long ) so a smaller
3844:                							printf() library can be used. */
3845:                							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
3846:                						}
3847:                						#endif
3848:                					}
3849:                
3850:                					pcWriteBuffer += strlen( pcWriteBuffer );
3851:                				}
3852:                			}
3853:                			else
3854:                			{
3855:                				mtCOVERAGE_TEST_MARKER();
3856:                			}
3857:                
3858:                			/* Free the array again. */
3859:                			vPortFree( pxTaskStatusArray );
3860:                		}
3861:                		else
3862:                		{
3863:                			mtCOVERAGE_TEST_MARKER();
3864:                		}
3865:                	}
3866:                
3867:                #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
3868:                /*-----------------------------------------------------------*/
3869:                
3870:                TickType_t uxTaskResetEventItemValue( void )
3871:                {
BFD0990C      4FF9   ADDIU SP, SP, -16
BFD0990E      CBC3   SW S8, 12(SP)
BFD09910      0FDD   MOVE S8, SP
3872:                TickType_t uxReturn;
3873:                
3874:                	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
BFD09912  8030FC5C   LW V0, -32720(GP)
BFD09916      6926   LW V0, 24(V0)
BFD09918  0000F85E   SW V0, 0(S8)
3875:                
3876:                	/* Reset the event list item to its normal value - so it can be used with
3877:                	queues and semaphores. */
3878:                	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
BFD0991C  8030FC5C   LW V0, -32720(GP)
BFD09920  8030FC7C   LW V1, -32720(GP)
BFD09924      69BB   LW V1, 44(V1)
BFD09926      EE05   LI A0, 5
BFD09928      05B9   SUBU V1, A0, V1
BFD0992A      E9A6   SW V1, 24(V0)
3879:                
3880:                	return uxReturn;
BFD0992C  0000FC5E   LW V0, 0(S8)
3881:                }
BFD09930      0FBE   MOVE SP, S8
BFD09932      4BC3   LW S8, 12(SP)
BFD09934      4C09   ADDIU SP, SP, 16
BFD09936      459F   JR16 RA
BFD09938      0C00   NOP
3882:                /*-----------------------------------------------------------*/
3883:                
3884:                #if ( configUSE_MUTEXES == 1 )
3885:                
3886:                	void *pvTaskIncrementMutexHeldCount( void )
3887:                	{
BFD099C0      4FB0   ADDIU SP, SP, -8
BFD099C2      CBC1   SW S8, 4(SP)
BFD099C4      0FDD   MOVE S8, SP
3888:                		/* If xSemaphoreCreateMutex() is called before any tasks have been created
3889:                		then pxCurrentTCB will be NULL. */
3890:                		if( pxCurrentTCB != NULL )
BFD099C6  8030FC5C   LW V0, -32720(GP)
BFD099CA  000740E2   BEQZC V0, 0xBFD099DC
3891:                		{
3892:                			( pxCurrentTCB->uxMutexesHeld )++;
BFD099CE  8030FC5C   LW V0, -32720(GP)
BFD099D2  0044FC62   LW V1, 68(V0)
BFD099D6      6DB0   ADDIU V1, V1, 1
BFD099D8  0044F862   SW V1, 68(V0)
3893:                		}
3894:                
3895:                		return pxCurrentTCB;
BFD099DC  8030FC5C   LW V0, -32720(GP)
3896:                	}
BFD099E0      0FBE   MOVE SP, S8
BFD099E2      4BC1   LW S8, 4(SP)
BFD099E4      4C05   ADDIU SP, SP, 8
BFD099E6      459F   JR16 RA
BFD099E8      0C00   NOP
3897:                
3898:                #endif /* configUSE_MUTEXES */
3899:                /*-----------------------------------------------------------*/
3900:                
3901:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
3902:                
3903:                	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
3904:                	{
BFD039AC      4FED   ADDIU SP, SP, -40
BFD039AE      CBE9   SW RA, 36(SP)
BFD039B0      CBC8   SW S8, 32(SP)
BFD039B2      0FDD   MOVE S8, SP
BFD039B4  0028F89E   SW A0, 40(S8)
BFD039B8  002CF8BE   SW A1, 44(S8)
3905:                	TickType_t xTimeToWake;
3906:                	uint32_t ulReturn;
3907:                
3908:                		taskENTER_CRITICAL();
BFD039BC  33B877E8   JALS vTaskEnterCritical
BFD039BE  0C0033B8   ADDIU SP, T8, 3072
BFD039C0      0C00   NOP
3909:                		{
3910:                			/* Only block if the notification count is not already non-zero. */
3911:                			if( pxCurrentTCB->ulNotifiedValue == 0UL )
BFD039C2  8030FC5C   LW V0, -32720(GP)
BFD039C6  0048FC42   LW V0, 72(V0)
BFD039CA  004D40A2   BNEZC V0, 0xBFD03A68
3912:                			{
3913:                				/* Mark this task as waiting for a notification. */
3914:                				pxCurrentTCB->eNotifyState = eWaitingNotification;
BFD039CE  8030FC5C   LW V0, -32720(GP)
BFD039D2      ED81   LI V1, 1
BFD039D4  004CF862   SW V1, 76(V0)
3915:                
3916:                				if( xTicksToWait > ( TickType_t ) 0 )
BFD039D8  002CFC5E   LW V0, 44(S8)
BFD039DC  004440E2   BEQZC V0, 0xBFD03A68
3917:                				{
3918:                					/* The task is going to block.  First it must be removed
3919:                					from the ready list. */
3920:                					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD039E0  8030FC5C   LW V0, -32720(GP)
BFD039E4      6D22   ADDIU V0, V0, 4
BFD039E6      0C82   MOVE A0, V0
BFD039E8  00C877E8   JALS uxListRemove
BFD039EA  0C0000C8   SLL A2, T0, 1
BFD039EC      0C00   NOP
BFD039EE  000C40A2   BNEZC V0, 0xBFD03A0A
3921:                					{
3922:                						/* The current task must be in a ready list, so there is
3923:                						no need to check, and the port reset macro can be called
3924:                						directly. */
3925:                						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
BFD039F2  8030FC5C   LW V0, -32720(GP)
BFD039F6      692B   LW V0, 44(V0)
BFD039F8      ED81   LI V1, 1
BFD039FA  10100062   SLLV V0, V0, V1
BFD039FC  441A1010   ADDI ZERO, S0, 17434
BFD039FE      441A   NOT16 V1, V0
BFD03A00  8040FC5C   LW V0, -32704(GP)
BFD03A04      4493   AND16 V0, V1
BFD03A06  8040F85C   SW V0, -32704(GP)
3926:                					}
3927:                					else
3928:                					{
3929:                						mtCOVERAGE_TEST_MARKER();
3930:                					}
3931:                
3932:                					#if ( INCLUDE_vTaskSuspend == 1 )
3933:                					{
3934:                						if( xTicksToWait == portMAX_DELAY )
BFD03A0A  002CFC7E   LW V1, 44(S8)
BFD03A0E      ED7F   LI V0, -1
BFD03A10  000EB443   BNE V1, V0, 0xBFD03A30
BFD03A12  0C00000E   SLL ZERO, T6, 1
BFD03A14      0C00   NOP
3935:                						{
3936:                							/* Add the task to the suspended task list instead
3937:                							of a delayed task list to ensure the task is not
3938:                							woken by a timing event.  It will block
3939:                							indefinitely. */
3940:                							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
BFD03A16  8030FC5C   LW V0, -32720(GP)
BFD03A1A      6D22   ADDIU V0, V0, 4
BFD03A1C  BFD241A3   LUI V1, 0xBFD2
BFD03A1E  3083BFD2   LDC1 F30, 12419(S2)
BFD03A20  80E43083   ADDIU A0, V1, -32540
BFD03A24      0CA2   MOVE A1, V0
BFD03A26  3E4A77E8   JALS vListInsertEnd
BFD03A28  0C003E4A   LH S2, 3072(T2)
BFD03A2A      0C00   NOP
BFD03A2C      CC0D   B 0xBFD03A48
BFD03A2E      0C00   NOP
3941:                						}
3942:                						else
3943:                						{
3944:                							/* Calculate the time at which the task should be
3945:                							woken if no notification events occur.  This may
3946:                							overflow but this doesn't matter, the scheduler will
3947:                							handle it. */
3948:                							xTimeToWake = xTickCount + xTicksToWait;
BFD03A30  803CFC7C   LW V1, -32708(GP)
BFD03A34  002CFC5E   LW V0, 44(S8)
BFD03A38      0526   ADDU V0, V1, V0
BFD03A3A  0010F85E   SW V0, 16(S8)
3949:                							prvAddCurrentTaskToDelayedList( xTimeToWake );
BFD03A3E  0010FC9E   LW A0, 16(S8)
BFD03A42  373477E8   JALS prvAddCurrentTaskToDelayedList
BFD03A44  0C003734   LHU T9, 3072(S4)
BFD03A46      0C00   NOP
3950:                						}
3951:                					}
3952:                					#else /* INCLUDE_vTaskSuspend */
3953:                					{
3954:                							/* Calculate the time at which the task should be
3955:                							woken if the event does not occur.  This may
3956:                							overflow but this doesn't matter, the scheduler will
3957:                							handle it. */
3958:                							xTimeToWake = xTickCount + xTicksToWait;
3959:                							prvAddCurrentTaskToDelayedList( xTimeToWake );
3960:                					}
3961:                					#endif /* INCLUDE_vTaskSuspend */
3962:                
3963:                					/* All ports are written to allow a yield in a critical
3964:                					section (some will yield immediately, others wait until the
3965:                					critical section exits) - but it is not something that
3966:                					application code should ever do. */
3967:                					portYIELD_WITHIN_API();
BFD03A48  4E5677E8   JALS ulPortGetCP0Cause
BFD03A4A      4E56   ADDIU S2, S2, -5
BFD03A4C      0C00   NOP
BFD03A4E  0014F85E   SW V0, 20(S8)
BFD03A52  0014FC5E   LW V0, 20(S8)
BFD03A56  01005042   ORI V0, V0, 256
BFD03A5A  0014F85E   SW V0, 20(S8)
BFD03A5E  0014FC9E   LW A0, 20(S8)
BFD03A62  4E6677E8   JALS vPortSetCP0Cause
BFD03A64      4E66   ADDIU S3, S3, 3
BFD03A66      0C00   NOP
3968:                				}
3969:                				else
3970:                				{
3971:                					mtCOVERAGE_TEST_MARKER();
3972:                				}
3973:                			}
3974:                			else
3975:                			{
3976:                				mtCOVERAGE_TEST_MARKER();
3977:                			}
3978:                		}
3979:                		taskEXIT_CRITICAL();
BFD03A68  40AA77E8   JALS vTaskExitCritical
BFD03A6A  0C0040AA   BNEZC T2, 0xBFD0526E
BFD03A6C      0C00   NOP
3980:                
3981:                		taskENTER_CRITICAL();
BFD03A6E  33B877E8   JALS vTaskEnterCritical
BFD03A70  0C0033B8   ADDIU SP, T8, 3072
BFD03A72      0C00   NOP
3982:                		{
3983:                			ulReturn = pxCurrentTCB->ulNotifiedValue;
BFD03A74  8030FC5C   LW V0, -32720(GP)
BFD03A78  0048FC42   LW V0, 72(V0)
BFD03A7C  0018F85E   SW V0, 24(S8)
3984:                
3985:                			if( ulReturn != 0UL )
BFD03A80  0018FC5E   LW V0, 24(S8)
BFD03A84  001140E2   BEQZC V0, 0xBFD03AAA
3986:                			{
3987:                				if( xClearCountOnExit != pdFALSE )
BFD03A88  0028FC5E   LW V0, 40(S8)
BFD03A8C  000640E2   BEQZC V0, 0xBFD03A9C
3988:                				{
3989:                					pxCurrentTCB->ulNotifiedValue = 0UL;
BFD03A90  8030FC5C   LW V0, -32720(GP)
BFD03A94  0048F802   SW ZERO, 72(V0)
BFD03A98      CC08   B 0xBFD03AAA
BFD03A9A      0C00   NOP
3990:                				}
3991:                				else
3992:                				{
3993:                					( pxCurrentTCB->ulNotifiedValue )--;
BFD03A9C  8030FC5C   LW V0, -32720(GP)
BFD03AA0  0048FC62   LW V1, 72(V0)
BFD03AA4      6DBE   ADDIU V1, V1, -1
BFD03AA6  0048F862   SW V1, 72(V0)
3994:                				}
3995:                			}
3996:                			else
3997:                			{
3998:                				mtCOVERAGE_TEST_MARKER();
3999:                			}
4000:                
4001:                			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
BFD03AAA  8030FC5C   LW V0, -32720(GP)
BFD03AAE  004CF802   SW ZERO, 76(V0)
4002:                		}
4003:                		taskEXIT_CRITICAL();
BFD03AB2  40AA77E8   JALS vTaskExitCritical
BFD03AB4  0C0040AA   BNEZC T2, 0xBFD052B8
BFD03AB6      0C00   NOP
4004:                
4005:                		return ulReturn;
BFD03AB8  0018FC5E   LW V0, 24(S8)
4006:                	}
BFD03ABC      0FBE   MOVE SP, S8
BFD03ABE      4BE9   LW RA, 36(SP)
BFD03AC0      4BC8   LW S8, 32(SP)
BFD03AC2      4C15   ADDIU SP, SP, 40
BFD03AC4      459F   JR16 RA
BFD03AC6      0C00   NOP
4007:                
4008:                #endif /* configUSE_TASK_NOTIFICATIONS */
4009:                /*-----------------------------------------------------------*/
4010:                
4011:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4012:                
4013:                	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
4014:                	{
BFD02C6C      4FED   ADDIU SP, SP, -40
BFD02C6E      CBE9   SW RA, 36(SP)
BFD02C70      CBC8   SW S8, 32(SP)
BFD02C72      0FDD   MOVE S8, SP
BFD02C74  0028F89E   SW A0, 40(S8)
BFD02C78  002CF8BE   SW A1, 44(S8)
BFD02C7C  0030F8DE   SW A2, 48(S8)
BFD02C80  0034F8FE   SW A3, 52(S8)
4015:                	TickType_t xTimeToWake;
4016:                	BaseType_t xReturn;
4017:                
4018:                		taskENTER_CRITICAL();
BFD02C84  33B877E8   JALS vTaskEnterCritical
BFD02C86  0C0033B8   ADDIU SP, T8, 3072
BFD02C88      0C00   NOP
4019:                		{
4020:                			/* Only block if a notification is not already pending. */
4021:                			if( pxCurrentTCB->eNotifyState != eNotified )
BFD02C8A  8030FC5C   LW V0, -32720(GP)
BFD02C8E  004CFC62   LW V1, 76(V0)
BFD02C92      ED02   LI V0, 2
BFD02C94  00589443   BEQ V1, V0, 0xBFD02D48
BFD02C96  0C000058   SLL V0, T8, 1
BFD02C98      0C00   NOP
4022:                			{
4023:                				/* Clear bits in the task's notification value as bits may get
4024:                				set	by the notifying task or interrupt.  This can be used to
4025:                				clear the value to zero. */
4026:                				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
BFD02C9A  8030FC5C   LW V0, -32720(GP)
BFD02C9E  0048FC82   LW A0, 72(V0)
BFD02CA2  0028FC7E   LW V1, 40(S8)
BFD02CA6      441B   NOT16 V1, V1
BFD02CA8      449C   AND16 V1, A0
BFD02CAA  0048F862   SW V1, 72(V0)
4027:                
4028:                				/* Mark this task as waiting for a notification. */
4029:                				pxCurrentTCB->eNotifyState = eWaitingNotification;
BFD02CAE  8030FC5C   LW V0, -32720(GP)
BFD02CB2      ED81   LI V1, 1
BFD02CB4  004CF862   SW V1, 76(V0)
4030:                
4031:                				if( xTicksToWait > ( TickType_t ) 0 )
BFD02CB8  0034FC5E   LW V0, 52(S8)
BFD02CBC  004440E2   BEQZC V0, 0xBFD02D48
4032:                				{
4033:                					/* The task is going to block.  First it must be removed
4034:                					from the	ready list. */
4035:                					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
BFD02CC0  8030FC5C   LW V0, -32720(GP)
BFD02CC4      6D22   ADDIU V0, V0, 4
BFD02CC6      0C82   MOVE A0, V0
BFD02CC8  00C877E8   JALS uxListRemove
BFD02CCA  0C0000C8   SLL A2, T0, 1
BFD02CCC      0C00   NOP
BFD02CCE  000C40A2   BNEZC V0, 0xBFD02CEA
4036:                					{
4037:                						/* The current task must be in a ready list, so there is
4038:                						no need to check, and the port reset macro can be called
4039:                						directly. */
4040:                						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
BFD02CD2  8030FC5C   LW V0, -32720(GP)
BFD02CD6      692B   LW V0, 44(V0)
BFD02CD8      ED81   LI V1, 1
BFD02CDA  10100062   SLLV V0, V0, V1
BFD02CDC  441A1010   ADDI ZERO, S0, 17434
BFD02CDE      441A   NOT16 V1, V0
BFD02CE0  8040FC5C   LW V0, -32704(GP)
BFD02CE4      4493   AND16 V0, V1
BFD02CE6  8040F85C   SW V0, -32704(GP)
4041:                					}
4042:                					else
4043:                					{
4044:                						mtCOVERAGE_TEST_MARKER();
4045:                					}
4046:                
4047:                					#if ( INCLUDE_vTaskSuspend == 1 )
4048:                					{
4049:                						if( xTicksToWait == portMAX_DELAY )
BFD02CEA  0034FC7E   LW V1, 52(S8)
BFD02CEE      ED7F   LI V0, -1
BFD02CF0  000EB443   BNE V1, V0, 0xBFD02D10
BFD02CF2  0C00000E   SLL ZERO, T6, 1
BFD02CF4      0C00   NOP
4050:                						{
4051:                							/* Add the task to the suspended task list instead
4052:                							of a delayed task list to ensure the task is not
4053:                							woken by a timing event.  It will block
4054:                							indefinitely. */
4055:                							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
BFD02CF6  8030FC5C   LW V0, -32720(GP)
BFD02CFA      6D22   ADDIU V0, V0, 4
BFD02CFC  BFD241A3   LUI V1, 0xBFD2
BFD02CFE  3083BFD2   LDC1 F30, 12419(S2)
BFD02D00  80E43083   ADDIU A0, V1, -32540
BFD02D04      0CA2   MOVE A1, V0
BFD02D06  3E4A77E8   JALS vListInsertEnd
BFD02D08  0C003E4A   LH S2, 3072(T2)
BFD02D0A      0C00   NOP
BFD02D0C      CC0D   B 0xBFD02D28
BFD02D0E      0C00   NOP
4056:                						}
4057:                						else
4058:                						{
4059:                							/* Calculate the time at which the task should be
4060:                							woken if no notification events occur.  This may
4061:                							overflow but this doesn't matter, the scheduler will
4062:                							handle it. */
4063:                							xTimeToWake = xTickCount + xTicksToWait;
BFD02D10  803CFC7C   LW V1, -32708(GP)
BFD02D14  0034FC5E   LW V0, 52(S8)
BFD02D18      0526   ADDU V0, V1, V0
BFD02D1A  0014F85E   SW V0, 20(S8)
4064:                							prvAddCurrentTaskToDelayedList( xTimeToWake );
BFD02D1E  0014FC9E   LW A0, 20(S8)
BFD02D22  373477E8   JALS prvAddCurrentTaskToDelayedList
BFD02D24  0C003734   LHU T9, 3072(S4)
BFD02D26      0C00   NOP
4065:                						}
4066:                					}
4067:                					#else /* INCLUDE_vTaskSuspend */
4068:                					{
4069:                							/* Calculate the time at which the task should be
4070:                							woken if the event does not occur.  This may
4071:                							overflow but this doesn't matter, the scheduler will
4072:                							handle it. */
4073:                							xTimeToWake = xTickCount + xTicksToWait;
4074:                							prvAddCurrentTaskToDelayedList( xTimeToWake );
4075:                					}
4076:                					#endif /* INCLUDE_vTaskSuspend */
4077:                
4078:                					/* All ports are written to allow a yield in a critical
4079:                					section (some will yield immediately, others wait until the
4080:                					critical section exits) - but it is not something that
4081:                					application code should ever do. */
4082:                					portYIELD_WITHIN_API();
BFD02D28  4E5677E8   JALS ulPortGetCP0Cause
BFD02D2A      4E56   ADDIU S2, S2, -5
BFD02D2C      0C00   NOP
BFD02D2E  0018F85E   SW V0, 24(S8)
BFD02D32  0018FC5E   LW V0, 24(S8)
BFD02D36  01005042   ORI V0, V0, 256
BFD02D3A  0018F85E   SW V0, 24(S8)
BFD02D3E  0018FC9E   LW A0, 24(S8)
BFD02D42  4E6677E8   JALS vPortSetCP0Cause
BFD02D44      4E66   ADDIU S3, S3, 3
BFD02D46      0C00   NOP
4083:                				}
4084:                				else
4085:                				{
4086:                					mtCOVERAGE_TEST_MARKER();
4087:                				}
4088:                			}
4089:                			else
4090:                			{
4091:                				mtCOVERAGE_TEST_MARKER();
4092:                			}
4093:                		}
4094:                		taskEXIT_CRITICAL();
BFD02D48  40AA77E8   JALS vTaskExitCritical
BFD02D4A  0C0040AA   BNEZC T2, 0xBFD0454E
BFD02D4C      0C00   NOP
4095:                
4096:                		taskENTER_CRITICAL();
BFD02D4E  33B877E8   JALS vTaskEnterCritical
BFD02D50  0C0033B8   ADDIU SP, T8, 3072
BFD02D52      0C00   NOP
4097:                		{
4098:                			if( pulNotificationValue != NULL )
BFD02D54  0030FC5E   LW V0, 48(S8)
BFD02D58  000740E2   BEQZC V0, 0xBFD02D6A
4099:                			{
4100:                				/* Output the current notification value, which may or may not
4101:                				have changed. */
4102:                				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
BFD02D5C  8030FC5C   LW V0, -32720(GP)
BFD02D60  0048FC62   LW V1, 72(V0)
BFD02D64  0030FC5E   LW V0, 48(S8)
BFD02D68      E9A0   SW V1, 0(V0)
4103:                			}
4104:                
4105:                			/* If eNotifyValue is set then either the task never entered the
4106:                			blocked state (because a notification was already pending) or the
4107:                			task unblocked because of a notification.  Otherwise the task
4108:                			unblocked because of a timeout. */
4109:                			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
BFD02D6A  8030FC5C   LW V0, -32720(GP)
BFD02D6E  004CFC62   LW V1, 76(V0)
BFD02D72      ED01   LI V0, 1
BFD02D74  0005B443   BNE V1, V0, 0xBFD02D82
BFD02D76  0C000005   SLL ZERO, A1, 1
BFD02D78      0C00   NOP
4110:                			{
4111:                				/* A notification was not received. */
4112:                				xReturn = pdFALSE;
BFD02D7A  0010F81E   SW ZERO, 16(S8)
BFD02D7E      CC0E   B 0xBFD02D9C
BFD02D80      0C00   NOP
4113:                			}
4114:                			else
4115:                			{
4116:                				/* A notification was already pending or a notification was
4117:                				received while the task was waiting. */
4118:                				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
BFD02D82  8030FC5C   LW V0, -32720(GP)
BFD02D86  0048FC82   LW A0, 72(V0)
BFD02D8A  002CFC7E   LW V1, 44(S8)
BFD02D8E      441B   NOT16 V1, V1
BFD02D90      449C   AND16 V1, A0
BFD02D92  0048F862   SW V1, 72(V0)
4119:                				xReturn = pdTRUE;
BFD02D96      ED01   LI V0, 1
BFD02D98  0010F85E   SW V0, 16(S8)
4120:                			}
4121:                
4122:                			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
BFD02D9C  8030FC5C   LW V0, -32720(GP)
BFD02DA0  004CF802   SW ZERO, 76(V0)
4123:                		}
4124:                		taskEXIT_CRITICAL();
BFD02DA4  40AA77E8   JALS vTaskExitCritical
BFD02DA6  0C0040AA   BNEZC T2, 0xBFD045AA
BFD02DA8      0C00   NOP
4125:                
4126:                		return xReturn;
BFD02DAA  0010FC5E   LW V0, 16(S8)
4127:                	}
BFD02DAE      0FBE   MOVE SP, S8
BFD02DB0      4BE9   LW RA, 36(SP)
BFD02DB2      4BC8   LW S8, 32(SP)
BFD02DB4      4C15   ADDIU SP, SP, 40
BFD02DB6      459F   JR16 RA
BFD02DB8      0C00   NOP
4128:                
4129:                #endif /* configUSE_TASK_NOTIFICATIONS */
4130:                /*-----------------------------------------------------------*/
4131:                
4132:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4133:                
4134:                	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
4135:                	{
BFD01CE8      4FED   ADDIU SP, SP, -40
BFD01CEA      CBE9   SW RA, 36(SP)
BFD01CEC      CBC8   SW S8, 32(SP)
BFD01CEE      0FDD   MOVE S8, SP
BFD01CF0  0028F89E   SW A0, 40(S8)
BFD01CF4  002CF8BE   SW A1, 44(S8)
BFD01CF8  0030F8DE   SW A2, 48(S8)
BFD01CFC  0034F8FE   SW A3, 52(S8)
4136:                	TCB_t * pxTCB;
4137:                	eNotifyValue eOriginalNotifyState;
4138:                	BaseType_t xReturn = pdPASS;
BFD01D00      ED01   LI V0, 1
BFD01D02  0010F85E   SW V0, 16(S8)
4139:                
4140:                		configASSERT( xTaskToNotify );
BFD01D06  0028FC5E   LW V0, 40(S8)
BFD01D0A  000940A2   BNEZC V0, 0xBFD01D20
BFD01D0E  BFD141A2   LUI V0, 0xBFD1
BFD01D10  3082BFD1   LDC1 F30, 12418(S1)
BFD01D12  98103082   ADDIU A0, V0, -26608
BFD01D14  30A09810   SWC1 F0, 12448(S0)
BFD01D16  102C30A0   ADDIU A1, ZERO, 4140
BFD01D18  77E8102C   ADDI AT, T4, 30696
BFD01D1A  4B7E77E8   JALS vAssertCalled
BFD01D1C      4B7E   LW K1, 120(SP)
BFD01D1E      0C00   NOP
4141:                		pxTCB = ( TCB_t * ) xTaskToNotify;
BFD01D20  0028FC5E   LW V0, 40(S8)
BFD01D24  0014F85E   SW V0, 20(S8)
4142:                
4143:                		taskENTER_CRITICAL();
BFD01D28  33B877E8   JALS vTaskEnterCritical
BFD01D2A  0C0033B8   ADDIU SP, T8, 3072
BFD01D2C      0C00   NOP
4144:                		{
4145:                			if( pulPreviousNotificationValue != NULL )
BFD01D2E  0034FC5E   LW V0, 52(S8)
BFD01D32  000740E2   BEQZC V0, 0xBFD01D44
4146:                			{
4147:                				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
BFD01D36  0014FC5E   LW V0, 20(S8)
BFD01D3A  0048FC62   LW V1, 72(V0)
BFD01D3E  0034FC5E   LW V0, 52(S8)
BFD01D42      E9A0   SW V1, 0(V0)
4148:                			}
4149:                
4150:                			eOriginalNotifyState = pxTCB->eNotifyState;
BFD01D44  0014FC5E   LW V0, 20(S8)
BFD01D48  004CFC42   LW V0, 76(V0)
BFD01D4C  0018F85E   SW V0, 24(S8)
4151:                
4152:                			pxTCB->eNotifyState = eNotified;
BFD01D50  0014FC5E   LW V0, 20(S8)
BFD01D54      ED82   LI V1, 2
BFD01D56  004CF862   SW V1, 76(V0)
4153:                
4154:                			switch( eAction )
BFD01D5A  0030FC5E   LW V0, 48(S8)
BFD01D5E  0005B042   SLTIU V0, V0, 5
BFD01D62  004840E2   BEQZC V0, 0xBFD01DF6
BFD01D66  0030FC5E   LW V0, 48(S8)
BFD01D6A      25A4   SLL V1, V0, 2
BFD01D6C  BFD041A2   LUI V0, 0xBFD0
BFD01D6E  3042BFD0   LDC1 F30, 12354(S0)
BFD01D70  1D7C3042   ADDIU V0, V0, 7548
BFD01D72  05261D7C   LB T3, 1318(GP)
BFD01D74      0526   ADDU V0, V1, V0
BFD01D76      6920   LW V0, 0(V0)
BFD01D78      45A2   JRC V0
BFD01D7A      0C00   NOP
BFD01D7C  BFD01DF5   LB T7, -16432(S5)
BFD01D7E  1D91BFD0   LDC1 F30, 7569(S0)
BFD01D80  BFD01D91   LB T4, -16432(S1)
BFD01D82  1DABBFD0   LDC1 F30, 7595(S0)
BFD01D84  BFD01DAB   LB T5, -16432(T3)
BFD01D86  1DC1BFD0   LDC1 F30, 7617(S0)
BFD01D88  BFD01DC1   LB T6, -16432(AT)
BFD01D8A  1DD1BFD0   LDC1 F30, 7633(S0)
BFD01D8C  BFD01DD1   LB T6, -16432(S1)
BFD01D8E  FC5EBFD0   LDC1 F30, -930(S0)
4155:                			{
4156:                				case eSetBits	:
4157:                					pxTCB->ulNotifiedValue |= ulValue;
BFD01D90  0014FC5E   LW V0, 20(S8)
BFD01D94  0048FC62   LW V1, 72(V0)
BFD01D98  002CFC5E   LW V0, 44(S8)
BFD01D9C      44DA   OR16 V1, V0
BFD01D9E  0014FC5E   LW V0, 20(S8)
BFD01DA2  0048F862   SW V1, 72(V0)
4158:                					break;
BFD01DA6      CC27   B 0xBFD01DF6
BFD01DA8      0C00   NOP
4159:                
4160:                				case eIncrement	:
4161:                					( pxTCB->ulNotifiedValue )++;
BFD01DAA  0014FC5E   LW V0, 20(S8)
BFD01DAE  0048FC42   LW V0, 72(V0)
BFD01DB2      6DA0   ADDIU V1, V0, 1
BFD01DB4  0014FC5E   LW V0, 20(S8)
BFD01DB8  0048F862   SW V1, 72(V0)
4162:                					break;
BFD01DBC      CC1C   B 0xBFD01DF6
BFD01DBE      0C00   NOP
4163:                
4164:                				case eSetValueWithOverwrite	:
4165:                					pxTCB->ulNotifiedValue = ulValue;
BFD01DC0  0014FC5E   LW V0, 20(S8)
BFD01DC4  002CFC7E   LW V1, 44(S8)
BFD01DC8  0048F862   SW V1, 72(V0)
4166:                					break;
BFD01DCC      CC14   B 0xBFD01DF6
BFD01DCE      0C00   NOP
4167:                
4168:                				case eSetValueWithoutOverwrite :
4169:                					if( eOriginalNotifyState != eNotified )
BFD01DD0  0018FC7E   LW V1, 24(S8)
BFD01DD4      ED02   LI V0, 2
BFD01DD6  00099443   BEQ V1, V0, 0xBFD01DEC
BFD01DD8  0C000009   SLL ZERO, T1, 1
BFD01DDA      0C00   NOP
4170:                					{
4171:                						pxTCB->ulNotifiedValue = ulValue;
BFD01DDC  0014FC5E   LW V0, 20(S8)
BFD01DE0  002CFC7E   LW V1, 44(S8)
BFD01DE4  0048F862   SW V1, 72(V0)
4172:                					}
4173:                					else
4174:                					{
4175:                						/* The value could not be written to the task. */
4176:                						xReturn = pdFAIL;
BFD01DEC  0010F81E   SW ZERO, 16(S8)
4177:                					}
4178:                					break;
BFD01DE8      CC06   B 0xBFD01DF6
BFD01DEA      0C00   NOP
BFD01DF0      CC02   B 0xBFD01DF6
BFD01DF2      0C00   NOP
4179:                
4180:                				case eNoAction:
4181:                					/* The task is being notified without its notify value being
4182:                					updated. */
4183:                					break;
BFD01DF4      0C00   NOP
4184:                			}
4185:                
4186:                
4187:                			/* If the task is in the blocked state specifically to wait for a
4188:                			notification then unblock it now. */
4189:                			if( eOriginalNotifyState == eWaitingNotification )
BFD01DF6  0018FC7E   LW V1, 24(S8)
BFD01DFA      ED01   LI V0, 1
BFD01DFC  004EB443   BNE V1, V0, 0xBFD01E9C
BFD01DFE  0C00004E   SLL V0, T6, 1
BFD01E00      0C00   NOP
4190:                			{
4191:                				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
BFD01E02  0014FC5E   LW V0, 20(S8)
BFD01E06      6D22   ADDIU V0, V0, 4
BFD01E08      0C82   MOVE A0, V0
BFD01E0A  00C877E8   JALS uxListRemove
BFD01E0C  0C0000C8   SLL A2, T0, 1
BFD01E0E      0C00   NOP
4192:                				prvAddTaskToReadyList( pxTCB );
BFD01E10  0014FC5E   LW V0, 20(S8)
BFD01E14      692B   LW V0, 44(V0)
BFD01E16      ED81   LI V1, 1
BFD01E18  18100062   SLLV V1, V0, V1
BFD01E1A  FC5C1810   SB ZERO, -932(S0)
BFD01E1C  8040FC5C   LW V0, -32704(GP)
BFD01E20      44D3   OR16 V0, V1
BFD01E22  8040F85C   SW V0, -32704(GP)
BFD01E26  0014FC5E   LW V0, 20(S8)
BFD01E2A      692B   LW V0, 44(V0)
BFD01E2C      2524   SLL V0, V0, 2
BFD01E2E      25A4   SLL V1, V0, 2
BFD01E30      05B4   ADDU V1, V0, V1
BFD01E32  BFD241A2   LUI V0, 0xBFD2
BFD01E34  3042BFD2   LDC1 F30, 12354(S2)
BFD01E36  806C3042   ADDIU V0, V0, -32660
BFD01E3A      05A6   ADDU V1, V1, V0
BFD01E3C  0014FC5E   LW V0, 20(S8)
BFD01E40      6D22   ADDIU V0, V0, 4
BFD01E42      0C83   MOVE A0, V1
BFD01E44      0CA2   MOVE A1, V0
BFD01E46  3E4A77E8   JALS vListInsertEnd
BFD01E48  0C003E4A   LH S2, 3072(T2)
BFD01E4A      0C00   NOP
4193:                
4194:                				/* The task should not have been on an event list. */
4195:                				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
BFD01E4C  0014FC5E   LW V0, 20(S8)
BFD01E50      692A   LW V0, 40(V0)
BFD01E52  000940E2   BEQZC V0, 0xBFD01E68
BFD01E56  BFD141A2   LUI V0, 0xBFD1
BFD01E58  3082BFD1   LDC1 F30, 12418(S1)
BFD01E5A  98103082   ADDIU A0, V0, -26608
BFD01E5C  30A09810   SWC1 F0, 12448(S0)
BFD01E5E  106330A0   ADDIU A1, ZERO, 4195
BFD01E60  77E81063   ADDI V1, V1, 30696
BFD01E62  4B7E77E8   JALS vAssertCalled
BFD01E64      4B7E   LW K1, 120(SP)
BFD01E66      0C00   NOP
4196:                
4197:                				#if( configUSE_TICKLESS_IDLE != 0 )
4198:                				{
4199:                					/* If a task is blocked waiting for a notification then
4200:                					xNextTaskUnblockTime might be set to the blocked task's time
4201:                					out time.  If the task is unblocked for a reason other than
4202:                					a timeout xNextTaskUnblockTime is normally left unchanged,
4203:                					because it will automatically get reset to a new value when
4204:                					the tick count equals xNextTaskUnblockTime.  However if
4205:                					tickless idling is used it might be more important to enter
4206:                					sleep mode at the earliest possible time - so reset
4207:                					xNextTaskUnblockTime here to ensure it is updated at the
4208:                					earliest possible time. */
4209:                					prvResetNextTaskUnblockTime();
4210:                				}
4211:                				#endif
4212:                
4213:                				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
BFD01E68  0014FC5E   LW V0, 20(S8)
BFD01E6C      69AB   LW V1, 44(V0)
BFD01E6E  8030FC5C   LW V0, -32720(GP)
BFD01E72      692B   LW V0, 44(V0)
BFD01E74  13900062   SLTU V0, V0, V1
BFD01E76  40E21390   ADDI GP, S0, 16610
BFD01E78  001040E2   BEQZC V0, 0xBFD01E9C
4214:                				{
4215:                					/* The notified task has a priority above the currently
4216:                					executing task so a yield is required. */
4217:                					taskYIELD_IF_USING_PREEMPTION();
BFD01E7C  4E5677E8   JALS ulPortGetCP0Cause
BFD01E7E      4E56   ADDIU S2, S2, -5
BFD01E80      0C00   NOP
BFD01E82  001CF85E   SW V0, 28(S8)
BFD01E86  001CFC5E   LW V0, 28(S8)
BFD01E8A  01005042   ORI V0, V0, 256
BFD01E8E  001CF85E   SW V0, 28(S8)
BFD01E92  001CFC9E   LW A0, 28(S8)
BFD01E96  4E6677E8   JALS vPortSetCP0Cause
BFD01E98      4E66   ADDIU S3, S3, 3
BFD01E9A      0C00   NOP
4218:                				}
4219:                				else
4220:                				{
4221:                					mtCOVERAGE_TEST_MARKER();
4222:                				}
4223:                			}
4224:                			else
4225:                			{
4226:                				mtCOVERAGE_TEST_MARKER();
4227:                			}
4228:                		}
4229:                		taskEXIT_CRITICAL();
BFD01E9C  40AA77E8   JALS vTaskExitCritical
BFD01E9E  0C0040AA   BNEZC T2, 0xBFD036A2
BFD01EA0      0C00   NOP
4230:                
4231:                		return xReturn;
BFD01EA2  0010FC5E   LW V0, 16(S8)
4232:                	}
BFD01EA6      0FBE   MOVE SP, S8
BFD01EA8      4BE9   LW RA, 36(SP)
BFD01EAA      4BC8   LW S8, 32(SP)
BFD01EAC      4C15   ADDIU SP, SP, 40
BFD01EAE      459F   JR16 RA
BFD01EB0      0C00   NOP
4233:                
4234:                #endif /* configUSE_TASK_NOTIFICATIONS */
4235:                /*-----------------------------------------------------------*/
4236:                
4237:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4238:                
4239:                	BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )
4240:                	{
BFD01EB4      4FED   ADDIU SP, SP, -40
BFD01EB6      CBE9   SW RA, 36(SP)
BFD01EB8      CBC8   SW S8, 32(SP)
BFD01EBA      0FDD   MOVE S8, SP
BFD01EBC  0028F89E   SW A0, 40(S8)
BFD01EC0  002CF8BE   SW A1, 44(S8)
BFD01EC4  0030F8DE   SW A2, 48(S8)
BFD01EC8  0034F8FE   SW A3, 52(S8)
4241:                	TCB_t * pxTCB;
4242:                	eNotifyValue eOriginalNotifyState;
4243:                	BaseType_t xReturn = pdPASS;
BFD01ECC      ED01   LI V0, 1
BFD01ECE  0010F85E   SW V0, 16(S8)
4244:                	UBaseType_t uxSavedInterruptStatus;
4245:                
4246:                		configASSERT( xTaskToNotify );
BFD01ED2  0028FC5E   LW V0, 40(S8)
BFD01ED6  000940A2   BNEZC V0, 0xBFD01EEC
BFD01EDA  BFD141A2   LUI V0, 0xBFD1
BFD01EDC  3082BFD1   LDC1 F30, 12418(S1)
BFD01EDE  98103082   ADDIU A0, V0, -26608
BFD01EE0  30A09810   SWC1 F0, 12448(S0)
BFD01EE2  109630A0   ADDIU A1, ZERO, 4246
BFD01EE4  77E81096   ADDI A0, S6, 30696
BFD01EE6  4B7E77E8   JALS vAssertCalled
BFD01EE8      4B7E   LW K1, 120(SP)
BFD01EEA      0C00   NOP
4247:                
4248:                		/* RTOS ports that support interrupt nesting have the concept of a
4249:                		maximum	system call (or maximum API call) interrupt priority.
4250:                		Interrupts that are	above the maximum system call priority are keep
4251:                		permanently enabled, even when the RTOS kernel is in a critical section,
4252:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4253:                		is defined in FreeRTOSConfig.h then
4254:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4255:                		failure if a FreeRTOS API function is called from an interrupt that has
4256:                		been assigned a priority above the configured maximum system call
4257:                		priority.  Only FreeRTOS functions that end in FromISR can be called
4258:                		from interrupts	that have been assigned a priority at or (logically)
4259:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
4260:                		separate interrupt safe API to ensure interrupt entry is as fast and as
4261:                		simple as possible.  More information (albeit Cortex-M specific) is
4262:                		provided on the following link:
4263:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4264:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4265:                
4266:                		pxTCB = ( TCB_t * ) xTaskToNotify;
BFD01EEC  0028FC5E   LW V0, 40(S8)
BFD01EF0  0014F85E   SW V0, 20(S8)
4267:                
4268:                		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
BFD01EF4  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD01EF8      0C00   NOP
BFD01EFA  0018F85E   SW V0, 24(S8)
4269:                		{
4270:                			eOriginalNotifyState = pxTCB->eNotifyState;
BFD01EFE  0014FC5E   LW V0, 20(S8)
BFD01F02  004CFC42   LW V0, 76(V0)
BFD01F06  001CF85E   SW V0, 28(S8)
4271:                
4272:                			pxTCB->eNotifyState = eNotified;
BFD01F0A  0014FC5E   LW V0, 20(S8)
BFD01F0E      ED82   LI V1, 2
BFD01F10  004CF862   SW V1, 76(V0)
4273:                
4274:                			switch( eAction )
BFD01F14  0030FC5E   LW V0, 48(S8)
BFD01F18  0005B042   SLTIU V0, V0, 5
BFD01F1C  004740E2   BEQZC V0, 0xBFD01FAE
BFD01F20  0030FC5E   LW V0, 48(S8)
BFD01F24      25A4   SLL V1, V0, 2
BFD01F26  BFD041A2   LUI V0, 0xBFD0
BFD01F28  3042BFD0   LDC1 F30, 12354(S0)
BFD01F2A  1F343042   ADDIU V0, V0, 7988
BFD01F2C  05261F34   LB T9, 1318(S4)
BFD01F2E      0526   ADDU V0, V1, V0
BFD01F30      6920   LW V0, 0(V0)
BFD01F32      45A2   JRC V0
BFD01F34  BFD01FAD   LB SP, -16432(T5)
BFD01F36  1F49BFD0   LDC1 F30, 8009(S0)
BFD01F38  BFD01F49   LB K0, -16432(T1)
BFD01F3A  1F63BFD0   LDC1 F30, 8035(S0)
BFD01F3C  BFD01F63   LB K1, -16432(V1)
BFD01F3E  1F79BFD0   LDC1 F30, 8057(S0)
BFD01F40  BFD01F79   LB K1, -16432(T9)
BFD01F42  1F89BFD0   LDC1 F30, 8073(S0)
BFD01F44  BFD01F89   LB GP, -16432(T1)
BFD01F46  FC5EBFD0   LDC1 F30, -930(S0)
4275:                			{
4276:                				case eSetBits	:
4277:                					pxTCB->ulNotifiedValue |= ulValue;
BFD01F48  0014FC5E   LW V0, 20(S8)
BFD01F4C  0048FC62   LW V1, 72(V0)
BFD01F50  002CFC5E   LW V0, 44(S8)
BFD01F54      44DA   OR16 V1, V0
BFD01F56  0014FC5E   LW V0, 20(S8)
BFD01F5A  0048F862   SW V1, 72(V0)
4278:                					break;
BFD01F5E      CC27   B 0xBFD01FAE
BFD01F60      0C00   NOP
4279:                
4280:                				case eIncrement	:
4281:                					( pxTCB->ulNotifiedValue )++;
BFD01F62  0014FC5E   LW V0, 20(S8)
BFD01F66  0048FC42   LW V0, 72(V0)
BFD01F6A      6DA0   ADDIU V1, V0, 1
BFD01F6C  0014FC5E   LW V0, 20(S8)
BFD01F70  0048F862   SW V1, 72(V0)
4282:                					break;
BFD01F74      CC1C   B 0xBFD01FAE
BFD01F76      0C00   NOP
4283:                
4284:                				case eSetValueWithOverwrite	:
4285:                					pxTCB->ulNotifiedValue = ulValue;
BFD01F78  0014FC5E   LW V0, 20(S8)
BFD01F7C  002CFC7E   LW V1, 44(S8)
BFD01F80  0048F862   SW V1, 72(V0)
4286:                					break;
BFD01F84      CC14   B 0xBFD01FAE
BFD01F86      0C00   NOP
4287:                
4288:                				case eSetValueWithoutOverwrite :
4289:                					if( eOriginalNotifyState != eNotified )
BFD01F88  001CFC7E   LW V1, 28(S8)
BFD01F8C      ED02   LI V0, 2
BFD01F8E  00099443   BEQ V1, V0, 0xBFD01FA4
BFD01F90  0C000009   SLL ZERO, T1, 1
BFD01F92      0C00   NOP
4290:                					{
4291:                						pxTCB->ulNotifiedValue = ulValue;
BFD01F94  0014FC5E   LW V0, 20(S8)
BFD01F98  002CFC7E   LW V1, 44(S8)
BFD01F9C  0048F862   SW V1, 72(V0)
4292:                					}
4293:                					else
4294:                					{
4295:                						/* The value could not be written to the task. */
4296:                						xReturn = pdFAIL;
BFD01FA4  0010F81E   SW ZERO, 16(S8)
4297:                					}
4298:                					break;
BFD01FA0      CC06   B 0xBFD01FAE
BFD01FA2      0C00   NOP
BFD01FA8      CC02   B 0xBFD01FAE
BFD01FAA      0C00   NOP
4299:                
4300:                				case eNoAction :
4301:                					/* The task is being notified without its notify value being
4302:                					updated. */
4303:                					break;
BFD01FAC      0C00   NOP
4304:                			}
4305:                
4306:                
4307:                			/* If the task is in the blocked state specifically to wait for a
4308:                			notification then unblock it now. */
4309:                			if( eOriginalNotifyState == eWaitingNotification )
BFD01FAE  001CFC7E   LW V1, 28(S8)
BFD01FB2      ED01   LI V0, 1
BFD01FB4  0057B443   BNE V1, V0, 0xBFD02066
BFD01FB6  0C000057   SLL V0, S7, 1
BFD01FB8      0C00   NOP
4310:                			{
4311:                				/* The task should not have been on an event list. */
4312:                				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
BFD01FBA  0014FC5E   LW V0, 20(S8)
BFD01FBE      692A   LW V0, 40(V0)
BFD01FC0  000940E2   BEQZC V0, 0xBFD01FD6
BFD01FC4  BFD141A2   LUI V0, 0xBFD1
BFD01FC6  3082BFD1   LDC1 F30, 12418(S1)
BFD01FC8  98103082   ADDIU A0, V0, -26608
BFD01FCA  30A09810   SWC1 F0, 12448(S0)
BFD01FCC  10D830A0   ADDIU A1, ZERO, 4312
BFD01FCE  77E810D8   ADDI A2, T8, 30696
BFD01FD0  4B7E77E8   JALS vAssertCalled
BFD01FD2      4B7E   LW K1, 120(SP)
BFD01FD4      0C00   NOP
4313:                
4314:                				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
BFD01FD6  805CFC5C   LW V0, -32676(GP)
BFD01FDA  002740A2   BNEZC V0, 0xBFD0202C
4315:                				{
4316:                					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
BFD01FDE  0014FC5E   LW V0, 20(S8)
BFD01FE2      6D22   ADDIU V0, V0, 4
BFD01FE4      0C82   MOVE A0, V0
BFD01FE6  00C877E8   JALS uxListRemove
BFD01FE8  0C0000C8   SLL A2, T0, 1
BFD01FEA      0C00   NOP
4317:                					prvAddTaskToReadyList( pxTCB );
BFD01FEC  0014FC5E   LW V0, 20(S8)
BFD01FF0      692B   LW V0, 44(V0)
BFD01FF2      ED81   LI V1, 1
BFD01FF4  18100062   SLLV V1, V0, V1
BFD01FF6  FC5C1810   SB ZERO, -932(S0)
BFD01FF8  8040FC5C   LW V0, -32704(GP)
BFD01FFC      44D3   OR16 V0, V1
BFD01FFE  8040F85C   SW V0, -32704(GP)
BFD02002  0014FC5E   LW V0, 20(S8)
BFD02006      692B   LW V0, 44(V0)
BFD02008      2524   SLL V0, V0, 2
BFD0200A      25A4   SLL V1, V0, 2
BFD0200C      05B4   ADDU V1, V0, V1
BFD0200E  BFD241A2   LUI V0, 0xBFD2
BFD02010  3042BFD2   LDC1 F30, 12354(S2)
BFD02012  806C3042   ADDIU V0, V0, -32660
BFD02016      05A6   ADDU V1, V1, V0
BFD02018  0014FC5E   LW V0, 20(S8)
BFD0201C      6D22   ADDIU V0, V0, 4
BFD0201E      0C83   MOVE A0, V1
BFD02020      0CA2   MOVE A1, V0
BFD02022  3E4A77E8   JALS vListInsertEnd
BFD02024  0C003E4A   LH S2, 3072(T2)
BFD02026      0C00   NOP
BFD02028      CC0C   B 0xBFD02042
BFD0202A      0C00   NOP
4318:                				}
4319:                				else
4320:                				{
4321:                					/* The delayed and ready lists cannot be accessed, so hold
4322:                					this task pending until the scheduler is resumed. */
4323:                					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
BFD0202C  0014FC5E   LW V0, 20(S8)
BFD0202E  6D2C0014   EXT ZERO, S4, 20, 14
BFD02030      6D2C   ADDIU V0, V0, 24
BFD02032  BFD241A3   LUI V1, 0xBFD2
BFD02034  3083BFD2   LDC1 F30, 12419(S2)
BFD02036  80D03083   ADDIU A0, V1, -32560
BFD0203A      0CA2   MOVE A1, V0
BFD0203C  3E4A77E8   JALS vListInsertEnd
BFD0203E  0C003E4A   LH S2, 3072(T2)
BFD02040      0C00   NOP
4324:                				}
4325:                
4326:                				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
BFD02042  0014FC5E   LW V0, 20(S8)
BFD02046      69AB   LW V1, 44(V0)
BFD02048  8030FC5C   LW V0, -32720(GP)
BFD0204C      692B   LW V0, 44(V0)
BFD0204E  13900062   SLTU V0, V0, V1
BFD02050  40E21390   ADDI GP, S0, 16610
BFD02052  000840E2   BEQZC V0, 0xBFD02066
4327:                				{
4328:                					/* The notified task has a priority above the currently
4329:                					executing task so a yield is required. */
4330:                					if( pxHigherPriorityTaskWoken != NULL )
BFD02056  0034FC5E   LW V0, 52(S8)
BFD0205A  000440E2   BEQZC V0, 0xBFD02066
4331:                					{
4332:                						*pxHigherPriorityTaskWoken = pdTRUE;
BFD0205E  0034FC5E   LW V0, 52(S8)
BFD02062      ED81   LI V1, 1
BFD02064      E9A0   SW V1, 0(V0)
4333:                					}
4334:                				}
4335:                				else
4336:                				{
4337:                					mtCOVERAGE_TEST_MARKER();
4338:                				}
4339:                			}
4340:                		}
4341:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
BFD02066  0018FC9E   LW A0, 24(S8)
BFD0206A  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD0206C      4D5E   ADDIU T2, T2, -1
BFD0206E      0C00   NOP
4342:                
4343:                		return xReturn;
BFD02070  0010FC5E   LW V0, 16(S8)
4344:                	}
BFD02074      0FBE   MOVE SP, S8
BFD02076      4BE9   LW RA, 36(SP)
BFD02078      4BC8   LW S8, 32(SP)
BFD0207A      4C15   ADDIU SP, SP, 40
BFD0207C      459F   JR16 RA
BFD0207E      0C00   NOP
4345:                
4346:                #endif /* configUSE_TASK_NOTIFICATIONS */
4347:                /*-----------------------------------------------------------*/
4348:                
4349:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4350:                
4351:                	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4352:                	{
BFD03190      4FED   ADDIU SP, SP, -40
BFD03192      CBE9   SW RA, 36(SP)
BFD03194      CBC8   SW S8, 32(SP)
BFD03196      0FDD   MOVE S8, SP
BFD03198  0028F89E   SW A0, 40(S8)
BFD0319C  002CF8BE   SW A1, 44(S8)
4353:                	TCB_t * pxTCB;
4354:                	eNotifyValue eOriginalNotifyState;
4355:                	UBaseType_t uxSavedInterruptStatus;
4356:                
4357:                		configASSERT( xTaskToNotify );
BFD031A0  0028FC5E   LW V0, 40(S8)
BFD031A4  000940A2   BNEZC V0, 0xBFD031BA
BFD031A8  BFD141A2   LUI V0, 0xBFD1
BFD031AA  3082BFD1   LDC1 F30, 12418(S1)
BFD031AC  98103082   ADDIU A0, V0, -26608
BFD031AE  30A09810   SWC1 F0, 12448(S0)
BFD031B0  110530A0   ADDIU A1, ZERO, 4357
BFD031B2  77E81105   ADDI T0, A1, 30696
BFD031B4  4B7E77E8   JALS vAssertCalled
BFD031B6      4B7E   LW K1, 120(SP)
BFD031B8      0C00   NOP
4358:                
4359:                		/* RTOS ports that support interrupt nesting have the concept of a
4360:                		maximum	system call (or maximum API call) interrupt priority.
4361:                		Interrupts that are	above the maximum system call priority are keep
4362:                		permanently enabled, even when the RTOS kernel is in a critical section,
4363:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4364:                		is defined in FreeRTOSConfig.h then
4365:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4366:                		failure if a FreeRTOS API function is called from an interrupt that has
4367:                		been assigned a priority above the configured maximum system call
4368:                		priority.  Only FreeRTOS functions that end in FromISR can be called
4369:                		from interrupts	that have been assigned a priority at or (logically)
4370:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
4371:                		separate interrupt safe API to ensure interrupt entry is as fast and as
4372:                		simple as possible.  More information (albeit Cortex-M specific) is
4373:                		provided on the following link:
4374:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4375:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4376:                
4377:                		pxTCB = ( TCB_t * ) xTaskToNotify;
BFD031BA  0028FC5E   LW V0, 40(S8)
BFD031BE  0010F85E   SW V0, 16(S8)
4378:                
4379:                		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
BFD031C2  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD031C6      0C00   NOP
BFD031C8  0014F85E   SW V0, 20(S8)
4380:                		{
4381:                			eOriginalNotifyState = pxTCB->eNotifyState;
BFD031CC  0010FC5E   LW V0, 16(S8)
BFD031D0  004CFC42   LW V0, 76(V0)
BFD031D4  0018F85E   SW V0, 24(S8)
4382:                			pxTCB->eNotifyState = eNotified;
BFD031D8  0010FC5E   LW V0, 16(S8)
BFD031DC      ED82   LI V1, 2
BFD031DE  004CF862   SW V1, 76(V0)
4383:                
4384:                			/* 'Giving' is equivalent to incrementing a count in a counting
4385:                			semaphore. */
4386:                			( pxTCB->ulNotifiedValue )++;
BFD031E2  0010FC5E   LW V0, 16(S8)
BFD031E6  0048FC42   LW V0, 72(V0)
BFD031EA      6DA0   ADDIU V1, V0, 1
BFD031EC  0010FC5E   LW V0, 16(S8)
BFD031F0  0048F862   SW V1, 72(V0)
4387:                
4388:                			/* If the task is in the blocked state specifically to wait for a
4389:                			notification then unblock it now. */
4390:                			if( eOriginalNotifyState == eWaitingNotification )
BFD031F4  0018FC7E   LW V1, 24(S8)
BFD031F8      ED01   LI V0, 1
BFD031FA  0057B443   BNE V1, V0, 0xBFD032AC
BFD031FC  0C000057   SLL V0, S7, 1
BFD031FE      0C00   NOP
4391:                			{
4392:                				/* The task should not have been on an event list. */
4393:                				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
BFD03200  0010FC5E   LW V0, 16(S8)
BFD03204      692A   LW V0, 40(V0)
BFD03206  000940E2   BEQZC V0, 0xBFD0321C
BFD0320A  BFD141A2   LUI V0, 0xBFD1
BFD0320C  3082BFD1   LDC1 F30, 12418(S1)
BFD0320E  98103082   ADDIU A0, V0, -26608
BFD03210  30A09810   SWC1 F0, 12448(S0)
BFD03212  112930A0   ADDIU A1, ZERO, 4393
BFD03214  77E81129   ADDI T1, T1, 30696
BFD03216  4B7E77E8   JALS vAssertCalled
BFD03218      4B7E   LW K1, 120(SP)
BFD0321A      0C00   NOP
4394:                
4395:                				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
BFD0321C  805CFC5C   LW V0, -32676(GP)
BFD03220  002740A2   BNEZC V0, 0xBFD03272
4396:                				{
4397:                					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
BFD03224  0010FC5E   LW V0, 16(S8)
BFD03228      6D22   ADDIU V0, V0, 4
BFD0322A      0C82   MOVE A0, V0
BFD0322C  00C877E8   JALS uxListRemove
BFD0322E  0C0000C8   SLL A2, T0, 1
BFD03230      0C00   NOP
4398:                					prvAddTaskToReadyList( pxTCB );
BFD03232  0010FC5E   LW V0, 16(S8)
BFD03236      692B   LW V0, 44(V0)
BFD03238      ED81   LI V1, 1
BFD0323A  18100062   SLLV V1, V0, V1
BFD0323C  FC5C1810   SB ZERO, -932(S0)
BFD0323E  8040FC5C   LW V0, -32704(GP)
BFD03242      44D3   OR16 V0, V1
BFD03244  8040F85C   SW V0, -32704(GP)
BFD03248  0010FC5E   LW V0, 16(S8)
BFD0324C      692B   LW V0, 44(V0)
BFD0324E      2524   SLL V0, V0, 2
BFD03250      25A4   SLL V1, V0, 2
BFD03252      05B4   ADDU V1, V0, V1
BFD03254  BFD241A2   LUI V0, 0xBFD2
BFD03256  3042BFD2   LDC1 F30, 12354(S2)
BFD03258  806C3042   ADDIU V0, V0, -32660
BFD0325C      05A6   ADDU V1, V1, V0
BFD0325E  0010FC5E   LW V0, 16(S8)
BFD03262      6D22   ADDIU V0, V0, 4
BFD03264      0C83   MOVE A0, V1
BFD03266      0CA2   MOVE A1, V0
BFD03268  3E4A77E8   JALS vListInsertEnd
BFD0326A  0C003E4A   LH S2, 3072(T2)
BFD0326C      0C00   NOP
BFD0326E      CC0C   B 0xBFD03288
BFD03270      0C00   NOP
4399:                				}
4400:                				else
4401:                				{
4402:                					/* The delayed and ready lists cannot be accessed, so hold
4403:                					this task pending until the scheduler is resumed. */
4404:                					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
BFD03272  0010FC5E   LW V0, 16(S8)
BFD03274  6D2C0010   EXT ZERO, S0, 20, 14
BFD03276      6D2C   ADDIU V0, V0, 24
BFD03278  BFD241A3   LUI V1, 0xBFD2
BFD0327A  3083BFD2   LDC1 F30, 12419(S2)
BFD0327C  80D03083   ADDIU A0, V1, -32560
BFD03280      0CA2   MOVE A1, V0
BFD03282  3E4A77E8   JALS vListInsertEnd
BFD03284  0C003E4A   LH S2, 3072(T2)
BFD03286      0C00   NOP
4405:                				}
4406:                
4407:                				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
BFD03288  0010FC5E   LW V0, 16(S8)
BFD0328C      69AB   LW V1, 44(V0)
BFD0328E  8030FC5C   LW V0, -32720(GP)
BFD03292      692B   LW V0, 44(V0)
BFD03294  13900062   SLTU V0, V0, V1
BFD03296  40E21390   ADDI GP, S0, 16610
BFD03298  000840E2   BEQZC V0, 0xBFD032AC
4408:                				{
4409:                					/* The notified task has a priority above the currently
4410:                					executing task so a yield is required. */
4411:                					if( pxHigherPriorityTaskWoken != NULL )
BFD0329C  002CFC5E   LW V0, 44(S8)
BFD032A0  000440E2   BEQZC V0, 0xBFD032AC
4412:                					{
4413:                						*pxHigherPriorityTaskWoken = pdTRUE;
BFD032A4  002CFC5E   LW V0, 44(S8)
BFD032A8      ED81   LI V1, 1
BFD032AA      E9A0   SW V1, 0(V0)
4414:                					}
4415:                				}
4416:                				else
4417:                				{
4418:                					mtCOVERAGE_TEST_MARKER();
4419:                				}
4420:                			}
4421:                		}
4422:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
BFD032AC  0014FC9E   LW A0, 20(S8)
BFD032B0  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD032B2      4D5E   ADDIU T2, T2, -1
BFD032B4      0C00   NOP
4423:                	}
BFD032B6      0FBE   MOVE SP, S8
BFD032B8      4BE9   LW RA, 36(SP)
BFD032BA      4BC8   LW S8, 32(SP)
BFD032BC      4C15   ADDIU SP, SP, 40
BFD032BE      459F   JR16 RA
BFD032C0      0C00   NOP
4424:                
4425:                #endif /* configUSE_TASK_NOTIFICATIONS */
4426:                
4427:                /*-----------------------------------------------------------*/
4428:                
4429:                
4430:                #ifdef FREERTOS_MODULE_TEST
4431:                	#include "tasks_test_access_functions.h"
4432:                #endif
4433:                
---  c:/e/dev/freertos/workingcopy/freertos/source/queue.c  ---------------------------------------------
1:                   /*
2:                       FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  #include <stdlib.h>
71:                  #include <string.h>
72:                  
73:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
74:                  all the API functions to use the MPU wrappers.  That should only be done when
75:                  task.h is included from an application file. */
76:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
77:                  
78:                  #include "FreeRTOS.h"
79:                  #include "task.h"
80:                  #include "queue.h"
81:                  
82:                  #if ( configUSE_CO_ROUTINES == 1 )
83:                  	#include "croutine.h"
84:                  #endif
85:                  
86:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
87:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
88:                  header files above, but not in this file, in order to generate the correct
89:                  privileged Vs unprivileged linkage and placement. */
90:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
91:                  
92:                  
93:                  /* Constants used with the xRxLock and xTxLock structure members. */
94:                  #define queueUNLOCKED					( ( BaseType_t ) -1 )
95:                  #define queueLOCKED_UNMODIFIED			( ( BaseType_t ) 0 )
96:                  
97:                  /* When the Queue_t structure is used to represent a base queue its pcHead and
98:                  pcTail members are used as pointers into the queue storage area.  When the
99:                  Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
100:                 not necessary, and the pcHead pointer is set to NULL to indicate that the
101:                 pcTail pointer actually points to the mutex holder (if any).  Map alternative
102:                 names to the pcHead and pcTail structure members to ensure the readability of
103:                 the code is maintained despite this dual use of two structure members.  An
104:                 alternative implementation would be to use a union, but use of a union is
105:                 against the coding standard (although an exception to the standard has been
106:                 permitted where the dual use also significantly changes the type of the
107:                 structure member). */
108:                 #define pxMutexHolder					pcTail
109:                 #define uxQueueType						pcHead
110:                 #define queueQUEUE_IS_MUTEX				NULL
111:                 
112:                 /* Semaphores do not actually store or copy data, so have an item size of
113:                 zero. */
114:                 #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
115:                 #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
116:                 
117:                 #if( configUSE_PREEMPTION == 0 )
118:                 	/* If the cooperative scheduler is being used then a yield should not be
119:                 	performed just because a higher priority task has been woken. */
120:                 	#define queueYIELD_IF_USING_PREEMPTION()
121:                 #else
122:                 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
123:                 #endif
124:                 
125:                 /*
126:                  * Definition of the queue used by the scheduler.
127:                  * Items are queued by copy, not reference.  See the following link for the
128:                  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
129:                  */
130:                 typedef struct QueueDefinition
131:                 {
132:                 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
133:                 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
134:                 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
135:                 
136:                 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
137:                 	{
138:                 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
139:                 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
140:                 	} u;
141:                 
142:                 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
143:                 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
144:                 
145:                 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
146:                 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
147:                 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
148:                 
149:                 	volatile BaseType_t xRxLock;	/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
150:                 	volatile BaseType_t xTxLock;	/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
151:                 
152:                 	#if ( configUSE_TRACE_FACILITY == 1 )
153:                 		UBaseType_t uxQueueNumber;
154:                 		uint8_t ucQueueType;
155:                 	#endif
156:                 
157:                 	#if ( configUSE_QUEUE_SETS == 1 )
158:                 		struct QueueDefinition *pxQueueSetContainer;
159:                 	#endif
160:                 
161:                 } xQUEUE;
162:                 
163:                 /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
164:                 name below to enable the use of older kernel aware debuggers. */
165:                 typedef xQUEUE Queue_t;
166:                 
167:                 /*-----------------------------------------------------------*/
168:                 
169:                 /*
170:                  * The queue registry is just a means for kernel aware debuggers to locate
171:                  * queue structures.  It has no other purpose so is an optional component.
172:                  */
173:                 #if ( configQUEUE_REGISTRY_SIZE > 0 )
174:                 
175:                 	/* The type stored within the queue registry array.  This allows a name
176:                 	to be assigned to each queue making kernel aware debugging a little
177:                 	more user friendly. */
178:                 	typedef struct QUEUE_REGISTRY_ITEM
179:                 	{
180:                 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
181:                 		QueueHandle_t xHandle;
182:                 	} xQueueRegistryItem;
183:                 
184:                 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
185:                 	new xQueueRegistryItem name below to enable the use of older kernel aware
186:                 	debuggers. */
187:                 	typedef xQueueRegistryItem QueueRegistryItem_t;
188:                 
189:                 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
190:                 	The pcQueueName member of a structure being NULL is indicative of the
191:                 	array position being vacant. */
192:                 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
193:                 
194:                 #endif /* configQUEUE_REGISTRY_SIZE */
195:                 
196:                 /*
197:                  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
198:                  * prevent an ISR from adding or removing items to the queue, but does prevent
199:                  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
200:                  * queue is locked it will instead increment the appropriate queue lock count
201:                  * to indicate that a task may require unblocking.  When the queue in unlocked
202:                  * these lock counts are inspected, and the appropriate action taken.
203:                  */
204:                 static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
205:                 
206:                 /*
207:                  * Uses a critical section to determine if there is any data in a queue.
208:                  *
209:                  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
210:                  */
211:                 static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
212:                 
213:                 /*
214:                  * Uses a critical section to determine if there is any space in a queue.
215:                  *
216:                  * @return pdTRUE if there is no space, otherwise pdFALSE;
217:                  */
218:                 static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
219:                 
220:                 /*
221:                  * Copies an item into the queue, either at the front of the queue or the
222:                  * back of the queue.
223:                  */
224:                 static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
225:                 
226:                 /*
227:                  * Copies an item out of a queue.
228:                  */
229:                 static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
230:                 
231:                 #if ( configUSE_QUEUE_SETS == 1 )
232:                 	/*
233:                 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
234:                 	 * the queue set that the queue contains data.
235:                 	 */
236:                 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
237:                 #endif
238:                 
239:                 /*-----------------------------------------------------------*/
240:                 
241:                 /*
242:                  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
243:                  * accessing the queue event lists.
244:                  */
245:                 #define prvLockQueue( pxQueue )								\
246:                 	taskENTER_CRITICAL();									\
247:                 	{														\
248:                 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
249:                 		{													\
250:                 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
251:                 		}													\
252:                 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
253:                 		{													\
254:                 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
255:                 		}													\
256:                 	}														\
257:                 	taskEXIT_CRITICAL()
258:                 /*-----------------------------------------------------------*/
259:                 
260:                 BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
261:                 {
BFD0388C      4FF1   ADDIU SP, SP, -32
BFD0388E      CBE7   SW RA, 28(SP)
BFD03890      CBC6   SW S8, 24(SP)
BFD03892      0FDD   MOVE S8, SP
BFD03894  0020F89E   SW A0, 32(S8)
BFD03898  0024F8BE   SW A1, 36(S8)
262:                 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
BFD0389C  0020FC5E   LW V0, 32(S8)
BFD038A0  0010F85E   SW V0, 16(S8)
263:                 
264:                 	configASSERT( pxQueue );
BFD038A4  0010FC5E   LW V0, 16(S8)
BFD038A8  000940A2   BNEZC V0, 0xBFD038BE
BFD038AC  BFD141A2   LUI V0, 0xBFD1
BFD038AE  3082BFD1   LDC1 F30, 12418(S1)
BFD038B0  9E3C3082   ADDIU A0, V0, -25028
BFD038B2  30A09E3C   LWC1 F17, 12448(GP)
BFD038B4  010830A0   ADDIU A1, ZERO, 264
BFD038B8  4B7E77E8   JALS vAssertCalled
BFD038BA      4B7E   LW K1, 120(SP)
BFD038BC      0C00   NOP
265:                 
266:                 	taskENTER_CRITICAL();
BFD038BE  33B877E8   JALS vTaskEnterCritical
BFD038C0  0C0033B8   ADDIU SP, T8, 3072
BFD038C2      0C00   NOP
267:                 	{
268:                 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
BFD038C4  0010FC5E   LW V0, 16(S8)
BFD038C8      6920   LW V0, 0(V0)
BFD038CA  0010FC7E   LW V1, 16(S8)
BFD038CE      6A3F   LW A0, 60(V1)
BFD038D0  0010FC7E   LW V1, 16(S8)
BFD038D4  0040FC63   LW V1, 64(V1)
BFD038D8  1A100064   MUL V1, A0, V1
BFD038DA  05B41A10   SB S0, 1460(S0)
BFD038DC      05B4   ADDU V1, V0, V1
BFD038DE  0010FC5E   LW V0, 16(S8)
BFD038E2      E9A1   SW V1, 4(V0)
269:                 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
BFD038E4  0010FC5E   LW V0, 16(S8)
BFD038E8      E82E   SW S0, 56(V0)
270:                 		pxQueue->pcWriteTo = pxQueue->pcHead;
BFD038EA  0010FC5E   LW V0, 16(S8)
BFD038EE      69A0   LW V1, 0(V0)
BFD038F0  0010FC5E   LW V0, 16(S8)
BFD038F4      E9A2   SW V1, 8(V0)
271:                 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
BFD038F6  0010FC5E   LW V0, 16(S8)
BFD038FA      6920   LW V0, 0(V0)
BFD038FC  0010FC7E   LW V1, 16(S8)
BFD03900      69BF   LW V1, 60(V1)
BFD03902      6E3E   ADDIU A0, V1, -1
BFD03904  0010FC7E   LW V1, 16(S8)
BFD03908  0040FC63   LW V1, 64(V1)
BFD0390C  1A100064   MUL V1, A0, V1
BFD0390E  05B41A10   SB S0, 1460(S0)
BFD03910      05B4   ADDU V1, V0, V1
BFD03912  0010FC5E   LW V0, 16(S8)
BFD03916      E9A3   SW V1, 12(V0)
272:                 		pxQueue->xRxLock = queueUNLOCKED;
BFD03918  0010FC5E   LW V0, 16(S8)
BFD0391C      EDFF   LI V1, -1
BFD0391E  0044F862   SW V1, 68(V0)
273:                 		pxQueue->xTxLock = queueUNLOCKED;
BFD03922  0010FC5E   LW V0, 16(S8)
BFD03926      EDFF   LI V1, -1
BFD03928  0048F862   SW V1, 72(V0)
274:                 
275:                 		if( xNewQueue == pdFALSE )
BFD0392C  0024FC5E   LW V0, 36(S8)
BFD03930  002340A2   BNEZC V0, 0xBFD0397A
276:                 		{
277:                 			/* If there are tasks blocked waiting to read from the queue, then
278:                 			the tasks will remain blocked as after this function exits the queue
279:                 			will still be empty.  If there are tasks blocked waiting to write to
280:                 			the queue, then one should be unblocked as after this function exits
281:                 			it will be possible to write to it. */
282:                 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
BFD03934  0010FC5E   LW V0, 16(S8)
BFD03938      6924   LW V0, 16(V0)
BFD0393A  002D40E2   BEQZC V0, 0xBFD03998
283:                 			{
284:                 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
BFD0393E  0010FC5E   LW V0, 16(S8)
BFD03942      6D28   ADDIU V0, V0, 16
BFD03944      0C82   MOVE A0, V0
BFD03946  22BC77E8   JALS xTaskRemoveFromEventList
BFD03948  0C0022BC   LWC2 S5, 3072(GP)
BFD0394A      0C00   NOP
BFD0394C      0C62   MOVE V1, V0
BFD0394E      ED01   LI V0, 1
BFD03950  0022B443   BNE V1, V0, 0xBFD03998
BFD03952  0C000022   SLL AT, V0, 1
BFD03954      0C00   NOP
285:                 				{
286:                 					queueYIELD_IF_USING_PREEMPTION();
BFD03956  4E1677E8   JALS ulPortGetCP0Cause
BFD03958      4E16   ADDIU S0, S0, -5
BFD0395A      0C00   NOP
BFD0395C  0014F85E   SW V0, 20(S8)
BFD03960  0014FC5E   LW V0, 20(S8)
BFD03964  01005042   ORI V0, V0, 256
BFD03968  0014F85E   SW V0, 20(S8)
BFD0396C  0014FC9E   LW A0, 20(S8)
BFD03970  4E2677E8   JALS vPortSetCP0Cause
BFD03972      4E26   ADDIU S1, S1, 3
BFD03974      0C00   NOP
BFD03976      CC10   B 0xBFD03998
BFD03978      0C00   NOP
287:                 				}
288:                 				else
289:                 				{
290:                 					mtCOVERAGE_TEST_MARKER();
291:                 				}
292:                 			}
293:                 			else
294:                 			{
295:                 				mtCOVERAGE_TEST_MARKER();
296:                 			}
297:                 		}
298:                 		else
299:                 		{
300:                 			/* Ensure the event queues start in the correct state. */
301:                 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
BFD0397A  0010FC5E   LW V0, 16(S8)
BFD0397E      6D28   ADDIU V0, V0, 16
BFD03980      0C82   MOVE A0, V0
BFD03982  457077E8   JALS vListInitialise
BFD03984      4570   SWM16 0x3, 0(SP)
BFD03986      0C00   NOP
302:                 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
BFD03988  0010FC5E   LW V0, 16(S8)
BFD0398C  00243042   ADDIU V0, V0, 36
BFD03990      0C82   MOVE A0, V0
BFD03992  457077E8   JALS vListInitialise
BFD03994      4570   SWM16 0x3, 0(SP)
BFD03996      0C00   NOP
303:                 		}
304:                 	}
305:                 	taskEXIT_CRITICAL();
BFD03998  40AA77E8   JALS vTaskExitCritical
BFD0399A  0C0040AA   BNEZC T2, 0xBFD0519E
BFD0399C      0C00   NOP
306:                 
307:                 	/* A value is returned for calling semantic consistency with previous
308:                 	versions. */
309:                 	return pdPASS;
BFD0399E      ED01   LI V0, 1
310:                 }
BFD039A0      0FBE   MOVE SP, S8
BFD039A2      4BE7   LW RA, 28(SP)
BFD039A4      4BC6   LW S8, 24(SP)
BFD039A6      4C11   ADDIU SP, SP, 32
BFD039A8      459F   JR16 RA
BFD039AA      0C00   NOP
311:                 /*-----------------------------------------------------------*/
312:                 
313:                 QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
314:                 {
BFD03DF4      4FED   ADDIU SP, SP, -40
BFD03DF6      CBE9   SW RA, 36(SP)
BFD03DF8      CBC8   SW S8, 32(SP)
BFD03DFA      0FDD   MOVE S8, SP
BFD03DFC  0028F89E   SW A0, 40(S8)
BFD03E00  002CF8BE   SW A1, 44(S8)
BFD03E04      0C46   MOVE V0, A2
BFD03E06  0030185E   SB V0, 48(S8)
315:                 Queue_t *pxNewQueue;
316:                 size_t xQueueSizeInBytes;
317:                 QueueHandle_t xReturn = NULL;
BFD03E0A  0014F81E   SW ZERO, 20(S8)
318:                 int8_t *pcAllocatedBuffer;
319:                 
320:                 	/* Remove compiler warnings about unused parameters should
321:                 	configUSE_TRACE_FACILITY not be set to 1. */
322:                 	( void ) ucQueueType;
323:                 
324:                 	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
BFD03E0E  0028FC5E   LW V0, 40(S8)
BFD03E12  000940A2   BNEZC V0, 0xBFD03E28
BFD03E16  BFD141A2   LUI V0, 0xBFD1
BFD03E18  3082BFD1   LDC1 F30, 12418(S1)
BFD03E1A  9E3C3082   ADDIU A0, V0, -25028
BFD03E1C  30A09E3C   LWC1 F17, 12448(GP)
BFD03E1E  014430A0   ADDIU A1, ZERO, 324
BFD03E22  4B7E77E8   JALS vAssertCalled
BFD03E24      4B7E   LW K1, 120(SP)
BFD03E26      0C00   NOP
325:                 
326:                 	if( uxItemSize == ( UBaseType_t ) 0 )
BFD03E28  002CFC5E   LW V0, 44(S8)
BFD03E2C  000440A2   BNEZC V0, 0xBFD03E38
327:                 	{
328:                 		/* There is not going to be a queue storage area. */
329:                 		xQueueSizeInBytes = ( size_t ) 0;
BFD03E30  0010F81E   SW ZERO, 16(S8)
BFD03E34      CC0A   B 0xBFD03E4A
BFD03E36      0C00   NOP
330:                 	}
331:                 	else
332:                 	{
333:                 		/* The queue is one byte longer than asked for to make wrap checking
334:                 		easier/faster. */
335:                 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
BFD03E38  0028FC7E   LW V1, 40(S8)
BFD03E3C  002CFC5E   LW V0, 44(S8)
BFD03E40  12100043   MUL V0, V1, V0
BFD03E42  6D201210   ADDI S0, S0, 27936
BFD03E44      6D20   ADDIU V0, V0, 1
BFD03E46  0010F85E   SW V0, 16(S8)
336:                 	}
337:                 
338:                 	/* Allocate the new queue structure and storage area. */
339:                 	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
BFD03E4A  0010FC5E   LW V0, 16(S8)
BFD03E4E  00503042   ADDIU V0, V0, 80
BFD03E52      0C82   MOVE A0, V0
BFD03E54  111677E8   JALS pvPortMalloc
BFD03E56  0C001116   ADDI T0, S6, 3072
BFD03E58      0C00   NOP
BFD03E5A  0018F85E   SW V0, 24(S8)
340:                 
341:                 	if( pcAllocatedBuffer != NULL )
BFD03E5E  0018FC5E   LW V0, 24(S8)
BFD03E62  002F40E2   BEQZC V0, 0xBFD03EC4
342:                 	{
343:                 		pxNewQueue = ( Queue_t * ) pcAllocatedBuffer; /*lint !e826 MISRA The buffer cannot be too small because it was dimensioned by sizeof( Queue_t ) + xQueueSizeInBytes. */
BFD03E66  0018FC5E   LW V0, 24(S8)
BFD03E6A  001CF85E   SW V0, 28(S8)
344:                 
345:                 		if( uxItemSize == ( UBaseType_t ) 0 )
BFD03E6E  002CFC5E   LW V0, 44(S8)
BFD03E72  000740A2   BNEZC V0, 0xBFD03E84
346:                 		{
347:                 			/* No RAM was allocated for the queue storage area, but PC head
348:                 			cannot be set to NULL because NULL is used as a key to say the queue
349:                 			is used as a mutex.  Therefore just set pcHead to point to the queue
350:                 			as a benign value that is known to be within the memory map. */
351:                 			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
BFD03E76  001CFC7E   LW V1, 28(S8)
BFD03E7A  001CFC5E   LW V0, 28(S8)
BFD03E7E      E9A0   SW V1, 0(V0)
BFD03E80      CC08   B 0xBFD03E92
BFD03E82      0C00   NOP
352:                 		}
353:                 		else
354:                 		{
355:                 			/* Jump past the queue structure to find the location of the queue
356:                 			storage area - adding the padding bytes to get a better alignment. */
357:                 			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
BFD03E84  0018FC5E   LW V0, 24(S8)
BFD03E88  00503062   ADDIU V1, V0, 80
BFD03E8C  001CFC5E   LW V0, 28(S8)
BFD03E90      E9A0   SW V1, 0(V0)
358:                 		}
359:                 
360:                 		/* Initialise the queue members as described above where the queue type
361:                 		is defined. */
362:                 		pxNewQueue->uxLength = uxQueueLength;
BFD03E92  001CFC5E   LW V0, 28(S8)
BFD03E96  0028FC7E   LW V1, 40(S8)
BFD03E9A      E9AF   SW V1, 60(V0)
363:                 		pxNewQueue->uxItemSize = uxItemSize;
BFD03E9C  001CFC5E   LW V0, 28(S8)
BFD03EA0  002CFC7E   LW V1, 44(S8)
BFD03EA4  0040F862   SW V1, 64(V0)
364:                 		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
BFD03EA8  001CFC9E   LW A0, 28(S8)
BFD03EAC      EE81   LI A1, 1
BFD03EAE  1C4677E8   JALS xQueueGenericReset
BFD03EB0  0C001C46   LB V0, 3072(A2)
BFD03EB2      0C00   NOP
365:                 
366:                 		#if ( configUSE_TRACE_FACILITY == 1 )
367:                 		{
368:                 			pxNewQueue->ucQueueType = ucQueueType;
369:                 		}
370:                 		#endif /* configUSE_TRACE_FACILITY */
371:                 
372:                 		#if( configUSE_QUEUE_SETS == 1 )
373:                 		{
374:                 			pxNewQueue->pxQueueSetContainer = NULL;
BFD03EB4  001CFC5E   LW V0, 28(S8)
BFD03EB8  004CF802   SW ZERO, 76(V0)
375:                 		}
376:                 		#endif /* configUSE_QUEUE_SETS */
377:                 
378:                 		traceQUEUE_CREATE( pxNewQueue );
379:                 		xReturn = pxNewQueue;
BFD03EBC  001CFC5E   LW V0, 28(S8)
BFD03EC0  0014F85E   SW V0, 20(S8)
380:                 	}
381:                 	else
382:                 	{
383:                 		mtCOVERAGE_TEST_MARKER();
384:                 	}
385:                 
386:                 	configASSERT( xReturn );
BFD03EC4  0014FC5E   LW V0, 20(S8)
BFD03EC8  000940A2   BNEZC V0, 0xBFD03EDE
BFD03ECC  BFD141A2   LUI V0, 0xBFD1
BFD03ECE  3082BFD1   LDC1 F30, 12418(S1)
BFD03ED0  9E3C3082   ADDIU A0, V0, -25028
BFD03ED2  30A09E3C   LWC1 F17, 12448(GP)
BFD03ED4  018230A0   ADDIU A1, ZERO, 386
BFD03ED8  4B7E77E8   JALS vAssertCalled
BFD03EDA      4B7E   LW K1, 120(SP)
BFD03EDC      0C00   NOP
387:                 
388:                 	return xReturn;
BFD03EDE  0014FC5E   LW V0, 20(S8)
389:                 }
BFD03EE2      0FBE   MOVE SP, S8
BFD03EE4      4BE9   LW RA, 36(SP)
BFD03EE6      4BC8   LW S8, 32(SP)
BFD03EE8      4C15   ADDIU SP, SP, 40
BFD03EEA      459F   JR16 RA
BFD03EEC      0C00   NOP
390:                 /*-----------------------------------------------------------*/
391:                 
392:                 #if ( configUSE_MUTEXES == 1 )
393:                 
394:                 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
395:                 	{
BFD05958      4FF1   ADDIU SP, SP, -32
BFD0595A      CBE7   SW RA, 28(SP)
BFD0595C      CBC6   SW S8, 24(SP)
BFD0595E      0FDD   MOVE S8, SP
BFD05960      0C44   MOVE V0, A0
BFD05962  0020185E   SB V0, 32(S8)
BFD05964  EE500020   AND SP, ZERO, AT
396:                 	Queue_t *pxNewQueue;
397:                 
398:                 		/* Prevent compiler warnings about unused parameters if
399:                 		configUSE_TRACE_FACILITY does not equal 1. */
400:                 		( void ) ucQueueType;
401:                 
402:                 		/* Allocate the new queue structure. */
403:                 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
BFD05966      EE50   LI A0, 80
BFD05968  111677E8   JALS pvPortMalloc
BFD0596A  0C001116   ADDI T0, S6, 3072
BFD0596C      0C00   NOP
BFD0596E  0010F85E   SW V0, 16(S8)
404:                 		if( pxNewQueue != NULL )
BFD05972  0010FC5E   LW V0, 16(S8)
BFD05976  003C40E2   BEQZC V0, 0xBFD059F2
405:                 		{
406:                 			/* Information required for priority inheritance. */
407:                 			pxNewQueue->pxMutexHolder = NULL;
BFD0597A  0010FC5E   LW V0, 16(S8)
BFD0597E      E821   SW S0, 4(V0)
408:                 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
BFD05980  0010FC5E   LW V0, 16(S8)
BFD05984      E820   SW S0, 0(V0)
409:                 
410:                 			/* Queues used as a mutex no data is actually copied into or out
411:                 			of the queue. */
412:                 			pxNewQueue->pcWriteTo = NULL;
BFD05986  0010FC5E   LW V0, 16(S8)
BFD0598A      E822   SW S0, 8(V0)
413:                 			pxNewQueue->u.pcReadFrom = NULL;
BFD0598C  0010FC5E   LW V0, 16(S8)
BFD05990      E823   SW S0, 12(V0)
414:                 
415:                 			/* Each mutex has a length of 1 (like a binary semaphore) and
416:                 			an item size of 0 as nothing is actually copied into or out
417:                 			of the mutex. */
418:                 			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
BFD05992  0010FC5E   LW V0, 16(S8)
BFD05996      E82E   SW S0, 56(V0)
419:                 			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
BFD05998  0010FC5E   LW V0, 16(S8)
BFD0599C      ED81   LI V1, 1
BFD0599E      E9AF   SW V1, 60(V0)
420:                 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
BFD059A0  0010FC5E   LW V0, 16(S8)
BFD059A4  0040F802   SW ZERO, 64(V0)
421:                 			pxNewQueue->xRxLock = queueUNLOCKED;
BFD059A8  0010FC5E   LW V0, 16(S8)
BFD059AC      EDFF   LI V1, -1
BFD059AE  0044F862   SW V1, 68(V0)
422:                 			pxNewQueue->xTxLock = queueUNLOCKED;
BFD059B2  0010FC5E   LW V0, 16(S8)
BFD059B6      EDFF   LI V1, -1
BFD059B8  0048F862   SW V1, 72(V0)
423:                 
424:                 			#if ( configUSE_TRACE_FACILITY == 1 )
425:                 			{
426:                 				pxNewQueue->ucQueueType = ucQueueType;
427:                 			}
428:                 			#endif
429:                 
430:                 			#if ( configUSE_QUEUE_SETS == 1 )
431:                 			{
432:                 				pxNewQueue->pxQueueSetContainer = NULL;
BFD059BC  0010FC5E   LW V0, 16(S8)
BFD059C0  004CF802   SW ZERO, 76(V0)
433:                 			}
434:                 			#endif
435:                 
436:                 			/* Ensure the event queues start with the correct state. */
437:                 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
BFD059C4  0010FC5E   LW V0, 16(S8)
BFD059C8      6D28   ADDIU V0, V0, 16
BFD059CA      0C82   MOVE A0, V0
BFD059CC  457077E8   JALS vListInitialise
BFD059CE      4570   SWM16 0x3, 0(SP)
BFD059D0      0C00   NOP
438:                 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
BFD059D2  0010FC5E   LW V0, 16(S8)
BFD059D6  00243042   ADDIU V0, V0, 36
BFD059DA      0C82   MOVE A0, V0
BFD059DC  457077E8   JALS vListInitialise
BFD059DE      4570   SWM16 0x3, 0(SP)
BFD059E0      0C00   NOP
439:                 
440:                 			traceCREATE_MUTEX( pxNewQueue );
441:                 
442:                 			/* Start with the semaphore in the expected state. */
443:                 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
BFD059E2  0010FC9E   LW A0, 16(S8)
BFD059E6      0CA0   MOVE A1, ZERO
BFD059E8      0CC0   MOVE A2, ZERO
BFD059EA      0CE0   MOVE A3, ZERO
BFD059EC  06A277E8   JALS xQueueGenericSend
BFD059EE      06A2   ADDU A1, S1, V0
BFD059F0      0C00   NOP
444:                 		}
445:                 		else
446:                 		{
447:                 			traceCREATE_MUTEX_FAILED();
448:                 		}
449:                 
450:                 		configASSERT( pxNewQueue );
BFD059F2  0010FC5E   LW V0, 16(S8)
BFD059F6  000940A2   BNEZC V0, 0xBFD05A0C
BFD059FA  BFD141A2   LUI V0, 0xBFD1
BFD059FC  3082BFD1   LDC1 F30, 12418(S1)
BFD059FE  9E3C3082   ADDIU A0, V0, -25028
BFD05A00  30A09E3C   LWC1 F17, 12448(GP)
BFD05A02  01C230A0   ADDIU A1, ZERO, 450
BFD05A06  4B7E77E8   JALS vAssertCalled
BFD05A08      4B7E   LW K1, 120(SP)
BFD05A0A      0C00   NOP
451:                 		return pxNewQueue;
BFD05A0C  0010FC5E   LW V0, 16(S8)
452:                 	}
BFD05A10      0FBE   MOVE SP, S8
BFD05A12      4BE7   LW RA, 28(SP)
BFD05A14      4BC6   LW S8, 24(SP)
BFD05A16      4C11   ADDIU SP, SP, 32
BFD05A18      459F   JR16 RA
BFD05A1A      0C00   NOP
453:                 
454:                 #endif /* configUSE_MUTEXES */
455:                 /*-----------------------------------------------------------*/
456:                 
457:                 #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
458:                 
459:                 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
460:                 	{
461:                 	void *pxReturn;
462:                 
463:                 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
464:                 		be called directly.  Note:  This is a good way of determining if the
465:                 		calling task is the mutex holder, but not a good way of determining the
466:                 		identity of the mutex holder, as the holder may change between the
467:                 		following critical section exiting and the function returning. */
468:                 		taskENTER_CRITICAL();
469:                 		{
470:                 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
471:                 			{
472:                 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
473:                 			}
474:                 			else
475:                 			{
476:                 				pxReturn = NULL;
477:                 			}
478:                 		}
479:                 		taskEXIT_CRITICAL();
480:                 
481:                 		return pxReturn;
482:                 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
483:                 
484:                 #endif
485:                 /*-----------------------------------------------------------*/
486:                 
487:                 #if ( configUSE_RECURSIVE_MUTEXES == 1 )
488:                 
489:                 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
490:                 	{
BFD06AD0      4FED   ADDIU SP, SP, -40
BFD06AD2      CBE9   SW RA, 36(SP)
BFD06AD4      CBC8   SW S8, 32(SP)
BFD06AD6      CA07   SW S0, 28(SP)
BFD06AD8      0FDD   MOVE S8, SP
BFD06ADA  0028F89E   SW A0, 40(S8)
491:                 	BaseType_t xReturn;
492:                 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
BFD06ADE  0028FC5E   LW V0, 40(S8)
BFD06AE2  0014F85E   SW V0, 20(S8)
493:                 
494:                 		configASSERT( pxMutex );
BFD06AE6  0014FC5E   LW V0, 20(S8)
BFD06AEA  000940A2   BNEZC V0, 0xBFD06B00
BFD06AEE  BFD141A2   LUI V0, 0xBFD1
BFD06AF0  3082BFD1   LDC1 F30, 12418(S1)
BFD06AF2  9E3C3082   ADDIU A0, V0, -25028
BFD06AF4  30A09E3C   LWC1 F17, 12448(GP)
BFD06AF6  01EE30A0   ADDIU A1, ZERO, 494
BFD06AFA  4B7E77E8   JALS vAssertCalled
BFD06AFC      4B7E   LW K1, 120(SP)
BFD06AFE      0C00   NOP
495:                 
496:                 		/* If this is the task that holds the mutex then pxMutexHolder will not
497:                 		change outside of this task.  If this task does not hold the mutex then
498:                 		pxMutexHolder can never coincidentally equal the tasks handle, and as
499:                 		this is the only condition we are interested in it does not matter if
500:                 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
501:                 		mutual exclusion is required to test the pxMutexHolder variable. */
502:                 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
BFD06B00  0014FC5E   LW V0, 20(S8)
BFD06B04      6821   LW S0, 4(V0)
BFD06B06  4F0277E8   JALS xTaskGetCurrentTaskHandle
BFD06B08      4F02   ADDIU T8, T8, 1
BFD06B0A      0C00   NOP
BFD06B0C  001AB450   BNE S0, V0, 0xBFD06B44
BFD06B0E  0C00001A   SLL ZERO, K0, 1
BFD06B10      0C00   NOP
503:                 		{
504:                 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
505:                 
506:                 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
507:                 			the task handle, therefore no underflow check is required.  Also,
508:                 			uxRecursiveCallCount is only modified by the mutex holder, and as
509:                 			there can only be one, no mutual exclusion is required to modify the
510:                 			uxRecursiveCallCount member. */
511:                 			( pxMutex->u.uxRecursiveCallCount )--;
BFD06B12  0014FC5E   LW V0, 20(S8)
BFD06B16      6923   LW V0, 12(V0)
BFD06B18      6DAE   ADDIU V1, V0, -1
BFD06B1A  0014FC5E   LW V0, 20(S8)
BFD06B1E      E9A3   SW V1, 12(V0)
512:                 
513:                 			/* Have we unwound the call count? */
514:                 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
BFD06B20  0014FC5E   LW V0, 20(S8)
BFD06B24      6923   LW V0, 12(V0)
BFD06B26  000840A2   BNEZC V0, 0xBFD06B3A
515:                 			{
516:                 				/* Return the mutex.  This will automatically unblock any other
517:                 				task that might be waiting to access the mutex. */
518:                 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
BFD06B2A  0014FC9E   LW A0, 20(S8)
BFD06B2E      0CA0   MOVE A1, ZERO
BFD06B30      0CC0   MOVE A2, ZERO
BFD06B32      0CE0   MOVE A3, ZERO
BFD06B34  06A277E8   JALS xQueueGenericSend
BFD06B36      06A2   ADDU A1, S1, V0
BFD06B38      0C00   NOP
519:                 			}
520:                 			else
521:                 			{
522:                 				mtCOVERAGE_TEST_MARKER();
523:                 			}
524:                 
525:                 			xReturn = pdPASS;
BFD06B3A      ED01   LI V0, 1
BFD06B3C  0010F85E   SW V0, 16(S8)
BFD06B40      CC03   B 0xBFD06B48
BFD06B42      0C00   NOP
526:                 		}
527:                 		else
528:                 		{
529:                 			/* The mutex cannot be given because the calling task is not the
530:                 			holder. */
531:                 			xReturn = pdFAIL;
BFD06B44  0010F81E   SW ZERO, 16(S8)
532:                 
533:                 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
534:                 		}
535:                 
536:                 		return xReturn;
BFD06B48  0010FC5E   LW V0, 16(S8)
537:                 	}
BFD06B4C      0FBE   MOVE SP, S8
BFD06B4E      4BE9   LW RA, 36(SP)
BFD06B50      4BC8   LW S8, 32(SP)
BFD06B52      4A07   LW S0, 28(SP)
BFD06B54      4C15   ADDIU SP, SP, 40
BFD06B56      459F   JR16 RA
BFD06B58      0C00   NOP
538:                 
539:                 #endif /* configUSE_RECURSIVE_MUTEXES */
540:                 /*-----------------------------------------------------------*/
541:                 
542:                 #if ( configUSE_RECURSIVE_MUTEXES == 1 )
543:                 
544:                 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
545:                 	{
BFD063CC      4FED   ADDIU SP, SP, -40
BFD063CE      CBE9   SW RA, 36(SP)
BFD063D0      CBC8   SW S8, 32(SP)
BFD063D2      CA07   SW S0, 28(SP)
BFD063D4      0FDD   MOVE S8, SP
BFD063D6  0028F89E   SW A0, 40(S8)
BFD063DA  002CF8BE   SW A1, 44(S8)
546:                 	BaseType_t xReturn;
547:                 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
BFD063DE  0028FC5E   LW V0, 40(S8)
BFD063E2  0014F85E   SW V0, 20(S8)
548:                 
549:                 		configASSERT( pxMutex );
BFD063E6  0014FC5E   LW V0, 20(S8)
BFD063EA  000940A2   BNEZC V0, 0xBFD06400
BFD063EE  BFD141A2   LUI V0, 0xBFD1
BFD063F0  3082BFD1   LDC1 F30, 12418(S1)
BFD063F2  9E3C3082   ADDIU A0, V0, -25028
BFD063F4  30A09E3C   LWC1 F17, 12448(GP)
BFD063F6  022530A0   ADDIU A1, ZERO, 549
BFD063FA  4B7E77E8   JALS vAssertCalled
BFD063FC      4B7E   LW K1, 120(SP)
BFD063FE      0C00   NOP
550:                 
551:                 		/* Comments regarding mutual exclusion as per those within
552:                 		xQueueGiveMutexRecursive(). */
553:                 
554:                 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
555:                 
556:                 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
BFD06400  0014FC5E   LW V0, 20(S8)
BFD06404      6821   LW S0, 4(V0)
BFD06406  4F0277E8   JALS xTaskGetCurrentTaskHandle
BFD06408      4F02   ADDIU T8, T8, 1
BFD0640A      0C00   NOP
BFD0640C  000DB450   BNE S0, V0, 0xBFD0642A
BFD0640E  0C00000D   SLL ZERO, T5, 1
BFD06410      0C00   NOP
557:                 		{
558:                 			( pxMutex->u.uxRecursiveCallCount )++;
BFD06412  0014FC5E   LW V0, 20(S8)
BFD06416      6923   LW V0, 12(V0)
BFD06418      6DA0   ADDIU V1, V0, 1
BFD0641A  0014FC5E   LW V0, 20(S8)
BFD0641E      E9A3   SW V1, 12(V0)
559:                 			xReturn = pdPASS;
BFD06420      ED01   LI V0, 1
BFD06422  0010F85E   SW V0, 16(S8)
BFD06426      CC19   B 0xBFD0645A
BFD06428      0C00   NOP
560:                 		}
561:                 		else
562:                 		{
563:                 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
BFD0642A  0014FC9E   LW A0, 20(S8)
BFD0642E      0CA0   MOVE A1, ZERO
BFD06430  002CFCDE   LW A2, 44(S8)
BFD06434      0CE0   MOVE A3, ZERO
BFD06436  081E77E8   JALS xQueueGenericReceive
BFD06438      081E   LBU S0, 14(S1)
BFD0643A      0C00   NOP
BFD0643C  0010F85E   SW V0, 16(S8)
564:                 
565:                 			/* pdPASS will only be returned if the mutex was successfully
566:                 			obtained.  The calling task may have entered the Blocked state
567:                 			before reaching here. */
568:                 			if( xReturn == pdPASS )
BFD06440  0010FC7E   LW V1, 16(S8)
BFD06444      ED01   LI V0, 1
BFD06446  0008B443   BNE V1, V0, 0xBFD0645A
BFD06448  0C000008   SLL ZERO, T0, 1
BFD0644A      0C00   NOP
569:                 			{
570:                 				( pxMutex->u.uxRecursiveCallCount )++;
BFD0644C  0014FC5E   LW V0, 20(S8)
BFD06450      6923   LW V0, 12(V0)
BFD06452      6DA0   ADDIU V1, V0, 1
BFD06454  0014FC5E   LW V0, 20(S8)
BFD06458      E9A3   SW V1, 12(V0)
571:                 			}
572:                 			else
573:                 			{
574:                 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
575:                 			}
576:                 		}
577:                 
578:                 		return xReturn;
BFD0645A  0010FC5E   LW V0, 16(S8)
579:                 	}
BFD0645E      0FBE   MOVE SP, S8
BFD06460      4BE9   LW RA, 36(SP)
BFD06462      4BC8   LW S8, 32(SP)
BFD06464      4A07   LW S0, 28(SP)
BFD06466      4C15   ADDIU SP, SP, 40
BFD06468      459F   JR16 RA
BFD0646A      0C00   NOP
580:                 
581:                 #endif /* configUSE_RECURSIVE_MUTEXES */
582:                 /*-----------------------------------------------------------*/
583:                 
584:                 #if ( configUSE_COUNTING_SEMAPHORES == 1 )
585:                 
586:                 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
587:                 	{
BFD0650C      4FF1   ADDIU SP, SP, -32
BFD0650E      CBE7   SW RA, 28(SP)
BFD06510      CBC6   SW S8, 24(SP)
BFD06512      0FDD   MOVE S8, SP
BFD06514  0020F89E   SW A0, 32(S8)
BFD06518  0024F8BE   SW A1, 36(S8)
588:                 	QueueHandle_t xHandle;
589:                 
590:                 		configASSERT( uxMaxCount != 0 );
BFD0651C  0020FC5E   LW V0, 32(S8)
BFD06520  000940A2   BNEZC V0, 0xBFD06536
BFD06524  BFD141A2   LUI V0, 0xBFD1
BFD06526  3082BFD1   LDC1 F30, 12418(S1)
BFD06528  9E3C3082   ADDIU A0, V0, -25028
BFD0652A  30A09E3C   LWC1 F17, 12448(GP)
BFD0652C  024E30A0   ADDIU A1, ZERO, 590
BFD06530  4B7E77E8   JALS vAssertCalled
BFD06532      4B7E   LW K1, 120(SP)
BFD06534      0C00   NOP
591:                 		configASSERT( uxInitialCount <= uxMaxCount );
BFD06536  0024FC7E   LW V1, 36(S8)
BFD0653A  0020FC5E   LW V0, 32(S8)
BFD0653E  13900062   SLTU V0, V0, V1
BFD06540  40E21390   ADDI GP, S0, 16610
BFD06542  000940E2   BEQZC V0, 0xBFD06558
BFD06546  BFD141A2   LUI V0, 0xBFD1
BFD06548  3082BFD1   LDC1 F30, 12418(S1)
BFD0654A  9E3C3082   ADDIU A0, V0, -25028
BFD0654C  30A09E3C   LWC1 F17, 12448(GP)
BFD0654E  024F30A0   ADDIU A1, ZERO, 591
BFD06552  4B7E77E8   JALS vAssertCalled
BFD06554      4B7E   LW K1, 120(SP)
BFD06556      0C00   NOP
592:                 
593:                 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
BFD06558  0020FC9E   LW A0, 32(S8)
BFD0655C      0CA0   MOVE A1, ZERO
BFD0655E      EF02   LI A2, 2
BFD06560  1EFA77E8   JALS xQueueGenericCreate
BFD06562  0C001EFA   LB S7, 3072(K0)
BFD06564      0C00   NOP
BFD06566  0010F85E   SW V0, 16(S8)
594:                 
595:                 		if( xHandle != NULL )
BFD0656A  0010FC5E   LW V0, 16(S8)
BFD0656E  000540E2   BEQZC V0, 0xBFD0657C
596:                 		{
597:                 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
BFD06572  0010FC5E   LW V0, 16(S8)
BFD06576  0024FC7E   LW V1, 36(S8)
BFD0657A      E9AE   SW V1, 56(V0)
598:                 
599:                 			traceCREATE_COUNTING_SEMAPHORE();
600:                 		}
601:                 		else
602:                 		{
603:                 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
604:                 		}
605:                 
606:                 		configASSERT( xHandle );
BFD0657C  0010FC5E   LW V0, 16(S8)
BFD06580  000940A2   BNEZC V0, 0xBFD06596
BFD06584  BFD141A2   LUI V0, 0xBFD1
BFD06586  3082BFD1   LDC1 F30, 12418(S1)
BFD06588  9E3C3082   ADDIU A0, V0, -25028
BFD0658A  30A09E3C   LWC1 F17, 12448(GP)
BFD0658C  025E30A0   ADDIU A1, ZERO, 606
BFD06590  4B7E77E8   JALS vAssertCalled
BFD06592      4B7E   LW K1, 120(SP)
BFD06594      0C00   NOP
607:                 		return xHandle;
BFD06596  0010FC5E   LW V0, 16(S8)
608:                 	}
BFD0659A      0FBE   MOVE SP, S8
BFD0659C      4BE7   LW RA, 28(SP)
BFD0659E      4BC6   LW S8, 24(SP)
BFD065A0      4C11   ADDIU SP, SP, 32
BFD065A2      459F   JR16 RA
BFD065A4      0C00   NOP
609:                 
610:                 #endif /* configUSE_COUNTING_SEMAPHORES */
611:                 /*-----------------------------------------------------------*/
612:                 
613:                 BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
614:                 {
BFD00D44      4FE1   ADDIU SP, SP, -64
BFD00D46      CBEF   SW RA, 60(SP)
BFD00D48      CBCE   SW S8, 56(SP)
BFD00D4A      0FDD   MOVE S8, SP
BFD00D4C  0040F89E   SW A0, 64(S8)
BFD00D50  0044F8BE   SW A1, 68(S8)
BFD00D54  0048F8DE   SW A2, 72(S8)
BFD00D58  004CF8FE   SW A3, 76(S8)
615:                 BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
BFD00D5C  0010F81E   SW ZERO, 16(S8)
616:                 TimeOut_t xTimeOut;
617:                 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
BFD00D60  0040FC5E   LW V0, 64(S8)
BFD00D64  0014F85E   SW V0, 20(S8)
618:                 
619:                 	configASSERT( pxQueue );
BFD00D68  0014FC5E   LW V0, 20(S8)
BFD00D6C  000940A2   BNEZC V0, 0xBFD00D82
BFD00D70  BFD141A2   LUI V0, 0xBFD1
BFD00D72  3082BFD1   LDC1 F30, 12418(S1)
BFD00D74  9E3C3082   ADDIU A0, V0, -25028
BFD00D76  30A09E3C   LWC1 F17, 12448(GP)
BFD00D78  026B30A0   ADDIU A1, ZERO, 619
BFD00D7C  4B7E77E8   JALS vAssertCalled
BFD00D7E      4B7E   LW K1, 120(SP)
BFD00D80      0C00   NOP
620:                 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
BFD00D82  0044FC5E   LW V0, 68(S8)
BFD00D86  000640A2   BNEZC V0, 0xBFD00D96
BFD00D8A  0014FC5E   LW V0, 20(S8)
BFD00D8E  0040FC42   LW V0, 64(V0)
BFD00D92  000340A2   BNEZC V0, 0xBFD00D9C
BFD00D96      ED01   LI V0, 1
BFD00D98      CC02   B 0xBFD00D9E
BFD00D9A      0C00   NOP
BFD00D9C      0C40   MOVE V0, ZERO
BFD00D9E  000940A2   BNEZC V0, 0xBFD00DB4
BFD00DA2  BFD141A2   LUI V0, 0xBFD1
BFD00DA4  3082BFD1   LDC1 F30, 12418(S1)
BFD00DA6  9E3C3082   ADDIU A0, V0, -25028
BFD00DA8  30A09E3C   LWC1 F17, 12448(GP)
BFD00DAA  026C30A0   ADDIU A1, ZERO, 620
BFD00DAE  4B7E77E8   JALS vAssertCalled
BFD00DB0      4B7E   LW K1, 120(SP)
BFD00DB2      0C00   NOP
621:                 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
BFD00DB4  004CFC7E   LW V1, 76(S8)
BFD00DB8      ED02   LI V0, 2
BFD00DBA  0008B443   BNE V1, V0, 0xBFD00DCE
BFD00DBC  0C000008   SLL ZERO, T0, 1
BFD00DBE      0C00   NOP
BFD00DC0  0014FC5E   LW V0, 20(S8)
BFD00DC4      69AF   LW V1, 60(V0)
BFD00DC6      ED01   LI V0, 1
BFD00DC8  0004B443   BNE V1, V0, 0xBFD00DD4
BFD00DCA  0C000004   SLL ZERO, A0, 1
BFD00DCC      0C00   NOP
BFD00DCE      ED01   LI V0, 1
BFD00DD0      CC02   B 0xBFD00DD6
BFD00DD2      0C00   NOP
BFD00DD4      0C40   MOVE V0, ZERO
BFD00DD6  000940A2   BNEZC V0, 0xBFD00DEC
BFD00DDA  BFD141A2   LUI V0, 0xBFD1
BFD00DDC  3082BFD1   LDC1 F30, 12418(S1)
BFD00DDE  9E3C3082   ADDIU A0, V0, -25028
BFD00DE0  30A09E3C   LWC1 F17, 12448(GP)
BFD00DE2  026D30A0   ADDIU A1, ZERO, 621
BFD00DE6  4B7E77E8   JALS vAssertCalled
BFD00DE8      4B7E   LW K1, 120(SP)
BFD00DEA      0C00   NOP
622:                 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
623:                 	{
624:                 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
BFD00DEC  4A8E77E8   JALS xTaskGetSchedulerState
BFD00DEE      4A8E   LW S4, 56(SP)
BFD00DF0      0C00   NOP
BFD00DF2  000440A2   BNEZC V0, 0xBFD00DFE
BFD00DF6  0048FC5E   LW V0, 72(S8)
BFD00DFA  000340A2   BNEZC V0, 0xBFD00E04
BFD00DFE      ED01   LI V0, 1
BFD00E00      CC02   B 0xBFD00E06
BFD00E02      0C00   NOP
BFD00E04      0C40   MOVE V0, ZERO
BFD00E06  000C40A2   BNEZC V0, 0xBFD00E22
BFD00E0A  BFD141A2   LUI V0, 0xBFD1
BFD00E0C  3082BFD1   LDC1 F30, 12418(S1)
BFD00E0E  9E3C3082   ADDIU A0, V0, -25028
BFD00E10  30A09E3C   LWC1 F17, 12448(GP)
BFD00E12  027030A0   ADDIU A1, ZERO, 624
BFD00E16  4B7E77E8   JALS vAssertCalled
BFD00E18      4B7E   LW K1, 120(SP)
BFD00E1A      0C00   NOP
BFD00E1C      CC02   B 0xBFD00E22
BFD00E1E      0C00   NOP
625:                 	}
626:                 	#endif
627:                 
628:                 
629:                 	/* This function relaxes the coding standard somewhat to allow return
630:                 	statements within the function itself.  This is done in the interest
631:                 	of execution time efficiency. */
632:                 	for( ;; )
633:                 	{
634:                 		taskENTER_CRITICAL();
BFD00E22  33B877E8   JALS vTaskEnterCritical
BFD00E24  0C0033B8   ADDIU SP, T8, 3072
BFD00E26      0C00   NOP
635:                 		{
636:                 			/* Is there room on the queue now?  The running task must be the
637:                 			highest priority task wanting to access the queue.  If the head item
638:                 			in the queue is to be overwritten then it does not matter if the
639:                 			queue is full. */
640:                 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
BFD00E28  0014FC5E   LW V0, 20(S8)
BFD00E2C      69AE   LW V1, 56(V0)
BFD00E2E  0014FC5E   LW V0, 20(S8)
BFD00E32      692F   LW V0, 60(V0)
BFD00E34  13900043   SLTU V0, V1, V0
BFD00E36  40A21390   ADDI GP, S0, 16546
BFD00E38  000640A2   BNEZC V0, 0xBFD00E48
BFD00E3C  004CFC7E   LW V1, 76(S8)
BFD00E40      ED02   LI V0, 2
BFD00E42  006EB443   BNE V1, V0, 0xBFD00F22
BFD00E44  0C00006E   SLL V1, T6, 1
BFD00E46      0C00   NOP
641:                 			{
642:                 				traceQUEUE_SEND( pxQueue );
643:                 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
BFD00E48  0014FC9E   LW A0, 20(S8)
BFD00E4C  0044FCBE   LW A1, 68(S8)
BFD00E50  004CFCDE   LW A2, 76(S8)
BFD00E54  14E677E8   JALS prvCopyDataToQueue
BFD00E56  0C0014E6   LBU A3, 3072(A2)
BFD00E58      0C00   NOP
BFD00E5A  001CF85E   SW V0, 28(S8)
644:                 
645:                 				#if ( configUSE_QUEUE_SETS == 1 )
646:                 				{
647:                 					if( pxQueue->pxQueueSetContainer != NULL )
BFD00E5E  0014FC5E   LW V0, 20(S8)
BFD00E62  004CFC42   LW V0, 76(V0)
BFD00E66  001E40E2   BEQZC V0, 0xBFD00EA6
648:                 					{
649:                 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
BFD00E6A  0014FC9E   LW A0, 20(S8)
BFD00E6E  004CFCBE   LW A1, 76(S8)
BFD00E72  21D877E8   JALS prvNotifyQueueSetContainer
BFD00E74  0C0021D8   LWC2 T6, 3072(T8)
BFD00E76      0C00   NOP
BFD00E78      0C62   MOVE V1, V0
BFD00E7A      ED01   LI V0, 1
BFD00E7C  004BB443   BNE V1, V0, 0xBFD00F16
BFD00E7E  0C00004B   SLL V0, T3, 1
BFD00E80      0C00   NOP
650:                 						{
651:                 							/* The queue is a member of a queue set, and posting
652:                 							to the queue set caused a higher priority task to
653:                 							unblock. A context switch is required. */
654:                 							queueYIELD_IF_USING_PREEMPTION();
BFD00E82  4E1677E8   JALS ulPortGetCP0Cause
BFD00E84      4E16   ADDIU S0, S0, -5
BFD00E86      0C00   NOP
BFD00E88  0020F85E   SW V0, 32(S8)
BFD00E8C  0020FC5E   LW V0, 32(S8)
BFD00E90  01005042   ORI V0, V0, 256
BFD00E94  0020F85E   SW V0, 32(S8)
BFD00E98  0020FC9E   LW A0, 32(S8)
BFD00E9C  4E2677E8   JALS vPortSetCP0Cause
BFD00E9E      4E26   ADDIU S1, S1, 3
BFD00EA0      0C00   NOP
BFD00EA2      CC39   B 0xBFD00F16
BFD00EA4      0C00   NOP
655:                 						}
656:                 						else
657:                 						{
658:                 							mtCOVERAGE_TEST_MARKER();
659:                 						}
660:                 					}
661:                 					else
662:                 					{
663:                 						/* If there was a task waiting for data to arrive on the
664:                 						queue then unblock it now. */
665:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
BFD00EA6  0014FC5E   LW V0, 20(S8)
BFD00EAA      6929   LW V0, 36(V0)
BFD00EAC  001F40E2   BEQZC V0, 0xBFD00EEE
666:                 						{
667:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
BFD00EB0  0014FC5E   LW V0, 20(S8)
BFD00EB4  00243042   ADDIU V0, V0, 36
BFD00EB8      0C82   MOVE A0, V0
BFD00EBA  22BC77E8   JALS xTaskRemoveFromEventList
BFD00EBC  0C0022BC   LWC2 S5, 3072(GP)
BFD00EBE      0C00   NOP
BFD00EC0      0C62   MOVE V1, V0
BFD00EC2      ED01   LI V0, 1
BFD00EC4  0027B443   BNE V1, V0, 0xBFD00F16
BFD00EC6  0C000027   SLL AT, A3, 1
BFD00EC8      0C00   NOP
668:                 							{
669:                 								/* The unblocked task has a priority higher than
670:                 								our own so yield immediately.  Yes it is ok to
671:                 								do this from within the critical section - the
672:                 								kernel takes care of that. */
673:                 								queueYIELD_IF_USING_PREEMPTION();
BFD00ECA  4E1677E8   JALS ulPortGetCP0Cause
BFD00ECC      4E16   ADDIU S0, S0, -5
BFD00ECE      0C00   NOP
BFD00ED0  0024F85E   SW V0, 36(S8)
BFD00ED4  0024FC5E   LW V0, 36(S8)
BFD00ED8  01005042   ORI V0, V0, 256
BFD00EDC  0024F85E   SW V0, 36(S8)
BFD00EE0  0024FC9E   LW A0, 36(S8)
BFD00EE4  4E2677E8   JALS vPortSetCP0Cause
BFD00EE6      4E26   ADDIU S1, S1, 3
BFD00EE8      0C00   NOP
BFD00EEA      CC15   B 0xBFD00F16
BFD00EEC      0C00   NOP
674:                 							}
675:                 							else
676:                 							{
677:                 								mtCOVERAGE_TEST_MARKER();
678:                 							}
679:                 						}
680:                 						else if( xYieldRequired != pdFALSE )
BFD00EEE  001CFC5E   LW V0, 28(S8)
BFD00EF2  001040E2   BEQZC V0, 0xBFD00F16
681:                 						{
682:                 							/* This path is a special case that will only get
683:                 							executed if the task was holding multiple mutexes
684:                 							and the mutexes were given back in an order that is
685:                 							different to that in which they were taken. */
686:                 							queueYIELD_IF_USING_PREEMPTION();
BFD00EF6  4E1677E8   JALS ulPortGetCP0Cause
BFD00EF8      4E16   ADDIU S0, S0, -5
BFD00EFA      0C00   NOP
BFD00EFC  0028F85E   SW V0, 40(S8)
BFD00F00  0028FC5E   LW V0, 40(S8)
BFD00F04  01005042   ORI V0, V0, 256
BFD00F08  0028F85E   SW V0, 40(S8)
BFD00F0C  0028FC9E   LW A0, 40(S8)
BFD00F10  4E2677E8   JALS vPortSetCP0Cause
BFD00F12      4E26   ADDIU S1, S1, 3
BFD00F14      0C00   NOP
687:                 						}
688:                 						else
689:                 						{
690:                 							mtCOVERAGE_TEST_MARKER();
691:                 						}
692:                 					}
693:                 				}
694:                 				#else /* configUSE_QUEUE_SETS */
695:                 				{
696:                 					/* If there was a task waiting for data to arrive on the
697:                 					queue then unblock it now. */
698:                 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
699:                 					{
700:                 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
701:                 						{
702:                 							/* The unblocked task has a priority higher than
703:                 							our own so yield immediately.  Yes it is ok to do
704:                 							this from within the critical section - the kernel
705:                 							takes care of that. */
706:                 							queueYIELD_IF_USING_PREEMPTION();
707:                 						}
708:                 						else
709:                 						{
710:                 							mtCOVERAGE_TEST_MARKER();
711:                 						}
712:                 					}
713:                 					else if( xYieldRequired != pdFALSE )
714:                 					{
715:                 						/* This path is a special case that will only get
716:                 						executed if the task was holding multiple mutexes and
717:                 						the mutexes were given back in an order that is
718:                 						different to that in which they were taken. */
719:                 						queueYIELD_IF_USING_PREEMPTION();
720:                 					}
721:                 					else
722:                 					{
723:                 						mtCOVERAGE_TEST_MARKER();
724:                 					}
725:                 				}
726:                 				#endif /* configUSE_QUEUE_SETS */
727:                 
728:                 				taskEXIT_CRITICAL();
BFD00F16  40AA77E8   JALS vTaskExitCritical
BFD00F18  0C0040AA   BNEZC T2, 0xBFD0271C
BFD00F1A      0C00   NOP
729:                 				return pdPASS;
BFD00F1C      ED01   LI V0, 1
BFD00F1E      CC87   B 0xBFD0102E
BFD00F20      0C00   NOP
730:                 			}
731:                 			else
732:                 			{
733:                 				if( xTicksToWait == ( TickType_t ) 0 )
BFD00F22  0048FC5E   LW V0, 72(S8)
BFD00F26  000640A2   BNEZC V0, 0xBFD00F36
734:                 				{
735:                 					/* The queue was full and no block time is specified (or
736:                 					the block time has expired) so leave now. */
737:                 					taskEXIT_CRITICAL();
BFD00F2A  40AA77E8   JALS vTaskExitCritical
BFD00F2C  0C0040AA   BNEZC T2, 0xBFD02730
BFD00F2E      0C00   NOP
738:                 
739:                 					/* Return to the original privilege level before exiting
740:                 					the function. */
741:                 					traceQUEUE_SEND_FAILED( pxQueue );
742:                 					return errQUEUE_FULL;
BFD00F30      0C40   MOVE V0, ZERO
BFD00F32      CC7D   B 0xBFD0102E
BFD00F34      0C00   NOP
743:                 				}
744:                 				else if( xEntryTimeSet == pdFALSE )
BFD00F36  0010FC5E   LW V0, 16(S8)
BFD00F3A  000940A2   BNEZC V0, 0xBFD00F50
745:                 				{
746:                 					/* The queue was full and a block time was specified so
747:                 					configure the timeout structure. */
748:                 					vTaskSetTimeOutState( &xTimeOut );
BFD00F3E  002C305E   ADDIU V0, S8, 44
BFD00F42      0C82   MOVE A0, V0
BFD00F44  47A677E8   JALS vTaskSetTimeOutState
BFD00F48      0C00   NOP
749:                 					xEntryTimeSet = pdTRUE;
BFD00F4A      ED01   LI V0, 1
BFD00F4C  0010F85E   SW V0, 16(S8)
750:                 				}
751:                 				else
752:                 				{
753:                 					/* Entry time was already set. */
754:                 					mtCOVERAGE_TEST_MARKER();
755:                 				}
756:                 			}
757:                 		}
758:                 		taskEXIT_CRITICAL();
BFD00F50  40AA77E8   JALS vTaskExitCritical
BFD00F52  0C0040AA   BNEZC T2, 0xBFD02756
BFD00F54      0C00   NOP
759:                 
760:                 		/* Interrupts and other tasks can send to and receive from the queue
761:                 		now the critical section has been exited. */
762:                 
763:                 		vTaskSuspendAll();
BFD00F56  4EF477E8   JALS vTaskSuspendAll
BFD00F58      4EF4   ADDIU S7, S7, -6
BFD00F5A      0C00   NOP
764:                 		prvLockQueue( pxQueue );
BFD00F5C  33B877E8   JALS vTaskEnterCritical
BFD00F5E  0C0033B8   ADDIU SP, T8, 3072
BFD00F60      0C00   NOP
BFD00F62  0014FC5E   LW V0, 20(S8)
BFD00F66  0044FC62   LW V1, 68(V0)
BFD00F6A      ED7F   LI V0, -1
BFD00F6C  0005B443   BNE V1, V0, 0xBFD00F7A
BFD00F6E  0C000005   SLL ZERO, A1, 1
BFD00F70      0C00   NOP
BFD00F72  0014FC5E   LW V0, 20(S8)
BFD00F76  0044F802   SW ZERO, 68(V0)
BFD00F7A  0014FC5E   LW V0, 20(S8)
BFD00F7E  0048FC62   LW V1, 72(V0)
BFD00F82      ED7F   LI V0, -1
BFD00F84  0005B443   BNE V1, V0, 0xBFD00F92
BFD00F86  0C000005   SLL ZERO, A1, 1
BFD00F88      0C00   NOP
BFD00F8A  0014FC5E   LW V0, 20(S8)
BFD00F8E  0048F802   SW ZERO, 72(V0)
BFD00F92  40AA77E8   JALS vTaskExitCritical
BFD00F94  0C0040AA   BNEZC T2, 0xBFD02798
BFD00F96      0C00   NOP
765:                 
766:                 		/* Update the timeout state to see if it has expired yet. */
767:                 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
BFD00F98  002C307E   ADDIU V1, S8, 44
BFD00F9C  0048305E   ADDIU V0, S8, 72
BFD00FA0      0C83   MOVE A0, V1
BFD00FA2      0CA2   MOVE A1, V0
BFD00FA4  1FF677E8   JALS xTaskCheckForTimeOut
BFD00FA6  0C001FF6   LB RA, 3072(S6)
BFD00FA8      0C00   NOP
BFD00FAA  003740A2   BNEZC V0, 0xBFD0101C
768:                 		{
769:                 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
BFD00FAE  0014FC9E   LW A0, 20(S8)
BFD00FB2  478277E8   JALS prvIsQueueFull
BFD00FB6      0C00   NOP
BFD00FB8  002640E2   BEQZC V0, 0xBFD01008
770:                 			{
771:                 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
772:                 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
BFD00FBC  0014FC5E   LW V0, 20(S8)
BFD00FC0      6DA8   ADDIU V1, V0, 16
BFD00FC2  0048FC5E   LW V0, 72(S8)
BFD00FC6      0C83   MOVE A0, V1
BFD00FC8      0CA2   MOVE A1, V0
BFD00FCA  2F3A77E8   JALS vTaskPlaceOnEventList
BFD00FCC      2F3A   ANDI A2, V1, 0x20
BFD00FCE      0C00   NOP
773:                 
774:                 				/* Unlocking the queue means queue events can effect the
775:                 				event list.  It is possible	that interrupts occurring now
776:                 				remove this task from the event	list again - but as the
777:                 				scheduler is suspended the task will go onto the pending
778:                 				ready last instead of the actual ready list. */
779:                 				prvUnlockQueue( pxQueue );
BFD00FD0  0014FC9E   LW A0, 20(S8)
BFD00FD4  1DEE77E8   JALS prvUnlockQueue
BFD00FD6  0C001DEE   LB T7, 3072(T6)
BFD00FD8      0C00   NOP
780:                 
781:                 				/* Resuming the scheduler will move tasks from the pending
782:                 				ready list into the ready list - so it is feasible that this
783:                 				task is already in a ready list before it yields - in which
784:                 				case the yield will not cause a context switch unless there
785:                 				is also a higher priority task in the pending ready list. */
786:                 				if( xTaskResumeAll() == pdFALSE )
BFD00FDA  158E77E8   JALS xTaskResumeAll
BFD00FDC  0C00158E   LBU T4, 3072(T6)
BFD00FDE      0C00   NOP
BFD00FE0  FF1E40A2   BNEZC V0, 0xBFD00E20
BFD00FE2  77E8FF1E   LW T8, 30696(S8)
787:                 				{
788:                 					portYIELD_WITHIN_API();
BFD00FE4  4E1677E8   JALS ulPortGetCP0Cause
BFD00FE6      4E16   ADDIU S0, S0, -5
BFD00FE8      0C00   NOP
BFD00FEA  0018F85E   SW V0, 24(S8)
BFD00FEE  0018FC5E   LW V0, 24(S8)
BFD00FF2  01005042   ORI V0, V0, 256
BFD00FF6  0018F85E   SW V0, 24(S8)
BFD00FFA  0018FC9E   LW A0, 24(S8)
BFD00FFE  4E2677E8   JALS vPortSetCP0Cause
BFD01000      4E26   ADDIU S1, S1, 3
BFD01002      0C00   NOP
789:                 				}
790:                 			}
791:                 			else
792:                 			{
793:                 				/* Try again. */
794:                 				prvUnlockQueue( pxQueue );
BFD01008  0014FC9E   LW A0, 20(S8)
BFD0100C  1DEE77E8   JALS prvUnlockQueue
BFD0100E  0C001DEE   LB T7, 3072(T6)
BFD01010      0C00   NOP
795:                 				( void ) xTaskResumeAll();
BFD01012  158E77E8   JALS xTaskResumeAll
BFD01014  0C00158E   LBU T4, 3072(T6)
BFD01016      0C00   NOP
796:                 			}
797:                 		}
798:                 		else
799:                 		{
800:                 			/* The timeout has expired. */
801:                 			prvUnlockQueue( pxQueue );
BFD0101C  0014FC9E   LW A0, 20(S8)
BFD01020  1DEE77E8   JALS prvUnlockQueue
BFD01022  0C001DEE   LB T7, 3072(T6)
BFD01024      0C00   NOP
802:                 			( void ) xTaskResumeAll();
BFD01026  158E77E8   JALS xTaskResumeAll
BFD01028  0C00158E   LBU T4, 3072(T6)
BFD0102A      0C00   NOP
803:                 
804:                 			/* Return to the original privilege level before exiting the
805:                 			function. */
806:                 			traceQUEUE_SEND_FAILED( pxQueue );
807:                 			return errQUEUE_FULL;
BFD0102C      0C40   MOVE V0, ZERO
808:                 		}
809:                 	}
BFD00E20      0C00   NOP
BFD01004      CF0E   B 0xBFD00E22
BFD01006      0C00   NOP
BFD01018      CF04   B 0xBFD00E22
BFD0101A      0C00   NOP
810:                 }
BFD0102E      0FBE   MOVE SP, S8
BFD01030      4BEF   LW RA, 60(SP)
BFD01032      4BCE   LW S8, 56(SP)
BFD01034      4C21   ADDIU SP, SP, 64
BFD01036      459F   JR16 RA
BFD01038      0C00   NOP
811:                 /*-----------------------------------------------------------*/
812:                 
813:                 #if ( configUSE_ALTERNATIVE_API == 1 )
814:                 
815:                 	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition )
816:                 	{
817:                 	BaseType_t xEntryTimeSet = pdFALSE;
818:                 	TimeOut_t xTimeOut;
819:                 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
820:                 
821:                 		configASSERT( pxQueue );
822:                 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
823:                 
824:                 		for( ;; )
825:                 		{
826:                 			taskENTER_CRITICAL();
827:                 			{
828:                 				/* Is there room on the queue now?  To be running we must be
829:                 				the highest priority task wanting to access the queue. */
830:                 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
831:                 				{
832:                 					traceQUEUE_SEND( pxQueue );
833:                 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
834:                 
835:                 					/* If there was a task waiting for data to arrive on the
836:                 					queue then unblock it now. */
837:                 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
838:                 					{
839:                 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
840:                 						{
841:                 							/* The unblocked task has a priority higher than
842:                 							our own so yield immediately. */
843:                 							portYIELD_WITHIN_API();
844:                 						}
845:                 						else
846:                 						{
847:                 							mtCOVERAGE_TEST_MARKER();
848:                 						}
849:                 					}
850:                 					else
851:                 					{
852:                 						mtCOVERAGE_TEST_MARKER();
853:                 					}
854:                 
855:                 					taskEXIT_CRITICAL();
856:                 					return pdPASS;
857:                 				}
858:                 				else
859:                 				{
860:                 					if( xTicksToWait == ( TickType_t ) 0 )
861:                 					{
862:                 						taskEXIT_CRITICAL();
863:                 						return errQUEUE_FULL;
864:                 					}
865:                 					else if( xEntryTimeSet == pdFALSE )
866:                 					{
867:                 						vTaskSetTimeOutState( &xTimeOut );
868:                 						xEntryTimeSet = pdTRUE;
869:                 					}
870:                 				}
871:                 			}
872:                 			taskEXIT_CRITICAL();
873:                 
874:                 			taskENTER_CRITICAL();
875:                 			{
876:                 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
877:                 				{
878:                 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
879:                 					{
880:                 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
881:                 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
882:                 						portYIELD_WITHIN_API();
883:                 					}
884:                 					else
885:                 					{
886:                 						mtCOVERAGE_TEST_MARKER();
887:                 					}
888:                 				}
889:                 				else
890:                 				{
891:                 					taskEXIT_CRITICAL();
892:                 					traceQUEUE_SEND_FAILED( pxQueue );
893:                 					return errQUEUE_FULL;
894:                 				}
895:                 			}
896:                 			taskEXIT_CRITICAL();
897:                 		}
898:                 	}
899:                 
900:                 #endif /* configUSE_ALTERNATIVE_API */
901:                 /*-----------------------------------------------------------*/
902:                 
903:                 #if ( configUSE_ALTERNATIVE_API == 1 )
904:                 
905:                 	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking )
906:                 	{
907:                 	BaseType_t xEntryTimeSet = pdFALSE;
908:                 	TimeOut_t xTimeOut;
909:                 	int8_t *pcOriginalReadPosition;
910:                 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
911:                 
912:                 		configASSERT( pxQueue );
913:                 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
914:                 
915:                 		for( ;; )
916:                 		{
917:                 			taskENTER_CRITICAL();
918:                 			{
919:                 				if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
920:                 				{
921:                 					/* Remember our read position in case we are just peeking. */
922:                 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
923:                 
924:                 					prvCopyDataFromQueue( pxQueue, pvBuffer );
925:                 
926:                 					if( xJustPeeking == pdFALSE )
927:                 					{
928:                 						traceQUEUE_RECEIVE( pxQueue );
929:                 
930:                 						/* Data is actually being removed (not just peeked). */
931:                 						--( pxQueue->uxMessagesWaiting );
932:                 
933:                 						#if ( configUSE_MUTEXES == 1 )
934:                 						{
935:                 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
936:                 							{
937:                 								/* Record the information required to implement
938:                 								priority inheritance should it become necessary. */
939:                 								pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle();
940:                 							}
941:                 							else
942:                 							{
943:                 								mtCOVERAGE_TEST_MARKER();
944:                 							}
945:                 						}
946:                 						#endif
947:                 
948:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
949:                 						{
950:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
951:                 							{
952:                 								portYIELD_WITHIN_API();
953:                 							}
954:                 							else
955:                 							{
956:                 								mtCOVERAGE_TEST_MARKER();
957:                 							}
958:                 						}
959:                 					}
960:                 					else
961:                 					{
962:                 						traceQUEUE_PEEK( pxQueue );
963:                 
964:                 						/* The data is not being removed, so reset our read
965:                 						pointer. */
966:                 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
967:                 
968:                 						/* The data is being left in the queue, so see if there are
969:                 						any other tasks waiting for the data. */
970:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
971:                 						{
972:                 							/* Tasks that are removed from the event list will get added to
973:                 							the pending ready list as the scheduler is still suspended. */
974:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
975:                 							{
976:                 								/* The task waiting has a higher priority than this task. */
977:                 								portYIELD_WITHIN_API();
978:                 							}
979:                 							else
980:                 							{
981:                 								mtCOVERAGE_TEST_MARKER();
982:                 							}
983:                 						}
984:                 						else
985:                 						{
986:                 							mtCOVERAGE_TEST_MARKER();
987:                 						}
988:                 					}
989:                 
990:                 					taskEXIT_CRITICAL();
991:                 					return pdPASS;
992:                 				}
993:                 				else
994:                 				{
995:                 					if( xTicksToWait == ( TickType_t ) 0 )
996:                 					{
997:                 						taskEXIT_CRITICAL();
998:                 						traceQUEUE_RECEIVE_FAILED( pxQueue );
999:                 						return errQUEUE_EMPTY;
1000:                					}
1001:                					else if( xEntryTimeSet == pdFALSE )
1002:                					{
1003:                						vTaskSetTimeOutState( &xTimeOut );
1004:                						xEntryTimeSet = pdTRUE;
1005:                					}
1006:                				}
1007:                			}
1008:                			taskEXIT_CRITICAL();
1009:                
1010:                			taskENTER_CRITICAL();
1011:                			{
1012:                				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1013:                				{
1014:                					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1015:                					{
1016:                						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1017:                
1018:                						#if ( configUSE_MUTEXES == 1 )
1019:                						{
1020:                							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1021:                							{
1022:                								taskENTER_CRITICAL();
1023:                								{
1024:                									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1025:                								}
1026:                								taskEXIT_CRITICAL();
1027:                							}
1028:                							else
1029:                							{
1030:                								mtCOVERAGE_TEST_MARKER();
1031:                							}
1032:                						}
1033:                						#endif
1034:                
1035:                						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1036:                						portYIELD_WITHIN_API();
1037:                					}
1038:                					else
1039:                					{
1040:                						mtCOVERAGE_TEST_MARKER();
1041:                					}
1042:                				}
1043:                				else
1044:                				{
1045:                					taskEXIT_CRITICAL();
1046:                					traceQUEUE_RECEIVE_FAILED( pxQueue );
1047:                					return errQUEUE_EMPTY;
1048:                				}
1049:                			}
1050:                			taskEXIT_CRITICAL();
1051:                		}
1052:                	}
1053:                
1054:                
1055:                #endif /* configUSE_ALTERNATIVE_API */
1056:                /*-----------------------------------------------------------*/
1057:                
1058:                BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
1059:                {
BFD023D4      4FED   ADDIU SP, SP, -40
BFD023D6      CBE9   SW RA, 36(SP)
BFD023D8      CBC8   SW S8, 32(SP)
BFD023DA      0FDD   MOVE S8, SP
BFD023DC  0028F89E   SW A0, 40(S8)
BFD023E0  002CF8BE   SW A1, 44(S8)
BFD023E4  0030F8DE   SW A2, 48(S8)
BFD023E8  0034F8FE   SW A3, 52(S8)
1060:                BaseType_t xReturn;
1061:                UBaseType_t uxSavedInterruptStatus;
1062:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
BFD023EC  0028FC5E   LW V0, 40(S8)
BFD023F0  0014F85E   SW V0, 20(S8)
1063:                
1064:                	configASSERT( pxQueue );
BFD023F4  0014FC5E   LW V0, 20(S8)
BFD023F8  000940A2   BNEZC V0, 0xBFD0240E
BFD023FC  BFD141A2   LUI V0, 0xBFD1
BFD023FE  3082BFD1   LDC1 F30, 12418(S1)
BFD02400  9E3C3082   ADDIU A0, V0, -25028
BFD02402  30A09E3C   LWC1 F17, 12448(GP)
BFD02404  042830A0   ADDIU A1, ZERO, 1064
BFD02406      0428   ADDU S0, A0, V0
BFD02408  4B7E77E8   JALS vAssertCalled
BFD0240A      4B7E   LW K1, 120(SP)
BFD0240C      0C00   NOP
1065:                	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
BFD0240E  002CFC5E   LW V0, 44(S8)
BFD02412  000640A2   BNEZC V0, 0xBFD02422
BFD02416  0014FC5E   LW V0, 20(S8)
BFD0241A  0040FC42   LW V0, 64(V0)
BFD0241E  000340A2   BNEZC V0, 0xBFD02428
BFD02422      ED01   LI V0, 1
BFD02424      CC02   B 0xBFD0242A
BFD02426      0C00   NOP
BFD02428      0C40   MOVE V0, ZERO
BFD0242A  000940A2   BNEZC V0, 0xBFD02440
BFD0242E  BFD141A2   LUI V0, 0xBFD1
BFD02430  3082BFD1   LDC1 F30, 12418(S1)
BFD02432  9E3C3082   ADDIU A0, V0, -25028
BFD02434  30A09E3C   LWC1 F17, 12448(GP)
BFD02436  042930A0   ADDIU A1, ZERO, 1065
BFD02438      0429   SUBU S0, A0, V0
BFD0243A  4B7E77E8   JALS vAssertCalled
BFD0243C      4B7E   LW K1, 120(SP)
BFD0243E      0C00   NOP
1066:                	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
BFD02440  0034FC7E   LW V1, 52(S8)
BFD02444      ED02   LI V0, 2
BFD02446  0008B443   BNE V1, V0, 0xBFD0245A
BFD02448  0C000008   SLL ZERO, T0, 1
BFD0244A      0C00   NOP
BFD0244C  0014FC5E   LW V0, 20(S8)
BFD02450      69AF   LW V1, 60(V0)
BFD02452      ED01   LI V0, 1
BFD02454  0004B443   BNE V1, V0, 0xBFD02460
BFD02456  0C000004   SLL ZERO, A0, 1
BFD02458      0C00   NOP
BFD0245A      ED01   LI V0, 1
BFD0245C      CC02   B 0xBFD02462
BFD0245E      0C00   NOP
BFD02460      0C40   MOVE V0, ZERO
BFD02462  000940A2   BNEZC V0, 0xBFD02478
BFD02466  BFD141A2   LUI V0, 0xBFD1
BFD02468  3082BFD1   LDC1 F30, 12418(S1)
BFD0246A  9E3C3082   ADDIU A0, V0, -25028
BFD0246C  30A09E3C   LWC1 F17, 12448(GP)
BFD0246E  042A30A0   ADDIU A1, ZERO, 1066
BFD02470      042A   ADDU S0, A1, V0
BFD02472  4B7E77E8   JALS vAssertCalled
BFD02474      4B7E   LW K1, 120(SP)
BFD02476      0C00   NOP
1067:                
1068:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1069:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1070:                	above the maximum system call priority are kept permanently enabled, even
1071:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1072:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1073:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1074:                	failure if a FreeRTOS API function is called from an interrupt that has been
1075:                	assigned a priority above the configured maximum system call priority.
1076:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1077:                	that have been assigned a priority at or (logically) below the maximum
1078:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1079:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1080:                	More information (albeit Cortex-M specific) is provided on the following
1081:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1082:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1083:                
1084:                	/* Similar to xQueueGenericSend, except without blocking if there is no room
1085:                	in the queue.  Also don't directly wake a task that was blocked on a queue
1086:                	read, instead return a flag to say whether a context switch is required or
1087:                	not (i.e. has a task with a higher priority than us been woken by this
1088:                	post). */
1089:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
BFD02478  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD0247C      0C00   NOP
BFD0247E  0018F85E   SW V0, 24(S8)
1090:                	{
1091:                		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
BFD02482  0014FC5E   LW V0, 20(S8)
BFD02486      69AE   LW V1, 56(V0)
BFD02488  0014FC5E   LW V0, 20(S8)
BFD0248C      692F   LW V0, 60(V0)
BFD0248E  13900043   SLTU V0, V1, V0
BFD02490  40A21390   ADDI GP, S0, 16546
BFD02492  000640A2   BNEZC V0, 0xBFD024A2
BFD02496  0034FC7E   LW V1, 52(S8)
BFD0249A      ED02   LI V0, 2
BFD0249C  0055B443   BNE V1, V0, 0xBFD0254A
BFD0249E  0C000055   SLL V0, S5, 1
BFD024A0      0C00   NOP
1092:                		{
1093:                			traceQUEUE_SEND_FROM_ISR( pxQueue );
1094:                
1095:                			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
1096:                			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
1097:                			in a task disinheriting a priority and prvCopyDataToQueue() can be
1098:                			called here even though the disinherit function does not check if
1099:                			the scheduler is suspended before accessing the ready lists. */
1100:                			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
BFD024A2  0014FC9E   LW A0, 20(S8)
BFD024A6  002CFCBE   LW A1, 44(S8)
BFD024AA  0034FCDE   LW A2, 52(S8)
BFD024AE  14E677E8   JALS prvCopyDataToQueue
BFD024B0  0C0014E6   LBU A3, 3072(A2)
BFD024B2      0C00   NOP
1101:                
1102:                			/* The event list is not altered if the queue is locked.  This will
1103:                			be done when the queue is unlocked later. */
1104:                			if( pxQueue->xTxLock == queueUNLOCKED )
BFD024B4  0014FC5E   LW V0, 20(S8)
BFD024B8  0048FC62   LW V1, 72(V0)
BFD024BC      ED7F   LI V0, -1
BFD024BE  0036B443   BNE V1, V0, 0xBFD0252E
BFD024C0  0C000036   SLL AT, S6, 1
BFD024C2      0C00   NOP
1105:                			{
1106:                				#if ( configUSE_QUEUE_SETS == 1 )
1107:                				{
1108:                					if( pxQueue->pxQueueSetContainer != NULL )
BFD024C4  0014FC5E   LW V0, 20(S8)
BFD024C8  004CFC42   LW V0, 76(V0)
BFD024CC  001640E2   BEQZC V0, 0xBFD024FC
1109:                					{
1110:                						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
BFD024D0  0014FC9E   LW A0, 20(S8)
BFD024D4  0034FCBE   LW A1, 52(S8)
BFD024D8  21D877E8   JALS prvNotifyQueueSetContainer
BFD024DA  0C0021D8   LWC2 T6, 3072(T8)
BFD024DC      0C00   NOP
BFD024DE      0C62   MOVE V1, V0
BFD024E0      ED01   LI V0, 1
BFD024E2  002DB443   BNE V1, V0, 0xBFD02540
BFD024E4  0C00002D   SLL AT, T5, 1
BFD024E6      0C00   NOP
1111:                						{
1112:                							/* The queue is a member of a queue set, and posting
1113:                							to the queue set caused a higher priority task to
1114:                							unblock.  A context switch is required. */
1115:                							if( pxHigherPriorityTaskWoken != NULL )
BFD024E8  0030FC5E   LW V0, 48(S8)
BFD024EC  002840E2   BEQZC V0, 0xBFD02540
1116:                							{
1117:                								*pxHigherPriorityTaskWoken = pdTRUE;
BFD024F0  0030FC5E   LW V0, 48(S8)
BFD024F4      ED81   LI V1, 1
BFD024F6      E9A0   SW V1, 0(V0)
BFD024F8      CC23   B 0xBFD02540
BFD024FA      0C00   NOP
1118:                							}
1119:                							else
1120:                							{
1121:                								mtCOVERAGE_TEST_MARKER();
1122:                							}
1123:                						}
1124:                						else
1125:                						{
1126:                							mtCOVERAGE_TEST_MARKER();
1127:                						}
1128:                					}
1129:                					else
1130:                					{
1131:                						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
BFD024FC  0014FC5E   LW V0, 20(S8)
BFD02500      6929   LW V0, 36(V0)
BFD02502  001D40E2   BEQZC V0, 0xBFD02540
1132:                						{
1133:                							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
BFD02506  0014FC5E   LW V0, 20(S8)
BFD0250A  00243042   ADDIU V0, V0, 36
BFD0250E      0C82   MOVE A0, V0
BFD02510  22BC77E8   JALS xTaskRemoveFromEventList
BFD02512  0C0022BC   LWC2 S5, 3072(GP)
BFD02514      0C00   NOP
BFD02516  001340E2   BEQZC V0, 0xBFD02540
1134:                							{
1135:                								/* The task waiting has a higher priority so
1136:                								record that a context switch is required. */
1137:                								if( pxHigherPriorityTaskWoken != NULL )
BFD0251A  0030FC5E   LW V0, 48(S8)
BFD0251E  000F40E2   BEQZC V0, 0xBFD02540
1138:                								{
1139:                									*pxHigherPriorityTaskWoken = pdTRUE;
BFD02522  0030FC5E   LW V0, 48(S8)
BFD02526      ED81   LI V1, 1
BFD02528      E9A0   SW V1, 0(V0)
BFD0252A      CC0A   B 0xBFD02540
BFD0252C      0C00   NOP
1140:                								}
1141:                								else
1142:                								{
1143:                									mtCOVERAGE_TEST_MARKER();
1144:                								}
1145:                							}
1146:                							else
1147:                							{
1148:                								mtCOVERAGE_TEST_MARKER();
1149:                							}
1150:                						}
1151:                						else
1152:                						{
1153:                							mtCOVERAGE_TEST_MARKER();
1154:                						}
1155:                					}
1156:                				}
1157:                				#else /* configUSE_QUEUE_SETS */
1158:                				{
1159:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1160:                					{
1161:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1162:                						{
1163:                							/* The task waiting has a higher priority so record that a
1164:                							context	switch is required. */
1165:                							if( pxHigherPriorityTaskWoken != NULL )
1166:                							{
1167:                								*pxHigherPriorityTaskWoken = pdTRUE;
1168:                							}
1169:                							else
1170:                							{
1171:                								mtCOVERAGE_TEST_MARKER();
1172:                							}
1173:                						}
1174:                						else
1175:                						{
1176:                							mtCOVERAGE_TEST_MARKER();
1177:                						}
1178:                					}
1179:                					else
1180:                					{
1181:                						mtCOVERAGE_TEST_MARKER();
1182:                					}
1183:                				}
1184:                				#endif /* configUSE_QUEUE_SETS */
1185:                			}
1186:                			else
1187:                			{
1188:                				/* Increment the lock count so the task that unlocks the queue
1189:                				knows that data was posted while it was locked. */
1190:                				++( pxQueue->xTxLock );
BFD0252E  0014FC5E   LW V0, 20(S8)
BFD02532  0048FC42   LW V0, 72(V0)
BFD02536      6DA0   ADDIU V1, V0, 1
BFD02538  0014FC5E   LW V0, 20(S8)
BFD0253C  0048F862   SW V1, 72(V0)
1191:                			}
1192:                
1193:                			xReturn = pdPASS;
BFD02540      ED01   LI V0, 1
BFD02542  0010F85E   SW V0, 16(S8)
BFD02546      CC03   B 0xBFD0254E
BFD02548      0C00   NOP
1194:                		}
1195:                		else
1196:                		{
1197:                			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1198:                			xReturn = errQUEUE_FULL;
BFD0254A  0010F81E   SW ZERO, 16(S8)
1199:                		}
1200:                	}
1201:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
BFD0254E  0018FC9E   LW A0, 24(S8)
BFD02552  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD02554      4D5E   ADDIU T2, T2, -1
BFD02556      0C00   NOP
1202:                
1203:                	return xReturn;
BFD02558  0010FC5E   LW V0, 16(S8)
1204:                }
BFD0255C      0FBE   MOVE SP, S8
BFD0255E      4BE9   LW RA, 36(SP)
BFD02560      4BC8   LW S8, 32(SP)
BFD02562      4C15   ADDIU SP, SP, 40
BFD02564      459F   JR16 RA
BFD02566      0C00   NOP
1205:                /*-----------------------------------------------------------*/
1206:                
1207:                BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1208:                {
BFD0286C      4FED   ADDIU SP, SP, -40
BFD0286E      CBE9   SW RA, 36(SP)
BFD02870      CBC8   SW S8, 32(SP)
BFD02872      0FDD   MOVE S8, SP
BFD02874  0028F89E   SW A0, 40(S8)
BFD02878  002CF8BE   SW A1, 44(S8)
1209:                BaseType_t xReturn;
1210:                UBaseType_t uxSavedInterruptStatus;
1211:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
BFD0287C  0028FC5E   LW V0, 40(S8)
BFD02880  0014F85E   SW V0, 20(S8)
1212:                
1213:                	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1214:                	item size is 0.  Don't directly wake a task that was blocked on a queue
1215:                	read, instead return a flag to say whether a context switch is required or
1216:                	not (i.e. has a task with a higher priority than us been woken by this
1217:                	post). */
1218:                
1219:                	configASSERT( pxQueue );
BFD02884  0014FC5E   LW V0, 20(S8)
BFD02888  000940A2   BNEZC V0, 0xBFD0289E
BFD0288C  BFD141A2   LUI V0, 0xBFD1
BFD0288E  3082BFD1   LDC1 F30, 12418(S1)
BFD02890  9E3C3082   ADDIU A0, V0, -25028
BFD02892  30A09E3C   LWC1 F17, 12448(GP)
BFD02894  04C330A0   ADDIU A1, ZERO, 1219
BFD02896      04C3   SUBU S1, S1, A0
BFD02898  4B7E77E8   JALS vAssertCalled
BFD0289A      4B7E   LW K1, 120(SP)
BFD0289C      0C00   NOP
1220:                
1221:                	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1222:                	if the item size is not 0. */
1223:                	configASSERT( pxQueue->uxItemSize == 0 );
BFD0289E  0014FC5E   LW V0, 20(S8)
BFD028A2  0040FC42   LW V0, 64(V0)
BFD028A6  000940E2   BEQZC V0, 0xBFD028BC
BFD028AA  BFD141A2   LUI V0, 0xBFD1
BFD028AC  3082BFD1   LDC1 F30, 12418(S1)
BFD028AE  9E3C3082   ADDIU A0, V0, -25028
BFD028B0  30A09E3C   LWC1 F17, 12448(GP)
BFD028B2  04C730A0   ADDIU A1, ZERO, 1223
BFD028B4      04C7   SUBU S1, V1, A0
BFD028B6  4B7E77E8   JALS vAssertCalled
BFD028B8      4B7E   LW K1, 120(SP)
BFD028BA      0C00   NOP
1224:                
1225:                	/* Normally a mutex would not be given from an interrupt, and doing so is
1226:                	definitely wrong if there is a mutex holder as priority inheritance makes no
1227:                	sense for an interrupts, only tasks. */
1228:                	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
BFD028BC  0014FC5E   LW V0, 20(S8)
BFD028C0      6920   LW V0, 0(V0)
BFD028C2  000540A2   BNEZC V0, 0xBFD028D0
BFD028C6  0014FC5E   LW V0, 20(S8)
BFD028CA      6921   LW V0, 4(V0)
BFD028CC  000340A2   BNEZC V0, 0xBFD028D6
BFD028D0      ED01   LI V0, 1
BFD028D2      CC02   B 0xBFD028D8
BFD028D4      0C00   NOP
BFD028D6      0C40   MOVE V0, ZERO
BFD028D8  000940A2   BNEZC V0, 0xBFD028EE
BFD028DC  BFD141A2   LUI V0, 0xBFD1
BFD028DE  3082BFD1   LDC1 F30, 12418(S1)
BFD028E0  9E3C3082   ADDIU A0, V0, -25028
BFD028E2  30A09E3C   LWC1 F17, 12448(GP)
BFD028E4  04CC30A0   ADDIU A1, ZERO, 1228
BFD028E6      04CC   ADDU S1, A2, A0
BFD028E8  4B7E77E8   JALS vAssertCalled
BFD028EA      4B7E   LW K1, 120(SP)
BFD028EC      0C00   NOP
1229:                
1230:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1231:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1232:                	above the maximum system call priority are kept permanently enabled, even
1233:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1234:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1235:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1236:                	failure if a FreeRTOS API function is called from an interrupt that has been
1237:                	assigned a priority above the configured maximum system call priority.
1238:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1239:                	that have been assigned a priority at or (logically) below the maximum
1240:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1241:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1242:                	More information (albeit Cortex-M specific) is provided on the following
1243:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1244:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1245:                
1246:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
BFD028EE  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD028F2      0C00   NOP
BFD028F4  0018F85E   SW V0, 24(S8)
1247:                	{
1248:                		/* When the queue is used to implement a semaphore no data is ever
1249:                		moved through the queue but it is still valid to see if the queue 'has
1250:                		space'. */
1251:                		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
BFD028F8  0014FC5E   LW V0, 20(S8)
BFD028FC      69AE   LW V1, 56(V0)
BFD028FE  0014FC5E   LW V0, 20(S8)
BFD02902      692F   LW V0, 60(V0)
BFD02904  13900043   SLTU V0, V1, V0
BFD02906  40E21390   ADDI GP, S0, 16610
BFD02908  005140E2   BEQZC V0, 0xBFD029AE
1252:                		{
1253:                			traceQUEUE_SEND_FROM_ISR( pxQueue );
1254:                
1255:                			/* A task can only have an inherited priority if it is a mutex
1256:                			holder - and if there is a mutex holder then the mutex cannot be
1257:                			given from an ISR.  As this is the ISR version of the function it
1258:                			can be assumed there is no mutex holder and no need to determine if
1259:                			priority disinheritance is needed.  Simply increase the count of
1260:                			messages (semaphores) available. */
1261:                			++( pxQueue->uxMessagesWaiting );
BFD0290C  0014FC5E   LW V0, 20(S8)
BFD02910      692E   LW V0, 56(V0)
BFD02912      6DA0   ADDIU V1, V0, 1
BFD02914  0014FC5E   LW V0, 20(S8)
BFD02918      E9AE   SW V1, 56(V0)
1262:                
1263:                			/* The event list is not altered if the queue is locked.  This will
1264:                			be done when the queue is unlocked later. */
1265:                			if( pxQueue->xTxLock == queueUNLOCKED )
BFD0291A  0014FC5E   LW V0, 20(S8)
BFD0291E  0048FC62   LW V1, 72(V0)
BFD02922      ED7F   LI V0, -1
BFD02924  0035B443   BNE V1, V0, 0xBFD02992
BFD02926  0C000035   SLL AT, S5, 1
BFD02928      0C00   NOP
1266:                			{
1267:                				#if ( configUSE_QUEUE_SETS == 1 )
1268:                				{
1269:                					if( pxQueue->pxQueueSetContainer != NULL )
BFD0292A  0014FC5E   LW V0, 20(S8)
BFD0292E  004CFC42   LW V0, 76(V0)
BFD02932  001540E2   BEQZC V0, 0xBFD02960
1270:                					{
1271:                						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
BFD02936  0014FC9E   LW A0, 20(S8)
BFD0293A      0CA0   MOVE A1, ZERO
BFD0293C  21D877E8   JALS prvNotifyQueueSetContainer
BFD0293E  0C0021D8   LWC2 T6, 3072(T8)
BFD02940      0C00   NOP
BFD02942      0C62   MOVE V1, V0
BFD02944      ED01   LI V0, 1
BFD02946  002DB443   BNE V1, V0, 0xBFD029A4
BFD02948  0C00002D   SLL AT, T5, 1
BFD0294A      0C00   NOP
1272:                						{
1273:                							/* The semaphore is a member of a queue set, and
1274:                							posting	to the queue set caused a higher priority
1275:                							task to	unblock.  A context switch is required. */
1276:                							if( pxHigherPriorityTaskWoken != NULL )
BFD0294C  002CFC5E   LW V0, 44(S8)
BFD02950  002840E2   BEQZC V0, 0xBFD029A4
1277:                							{
1278:                								*pxHigherPriorityTaskWoken = pdTRUE;
BFD02954  002CFC5E   LW V0, 44(S8)
BFD02958      ED81   LI V1, 1
BFD0295A      E9A0   SW V1, 0(V0)
BFD0295C      CC23   B 0xBFD029A4
BFD0295E      0C00   NOP
1279:                							}
1280:                							else
1281:                							{
1282:                								mtCOVERAGE_TEST_MARKER();
1283:                							}
1284:                						}
1285:                						else
1286:                						{
1287:                							mtCOVERAGE_TEST_MARKER();
1288:                						}
1289:                					}
1290:                					else
1291:                					{
1292:                						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
BFD02960  0014FC5E   LW V0, 20(S8)
BFD02964      6929   LW V0, 36(V0)
BFD02966  001D40E2   BEQZC V0, 0xBFD029A4
1293:                						{
1294:                							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
BFD0296A  0014FC5E   LW V0, 20(S8)
BFD0296E  00243042   ADDIU V0, V0, 36
BFD02972      0C82   MOVE A0, V0
BFD02974  22BC77E8   JALS xTaskRemoveFromEventList
BFD02976  0C0022BC   LWC2 S5, 3072(GP)
BFD02978      0C00   NOP
BFD0297A  001340E2   BEQZC V0, 0xBFD029A4
1295:                							{
1296:                								/* The task waiting has a higher priority so
1297:                								record that a context switch is required. */
1298:                								if( pxHigherPriorityTaskWoken != NULL )
BFD0297E  002CFC5E   LW V0, 44(S8)
BFD02982  000F40E2   BEQZC V0, 0xBFD029A4
1299:                								{
1300:                									*pxHigherPriorityTaskWoken = pdTRUE;
BFD02986  002CFC5E   LW V0, 44(S8)
BFD0298A      ED81   LI V1, 1
BFD0298C      E9A0   SW V1, 0(V0)
BFD0298E      CC0A   B 0xBFD029A4
BFD02990      0C00   NOP
1301:                								}
1302:                								else
1303:                								{
1304:                									mtCOVERAGE_TEST_MARKER();
1305:                								}
1306:                							}
1307:                							else
1308:                							{
1309:                								mtCOVERAGE_TEST_MARKER();
1310:                							}
1311:                						}
1312:                						else
1313:                						{
1314:                							mtCOVERAGE_TEST_MARKER();
1315:                						}
1316:                					}
1317:                				}
1318:                				#else /* configUSE_QUEUE_SETS */
1319:                				{
1320:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1321:                					{
1322:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1323:                						{
1324:                							/* The task waiting has a higher priority so record that a
1325:                							context	switch is required. */
1326:                							if( pxHigherPriorityTaskWoken != NULL )
1327:                							{
1328:                								*pxHigherPriorityTaskWoken = pdTRUE;
1329:                							}
1330:                							else
1331:                							{
1332:                								mtCOVERAGE_TEST_MARKER();
1333:                							}
1334:                						}
1335:                						else
1336:                						{
1337:                							mtCOVERAGE_TEST_MARKER();
1338:                						}
1339:                					}
1340:                					else
1341:                					{
1342:                						mtCOVERAGE_TEST_MARKER();
1343:                					}
1344:                				}
1345:                				#endif /* configUSE_QUEUE_SETS */
1346:                			}
1347:                			else
1348:                			{
1349:                				/* Increment the lock count so the task that unlocks the queue
1350:                				knows that data was posted while it was locked. */
1351:                				++( pxQueue->xTxLock );
BFD02992  0014FC5E   LW V0, 20(S8)
BFD02996  0048FC42   LW V0, 72(V0)
BFD0299A      6DA0   ADDIU V1, V0, 1
BFD0299C  0014FC5E   LW V0, 20(S8)
BFD029A0  0048F862   SW V1, 72(V0)
1352:                			}
1353:                
1354:                			xReturn = pdPASS;
BFD029A4      ED01   LI V0, 1
BFD029A6  0010F85E   SW V0, 16(S8)
BFD029AA      CC03   B 0xBFD029B2
BFD029AC      0C00   NOP
1355:                		}
1356:                		else
1357:                		{
1358:                			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1359:                			xReturn = errQUEUE_FULL;
BFD029AE  0010F81E   SW ZERO, 16(S8)
1360:                		}
1361:                	}
1362:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
BFD029B2  0018FC9E   LW A0, 24(S8)
BFD029B6  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD029B8      4D5E   ADDIU T2, T2, -1
BFD029BA      0C00   NOP
1363:                
1364:                	return xReturn;
BFD029BC  0010FC5E   LW V0, 16(S8)
1365:                }
BFD029C0      0FBE   MOVE SP, S8
BFD029C2      4BE9   LW RA, 36(SP)
BFD029C4      4BC8   LW S8, 32(SP)
BFD029C6      4C15   ADDIU SP, SP, 40
BFD029C8      459F   JR16 RA
BFD029CA      0C00   NOP
1366:                /*-----------------------------------------------------------*/
1367:                
1368:                BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
1369:                {
BFD0103C      4FE5   ADDIU SP, SP, -56
BFD0103E      CBED   SW RA, 52(SP)
BFD01040      CBCC   SW S8, 48(SP)
BFD01042      0FDD   MOVE S8, SP
BFD01044  0038F89E   SW A0, 56(S8)
BFD01048  003CF8BE   SW A1, 60(S8)
BFD0104C  0040F8DE   SW A2, 64(S8)
BFD01050  0044F8FE   SW A3, 68(S8)
1370:                BaseType_t xEntryTimeSet = pdFALSE;
BFD01054  0010F81E   SW ZERO, 16(S8)
1371:                TimeOut_t xTimeOut;
1372:                int8_t *pcOriginalReadPosition;
1373:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
BFD01058  0038FC5E   LW V0, 56(S8)
BFD0105C  0014F85E   SW V0, 20(S8)
1374:                
1375:                	configASSERT( pxQueue );
BFD01060  0014FC5E   LW V0, 20(S8)
BFD01064  000940A2   BNEZC V0, 0xBFD0107A
BFD01068  BFD141A2   LUI V0, 0xBFD1
BFD0106A  3082BFD1   LDC1 F30, 12418(S1)
BFD0106C  9E3C3082   ADDIU A0, V0, -25028
BFD0106E  30A09E3C   LWC1 F17, 12448(GP)
BFD01070  055F30A0   ADDIU A1, ZERO, 1375
BFD01072      055F   SUBU V0, A3, A1
BFD01074  4B7E77E8   JALS vAssertCalled
BFD01076      4B7E   LW K1, 120(SP)
BFD01078      0C00   NOP
1376:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
BFD0107A  003CFC5E   LW V0, 60(S8)
BFD0107E  000640A2   BNEZC V0, 0xBFD0108E
BFD01082  0014FC5E   LW V0, 20(S8)
BFD01086  0040FC42   LW V0, 64(V0)
BFD0108A  000340A2   BNEZC V0, 0xBFD01094
BFD0108E      ED01   LI V0, 1
BFD01090      CC02   B 0xBFD01096
BFD01092      0C00   NOP
BFD01094      0C40   MOVE V0, ZERO
BFD01096  000940A2   BNEZC V0, 0xBFD010AC
BFD0109A  BFD141A2   LUI V0, 0xBFD1
BFD0109C  3082BFD1   LDC1 F30, 12418(S1)
BFD0109E  9E3C3082   ADDIU A0, V0, -25028
BFD010A0  30A09E3C   LWC1 F17, 12448(GP)
BFD010A2  056030A0   ADDIU A1, ZERO, 1376
BFD010A4      0560   ADDU V0, S0, A2
BFD010A6  4B7E77E8   JALS vAssertCalled
BFD010A8      4B7E   LW K1, 120(SP)
BFD010AA      0C00   NOP
1377:                	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1378:                	{
1379:                		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
BFD010AC  4A8E77E8   JALS xTaskGetSchedulerState
BFD010AE      4A8E   LW S4, 56(SP)
BFD010B0      0C00   NOP
BFD010B2  000440A2   BNEZC V0, 0xBFD010BE
BFD010B6  0040FC5E   LW V0, 64(S8)
BFD010BA  000340A2   BNEZC V0, 0xBFD010C4
BFD010BE      ED01   LI V0, 1
BFD010C0      CC02   B 0xBFD010C6
BFD010C2      0C00   NOP
BFD010C4      0C40   MOVE V0, ZERO
BFD010C6  000C40A2   BNEZC V0, 0xBFD010E2
BFD010CA  BFD141A2   LUI V0, 0xBFD1
BFD010CC  3082BFD1   LDC1 F30, 12418(S1)
BFD010CE  9E3C3082   ADDIU A0, V0, -25028
BFD010D0  30A09E3C   LWC1 F17, 12448(GP)
BFD010D2  056330A0   ADDIU A1, ZERO, 1379
BFD010D4      0563   SUBU V0, S1, A2
BFD010D6  4B7E77E8   JALS vAssertCalled
BFD010D8      4B7E   LW K1, 120(SP)
BFD010DA      0C00   NOP
BFD010DC      CC02   B 0xBFD010E2
BFD010DE      0C00   NOP
1380:                	}
1381:                	#endif
1382:                
1383:                	/* This function relaxes the coding standard somewhat to allow return
1384:                	statements within the function itself.  This is done in the interest
1385:                	of execution time efficiency. */
1386:                
1387:                	for( ;; )
1388:                	{
1389:                		taskENTER_CRITICAL();
BFD010E2  33B877E8   JALS vTaskEnterCritical
BFD010E4  0C0033B8   ADDIU SP, T8, 3072
BFD010E6      0C00   NOP
1390:                		{
1391:                			/* Is there data in the queue now?  To be running the calling task
1392:                			must be	the highest priority task wanting to access the queue. */
1393:                			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
BFD010E8  0014FC5E   LW V0, 20(S8)
BFD010EC      692E   LW V0, 56(V0)
BFD010EE  007040E2   BEQZC V0, 0xBFD011D2
1394:                			{
1395:                				/* Remember the read position in case the queue is only being
1396:                				peeked. */
1397:                				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
BFD010F2  0014FC5E   LW V0, 20(S8)
BFD010F6      6923   LW V0, 12(V0)
BFD010F8  0018F85E   SW V0, 24(S8)
1398:                
1399:                				prvCopyDataFromQueue( pxQueue, pvBuffer );
BFD010FC  0014FC9E   LW A0, 20(S8)
BFD01100  003CFCBE   LW A1, 60(S8)
BFD01104  367A77E8   JALS prvCopyDataFromQueue
BFD01106  0C00367A   LHU S3, 3072(K0)
BFD01108      0C00   NOP
1400:                
1401:                				if( xJustPeeking == pdFALSE )
BFD0110A  0044FC5E   LW V0, 68(S8)
BFD0110E  003640A2   BNEZC V0, 0xBFD0117E
1402:                				{
1403:                					traceQUEUE_RECEIVE( pxQueue );
1404:                
1405:                					/* Actually removing data, not just peeking. */
1406:                					--( pxQueue->uxMessagesWaiting );
BFD01112  0014FC5E   LW V0, 20(S8)
BFD01116      692E   LW V0, 56(V0)
BFD01118      6DAE   ADDIU V1, V0, -1
BFD0111A  0014FC5E   LW V0, 20(S8)
BFD0111E      E9AE   SW V1, 56(V0)
1407:                
1408:                					#if ( configUSE_MUTEXES == 1 )
1409:                					{
1410:                						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
BFD01120  0014FC5E   LW V0, 20(S8)
BFD01124      6920   LW V0, 0(V0)
BFD01126  000740A2   BNEZC V0, 0xBFD01138
1411:                						{
1412:                							/* Record the information required to implement
1413:                							priority inheritance should it become necessary. */
1414:                							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
BFD0112A  4CE077E8   JALS pvTaskIncrementMutexHeldCount
BFD0112C      4CE0   ADDIU A3, A3, 0
BFD0112E      0C00   NOP
BFD01130      0C62   MOVE V1, V0
BFD01132  0014FC5E   LW V0, 20(S8)
BFD01136      E9A1   SW V1, 4(V0)
1415:                						}
1416:                						else
1417:                						{
1418:                							mtCOVERAGE_TEST_MARKER();
1419:                						}
1420:                					}
1421:                					#endif /* configUSE_MUTEXES */
1422:                
1423:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
BFD01138  0014FC5E   LW V0, 20(S8)
BFD0113C      6924   LW V0, 16(V0)
BFD0113E  004240E2   BEQZC V0, 0xBFD011C6
1424:                					{
1425:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
BFD01142  0014FC5E   LW V0, 20(S8)
BFD01146      6D28   ADDIU V0, V0, 16
BFD01148      0C82   MOVE A0, V0
BFD0114A  22BC77E8   JALS xTaskRemoveFromEventList
BFD0114C  0C0022BC   LWC2 S5, 3072(GP)
BFD0114E      0C00   NOP
BFD01150      0C62   MOVE V1, V0
BFD01152      ED01   LI V0, 1
BFD01154  0037B443   BNE V1, V0, 0xBFD011C6
BFD01156  0C000037   SLL AT, S7, 1
BFD01158      0C00   NOP
1426:                						{
1427:                							queueYIELD_IF_USING_PREEMPTION();
BFD0115A  4E1677E8   JALS ulPortGetCP0Cause
BFD0115C      4E16   ADDIU S0, S0, -5
BFD0115E      0C00   NOP
BFD01160  001CF85E   SW V0, 28(S8)
BFD01164  001CFC5E   LW V0, 28(S8)
BFD01168  01005042   ORI V0, V0, 256
BFD0116C  001CF85E   SW V0, 28(S8)
BFD01170  001CFC9E   LW A0, 28(S8)
BFD01174  4E2677E8   JALS vPortSetCP0Cause
BFD01176      4E26   ADDIU S1, S1, 3
BFD01178      0C00   NOP
BFD0117A      CC25   B 0xBFD011C6
BFD0117C      0C00   NOP
1428:                						}
1429:                						else
1430:                						{
1431:                							mtCOVERAGE_TEST_MARKER();
1432:                						}
1433:                					}
1434:                					else
1435:                					{
1436:                						mtCOVERAGE_TEST_MARKER();
1437:                					}
1438:                				}
1439:                				else
1440:                				{
1441:                					traceQUEUE_PEEK( pxQueue );
1442:                
1443:                					/* The data is not being removed, so reset the read
1444:                					pointer. */
1445:                					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
BFD0117E  0014FC5E   LW V0, 20(S8)
BFD01182  0018FC7E   LW V1, 24(S8)
BFD01186      E9A3   SW V1, 12(V0)
1446:                
1447:                					/* The data is being left in the queue, so see if there are
1448:                					any other tasks waiting for the data. */
1449:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
BFD01188  0014FC5E   LW V0, 20(S8)
BFD0118C      6929   LW V0, 36(V0)
BFD0118E  001A40E2   BEQZC V0, 0xBFD011C6
1450:                					{
1451:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
BFD01192  0014FC5E   LW V0, 20(S8)
BFD01196  00243042   ADDIU V0, V0, 36
BFD0119A      0C82   MOVE A0, V0
BFD0119C  22BC77E8   JALS xTaskRemoveFromEventList
BFD0119E  0C0022BC   LWC2 S5, 3072(GP)
BFD011A0      0C00   NOP
BFD011A2  001040E2   BEQZC V0, 0xBFD011C6
1452:                						{
1453:                							/* The task waiting has a higher priority than this task. */
1454:                							queueYIELD_IF_USING_PREEMPTION();
BFD011A6  4E1677E8   JALS ulPortGetCP0Cause
BFD011A8      4E16   ADDIU S0, S0, -5
BFD011AA      0C00   NOP
BFD011AC  0020F85E   SW V0, 32(S8)
BFD011B0  0020FC5E   LW V0, 32(S8)
BFD011B4  01005042   ORI V0, V0, 256
BFD011B8  0020F85E   SW V0, 32(S8)
BFD011BC  0020FC9E   LW A0, 32(S8)
BFD011C0  4E2677E8   JALS vPortSetCP0Cause
BFD011C2      4E26   ADDIU S1, S1, 3
BFD011C4      0C00   NOP
1455:                						}
1456:                						else
1457:                						{
1458:                							mtCOVERAGE_TEST_MARKER();
1459:                						}
1460:                					}
1461:                					else
1462:                					{
1463:                						mtCOVERAGE_TEST_MARKER();
1464:                					}
1465:                				}
1466:                
1467:                				taskEXIT_CRITICAL();
BFD011C6  40AA77E8   JALS vTaskExitCritical
BFD011C8  0C0040AA   BNEZC T2, prvCopyDataToQueue
BFD011CA      0C00   NOP
1468:                				return pdPASS;
BFD011CC      ED01   LI V0, 1
BFD011CE      CC9A   B 0xBFD01304
BFD011D0      0C00   NOP
1469:                			}
1470:                			else
1471:                			{
1472:                				if( xTicksToWait == ( TickType_t ) 0 )
BFD011D2  0040FC5E   LW V0, 64(S8)
BFD011D6  000640A2   BNEZC V0, 0xBFD011E6
1473:                				{
1474:                					/* The queue was empty and no block time is specified (or
1475:                					the block time has expired) so leave now. */
1476:                					taskEXIT_CRITICAL();
BFD011DA  40AA77E8   JALS vTaskExitCritical
BFD011DC  0C0040AA   BNEZC T2, 0xBFD029E0
BFD011DE      0C00   NOP
1477:                					traceQUEUE_RECEIVE_FAILED( pxQueue );
1478:                					return errQUEUE_EMPTY;
BFD011E0      0C40   MOVE V0, ZERO
BFD011E2      CC90   B 0xBFD01304
BFD011E4      0C00   NOP
1479:                				}
1480:                				else if( xEntryTimeSet == pdFALSE )
BFD011E6  0010FC5E   LW V0, 16(S8)
BFD011EA  000940A2   BNEZC V0, 0xBFD01200
1481:                				{
1482:                					/* The queue was empty and a block time was specified so
1483:                					configure the timeout structure. */
1484:                					vTaskSetTimeOutState( &xTimeOut );
BFD011EE  0028305E   ADDIU V0, S8, 40
BFD011F2      0C82   MOVE A0, V0
BFD011F4  47A677E8   JALS vTaskSetTimeOutState
BFD011F8      0C00   NOP
1485:                					xEntryTimeSet = pdTRUE;
BFD011FA      ED01   LI V0, 1
BFD011FC  0010F85E   SW V0, 16(S8)
1486:                				}
1487:                				else
1488:                				{
1489:                					/* Entry time was already set. */
1490:                					mtCOVERAGE_TEST_MARKER();
1491:                				}
1492:                			}
1493:                		}
1494:                		taskEXIT_CRITICAL();
BFD01200  40AA77E8   JALS vTaskExitCritical
BFD01202  0C0040AA   BNEZC T2, 0xBFD02A06
BFD01204      0C00   NOP
1495:                
1496:                		/* Interrupts and other tasks can send to and receive from the queue
1497:                		now the critical section has been exited. */
1498:                
1499:                		vTaskSuspendAll();
BFD01206  4EF477E8   JALS vTaskSuspendAll
BFD01208      4EF4   ADDIU S7, S7, -6
BFD0120A      0C00   NOP
1500:                		prvLockQueue( pxQueue );
BFD0120C  33B877E8   JALS vTaskEnterCritical
BFD0120E  0C0033B8   ADDIU SP, T8, 3072
BFD01210      0C00   NOP
BFD01212  0014FC5E   LW V0, 20(S8)
BFD01216  0044FC62   LW V1, 68(V0)
BFD0121A      ED7F   LI V0, -1
BFD0121C  0005B443   BNE V1, V0, 0xBFD0122A
BFD0121E  0C000005   SLL ZERO, A1, 1
BFD01220      0C00   NOP
BFD01222  0014FC5E   LW V0, 20(S8)
BFD01226  0044F802   SW ZERO, 68(V0)
BFD0122A  0014FC5E   LW V0, 20(S8)
BFD0122E  0048FC62   LW V1, 72(V0)
BFD01232      ED7F   LI V0, -1
BFD01234  0005B443   BNE V1, V0, 0xBFD01242
BFD01236  0C000005   SLL ZERO, A1, 1
BFD01238      0C00   NOP
BFD0123A  0014FC5E   LW V0, 20(S8)
BFD0123E  0048F802   SW ZERO, 72(V0)
BFD01242  40AA77E8   JALS vTaskExitCritical
BFD01244  0C0040AA   BNEZC T2, 0xBFD02A48
BFD01246      0C00   NOP
1501:                
1502:                		/* Update the timeout state to see if it has expired yet. */
1503:                		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
BFD01248  0028307E   ADDIU V1, S8, 40
BFD0124C  0040305E   ADDIU V0, S8, 64
BFD01250      0C83   MOVE A0, V1
BFD01252      0CA2   MOVE A1, V0
BFD01254  1FF677E8   JALS xTaskCheckForTimeOut
BFD01256  0C001FF6   LB RA, 3072(S6)
BFD01258      0C00   NOP
BFD0125A  004A40A2   BNEZC V0, 0xBFD012F2
1504:                		{
1505:                			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
BFD0125E  0014FC9E   LW A0, 20(S8)
BFD01262  49D077E8   JALS prvIsQueueEmpty
BFD01264      49D0   LW T6, 64(SP)
BFD01266      0C00   NOP
BFD01268  003940E2   BEQZC V0, 0xBFD012DE
1506:                			{
1507:                				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1508:                
1509:                				#if ( configUSE_MUTEXES == 1 )
1510:                				{
1511:                					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
BFD0126C  0014FC5E   LW V0, 20(S8)
BFD01270      6920   LW V0, 0(V0)
BFD01272  000D40A2   BNEZC V0, 0xBFD01290
1512:                					{
1513:                						taskENTER_CRITICAL();
BFD01276  33B877E8   JALS vTaskEnterCritical
BFD01278  0C0033B8   ADDIU SP, T8, 3072
BFD0127A      0C00   NOP
1514:                						{
1515:                							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
BFD0127C  0014FC5E   LW V0, 20(S8)
BFD01280      6921   LW V0, 4(V0)
BFD01282      0C82   MOVE A0, V0
BFD01284  1A9077E8   JALS vTaskPriorityInherit
BFD01286  0C001A90   SB S4, 3072(S0)
BFD01288      0C00   NOP
1516:                						}
1517:                						taskEXIT_CRITICAL();
BFD0128A  40AA77E8   JALS vTaskExitCritical
BFD0128C  0C0040AA   BNEZC T2, 0xBFD02A90
BFD0128E      0C00   NOP
1518:                					}
1519:                					else
1520:                					{
1521:                						mtCOVERAGE_TEST_MARKER();
1522:                					}
1523:                				}
1524:                				#endif
1525:                
1526:                				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
BFD01290  0014FC5E   LW V0, 20(S8)
BFD01294  00243062   ADDIU V1, V0, 36
BFD01298  0040FC5E   LW V0, 64(S8)
BFD0129C      0C83   MOVE A0, V1
BFD0129E      0CA2   MOVE A1, V0
BFD012A0  2F3A77E8   JALS vTaskPlaceOnEventList
BFD012A2      2F3A   ANDI A2, V1, 0x20
BFD012A4      0C00   NOP
1527:                				prvUnlockQueue( pxQueue );
BFD012A6  0014FC9E   LW A0, 20(S8)
BFD012AA  1DEE77E8   JALS prvUnlockQueue
BFD012AC  0C001DEE   LB T7, 3072(T6)
BFD012AE      0C00   NOP
1528:                				if( xTaskResumeAll() == pdFALSE )
BFD012B0  158E77E8   JALS xTaskResumeAll
BFD012B2  0C00158E   LBU T4, 3072(T6)
BFD012B4      0C00   NOP
BFD012B6  FF1340A2   BNEZC V0, 0xBFD010E0
BFD012B8  77E8FF13   LW T8, 30696(S3)
1529:                				{
1530:                					portYIELD_WITHIN_API();
BFD012BA  4E1677E8   JALS ulPortGetCP0Cause
BFD012BC      4E16   ADDIU S0, S0, -5
BFD012BE      0C00   NOP
BFD012C0  0024F85E   SW V0, 36(S8)
BFD012C4  0024FC5E   LW V0, 36(S8)
BFD012C8  01005042   ORI V0, V0, 256
BFD012CC  0024F85E   SW V0, 36(S8)
BFD012D0  0024FC9E   LW A0, 36(S8)
BFD012D4  4E2677E8   JALS vPortSetCP0Cause
BFD012D6      4E26   ADDIU S1, S1, 3
BFD012D8      0C00   NOP
1531:                				}
1532:                				else
1533:                				{
1534:                					mtCOVERAGE_TEST_MARKER();
1535:                				}
1536:                			}
1537:                			else
1538:                			{
1539:                				/* Try again. */
1540:                				prvUnlockQueue( pxQueue );
BFD012DE  0014FC9E   LW A0, 20(S8)
BFD012E2  1DEE77E8   JALS prvUnlockQueue
BFD012E4  0C001DEE   LB T7, 3072(T6)
BFD012E6      0C00   NOP
1541:                				( void ) xTaskResumeAll();
BFD012E8  158E77E8   JALS xTaskResumeAll
BFD012EA  0C00158E   LBU T4, 3072(T6)
BFD012EC      0C00   NOP
1542:                			}
1543:                		}
1544:                		else
1545:                		{
1546:                			prvUnlockQueue( pxQueue );
BFD012F2  0014FC9E   LW A0, 20(S8)
BFD012F6  1DEE77E8   JALS prvUnlockQueue
BFD012F8  0C001DEE   LB T7, 3072(T6)
BFD012FA      0C00   NOP
1547:                			( void ) xTaskResumeAll();
BFD012FC  158E77E8   JALS xTaskResumeAll
BFD012FE  0C00158E   LBU T4, 3072(T6)
BFD01300      0C00   NOP
1548:                			traceQUEUE_RECEIVE_FAILED( pxQueue );
1549:                			return errQUEUE_EMPTY;
BFD01302      0C40   MOVE V0, ZERO
1550:                		}
1551:                	}
BFD010E0      0C00   NOP
BFD012DA      CF03   B 0xBFD010E2
BFD012DC      0C00   NOP
BFD012EE      CEF9   B 0xBFD010E2
BFD012F0      0C00   NOP
1552:                }
BFD01304      0FBE   MOVE SP, S8
BFD01306      4BED   LW RA, 52(SP)
BFD01308      4BCC   LW S8, 48(SP)
BFD0130A      4C1D   ADDIU SP, SP, 56
BFD0130C      459F   JR16 RA
BFD0130E      0C00   NOP
1553:                /*-----------------------------------------------------------*/
1554:                
1555:                BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
1556:                {
BFD03AC8      4FED   ADDIU SP, SP, -40
BFD03ACA      CBE9   SW RA, 36(SP)
BFD03ACC      CBC8   SW S8, 32(SP)
BFD03ACE      0FDD   MOVE S8, SP
BFD03AD0  0028F89E   SW A0, 40(S8)
BFD03AD4  002CF8BE   SW A1, 44(S8)
BFD03AD8  0030F8DE   SW A2, 48(S8)
1557:                BaseType_t xReturn;
1558:                UBaseType_t uxSavedInterruptStatus;
1559:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
BFD03ADC  0028FC5E   LW V0, 40(S8)
BFD03AE0  0014F85E   SW V0, 20(S8)
1560:                
1561:                	configASSERT( pxQueue );
BFD03AE4  0014FC5E   LW V0, 20(S8)
BFD03AE8  000940A2   BNEZC V0, 0xBFD03AFE
BFD03AEC  BFD141A2   LUI V0, 0xBFD1
BFD03AEE  3082BFD1   LDC1 F30, 12418(S1)
BFD03AF0  9E3C3082   ADDIU A0, V0, -25028
BFD03AF2  30A09E3C   LWC1 F17, 12448(GP)
BFD03AF4  061930A0   ADDIU A1, ZERO, 1561
BFD03AF6      0619   SUBU A0, A0, S1
BFD03AF8  4B7E77E8   JALS vAssertCalled
BFD03AFA      4B7E   LW K1, 120(SP)
BFD03AFC      0C00   NOP
1562:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
BFD03AFE  002CFC5E   LW V0, 44(S8)
BFD03B02  000640A2   BNEZC V0, 0xBFD03B12
BFD03B06  0014FC5E   LW V0, 20(S8)
BFD03B0A  0040FC42   LW V0, 64(V0)
BFD03B0E  000340A2   BNEZC V0, 0xBFD03B18
BFD03B12      ED01   LI V0, 1
BFD03B14      CC02   B 0xBFD03B1A
BFD03B16      0C00   NOP
BFD03B18      0C40   MOVE V0, ZERO
BFD03B1A  000940A2   BNEZC V0, 0xBFD03B30
BFD03B1E  BFD141A2   LUI V0, 0xBFD1
BFD03B20  3082BFD1   LDC1 F30, 12418(S1)
BFD03B22  9E3C3082   ADDIU A0, V0, -25028
BFD03B24  30A09E3C   LWC1 F17, 12448(GP)
BFD03B26  061A30A0   ADDIU A1, ZERO, 1562
BFD03B28      061A   ADDU A0, A1, S1
BFD03B2A  4B7E77E8   JALS vAssertCalled
BFD03B2C      4B7E   LW K1, 120(SP)
BFD03B2E      0C00   NOP
1563:                
1564:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1565:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1566:                	above the maximum system call priority are kept permanently enabled, even
1567:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1568:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1569:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1570:                	failure if a FreeRTOS API function is called from an interrupt that has been
1571:                	assigned a priority above the configured maximum system call priority.
1572:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1573:                	that have been assigned a priority at or (logically) below the maximum
1574:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1575:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1576:                	More information (albeit Cortex-M specific) is provided on the following
1577:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1578:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1579:                
1580:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
BFD03B30  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD03B34      0C00   NOP
BFD03B36  0018F85E   SW V0, 24(S8)
1581:                	{
1582:                		/* Cannot block in an ISR, so check there is data available. */
1583:                		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
BFD03B3A  0014FC5E   LW V0, 20(S8)
BFD03B3E      692E   LW V0, 56(V0)
BFD03B40  003C40E2   BEQZC V0, 0xBFD03BBC
1584:                		{
1585:                			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1586:                
1587:                			prvCopyDataFromQueue( pxQueue, pvBuffer );
BFD03B44  0014FC9E   LW A0, 20(S8)
BFD03B48  002CFCBE   LW A1, 44(S8)
BFD03B4C  367A77E8   JALS prvCopyDataFromQueue
BFD03B4E  0C00367A   LHU S3, 3072(K0)
BFD03B50      0C00   NOP
1588:                			--( pxQueue->uxMessagesWaiting );
BFD03B52  0014FC5E   LW V0, 20(S8)
BFD03B56      692E   LW V0, 56(V0)
BFD03B58      6DAE   ADDIU V1, V0, -1
BFD03B5A  0014FC5E   LW V0, 20(S8)
BFD03B5E      E9AE   SW V1, 56(V0)
1589:                
1590:                			/* If the queue is locked the event list will not be modified.
1591:                			Instead update the lock count so the task that unlocks the queue
1592:                			will know that an ISR has removed data while the queue was
1593:                			locked. */
1594:                			if( pxQueue->xRxLock == queueUNLOCKED )
BFD03B60  0014FC5E   LW V0, 20(S8)
BFD03B64  0044FC62   LW V1, 68(V0)
BFD03B68      ED7F   LI V0, -1
BFD03B6A  0019B443   BNE V1, V0, 0xBFD03BA0
BFD03B6C  0C000019   SLL ZERO, T9, 1
BFD03B6E      0C00   NOP
1595:                			{
1596:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
BFD03B70  0014FC5E   LW V0, 20(S8)
BFD03B74      6924   LW V0, 16(V0)
BFD03B76  001C40E2   BEQZC V0, 0xBFD03BB2
1597:                				{
1598:                					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
BFD03B7A  0014FC5E   LW V0, 20(S8)
BFD03B7E      6D28   ADDIU V0, V0, 16
BFD03B80      0C82   MOVE A0, V0
BFD03B82  22BC77E8   JALS xTaskRemoveFromEventList
BFD03B84  0C0022BC   LWC2 S5, 3072(GP)
BFD03B86      0C00   NOP
BFD03B88  001340E2   BEQZC V0, 0xBFD03BB2
1599:                					{
1600:                						/* The task waiting has a higher priority than us so
1601:                						force a context switch. */
1602:                						if( pxHigherPriorityTaskWoken != NULL )
BFD03B8C  0030FC5E   LW V0, 48(S8)
BFD03B90  000F40E2   BEQZC V0, 0xBFD03BB2
1603:                						{
1604:                							*pxHigherPriorityTaskWoken = pdTRUE;
BFD03B94  0030FC5E   LW V0, 48(S8)
BFD03B98      ED81   LI V1, 1
BFD03B9A      E9A0   SW V1, 0(V0)
BFD03B9C      CC0A   B 0xBFD03BB2
BFD03B9E      0C00   NOP
1605:                						}
1606:                						else
1607:                						{
1608:                							mtCOVERAGE_TEST_MARKER();
1609:                						}
1610:                					}
1611:                					else
1612:                					{
1613:                						mtCOVERAGE_TEST_MARKER();
1614:                					}
1615:                				}
1616:                				else
1617:                				{
1618:                					mtCOVERAGE_TEST_MARKER();
1619:                				}
1620:                			}
1621:                			else
1622:                			{
1623:                				/* Increment the lock count so the task that unlocks the queue
1624:                				knows that data was removed while it was locked. */
1625:                				++( pxQueue->xRxLock );
BFD03BA0  0014FC5E   LW V0, 20(S8)
BFD03BA4  0044FC42   LW V0, 68(V0)
BFD03BA8      6DA0   ADDIU V1, V0, 1
BFD03BAA  0014FC5E   LW V0, 20(S8)
BFD03BAE  0044F862   SW V1, 68(V0)
1626:                			}
1627:                
1628:                			xReturn = pdPASS;
BFD03BB2      ED01   LI V0, 1
BFD03BB4  0010F85E   SW V0, 16(S8)
BFD03BB8      CC03   B 0xBFD03BC0
BFD03BBA      0C00   NOP
1629:                		}
1630:                		else
1631:                		{
1632:                			xReturn = pdFAIL;
BFD03BBC  0010F81E   SW ZERO, 16(S8)
1633:                			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1634:                		}
1635:                	}
1636:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
BFD03BC0  0018FC9E   LW A0, 24(S8)
BFD03BC4  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD03BC6      4D5E   ADDIU T2, T2, -1
BFD03BC8      0C00   NOP
1637:                
1638:                	return xReturn;
BFD03BCA  0010FC5E   LW V0, 16(S8)
1639:                }
BFD03BCE      0FBE   MOVE SP, S8
BFD03BD0      4BE9   LW RA, 36(SP)
BFD03BD2      4BC8   LW S8, 32(SP)
BFD03BD4      4C15   ADDIU SP, SP, 40
BFD03BD6      459F   JR16 RA
BFD03BD8      0C00   NOP
1640:                /*-----------------------------------------------------------*/
1641:                
1642:                BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1643:                {
BFD04824      4FED   ADDIU SP, SP, -40
BFD04826      CBE9   SW RA, 36(SP)
BFD04828      CBC8   SW S8, 32(SP)
BFD0482A      0FDD   MOVE S8, SP
BFD0482C  0028F89E   SW A0, 40(S8)
BFD04830  002CF8BE   SW A1, 44(S8)
1644:                BaseType_t xReturn;
1645:                UBaseType_t uxSavedInterruptStatus;
1646:                int8_t *pcOriginalReadPosition;
1647:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
BFD04834  0028FC5E   LW V0, 40(S8)
BFD04838  0014F85E   SW V0, 20(S8)
1648:                
1649:                	configASSERT( pxQueue );
BFD0483C  0014FC5E   LW V0, 20(S8)
BFD04840  000940A2   BNEZC V0, 0xBFD04856
BFD04844  BFD141A2   LUI V0, 0xBFD1
BFD04846  3082BFD1   LDC1 F30, 12418(S1)
BFD04848  9E3C3082   ADDIU A0, V0, -25028
BFD0484A  30A09E3C   LWC1 F17, 12448(GP)
BFD0484C  067130A0   ADDIU A1, ZERO, 1649
BFD0484E      0671   SUBU A0, S0, A3
BFD04850  4B7E77E8   JALS vAssertCalled
BFD04852      4B7E   LW K1, 120(SP)
BFD04854      0C00   NOP
1650:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
BFD04856  002CFC5E   LW V0, 44(S8)
BFD0485A  000640A2   BNEZC V0, 0xBFD0486A
BFD0485E  0014FC5E   LW V0, 20(S8)
BFD04862  0040FC42   LW V0, 64(V0)
BFD04866  000340A2   BNEZC V0, 0xBFD04870
BFD0486A      ED01   LI V0, 1
BFD0486C      CC02   B 0xBFD04872
BFD0486E      0C00   NOP
BFD04870      0C40   MOVE V0, ZERO
BFD04872  000940A2   BNEZC V0, 0xBFD04888
BFD04876  BFD141A2   LUI V0, 0xBFD1
BFD04878  3082BFD1   LDC1 F30, 12418(S1)
BFD0487A  9E3C3082   ADDIU A0, V0, -25028
BFD0487C  30A09E3C   LWC1 F17, 12448(GP)
BFD0487E  067230A0   ADDIU A1, ZERO, 1650
BFD04880      0672   ADDU A0, S1, A3
BFD04882  4B7E77E8   JALS vAssertCalled
BFD04884      4B7E   LW K1, 120(SP)
BFD04886      0C00   NOP
1651:                	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
BFD04888  0014FC5E   LW V0, 20(S8)
BFD0488C  0040FC42   LW V0, 64(V0)
BFD04890  000940A2   BNEZC V0, 0xBFD048A6
BFD04894  BFD141A2   LUI V0, 0xBFD1
BFD04896  3082BFD1   LDC1 F30, 12418(S1)
BFD04898  9E3C3082   ADDIU A0, V0, -25028
BFD0489A  30A09E3C   LWC1 F17, 12448(GP)
BFD0489C  067330A0   ADDIU A1, ZERO, 1651
BFD0489E      0673   SUBU A0, S1, A3
BFD048A0  4B7E77E8   JALS vAssertCalled
BFD048A2      4B7E   LW K1, 120(SP)
BFD048A4      0C00   NOP
1652:                
1653:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1654:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1655:                	above the maximum system call priority are kept permanently enabled, even
1656:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1657:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1658:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1659:                	failure if a FreeRTOS API function is called from an interrupt that has been
1660:                	assigned a priority above the configured maximum system call priority.
1661:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1662:                	that have been assigned a priority at or (logically) below the maximum
1663:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1664:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1665:                	More information (albeit Cortex-M specific) is provided on the following
1666:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1667:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1668:                
1669:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
BFD048A6  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD048AA      0C00   NOP
BFD048AC  0018F85E   SW V0, 24(S8)
1670:                	{
1671:                		/* Cannot block in an ISR, so check there is data available. */
1672:                		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
BFD048B0  0014FC5E   LW V0, 20(S8)
BFD048B4      692E   LW V0, 56(V0)
BFD048B6  001640E2   BEQZC V0, 0xBFD048E6
1673:                		{
1674:                			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1675:                
1676:                			/* Remember the read position so it can be reset as nothing is
1677:                			actually being removed from the queue. */
1678:                			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
BFD048BA  0014FC5E   LW V0, 20(S8)
BFD048BE      6923   LW V0, 12(V0)
BFD048C0  001CF85E   SW V0, 28(S8)
1679:                			prvCopyDataFromQueue( pxQueue, pvBuffer );
BFD048C4  0014FC9E   LW A0, 20(S8)
BFD048C8  002CFCBE   LW A1, 44(S8)
BFD048CC  367A77E8   JALS prvCopyDataFromQueue
BFD048CE  0C00367A   LHU S3, 3072(K0)
BFD048D0      0C00   NOP
1680:                			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
BFD048D2  0014FC5E   LW V0, 20(S8)
BFD048D6  001CFC7E   LW V1, 28(S8)
BFD048DA      E9A3   SW V1, 12(V0)
1681:                
1682:                			xReturn = pdPASS;
BFD048DC      ED01   LI V0, 1
BFD048DE  0010F85E   SW V0, 16(S8)
BFD048E2      CC03   B 0xBFD048EA
BFD048E4      0C00   NOP
1683:                		}
1684:                		else
1685:                		{
1686:                			xReturn = pdFAIL;
BFD048E6  0010F81E   SW ZERO, 16(S8)
1687:                			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1688:                		}
1689:                	}
1690:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
BFD048EA  0018FC9E   LW A0, 24(S8)
BFD048EE  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD048F0      4D5E   ADDIU T2, T2, -1
BFD048F2      0C00   NOP
1691:                
1692:                	return xReturn;
BFD048F4  0010FC5E   LW V0, 16(S8)
1693:                }
BFD048F8      0FBE   MOVE SP, S8
BFD048FA      4BE9   LW RA, 36(SP)
BFD048FC      4BC8   LW S8, 32(SP)
BFD048FE      4C15   ADDIU SP, SP, 40
BFD04900      459F   JR16 RA
BFD04902      0C00   NOP
1694:                /*-----------------------------------------------------------*/
1695:                
1696:                UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1697:                {
BFD08B2C      4FF1   ADDIU SP, SP, -32
BFD08B2E      CBE7   SW RA, 28(SP)
BFD08B30      CBC6   SW S8, 24(SP)
BFD08B32      0FDD   MOVE S8, SP
BFD08B34  0020F89E   SW A0, 32(S8)
1698:                UBaseType_t uxReturn;
1699:                
1700:                	configASSERT( xQueue );
BFD08B38  0020FC5E   LW V0, 32(S8)
BFD08B3C  000940A2   BNEZC V0, 0xBFD08B52
BFD08B40  BFD141A2   LUI V0, 0xBFD1
BFD08B42  3082BFD1   LDC1 F30, 12418(S1)
BFD08B44  9E3C3082   ADDIU A0, V0, -25028
BFD08B46  30A09E3C   LWC1 F17, 12448(GP)
BFD08B48  06A430A0   ADDIU A1, ZERO, 1700
BFD08B4A      06A4   ADDU A1, V0, V0
BFD08B4C  4B7E77E8   JALS vAssertCalled
BFD08B4E      4B7E   LW K1, 120(SP)
BFD08B50      0C00   NOP
1701:                
1702:                	taskENTER_CRITICAL();
BFD08B52  33B877E8   JALS vTaskEnterCritical
BFD08B54  0C0033B8   ADDIU SP, T8, 3072
BFD08B56      0C00   NOP
1703:                	{
1704:                		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
BFD08B58  0020FC5E   LW V0, 32(S8)
BFD08B5C      692E   LW V0, 56(V0)
BFD08B5E  0010F85E   SW V0, 16(S8)
1705:                	}
1706:                	taskEXIT_CRITICAL();
BFD08B62  40AA77E8   JALS vTaskExitCritical
BFD08B64  0C0040AA   BNEZC T2, 0xBFD0A368
BFD08B66      0C00   NOP
1707:                
1708:                	return uxReturn;
BFD08B68  0010FC5E   LW V0, 16(S8)
1709:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
BFD08B6C      0FBE   MOVE SP, S8
BFD08B6E      4BE7   LW RA, 28(SP)
BFD08B70      4BC6   LW S8, 24(SP)
BFD08B72      4C11   ADDIU SP, SP, 32
BFD08B74      459F   JR16 RA
BFD08B76      0C00   NOP
1710:                /*-----------------------------------------------------------*/
1711:                
1712:                UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1713:                {
BFD082D4      4FF1   ADDIU SP, SP, -32
BFD082D6      CBE7   SW RA, 28(SP)
BFD082D8      CBC6   SW S8, 24(SP)
BFD082DA      0FDD   MOVE S8, SP
BFD082DC  0020F89E   SW A0, 32(S8)
1714:                UBaseType_t uxReturn;
1715:                Queue_t *pxQueue;
1716:                
1717:                	pxQueue = ( Queue_t * ) xQueue;
BFD082E0  0020FC5E   LW V0, 32(S8)
BFD082E4  0010F85E   SW V0, 16(S8)
1718:                	configASSERT( pxQueue );
BFD082E8  0010FC5E   LW V0, 16(S8)
BFD082EC  000940A2   BNEZC V0, 0xBFD08302
BFD082F0  BFD141A2   LUI V0, 0xBFD1
BFD082F2  3082BFD1   LDC1 F30, 12418(S1)
BFD082F4  9E3C3082   ADDIU A0, V0, -25028
BFD082F6  30A09E3C   LWC1 F17, 12448(GP)
BFD082F8  06B630A0   ADDIU A1, ZERO, 1718
BFD082FA      06B6   ADDU A1, V1, V1
BFD082FC  4B7E77E8   JALS vAssertCalled
BFD082FE      4B7E   LW K1, 120(SP)
BFD08300      0C00   NOP
1719:                
1720:                	taskENTER_CRITICAL();
BFD08302  33B877E8   JALS vTaskEnterCritical
BFD08304  0C0033B8   ADDIU SP, T8, 3072
BFD08306      0C00   NOP
1721:                	{
1722:                		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
BFD08308  0010FC5E   LW V0, 16(S8)
BFD0830C      69AF   LW V1, 60(V0)
BFD0830E  0010FC5E   LW V0, 16(S8)
BFD08312      692E   LW V0, 56(V0)
BFD08314      0527   SUBU V0, V1, V0
BFD08316  0014F85E   SW V0, 20(S8)
1723:                	}
1724:                	taskEXIT_CRITICAL();
BFD0831A  40AA77E8   JALS vTaskExitCritical
BFD0831C  0C0040AA   BNEZC T2, 0xBFD09B20
BFD0831E      0C00   NOP
1725:                
1726:                	return uxReturn;
BFD08320  0014FC5E   LW V0, 20(S8)
1727:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
BFD08324      0FBE   MOVE SP, S8
BFD08326      4BE7   LW RA, 28(SP)
BFD08328      4BC6   LW S8, 24(SP)
BFD0832A      4C11   ADDIU SP, SP, 32
BFD0832C      459F   JR16 RA
BFD0832E      0C00   NOP
1728:                /*-----------------------------------------------------------*/
1729:                
1730:                UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1731:                {
BFD09360      4FF1   ADDIU SP, SP, -32
BFD09362      CBE7   SW RA, 28(SP)
BFD09364      CBC6   SW S8, 24(SP)
BFD09366      0FDD   MOVE S8, SP
BFD09368  0020F89E   SW A0, 32(S8)
1732:                UBaseType_t uxReturn;
1733:                
1734:                	configASSERT( xQueue );
BFD0936C  0020FC5E   LW V0, 32(S8)
BFD09370  000940A2   BNEZC V0, 0xBFD09386
BFD09374  BFD141A2   LUI V0, 0xBFD1
BFD09376  3082BFD1   LDC1 F30, 12418(S1)
BFD09378  9E3C3082   ADDIU A0, V0, -25028
BFD0937A  30A09E3C   LWC1 F17, 12448(GP)
BFD0937C  06C630A0   ADDIU A1, ZERO, 1734
BFD0937E      06C6   ADDU A1, V1, A0
BFD09380  4B7E77E8   JALS vAssertCalled
BFD09382      4B7E   LW K1, 120(SP)
BFD09384      0C00   NOP
1735:                
1736:                	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
BFD09386  0020FC5E   LW V0, 32(S8)
BFD0938A      692E   LW V0, 56(V0)
BFD0938C  0010F85E   SW V0, 16(S8)
1737:                
1738:                	return uxReturn;
BFD09390  0010FC5E   LW V0, 16(S8)
1739:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
BFD09394      0FBE   MOVE SP, S8
BFD09396      4BE7   LW RA, 28(SP)
BFD09398      4BC6   LW S8, 24(SP)
BFD0939A      4C11   ADDIU SP, SP, 32
BFD0939C      459F   JR16 RA
BFD0939E      0C00   NOP
1740:                /*-----------------------------------------------------------*/
1741:                
1742:                void vQueueDelete( QueueHandle_t xQueue )
1743:                {
BFD09188      4FF1   ADDIU SP, SP, -32
BFD0918A      CBE7   SW RA, 28(SP)
BFD0918C      CBC6   SW S8, 24(SP)
BFD0918E      0FDD   MOVE S8, SP
BFD09190  0020F89E   SW A0, 32(S8)
1744:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
BFD09194  0020FC5E   LW V0, 32(S8)
BFD09198  0010F85E   SW V0, 16(S8)
1745:                
1746:                	configASSERT( pxQueue );
BFD0919C  0010FC5E   LW V0, 16(S8)
BFD091A0  000940A2   BNEZC V0, 0xBFD091B6
BFD091A4  BFD141A2   LUI V0, 0xBFD1
BFD091A6  3082BFD1   LDC1 F30, 12418(S1)
BFD091A8  9E3C3082   ADDIU A0, V0, -25028
BFD091AA  30A09E3C   LWC1 F17, 12448(GP)
BFD091AC  06D230A0   ADDIU A1, ZERO, 1746
BFD091AE      06D2   ADDU A1, S1, A1
BFD091B0  4B7E77E8   JALS vAssertCalled
BFD091B2      4B7E   LW K1, 120(SP)
BFD091B4      0C00   NOP
1747:                
1748:                	traceQUEUE_DELETE( pxQueue );
1749:                	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1750:                	{
1751:                		vQueueUnregisterQueue( pxQueue );
1752:                	}
1753:                	#endif
1754:                	vPortFree( pxQueue );
BFD091B6  0010FC9E   LW A0, 16(S8)
BFD091BA  2FEA77E8   JALS vPortFree
BFD091BC      2FEA   ANDI A3, A2, 0x20
BFD091BE      0C00   NOP
1755:                }
BFD091C0      0FBE   MOVE SP, S8
BFD091C2      4BE7   LW RA, 28(SP)
BFD091C4      4BC6   LW S8, 24(SP)
BFD091C6      4C11   ADDIU SP, SP, 32
BFD091C8      459F   JR16 RA
BFD091CA      0C00   NOP
1756:                /*-----------------------------------------------------------*/
1757:                
1758:                #if ( configUSE_TRACE_FACILITY == 1 )
1759:                
1760:                	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1761:                	{
1762:                		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1763:                	}
1764:                
1765:                #endif /* configUSE_TRACE_FACILITY */
1766:                /*-----------------------------------------------------------*/
1767:                
1768:                #if ( configUSE_TRACE_FACILITY == 1 )
1769:                
1770:                	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1771:                	{
1772:                		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1773:                	}
1774:                
1775:                #endif /* configUSE_TRACE_FACILITY */
1776:                /*-----------------------------------------------------------*/
1777:                
1778:                #if ( configUSE_TRACE_FACILITY == 1 )
1779:                
1780:                	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1781:                	{
1782:                		return ( ( Queue_t * ) xQueue )->ucQueueType;
1783:                	}
1784:                
1785:                #endif /* configUSE_TRACE_FACILITY */
1786:                /*-----------------------------------------------------------*/
1787:                
1788:                static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
1789:                {
BFD029CC      4FF1   ADDIU SP, SP, -32
BFD029CE      CBE7   SW RA, 28(SP)
BFD029D0      CBC6   SW S8, 24(SP)
BFD029D2      0FDD   MOVE S8, SP
BFD029D4  0020F89E   SW A0, 32(S8)
BFD029D8  0024F8BE   SW A1, 36(S8)
BFD029DC  0028F8DE   SW A2, 40(S8)
1790:                BaseType_t xReturn = pdFALSE;
BFD029E0  0010F81E   SW ZERO, 16(S8)
1791:                
1792:                	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
BFD029E4  0020FC5E   LW V0, 32(S8)
BFD029E8  0040FC42   LW V0, 64(V0)
BFD029EC  001340A2   BNEZC V0, 0xBFD02A16
1793:                	{
1794:                		#if ( configUSE_MUTEXES == 1 )
1795:                		{
1796:                			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
BFD029F0  0020FC5E   LW V0, 32(S8)
BFD029F4      6920   LW V0, 0(V0)
BFD029F6  008140A2   BNEZC V0, 0xBFD02AFC
1797:                			{
1798:                				/* The mutex is no longer being held. */
1799:                				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
BFD029FA  0020FC5E   LW V0, 32(S8)
BFD029FE      6921   LW V0, 4(V0)
BFD02A00      0C82   MOVE A0, V0
BFD02A02  178277E8   JALS xTaskPriorityDisinherit
BFD02A04  0C001782   LBU GP, 3072(V0)
BFD02A06      0C00   NOP
BFD02A08  0010F85E   SW V0, 16(S8)
1800:                				pxQueue->pxMutexHolder = NULL;
BFD02A0C  0020FC5E   LW V0, 32(S8)
BFD02A10      E821   SW S0, 4(V0)
BFD02A12      CC74   B 0xBFD02AFC
BFD02A14      0C00   NOP
1801:                			}
1802:                			else
1803:                			{
1804:                				mtCOVERAGE_TEST_MARKER();
1805:                			}
1806:                		}
1807:                		#endif /* configUSE_MUTEXES */
1808:                	}
1809:                	else if( xPosition == queueSEND_TO_BACK )
BFD02A16  0028FC5E   LW V0, 40(S8)
BFD02A1A  002B40A2   BNEZC V0, 0xBFD02A74
1810:                	{
1811:                		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
BFD02A1E  0020FC5E   LW V0, 32(S8)
BFD02A22      69A2   LW V1, 8(V0)
BFD02A24  0020FC5E   LW V0, 32(S8)
BFD02A28  0040FC42   LW V0, 64(V0)
BFD02A2C      0C83   MOVE A0, V1
BFD02A2E  0024FCBE   LW A1, 36(S8)
BFD02A32      0CC2   MOVE A2, V0
BFD02A34  1BB477E8   JALS 0xBFD03768
BFD02A36  0C001BB4   SB SP, 3072(S4)
BFD02A38      0C00   NOP
1812:                		pxQueue->pcWriteTo += pxQueue->uxItemSize;
BFD02A3A  0020FC5E   LW V0, 32(S8)
BFD02A3E      69A2   LW V1, 8(V0)
BFD02A40  0020FC5E   LW V0, 32(S8)
BFD02A44  0040FC42   LW V0, 64(V0)
BFD02A48      05A6   ADDU V1, V1, V0
BFD02A4A  0020FC5E   LW V0, 32(S8)
BFD02A4E      E9A2   SW V1, 8(V0)
1813:                		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
BFD02A50  0020FC5E   LW V0, 32(S8)
BFD02A54      69A2   LW V1, 8(V0)
BFD02A56  0020FC5E   LW V0, 32(S8)
BFD02A5A      6921   LW V0, 4(V0)
BFD02A5C  13900043   SLTU V0, V1, V0
BFD02A5E  40A21390   ADDI GP, S0, 16546
BFD02A60  004C40A2   BNEZC V0, 0xBFD02AFC
1814:                		{
1815:                			pxQueue->pcWriteTo = pxQueue->pcHead;
BFD02A64  0020FC5E   LW V0, 32(S8)
BFD02A68      69A0   LW V1, 0(V0)
BFD02A6A  0020FC5E   LW V0, 32(S8)
BFD02A6E      E9A2   SW V1, 8(V0)
BFD02A70      CC45   B 0xBFD02AFC
BFD02A72      0C00   NOP
1816:                		}
1817:                		else
1818:                		{
1819:                			mtCOVERAGE_TEST_MARKER();
1820:                		}
1821:                	}
1822:                	else
1823:                	{
1824:                		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
BFD02A74  0020FC5E   LW V0, 32(S8)
BFD02A78      69A3   LW V1, 12(V0)
BFD02A7A  0020FC5E   LW V0, 32(S8)
BFD02A7E  0040FC42   LW V0, 64(V0)
BFD02A82      0C83   MOVE A0, V1
BFD02A84  0024FCBE   LW A1, 36(S8)
BFD02A88      0CC2   MOVE A2, V0
BFD02A8A  1BB477E8   JALS 0xBFD03768
BFD02A8C  0C001BB4   SB SP, 3072(S4)
BFD02A8E      0C00   NOP
1825:                		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
BFD02A90  0020FC5E   LW V0, 32(S8)
BFD02A94      69A3   LW V1, 12(V0)
BFD02A96  0020FC5E   LW V0, 32(S8)
BFD02A9A  0040FC42   LW V0, 64(V0)
BFD02A9C  00400040   SRL V0, ZERO, 0
BFD02A9E  11D00040   SUBU V0, ZERO, V0
BFD02AA0  05A611D0   ADDI T6, S0, 1446
BFD02AA2      05A6   ADDU V1, V1, V0
BFD02AA4  0020FC5E   LW V0, 32(S8)
BFD02AA8      E9A3   SW V1, 12(V0)
1826:                		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
BFD02AAA  0020FC5E   LW V0, 32(S8)
BFD02AAE      69A3   LW V1, 12(V0)
BFD02AB0  0020FC5E   LW V0, 32(S8)
BFD02AB4      6920   LW V0, 0(V0)
BFD02AB6  13900043   SLTU V0, V1, V0
BFD02AB8  40E21390   ADDI GP, S0, 16610
BFD02ABA  000D40E2   BEQZC V0, 0xBFD02AD8
1827:                		{
1828:                			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
BFD02ABE  0020FC5E   LW V0, 32(S8)
BFD02AC2      69A1   LW V1, 4(V0)
BFD02AC4  0020FC5E   LW V0, 32(S8)
BFD02AC8  0040FC42   LW V0, 64(V0)
BFD02ACA  00400040   SRL V0, ZERO, 0
BFD02ACC  11D00040   SUBU V0, ZERO, V0
BFD02ACE  05A611D0   ADDI T6, S0, 1446
BFD02AD0      05A6   ADDU V1, V1, V0
BFD02AD2  0020FC5E   LW V0, 32(S8)
BFD02AD6      E9A3   SW V1, 12(V0)
1829:                		}
1830:                		else
1831:                		{
1832:                			mtCOVERAGE_TEST_MARKER();
1833:                		}
1834:                
1835:                		if( xPosition == queueOVERWRITE )
BFD02AD8  0028FC7E   LW V1, 40(S8)
BFD02ADC      ED02   LI V0, 2
BFD02ADE  000DB443   BNE V1, V0, 0xBFD02AFC
BFD02AE0  0C00000D   SLL ZERO, T5, 1
BFD02AE2      0C00   NOP
1836:                		{
1837:                			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
BFD02AE4  0020FC5E   LW V0, 32(S8)
BFD02AE8      692E   LW V0, 56(V0)
BFD02AEA  000740E2   BEQZC V0, 0xBFD02AFC
1838:                			{
1839:                				/* An item is not being added but overwritten, so subtract
1840:                				one from the recorded number of items in the queue so when
1841:                				one is added again below the number of recorded items remains
1842:                				correct. */
1843:                				--( pxQueue->uxMessagesWaiting );
BFD02AEE  0020FC5E   LW V0, 32(S8)
BFD02AF2      692E   LW V0, 56(V0)
BFD02AF4      6DAE   ADDIU V1, V0, -1
BFD02AF6  0020FC5E   LW V0, 32(S8)
BFD02AFA      E9AE   SW V1, 56(V0)
1844:                			}
1845:                			else
1846:                			{
1847:                				mtCOVERAGE_TEST_MARKER();
1848:                			}
1849:                		}
1850:                		else
1851:                		{
1852:                			mtCOVERAGE_TEST_MARKER();
1853:                		}
1854:                	}
1855:                
1856:                	++( pxQueue->uxMessagesWaiting );
BFD02AFC  0020FC5E   LW V0, 32(S8)
BFD02B00      692E   LW V0, 56(V0)
BFD02B02      6DA0   ADDIU V1, V0, 1
BFD02B04  0020FC5E   LW V0, 32(S8)
BFD02B08      E9AE   SW V1, 56(V0)
1857:                
1858:                	return xReturn;
BFD02B0A  0010FC5E   LW V0, 16(S8)
1859:                }
BFD02B0E      0FBE   MOVE SP, S8
BFD02B10      4BE7   LW RA, 28(SP)
BFD02B12      4BC6   LW S8, 24(SP)
BFD02B14      4C11   ADDIU SP, SP, 32
BFD02B16      459F   JR16 RA
BFD02B18      0C00   NOP
1860:                /*-----------------------------------------------------------*/
1861:                
1862:                static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1863:                {
BFD06CF4      4FF5   ADDIU SP, SP, -24
BFD06CF6      CBE5   SW RA, 20(SP)
BFD06CF8      CBC4   SW S8, 16(SP)
BFD06CFA      0FDD   MOVE S8, SP
BFD06CFC  0018F89E   SW A0, 24(S8)
BFD06D00  001CF8BE   SW A1, 28(S8)
1864:                	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
BFD06D04  0018FC5E   LW V0, 24(S8)
BFD06D08  0040FC42   LW V0, 64(V0)
BFD06D0C  002940E2   BEQZC V0, 0xBFD06D62
1865:                	{
1866:                		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
BFD06D10  0018FC5E   LW V0, 24(S8)
BFD06D14      69A3   LW V1, 12(V0)
BFD06D16  0018FC5E   LW V0, 24(S8)
BFD06D1A  0040FC42   LW V0, 64(V0)
BFD06D1E      05A6   ADDU V1, V1, V0
BFD06D20  0018FC5E   LW V0, 24(S8)
BFD06D24      E9A3   SW V1, 12(V0)
1867:                		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
BFD06D26  0018FC5E   LW V0, 24(S8)
BFD06D2A      69A3   LW V1, 12(V0)
BFD06D2C  0018FC5E   LW V0, 24(S8)
BFD06D30      6921   LW V0, 4(V0)
BFD06D32  13900043   SLTU V0, V1, V0
BFD06D34  40A21390   ADDI GP, S0, 16546
BFD06D36  000640A2   BNEZC V0, 0xBFD06D46
1868:                		{
1869:                			pxQueue->u.pcReadFrom = pxQueue->pcHead;
BFD06D3A  0018FC5E   LW V0, 24(S8)
BFD06D3E      69A0   LW V1, 0(V0)
BFD06D40  0018FC5E   LW V0, 24(S8)
BFD06D44      E9A3   SW V1, 12(V0)
1870:                		}
1871:                		else
1872:                		{
1873:                			mtCOVERAGE_TEST_MARKER();
1874:                		}
1875:                		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
BFD06D46  0018FC5E   LW V0, 24(S8)
BFD06D4A      69A3   LW V1, 12(V0)
BFD06D4C  0018FC5E   LW V0, 24(S8)
BFD06D50  0040FC42   LW V0, 64(V0)
BFD06D54  001CFC9E   LW A0, 28(S8)
BFD06D58      0CA3   MOVE A1, V1
BFD06D5A      0CC2   MOVE A2, V0
BFD06D5C  1BB477E8   JALS 0xBFD03768
BFD06D5E  0C001BB4   SB SP, 3072(S4)
BFD06D60      0C00   NOP
1876:                	}
1877:                }
BFD06D62      0FBE   MOVE SP, S8
BFD06D64      4BE5   LW RA, 20(SP)
BFD06D66      4BC4   LW S8, 16(SP)
BFD06D68      4C0D   ADDIU SP, SP, 24
BFD06D6A      459F   JR16 RA
BFD06D6C      0C00   NOP
1878:                /*-----------------------------------------------------------*/
1879:                
1880:                static void prvUnlockQueue( Queue_t * const pxQueue )
1881:                {
BFD03BDC      4FF5   ADDIU SP, SP, -24
BFD03BDE      CBE5   SW RA, 20(SP)
BFD03BE0      CBC4   SW S8, 16(SP)
BFD03BE2      0FDD   MOVE S8, SP
BFD03BE4  0018F89E   SW A0, 24(S8)
1882:                	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1883:                
1884:                	/* The lock counts contains the number of extra data items placed or
1885:                	removed from the queue while the queue was locked.  When a queue is
1886:                	locked items can be added or removed, but the event lists cannot be
1887:                	updated. */
1888:                	taskENTER_CRITICAL();
BFD03BE8  33B877E8   JALS vTaskEnterCritical
BFD03BEA  0C0033B8   ADDIU SP, T8, 3072
BFD03BEC      0C00   NOP
1889:                	{
1890:                		/* See if data was added to the queue while it was locked. */
1891:                		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
BFD03BEE      CC32   B 0xBFD03C54
BFD03BF0      0C00   NOP
BFD03C54  0018FC5E   LW V0, 24(S8)
BFD03C58  0048FC42   LW V0, 72(V0)
BFD03C5C  FFC940C2   BGTZ V0, 0xBFD03BF2
BFD03C5E  0C00FFC9   LW S8, 3072(T1)
BFD03C60      0C00   NOP
BFD03C62      CC02   B 0xBFD03C68
BFD03C64      0C00   NOP
1892:                		{
1893:                			/* Data was posted while the queue was locked.  Are any tasks
1894:                			blocked waiting for data to become available? */
1895:                			#if ( configUSE_QUEUE_SETS == 1 )
1896:                			{
1897:                				if( pxQueue->pxQueueSetContainer != NULL )
BFD03BF2  0018FC5E   LW V0, 24(S8)
BFD03BF6  004CFC42   LW V0, 76(V0)
BFD03BFA  001040E2   BEQZC V0, 0xBFD03C1E
1898:                				{
1899:                					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
BFD03BFE  0018FC9E   LW A0, 24(S8)
BFD03C02      0CA0   MOVE A1, ZERO
BFD03C04  21D877E8   JALS prvNotifyQueueSetContainer
BFD03C06  0C0021D8   LWC2 T6, 3072(T8)
BFD03C08      0C00   NOP
BFD03C0A      0C62   MOVE V1, V0
BFD03C0C      ED01   LI V0, 1
BFD03C0E  0018B443   BNE V1, V0, 0xBFD03C42
BFD03C10  0C000018   SLL ZERO, T8, 1
BFD03C12      0C00   NOP
1900:                					{
1901:                						/* The queue is a member of a queue set, and posting to
1902:                						the queue set caused a higher priority task to unblock.
1903:                						A context switch is required. */
1904:                						vTaskMissedYield();
BFD03C14  4F2A77E8   JALS vTaskMissedYield
BFD03C16      4F2A   ADDIU T9, T9, 5
BFD03C18      0C00   NOP
BFD03C1A      CC13   B 0xBFD03C42
BFD03C1C      0C00   NOP
1905:                					}
1906:                					else
1907:                					{
1908:                						mtCOVERAGE_TEST_MARKER();
1909:                					}
1910:                				}
1911:                				else
1912:                				{
1913:                					/* Tasks that are removed from the event list will get added to
1914:                					the pending ready list as the scheduler is still suspended. */
1915:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
BFD03C1E  0018FC5E   LW V0, 24(S8)
BFD03C22      6929   LW V0, 36(V0)
BFD03C24  001F40E2   BEQZC V0, 0xBFD03C66
1916:                					{
1917:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
BFD03C28  0018FC5E   LW V0, 24(S8)
BFD03C2C  00243042   ADDIU V0, V0, 36
BFD03C30      0C82   MOVE A0, V0
BFD03C32  22BC77E8   JALS xTaskRemoveFromEventList
BFD03C34  0C0022BC   LWC2 S5, 3072(GP)
BFD03C36      0C00   NOP
BFD03C38  000340E2   BEQZC V0, 0xBFD03C42
1918:                						{
1919:                							/* The task waiting has a higher priority so record that a
1920:                							context	switch is required. */
1921:                							vTaskMissedYield();
BFD03C3C  4F2A77E8   JALS vTaskMissedYield
BFD03C3E      4F2A   ADDIU T9, T9, 5
BFD03C40      0C00   NOP
1922:                						}
1923:                						else
1924:                						{
1925:                							mtCOVERAGE_TEST_MARKER();
1926:                						}
1927:                					}
1928:                					else
1929:                					{
1930:                						break;
BFD03C66      0C00   NOP
1931:                					}
1932:                				}
1933:                			}
1934:                			#else /* configUSE_QUEUE_SETS */
1935:                			{
1936:                				/* Tasks that are removed from the event list will get added to
1937:                				the pending ready list as the scheduler is still suspended. */
1938:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1939:                				{
1940:                					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1941:                					{
1942:                						/* The task waiting has a higher priority so record that a
1943:                						context	switch is required. */
1944:                						vTaskMissedYield();
1945:                					}
1946:                					else
1947:                					{
1948:                						mtCOVERAGE_TEST_MARKER();
1949:                					}
1950:                				}
1951:                				else
1952:                				{
1953:                					break;
1954:                				}
1955:                			}
1956:                			#endif /* configUSE_QUEUE_SETS */
1957:                
1958:                			--( pxQueue->xTxLock );
BFD03C42  0018FC5E   LW V0, 24(S8)
BFD03C46  0048FC42   LW V0, 72(V0)
BFD03C4A      6DAE   ADDIU V1, V0, -1
BFD03C4C  0018FC5E   LW V0, 24(S8)
BFD03C50  0048F862   SW V1, 72(V0)
1959:                		}
1960:                
1961:                		pxQueue->xTxLock = queueUNLOCKED;
BFD03C68  0018FC5E   LW V0, 24(S8)
BFD03C6C      EDFF   LI V1, -1
BFD03C6E  0048F862   SW V1, 72(V0)
1962:                	}
1963:                	taskEXIT_CRITICAL();
BFD03C72  40AA77E8   JALS vTaskExitCritical
BFD03C74  0C0040AA   BNEZC T2, 0xBFD05478
BFD03C76      0C00   NOP
1964:                
1965:                	/* Do the same for the Rx lock. */
1966:                	taskENTER_CRITICAL();
BFD03C78  33B877E8   JALS vTaskEnterCritical
BFD03C7A  0C0033B8   ADDIU SP, T8, 3072
BFD03C7C      0C00   NOP
1967:                	{
1968:                		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
BFD03C7E      CC1B   B 0xBFD03CB6
BFD03C80      0C00   NOP
BFD03CB6  0018FC5E   LW V0, 24(S8)
BFD03CBA  0044FC42   LW V0, 68(V0)
BFD03CBE  FFE040C2   BGTZ V0, 0xBFD03C82
BFD03CC0  0C00FFE0   LW RA, 3072(ZERO)
BFD03CC2      0C00   NOP
BFD03CC4      CC02   B 0xBFD03CCA
BFD03CC6      0C00   NOP
1969:                		{
1970:                			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
BFD03C82  0018FC5E   LW V0, 24(S8)
BFD03C86      6924   LW V0, 16(V0)
BFD03C88  001E40E2   BEQZC V0, 0xBFD03CC8
1971:                			{
1972:                				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
BFD03C8C  0018FC5E   LW V0, 24(S8)
BFD03C90      6D28   ADDIU V0, V0, 16
BFD03C92      0C82   MOVE A0, V0
BFD03C94  22BC77E8   JALS xTaskRemoveFromEventList
BFD03C96  0C0022BC   LWC2 S5, 3072(GP)
BFD03C98      0C00   NOP
BFD03C9A  000340E2   BEQZC V0, 0xBFD03CA4
1973:                				{
1974:                					vTaskMissedYield();
BFD03C9E  4F2A77E8   JALS vTaskMissedYield
BFD03CA0      4F2A   ADDIU T9, T9, 5
BFD03CA2      0C00   NOP
1975:                				}
1976:                				else
1977:                				{
1978:                					mtCOVERAGE_TEST_MARKER();
1979:                				}
1980:                
1981:                				--( pxQueue->xRxLock );
BFD03CA4  0018FC5E   LW V0, 24(S8)
BFD03CA8  0044FC42   LW V0, 68(V0)
BFD03CAC      6DAE   ADDIU V1, V0, -1
BFD03CAE  0018FC5E   LW V0, 24(S8)
BFD03CB2  0044F862   SW V1, 68(V0)
1982:                			}
1983:                			else
1984:                			{
1985:                				break;
BFD03CC8      0C00   NOP
1986:                			}
1987:                		}
1988:                
1989:                		pxQueue->xRxLock = queueUNLOCKED;
BFD03CCA  0018FC5E   LW V0, 24(S8)
BFD03CCE      EDFF   LI V1, -1
BFD03CD0  0044F862   SW V1, 68(V0)
1990:                	}
1991:                	taskEXIT_CRITICAL();
BFD03CD4  40AA77E8   JALS vTaskExitCritical
BFD03CD6  0C0040AA   BNEZC T2, 0xBFD054DA
BFD03CD8      0C00   NOP
1992:                }
BFD03CDA      0FBE   MOVE SP, S8
BFD03CDC      4BE5   LW RA, 20(SP)
BFD03CDE      4BC4   LW S8, 16(SP)
BFD03CE0      4C0D   ADDIU SP, SP, 24
BFD03CE2      459F   JR16 RA
BFD03CE4      0C00   NOP
1993:                /*-----------------------------------------------------------*/
1994:                
1995:                static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1996:                {
BFD093A0      4FF1   ADDIU SP, SP, -32
BFD093A2      CBE7   SW RA, 28(SP)
BFD093A4      CBC6   SW S8, 24(SP)
BFD093A6      0FDD   MOVE S8, SP
BFD093A8  0020F89E   SW A0, 32(S8)
1997:                BaseType_t xReturn;
1998:                
1999:                	taskENTER_CRITICAL();
BFD093AC  33B877E8   JALS vTaskEnterCritical
BFD093AE  0C0033B8   ADDIU SP, T8, 3072
BFD093B0      0C00   NOP
2000:                	{
2001:                		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
BFD093B2  0020FC5E   LW V0, 32(S8)
BFD093B6      692E   LW V0, 56(V0)
BFD093B8  000540A2   BNEZC V0, 0xBFD093C6
2002:                		{
2003:                			xReturn = pdTRUE;
BFD093BC      ED01   LI V0, 1
BFD093BE  0010F85E   SW V0, 16(S8)
BFD093C2      CC03   B 0xBFD093CA
BFD093C4      0C00   NOP
2004:                		}
2005:                		else
2006:                		{
2007:                			xReturn = pdFALSE;
BFD093C6  0010F81E   SW ZERO, 16(S8)
2008:                		}
2009:                	}
2010:                	taskEXIT_CRITICAL();
BFD093CA  40AA77E8   JALS vTaskExitCritical
BFD093CC  0C0040AA   BNEZC T2, 0xBFD0ABD0
BFD093CE      0C00   NOP
2011:                
2012:                	return xReturn;
BFD093D0  0010FC5E   LW V0, 16(S8)
2013:                }
BFD093D4      0FBE   MOVE SP, S8
BFD093D6      4BE7   LW RA, 28(SP)
BFD093D8      4BC6   LW S8, 24(SP)
BFD093DA      4C11   ADDIU SP, SP, 32
BFD093DC      459F   JR16 RA
BFD093DE      0C00   NOP
2014:                /*-----------------------------------------------------------*/
2015:                
2016:                BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2017:                {
BFD08954      4FF1   ADDIU SP, SP, -32
BFD08956      CBE7   SW RA, 28(SP)
BFD08958      CBC6   SW S8, 24(SP)
BFD0895A      0FDD   MOVE S8, SP
BFD0895C  0020F89E   SW A0, 32(S8)
2018:                BaseType_t xReturn;
2019:                
2020:                	configASSERT( xQueue );
BFD08960  0020FC5E   LW V0, 32(S8)
BFD08964  000940A2   BNEZC V0, 0xBFD0897A
BFD08968  BFD141A2   LUI V0, 0xBFD1
BFD0896A  3082BFD1   LDC1 F30, 12418(S1)
BFD0896C  9E3C3082   ADDIU A0, V0, -25028
BFD0896E  30A09E3C   LWC1 F17, 12448(GP)
BFD08970  07E430A0   ADDIU A1, ZERO, 2020
BFD08972      07E4   ADDU A3, V0, A2
BFD08974  4B7E77E8   JALS vAssertCalled
BFD08976      4B7E   LW K1, 120(SP)
BFD08978      0C00   NOP
2021:                	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
BFD0897A  0020FC5E   LW V0, 32(S8)
BFD0897E      692E   LW V0, 56(V0)
BFD08980  000540A2   BNEZC V0, 0xBFD0898E
2022:                	{
2023:                		xReturn = pdTRUE;
BFD08984      ED01   LI V0, 1
BFD08986  0010F85E   SW V0, 16(S8)
BFD0898A      CC03   B 0xBFD08992
BFD0898C      0C00   NOP
2024:                	}
2025:                	else
2026:                	{
2027:                		xReturn = pdFALSE;
BFD0898E  0010F81E   SW ZERO, 16(S8)
2028:                	}
2029:                
2030:                	return xReturn;
BFD08992  0010FC5E   LW V0, 16(S8)
2031:                } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
BFD08996      0FBE   MOVE SP, S8
BFD08998      4BE7   LW RA, 28(SP)
BFD0899A      4BC6   LW S8, 24(SP)
BFD0899C      4C11   ADDIU SP, SP, 32
BFD0899E      459F   JR16 RA
BFD089A0      0C00   NOP
2032:                /*-----------------------------------------------------------*/
2033:                
2034:                static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2035:                {
BFD08F04      4FF1   ADDIU SP, SP, -32
BFD08F06      CBE7   SW RA, 28(SP)
BFD08F08      CBC6   SW S8, 24(SP)
BFD08F0A      0FDD   MOVE S8, SP
BFD08F0C  0020F89E   SW A0, 32(S8)
2036:                BaseType_t xReturn;
2037:                
2038:                	taskENTER_CRITICAL();
BFD08F10  33B877E8   JALS vTaskEnterCritical
BFD08F12  0C0033B8   ADDIU SP, T8, 3072
BFD08F14      0C00   NOP
2039:                	{
2040:                		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
BFD08F16  0020FC5E   LW V0, 32(S8)
BFD08F1A      69AE   LW V1, 56(V0)
BFD08F1C  0020FC5E   LW V0, 32(S8)
BFD08F20      692F   LW V0, 60(V0)
BFD08F22  0006B443   BNE V1, V0, 0xBFD08F32
BFD08F24  0C000006   SLL ZERO, A2, 1
BFD08F26      0C00   NOP
2041:                		{
2042:                			xReturn = pdTRUE;
BFD08F28      ED01   LI V0, 1
BFD08F2A  0010F85E   SW V0, 16(S8)
BFD08F2E      CC03   B 0xBFD08F36
BFD08F30      0C00   NOP
2043:                		}
2044:                		else
2045:                		{
2046:                			xReturn = pdFALSE;
BFD08F32  0010F81E   SW ZERO, 16(S8)
2047:                		}
2048:                	}
2049:                	taskEXIT_CRITICAL();
BFD08F36  40AA77E8   JALS vTaskExitCritical
BFD08F38  0C0040AA   BNEZC T2, 0xBFD0A73C
BFD08F3A      0C00   NOP
2050:                
2051:                	return xReturn;
BFD08F3C  0010FC5E   LW V0, 16(S8)
2052:                }
BFD08F40      0FBE   MOVE SP, S8
BFD08F42      4BE7   LW RA, 28(SP)
BFD08F44      4BC6   LW S8, 24(SP)
BFD08F46      4C11   ADDIU SP, SP, 32
BFD08F48      459F   JR16 RA
BFD08F4A      0C00   NOP
2053:                /*-----------------------------------------------------------*/
2054:                
2055:                BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2056:                {
BFD084F8      4FF1   ADDIU SP, SP, -32
BFD084FA      CBE7   SW RA, 28(SP)
BFD084FC      CBC6   SW S8, 24(SP)
BFD084FE      0FDD   MOVE S8, SP
BFD08500  0020F89E   SW A0, 32(S8)
2057:                BaseType_t xReturn;
2058:                
2059:                	configASSERT( xQueue );
BFD08504  0020FC5E   LW V0, 32(S8)
BFD08508  000940A2   BNEZC V0, 0xBFD0851E
BFD0850C  BFD141A2   LUI V0, 0xBFD1
BFD0850E  3082BFD1   LDC1 F30, 12418(S1)
BFD08510  9E3C3082   ADDIU A0, V0, -25028
BFD08512  30A09E3C   LWC1 F17, 12448(GP)
BFD08514  080B30A0   ADDIU A1, ZERO, 2059
BFD08516      080B   LBU S0, 11(S0)
BFD08518  4B7E77E8   JALS vAssertCalled
BFD0851A      4B7E   LW K1, 120(SP)
BFD0851C      0C00   NOP
2060:                	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
BFD0851E  0020FC5E   LW V0, 32(S8)
BFD08522      69AE   LW V1, 56(V0)
BFD08524  0020FC5E   LW V0, 32(S8)
BFD08528      692F   LW V0, 60(V0)
BFD0852A  0006B443   BNE V1, V0, 0xBFD0853A
BFD0852C  0C000006   SLL ZERO, A2, 1
BFD0852E      0C00   NOP
2061:                	{
2062:                		xReturn = pdTRUE;
BFD08530      ED01   LI V0, 1
BFD08532  0010F85E   SW V0, 16(S8)
BFD08536      CC03   B 0xBFD0853E
BFD08538      0C00   NOP
2063:                	}
2064:                	else
2065:                	{
2066:                		xReturn = pdFALSE;
BFD0853A  0010F81E   SW ZERO, 16(S8)
2067:                	}
2068:                
2069:                	return xReturn;
BFD0853E  0010FC5E   LW V0, 16(S8)
2070:                } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
BFD08542      0FBE   MOVE SP, S8
BFD08544      4BE7   LW RA, 28(SP)
BFD08546      4BC6   LW S8, 24(SP)
BFD08548      4C11   ADDIU SP, SP, 32
BFD0854A      459F   JR16 RA
BFD0854C      0C00   NOP
2071:                /*-----------------------------------------------------------*/
2072:                
2073:                #if ( configUSE_CO_ROUTINES == 1 )
2074:                
2075:                	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
2076:                	{
2077:                	BaseType_t xReturn;
2078:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2079:                
2080:                		/* If the queue is already full we may have to block.  A critical section
2081:                		is required to prevent an interrupt removing something from the queue
2082:                		between the check to see if the queue is full and blocking on the queue. */
2083:                		portDISABLE_INTERRUPTS();
2084:                		{
2085:                			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2086:                			{
2087:                				/* The queue is full - do we want to block or just leave without
2088:                				posting? */
2089:                				if( xTicksToWait > ( TickType_t ) 0 )
2090:                				{
2091:                					/* As this is called from a coroutine we cannot block directly, but
2092:                					return indicating that we need to block. */
2093:                					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2094:                					portENABLE_INTERRUPTS();
2095:                					return errQUEUE_BLOCKED;
2096:                				}
2097:                				else
2098:                				{
2099:                					portENABLE_INTERRUPTS();
2100:                					return errQUEUE_FULL;
2101:                				}
2102:                			}
2103:                		}
2104:                		portENABLE_INTERRUPTS();
2105:                
2106:                		portDISABLE_INTERRUPTS();
2107:                		{
2108:                			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2109:                			{
2110:                				/* There is room in the queue, copy the data into the queue. */
2111:                				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2112:                				xReturn = pdPASS;
2113:                
2114:                				/* Were any co-routines waiting for data to become available? */
2115:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2116:                				{
2117:                					/* In this instance the co-routine could be placed directly
2118:                					into the ready list as we are within a critical section.
2119:                					Instead the same pending ready list mechanism is used as if
2120:                					the event were caused from within an interrupt. */
2121:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2122:                					{
2123:                						/* The co-routine waiting has a higher priority so record
2124:                						that a yield might be appropriate. */
2125:                						xReturn = errQUEUE_YIELD;
2126:                					}
2127:                					else
2128:                					{
2129:                						mtCOVERAGE_TEST_MARKER();
2130:                					}
2131:                				}
2132:                				else
2133:                				{
2134:                					mtCOVERAGE_TEST_MARKER();
2135:                				}
2136:                			}
2137:                			else
2138:                			{
2139:                				xReturn = errQUEUE_FULL;
2140:                			}
2141:                		}
2142:                		portENABLE_INTERRUPTS();
2143:                
2144:                		return xReturn;
2145:                	}
2146:                
2147:                #endif /* configUSE_CO_ROUTINES */
2148:                /*-----------------------------------------------------------*/
2149:                
2150:                #if ( configUSE_CO_ROUTINES == 1 )
2151:                
2152:                	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2153:                	{
2154:                	BaseType_t xReturn;
2155:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2156:                
2157:                		/* If the queue is already empty we may have to block.  A critical section
2158:                		is required to prevent an interrupt adding something to the queue
2159:                		between the check to see if the queue is empty and blocking on the queue. */
2160:                		portDISABLE_INTERRUPTS();
2161:                		{
2162:                			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2163:                			{
2164:                				/* There are no messages in the queue, do we want to block or just
2165:                				leave with nothing? */
2166:                				if( xTicksToWait > ( TickType_t ) 0 )
2167:                				{
2168:                					/* As this is a co-routine we cannot block directly, but return
2169:                					indicating that we need to block. */
2170:                					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2171:                					portENABLE_INTERRUPTS();
2172:                					return errQUEUE_BLOCKED;
2173:                				}
2174:                				else
2175:                				{
2176:                					portENABLE_INTERRUPTS();
2177:                					return errQUEUE_FULL;
2178:                				}
2179:                			}
2180:                			else
2181:                			{
2182:                				mtCOVERAGE_TEST_MARKER();
2183:                			}
2184:                		}
2185:                		portENABLE_INTERRUPTS();
2186:                
2187:                		portDISABLE_INTERRUPTS();
2188:                		{
2189:                			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2190:                			{
2191:                				/* Data is available from the queue. */
2192:                				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2193:                				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2194:                				{
2195:                					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2196:                				}
2197:                				else
2198:                				{
2199:                					mtCOVERAGE_TEST_MARKER();
2200:                				}
2201:                				--( pxQueue->uxMessagesWaiting );
2202:                				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
2203:                
2204:                				xReturn = pdPASS;
2205:                
2206:                				/* Were any co-routines waiting for space to become available? */
2207:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2208:                				{
2209:                					/* In this instance the co-routine could be placed directly
2210:                					into the ready list as we are within a critical section.
2211:                					Instead the same pending ready list mechanism is used as if
2212:                					the event were caused from within an interrupt. */
2213:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2214:                					{
2215:                						xReturn = errQUEUE_YIELD;
2216:                					}
2217:                					else
2218:                					{
2219:                						mtCOVERAGE_TEST_MARKER();
2220:                					}
2221:                				}
2222:                				else
2223:                				{
2224:                					mtCOVERAGE_TEST_MARKER();
2225:                				}
2226:                			}
2227:                			else
2228:                			{
2229:                				xReturn = pdFAIL;
2230:                			}
2231:                		}
2232:                		portENABLE_INTERRUPTS();
2233:                
2234:                		return xReturn;
2235:                	}
2236:                
2237:                #endif /* configUSE_CO_ROUTINES */
2238:                /*-----------------------------------------------------------*/
2239:                
2240:                #if ( configUSE_CO_ROUTINES == 1 )
2241:                
2242:                	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
2243:                	{
2244:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2245:                
2246:                		/* Cannot block within an ISR so if there is no space on the queue then
2247:                		exit without doing anything. */
2248:                		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2249:                		{
2250:                			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2251:                
2252:                			/* We only want to wake one co-routine per ISR, so check that a
2253:                			co-routine has not already been woken. */
2254:                			if( xCoRoutinePreviouslyWoken == pdFALSE )
2255:                			{
2256:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2257:                				{
2258:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2259:                					{
2260:                						return pdTRUE;
2261:                					}
2262:                					else
2263:                					{
2264:                						mtCOVERAGE_TEST_MARKER();
2265:                					}
2266:                				}
2267:                				else
2268:                				{
2269:                					mtCOVERAGE_TEST_MARKER();
2270:                				}
2271:                			}
2272:                			else
2273:                			{
2274:                				mtCOVERAGE_TEST_MARKER();
2275:                			}
2276:                		}
2277:                		else
2278:                		{
2279:                			mtCOVERAGE_TEST_MARKER();
2280:                		}
2281:                
2282:                		return xCoRoutinePreviouslyWoken;
2283:                	}
2284:                
2285:                #endif /* configUSE_CO_ROUTINES */
2286:                /*-----------------------------------------------------------*/
2287:                
2288:                #if ( configUSE_CO_ROUTINES == 1 )
2289:                
2290:                	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
2291:                	{
2292:                	BaseType_t xReturn;
2293:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2294:                
2295:                		/* We cannot block from an ISR, so check there is data available. If
2296:                		not then just leave without doing anything. */
2297:                		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2298:                		{
2299:                			/* Copy the data from the queue. */
2300:                			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2301:                			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2302:                			{
2303:                				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2304:                			}
2305:                			else
2306:                			{
2307:                				mtCOVERAGE_TEST_MARKER();
2308:                			}
2309:                			--( pxQueue->uxMessagesWaiting );
2310:                			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
2311:                
2312:                			if( ( *pxCoRoutineWoken ) == pdFALSE )
2313:                			{
2314:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2315:                				{
2316:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2317:                					{
2318:                						*pxCoRoutineWoken = pdTRUE;
2319:                					}
2320:                					else
2321:                					{
2322:                						mtCOVERAGE_TEST_MARKER();
2323:                					}
2324:                				}
2325:                				else
2326:                				{
2327:                					mtCOVERAGE_TEST_MARKER();
2328:                				}
2329:                			}
2330:                			else
2331:                			{
2332:                				mtCOVERAGE_TEST_MARKER();
2333:                			}
2334:                
2335:                			xReturn = pdPASS;
2336:                		}
2337:                		else
2338:                		{
2339:                			xReturn = pdFAIL;
2340:                		}
2341:                
2342:                		return xReturn;
2343:                	}
2344:                
2345:                #endif /* configUSE_CO_ROUTINES */
2346:                /*-----------------------------------------------------------*/
2347:                
2348:                #if ( configQUEUE_REGISTRY_SIZE > 0 )
2349:                
2350:                	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2351:                	{
2352:                	UBaseType_t ux;
2353:                
2354:                		/* See if there is an empty space in the registry.  A NULL name denotes
2355:                		a free slot. */
2356:                		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2357:                		{
2358:                			if( xQueueRegistry[ ux ].pcQueueName == NULL )
2359:                			{
2360:                				/* Store the information on this queue. */
2361:                				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
2362:                				xQueueRegistry[ ux ].xHandle = xQueue;
2363:                
2364:                				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2365:                				break;
2366:                			}
2367:                			else
2368:                			{
2369:                				mtCOVERAGE_TEST_MARKER();
2370:                			}
2371:                		}
2372:                	}
2373:                
2374:                #endif /* configQUEUE_REGISTRY_SIZE */
2375:                /*-----------------------------------------------------------*/
2376:                
2377:                #if ( configQUEUE_REGISTRY_SIZE > 0 )
2378:                
2379:                	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2380:                	{
2381:                	UBaseType_t ux;
2382:                
2383:                		/* See if the handle of the queue being unregistered in actually in the
2384:                		registry. */
2385:                		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2386:                		{
2387:                			if( xQueueRegistry[ ux ].xHandle == xQueue )
2388:                			{
2389:                				/* Set the name to NULL to show that this slot if free again. */
2390:                				xQueueRegistry[ ux ].pcQueueName = NULL;
2391:                				break;
2392:                			}
2393:                			else
2394:                			{
2395:                				mtCOVERAGE_TEST_MARKER();
2396:                			}
2397:                		}
2398:                
2399:                	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2400:                
2401:                #endif /* configQUEUE_REGISTRY_SIZE */
2402:                /*-----------------------------------------------------------*/
2403:                
2404:                #if ( configUSE_TIMERS == 1 )
2405:                
2406:                	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2407:                	{
BFD06928      4FF1   ADDIU SP, SP, -32
BFD0692A      CBE7   SW RA, 28(SP)
BFD0692C      CBC6   SW S8, 24(SP)
BFD0692E      0FDD   MOVE S8, SP
BFD06930  0020F89E   SW A0, 32(S8)
BFD06934  0024F8BE   SW A1, 36(S8)
BFD06938  0028F8DE   SW A2, 40(S8)
2408:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
BFD0693C  0020FC5E   LW V0, 32(S8)
BFD06940  0010F85E   SW V0, 16(S8)
2409:                
2410:                		/* This function should not be called by application code hence the
2411:                		'Restricted' in its name.  It is not part of the public API.  It is
2412:                		designed for use by kernel code, and has special calling requirements.
2413:                		It can result in vListInsert() being called on a list that can only
2414:                		possibly ever have one item in it, so the list will be fast, but even
2415:                		so it should be called with the scheduler locked and not from a critical
2416:                		section. */
2417:                
2418:                		/* Only do anything if there are no messages in the queue.  This function
2419:                		will not actually cause the task to block, just place it on a blocked
2420:                		list.  It will not block until the scheduler is unlocked - at which
2421:                		time a yield will be performed.  If an item is added to the queue while
2422:                		the queue is locked, and the calling task blocks on the queue, then the
2423:                		calling task will be immediately unblocked when the queue is unlocked. */
2424:                		prvLockQueue( pxQueue );
BFD06944  33B877E8   JALS vTaskEnterCritical
BFD06946  0C0033B8   ADDIU SP, T8, 3072
BFD06948      0C00   NOP
BFD0694A  0010FC5E   LW V0, 16(S8)
BFD0694E  0044FC62   LW V1, 68(V0)
BFD06952      ED7F   LI V0, -1
BFD06954  0005B443   BNE V1, V0, 0xBFD06962
BFD06956  0C000005   SLL ZERO, A1, 1
BFD06958      0C00   NOP
BFD0695A  0010FC5E   LW V0, 16(S8)
BFD0695E  0044F802   SW ZERO, 68(V0)
BFD06962  0010FC5E   LW V0, 16(S8)
BFD06966  0048FC62   LW V1, 72(V0)
BFD0696A      ED7F   LI V0, -1
BFD0696C  0005B443   BNE V1, V0, 0xBFD0697A
BFD0696E  0C000005   SLL ZERO, A1, 1
BFD06970      0C00   NOP
BFD06972  0010FC5E   LW V0, 16(S8)
BFD06976  0048F802   SW ZERO, 72(V0)
BFD0697A  40AA77E8   JALS vTaskExitCritical
BFD0697C  0C0040AA   BNEZC T2, 0xBFD08180
BFD0697E      0C00   NOP
2425:                		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
BFD06980  0010FC5E   LW V0, 16(S8)
BFD06984      692E   LW V0, 56(V0)
BFD06986  000C40A2   BNEZC V0, 0xBFD069A2
2426:                		{
2427:                			/* There is nothing in the queue, block for the specified period. */
2428:                			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
BFD0698A  0010FC5E   LW V0, 16(S8)
BFD0698E  00243042   ADDIU V0, V0, 36
BFD06992      0C82   MOVE A0, V0
BFD06994  0024FCBE   LW A1, 36(S8)
BFD06998  0028FCDE   LW A2, 40(S8)
BFD0699C  2E2C77E8   JALS vTaskPlaceOnEventListRestricted
BFD0699E      2E2C   ANDI A0, V0, 0x40
BFD069A0      0C00   NOP
2429:                		}
2430:                		else
2431:                		{
2432:                			mtCOVERAGE_TEST_MARKER();
2433:                		}
2434:                		prvUnlockQueue( pxQueue );
BFD069A2  0010FC9E   LW A0, 16(S8)
BFD069A6  1DEE77E8   JALS prvUnlockQueue
BFD069A8  0C001DEE   LB T7, 3072(T6)
BFD069AA      0C00   NOP
2435:                	}
BFD069AC      0FBE   MOVE SP, S8
BFD069AE      4BE7   LW RA, 28(SP)
BFD069B0      4BC6   LW S8, 24(SP)
BFD069B2      4C11   ADDIU SP, SP, 32
BFD069B4      459F   JR16 RA
BFD069B6      0C00   NOP
2436:                
2437:                #endif /* configUSE_TIMERS */
2438:                /*-----------------------------------------------------------*/
2439:                
2440:                #if ( configUSE_QUEUE_SETS == 1 )
2441:                
2442:                	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
2443:                	{
BFD098AC      4FF1   ADDIU SP, SP, -32
BFD098AE      CBE7   SW RA, 28(SP)
BFD098B0      CBC6   SW S8, 24(SP)
BFD098B2      0FDD   MOVE S8, SP
BFD098B4  0020F89E   SW A0, 32(S8)
2444:                	QueueSetHandle_t pxQueue;
2445:                
2446:                		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
BFD098B8  0020FC9E   LW A0, 32(S8)
BFD098BC      EE84   LI A1, 4
BFD098BE      0CC0   MOVE A2, ZERO
BFD098C0  1EFA77E8   JALS xQueueGenericCreate
BFD098C2  0C001EFA   LB S7, 3072(K0)
BFD098C4      0C00   NOP
BFD098C6  0010F85E   SW V0, 16(S8)
2447:                
2448:                		return pxQueue;
BFD098CA  0010FC5E   LW V0, 16(S8)
2449:                	}
BFD098CE      0FBE   MOVE SP, S8
BFD098D0      4BE7   LW RA, 28(SP)
BFD098D2      4BC6   LW S8, 24(SP)
BFD098D4      4C11   ADDIU SP, SP, 32
BFD098D6      459F   JR16 RA
BFD098D8      0C00   NOP
2450:                
2451:                #endif /* configUSE_QUEUE_SETS */
2452:                /*-----------------------------------------------------------*/
2453:                
2454:                #if ( configUSE_QUEUE_SETS == 1 )
2455:                
2456:                	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2457:                	{
BFD07E9C      4FF1   ADDIU SP, SP, -32
BFD07E9E      CBE7   SW RA, 28(SP)
BFD07EA0      CBC6   SW S8, 24(SP)
BFD07EA2      0FDD   MOVE S8, SP
BFD07EA4  0020F89E   SW A0, 32(S8)
BFD07EA8  0024F8BE   SW A1, 36(S8)
2458:                	BaseType_t xReturn;
2459:                
2460:                		taskENTER_CRITICAL();
BFD07EAC  33B877E8   JALS vTaskEnterCritical
BFD07EAE  0C0033B8   ADDIU SP, T8, 3072
BFD07EB0      0C00   NOP
2461:                		{
2462:                			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
BFD07EB2  0020FC5E   LW V0, 32(S8)
BFD07EB6  004CFC42   LW V0, 76(V0)
BFD07EBA  000440E2   BEQZC V0, 0xBFD07EC6
2463:                			{
2464:                				/* Cannot add a queue/semaphore to more than one queue set. */
2465:                				xReturn = pdFAIL;
BFD07EBE  0010F81E   SW ZERO, 16(S8)
BFD07EC2      CC13   B 0xBFD07EEA
BFD07EC4      0C00   NOP
2466:                			}
2467:                			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
BFD07EC6  0020FC5E   LW V0, 32(S8)
BFD07ECA      692E   LW V0, 56(V0)
BFD07ECC  000440E2   BEQZC V0, 0xBFD07ED8
2468:                			{
2469:                				/* Cannot add a queue/semaphore to a queue set if there are already
2470:                				items in the queue/semaphore. */
2471:                				xReturn = pdFAIL;
BFD07ED0  0010F81E   SW ZERO, 16(S8)
BFD07ED4      CC0A   B 0xBFD07EEA
BFD07ED6      0C00   NOP
2472:                			}
2473:                			else
2474:                			{
2475:                				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
BFD07ED8  0020FC5E   LW V0, 32(S8)
BFD07EDC  0024FC7E   LW V1, 36(S8)
BFD07EE0  004CF862   SW V1, 76(V0)
2476:                				xReturn = pdPASS;
BFD07EE4      ED01   LI V0, 1
BFD07EE6  0010F85E   SW V0, 16(S8)
2477:                			}
2478:                		}
2479:                		taskEXIT_CRITICAL();
BFD07EEA  40AA77E8   JALS vTaskExitCritical
BFD07EEC  0C0040AA   BNEZC T2, 0xBFD096F0
BFD07EEE      0C00   NOP
2480:                
2481:                		return xReturn;
BFD07EF0  0010FC5E   LW V0, 16(S8)
2482:                	}
BFD07EF4      0FBE   MOVE SP, S8
BFD07EF6      4BE7   LW RA, 28(SP)
BFD07EF8      4BC6   LW S8, 24(SP)
BFD07EFA      4C11   ADDIU SP, SP, 32
BFD07EFC      459F   JR16 RA
BFD07EFE      0C00   NOP
2483:                
2484:                #endif /* configUSE_QUEUE_SETS */
2485:                /*-----------------------------------------------------------*/
2486:                
2487:                #if ( configUSE_QUEUE_SETS == 1 )
2488:                
2489:                	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2490:                	{
BFD079FC      4FF1   ADDIU SP, SP, -32
BFD079FE      CBE7   SW RA, 28(SP)
BFD07A00      CBC6   SW S8, 24(SP)
BFD07A02      0FDD   MOVE S8, SP
BFD07A04  0020F89E   SW A0, 32(S8)
BFD07A08  0024F8BE   SW A1, 36(S8)
2491:                	BaseType_t xReturn;
2492:                	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
BFD07A0C  0020FC5E   LW V0, 32(S8)
BFD07A10  0014F85E   SW V0, 20(S8)
2493:                
2494:                		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
BFD07A14  0014FC5E   LW V0, 20(S8)
BFD07A18  004CFC62   LW V1, 76(V0)
BFD07A1C  0024FC5E   LW V0, 36(S8)
BFD07A20  00059443   BEQ V1, V0, 0xBFD07A2E
BFD07A22  0C000005   SLL ZERO, A1, 1
BFD07A24      0C00   NOP
2495:                		{
2496:                			/* The queue was not a member of the set. */
2497:                			xReturn = pdFAIL;
BFD07A26  0010F81E   SW ZERO, 16(S8)
BFD07A2A      CC17   B 0xBFD07A5A
BFD07A2C      0C00   NOP
2498:                		}
2499:                		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
BFD07A2E  0014FC5E   LW V0, 20(S8)
BFD07A32      692E   LW V0, 56(V0)
BFD07A34  000440E2   BEQZC V0, 0xBFD07A40
2500:                		{
2501:                			/* It is dangerous to remove a queue from a set when the queue is
2502:                			not empty because the queue set will still hold pending events for
2503:                			the queue. */
2504:                			xReturn = pdFAIL;
BFD07A38  0010F81E   SW ZERO, 16(S8)
BFD07A3C      CC0E   B 0xBFD07A5A
BFD07A3E      0C00   NOP
2505:                		}
2506:                		else
2507:                		{
2508:                			taskENTER_CRITICAL();
BFD07A40  33B877E8   JALS vTaskEnterCritical
BFD07A42  0C0033B8   ADDIU SP, T8, 3072
BFD07A44      0C00   NOP
2509:                			{
2510:                				/* The queue is no longer contained in the set. */
2511:                				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
BFD07A46  0014FC5E   LW V0, 20(S8)
BFD07A4A  004CF802   SW ZERO, 76(V0)
2512:                			}
2513:                			taskEXIT_CRITICAL();
BFD07A4E  40AA77E8   JALS vTaskExitCritical
BFD07A50  0C0040AA   BNEZC T2, gpio_port_bitmaps
BFD07A52      0C00   NOP
2514:                			xReturn = pdPASS;
BFD07A54      ED01   LI V0, 1
BFD07A56  0010F85E   SW V0, 16(S8)
2515:                		}
2516:                
2517:                		return xReturn;
BFD07A5A  0010FC5E   LW V0, 16(S8)
2518:                	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
BFD07A5E      0FBE   MOVE SP, S8
BFD07A60      4BE7   LW RA, 28(SP)
BFD07A62      4BC6   LW S8, 24(SP)
BFD07A64      4C11   ADDIU SP, SP, 32
BFD07A66      459F   JR16 RA
BFD07A68      0C00   NOP
2519:                
2520:                #endif /* configUSE_QUEUE_SETS */
2521:                /*-----------------------------------------------------------*/
2522:                
2523:                #if ( configUSE_QUEUE_SETS == 1 )
2524:                
2525:                	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
2526:                	{
BFD094E0      4FF1   ADDIU SP, SP, -32
BFD094E2      CBE7   SW RA, 28(SP)
BFD094E4      CBC6   SW S8, 24(SP)
BFD094E6      0FDD   MOVE S8, SP
BFD094E8  0020F89E   SW A0, 32(S8)
BFD094EC  0024F8BE   SW A1, 36(S8)
2527:                	QueueSetMemberHandle_t xReturn = NULL;
BFD094F0  0010F81E   SW ZERO, 16(S8)
2528:                
2529:                		( void ) xQueueGenericReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
BFD094F4  0020FC9E   LW A0, 32(S8)
BFD094F8  0010305E   ADDIU V0, S8, 16
BFD094FC      0CA2   MOVE A1, V0
BFD094FE  0024FCDE   LW A2, 36(S8)
BFD09502      0CE0   MOVE A3, ZERO
BFD09504  081E77E8   JALS xQueueGenericReceive
BFD09506      081E   LBU S0, 14(S1)
BFD09508      0C00   NOP
2530:                		return xReturn;
BFD0950A  0010FC5E   LW V0, 16(S8)
2531:                	}
BFD0950E      0FBE   MOVE SP, S8
BFD09510      4BE7   LW RA, 28(SP)
BFD09512      4BC6   LW S8, 24(SP)
BFD09514      4C11   ADDIU SP, SP, 32
BFD09516      459F   JR16 RA
BFD09518      0C00   NOP
2532:                
2533:                #endif /* configUSE_QUEUE_SETS */
2534:                /*-----------------------------------------------------------*/
2535:                
2536:                #if ( configUSE_QUEUE_SETS == 1 )
2537:                
2538:                	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
2539:                	{
BFD097DC      4FF1   ADDIU SP, SP, -32
BFD097DE      CBE7   SW RA, 28(SP)
BFD097E0      CBC6   SW S8, 24(SP)
BFD097E2      0FDD   MOVE S8, SP
BFD097E4  0020F89E   SW A0, 32(S8)
2540:                	QueueSetMemberHandle_t xReturn = NULL;
BFD097E8  0010F81E   SW ZERO, 16(S8)
2541:                
2542:                		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
BFD097EC  0020FC9E   LW A0, 32(S8)
BFD097F0  0010305E   ADDIU V0, S8, 16
BFD097F4      0CA2   MOVE A1, V0
BFD097F6      0CC0   MOVE A2, ZERO
BFD097F8  1D6477E8   JALS xQueueReceiveFromISR
BFD097FA  0C001D64   LB T3, 3072(A0)
BFD097FC      0C00   NOP
2543:                		return xReturn;
BFD097FE  0010FC5E   LW V0, 16(S8)
2544:                	}
BFD09802      0FBE   MOVE SP, S8
BFD09804      4BE7   LW RA, 28(SP)
BFD09806      4BC6   LW S8, 24(SP)
BFD09808      4C11   ADDIU SP, SP, 32
BFD0980A      459F   JR16 RA
BFD0980C      0C00   NOP
2545:                
2546:                #endif /* configUSE_QUEUE_SETS */
2547:                /*-----------------------------------------------------------*/
2548:                
2549:                #if ( configUSE_QUEUE_SETS == 1 )
2550:                
2551:                	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
2552:                	{
BFD043B0      4FF1   ADDIU SP, SP, -32
BFD043B2      CBE7   SW RA, 28(SP)
BFD043B4      CBC6   SW S8, 24(SP)
BFD043B6      0FDD   MOVE S8, SP
BFD043B8  0020F89E   SW A0, 32(S8)
BFD043BC  0024F8BE   SW A1, 36(S8)
2553:                	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
BFD043C0  0020FC5E   LW V0, 32(S8)
BFD043C4  004CFC42   LW V0, 76(V0)
BFD043C8  0014F85E   SW V0, 20(S8)
2554:                	BaseType_t xReturn = pdFALSE;
BFD043CC  0010F81E   SW ZERO, 16(S8)
2555:                
2556:                		/* This function must be called form a critical section. */
2557:                
2558:                		configASSERT( pxQueueSetContainer );
BFD043D0  0014FC5E   LW V0, 20(S8)
BFD043D4  000940A2   BNEZC V0, 0xBFD043EA
BFD043D8  BFD141A2   LUI V0, 0xBFD1
BFD043DA  3082BFD1   LDC1 F30, 12418(S1)
BFD043DC  9E3C3082   ADDIU A0, V0, -25028
BFD043DE  30A09E3C   LWC1 F17, 12448(GP)
BFD043E0  09FE30A0   ADDIU A1, ZERO, 2558
BFD043E2      09FE   LBU V1, 14(A3)
BFD043E4  4B7E77E8   JALS vAssertCalled
BFD043E6      4B7E   LW K1, 120(SP)
BFD043E8      0C00   NOP
2559:                		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
BFD043EA  0014FC5E   LW V0, 20(S8)
BFD043EE      69AE   LW V1, 56(V0)
BFD043F0  0014FC5E   LW V0, 20(S8)
BFD043F4      692F   LW V0, 60(V0)
BFD043F6  13900043   SLTU V0, V1, V0
BFD043F8  40A21390   ADDI GP, S0, 16546
BFD043FA  000940A2   BNEZC V0, 0xBFD04410
BFD043FE  BFD141A2   LUI V0, 0xBFD1
BFD04400  3082BFD1   LDC1 F30, 12418(S1)
BFD04402  9E3C3082   ADDIU A0, V0, -25028
BFD04404  30A09E3C   LWC1 F17, 12448(GP)
BFD04406  09FF30A0   ADDIU A1, ZERO, 2559
BFD04408      09FF   LBU V1, -1(A3)
BFD0440A  4B7E77E8   JALS vAssertCalled
BFD0440C      4B7E   LW K1, 120(SP)
BFD0440E      0C00   NOP
2560:                
2561:                		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
BFD04410  0014FC5E   LW V0, 20(S8)
BFD04414      69AE   LW V1, 56(V0)
BFD04416  0014FC5E   LW V0, 20(S8)
BFD0441A      692F   LW V0, 60(V0)
BFD0441C  13900043   SLTU V0, V1, V0
BFD0441E  40E21390   ADDI GP, S0, 16610
BFD04420  003040E2   BEQZC V0, 0xBFD04484
2562:                		{
2563:                			traceQUEUE_SEND( pxQueueSetContainer );
2564:                
2565:                			/* The data copied is the handle of the queue that contains data. */
2566:                			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
BFD04424  0014FC9E   LW A0, 20(S8)
BFD04428  002030BE   ADDIU A1, S8, 32
BFD0442C  0024FCDE   LW A2, 36(S8)
BFD04430  14E677E8   JALS prvCopyDataToQueue
BFD04432  0C0014E6   LBU A3, 3072(A2)
BFD04434      0C00   NOP
BFD04436  0010F85E   SW V0, 16(S8)
2567:                
2568:                			if( pxQueueSetContainer->xTxLock == queueUNLOCKED )
BFD0443A  0014FC5E   LW V0, 20(S8)
BFD0443E  0048FC62   LW V1, 72(V0)
BFD04442      ED7F   LI V0, -1
BFD04444  0015B443   BNE V1, V0, 0xBFD04472
BFD04446  0C000015   SLL ZERO, S5, 1
BFD04448      0C00   NOP
2569:                			{
2570:                				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
BFD0444A  0014FC5E   LW V0, 20(S8)
BFD0444E      6929   LW V0, 36(V0)
BFD04450  001840E2   BEQZC V0, 0xBFD04484
2571:                				{
2572:                					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
BFD04454  0014FC5E   LW V0, 20(S8)
BFD04458  00243042   ADDIU V0, V0, 36
BFD0445C      0C82   MOVE A0, V0
BFD0445E  22BC77E8   JALS xTaskRemoveFromEventList
BFD04460  0C0022BC   LWC2 S5, 3072(GP)
BFD04462      0C00   NOP
BFD04464  000E40E2   BEQZC V0, 0xBFD04484
2573:                					{
2574:                						/* The task waiting has a higher priority. */
2575:                						xReturn = pdTRUE;
BFD04468      ED01   LI V0, 1
BFD0446A  0010F85E   SW V0, 16(S8)
BFD0446E      CC0A   B 0xBFD04484
BFD04470      0C00   NOP
2576:                					}
2577:                					else
2578:                					{
2579:                						mtCOVERAGE_TEST_MARKER();
2580:                					}
2581:                				}
2582:                				else
2583:                				{
2584:                					mtCOVERAGE_TEST_MARKER();
2585:                				}
2586:                			}
2587:                			else
2588:                			{
2589:                				( pxQueueSetContainer->xTxLock )++;
BFD04472  0014FC5E   LW V0, 20(S8)
BFD04476  0048FC42   LW V0, 72(V0)
BFD0447A      6DA0   ADDIU V1, V0, 1
BFD0447C  0014FC5E   LW V0, 20(S8)
BFD04480  0048F862   SW V1, 72(V0)
2590:                			}
2591:                		}
2592:                		else
2593:                		{
2594:                			mtCOVERAGE_TEST_MARKER();
2595:                		}
2596:                
2597:                		return xReturn;
BFD04484  0010FC5E   LW V0, 16(S8)
2598:                	}
BFD04488      0FBE   MOVE SP, S8
BFD0448A      4BE7   LW RA, 28(SP)
BFD0448C      4BC6   LW S8, 24(SP)
BFD0448E      4C11   ADDIU SP, SP, 32
BFD04490      459F   JR16 RA
BFD04492      0C00   NOP
2599:                
2600:                #endif /* configUSE_QUEUE_SETS */
2601:                
2602:                
2603:                
2604:                
2605:                
2606:                
2607:                
2608:                
2609:                
2610:                
2611:                
2612:                
---  c:/e/dev/freertos/workingcopy/freertos/source/portable/mplab/pic32mec14xx/portmacro.h  -------------
1:                   /*
2:                       FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  #ifndef PORTMACRO_H
71:                  #define PORTMACRO_H
72:                  
73:                  #ifdef __cplusplus
74:                  extern "C" {
75:                  #endif
76:                  
77:                  /*-----------------------------------------------------------
78:                   * Port specific definitions.
79:                   *
80:                   * The settings in this file configure FreeRTOS correctly for the
81:                   * given hardware and compiler.
82:                   *
83:                   * These settings should not be altered.
84:                   *-----------------------------------------------------------
85:                   */
86:                  
87:                  /* Type definitions. */
88:                  #define portCHAR        char
89:                  #define portFLOAT       float
90:                  #define portDOUBLE      double
91:                  #define portLONG        long
92:                  #define portSHORT       short
93:                  #define portSTACK_TYPE  uint32_t
94:                  #define portBASE_TYPE   long
95:                  
96:                  typedef portSTACK_TYPE StackType_t;
97:                  typedef long BaseType_t;
98:                  typedef unsigned long UBaseType_t;
99:                  
100:                 #if( configUSE_16_BIT_TICKS == 1 )
101:                     typedef uint16_t TickType_t;
102:                     #define portMAX_DELAY ( TickType_t ) 0xffff
103:                 #else
104:                     typedef uint32_t TickType_t;
105:                     #define portMAX_DELAY ( TickType_t ) 0xffffffffUL
106:                 #endif
107:                 /*-----------------------------------------------------------*/
108:                 
109:                 /* Hardware specifics. */
110:                 #define portBYTE_ALIGNMENT  8
111:                 #define portSTACK_GROWTH    -1
112:                 #define portTICK_PERIOD_MS  ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
113:                 /*-----------------------------------------------------------*/
114:                 
115:                 /* Critical section management. */
116:                 #define portIPL_SHIFT       ( 10UL )
117:                 /* Don't straddle the CEE bit.  Interrupts calling FreeRTOS functions should
118:                    never have higher IPL bits set anyway. */
119:                 #define portALL_IPL_BITS    ( 0x7FUL << portIPL_SHIFT )
120:                 #define portSW0_BIT         ( 0x01 << 8 )
121:                 
122:                 /*-----------------------------------------------------------*/
123:                 
124:                 static inline uint32_t ulPortGetCP0Status( void )
125:                 {
BFD09B4C      4FF9   ADDIU SP, SP, -16
BFD09B4E      CBC3   SW S8, 12(SP)
BFD09B50      CA02   SW S0, 8(SP)
BFD09B52      0FDD   MOVE S8, SP
BFD09C6C      4FF9   ADDIU SP, SP, -16
BFD09C6E      CBC3   SW S8, 12(SP)
BFD09C70      CA02   SW S0, 8(SP)
BFD09C72      0FDD   MOVE S8, SP
BFD09D6C      4FF9   ADDIU SP, SP, -16
BFD09D6E      CBC3   SW S8, 12(SP)
BFD09D70      CA02   SW S0, 8(SP)
BFD09D72      0FDD   MOVE S8, SP
126:                 uint32_t rv;
127:                 
128:                 	__asm volatile(
BFD09B54  00FC020C   MFC0 S0, Status
BFD09B58  0000FA1E   SW S0, 0(S8)
BFD09C74  00FC020C   MFC0 S0, Status
BFD09C78  0000FA1E   SW S0, 0(S8)
BFD09D74  00FC020C   MFC0 S0, Status
BFD09D78  0000FA1E   SW S0, 0(S8)
129:                 			"\n\t"
130:                 			"mfc0 %0,$12,0      \n\t"
131:                 			: "=r" ( rv ) :: );
132:                 
133:                 	return rv;
BFD09B5C  0000FC5E   LW V0, 0(S8)
BFD09C7C  0000FC5E   LW V0, 0(S8)
BFD09D7C  0000FC5E   LW V0, 0(S8)
134:                 }
BFD09B60      0FBE   MOVE SP, S8
BFD09B62      4BC3   LW S8, 12(SP)
BFD09B64      4A02   LW S0, 8(SP)
BFD09B66      459F   JR16 RA
BFD09B68      4C09   ADDIU SP, SP, 16
BFD09C80      0FBE   MOVE SP, S8
BFD09C82      4BC3   LW S8, 12(SP)
BFD09C84      4A02   LW S0, 8(SP)
BFD09C86      459F   JR16 RA
BFD09C88      4C09   ADDIU SP, SP, 16
BFD09D80      0FBE   MOVE SP, S8
BFD09D82      4BC3   LW S8, 12(SP)
BFD09D84      4A02   LW S0, 8(SP)
BFD09D86      459F   JR16 RA
BFD09D88      4C09   ADDIU SP, SP, 16
135:                 /*-----------------------------------------------------------*/
136:                 
137:                 static inline void vPortSetCP0Status( uint32_t new_status)
138:                 {
BFD09B6C      4FB0   ADDIU SP, SP, -8
BFD09B6E      CBC1   SW S8, 4(SP)
BFD09B70      0FDD   MOVE S8, SP
BFD09B72  0008F89E   SW A0, 8(S8)
BFD09C8C      4FB0   ADDIU SP, SP, -8
BFD09C8E      CBC1   SW S8, 4(SP)
BFD09C90      0FDD   MOVE S8, SP
BFD09C92  0008F89E   SW A0, 8(S8)
BFD09D8C      4FB0   ADDIU SP, SP, -8
BFD09D8E      CBC1   SW S8, 4(SP)
BFD09D90      0FDD   MOVE S8, SP
BFD09D92  0008F89E   SW A0, 8(S8)
139:                 	( void ) new_status;
140:                 
141:                 	__asm__ __volatile__(
BFD09B76  0008FC5E   LW V0, 8(S8)
BFD09B78  004C0008   INS ZERO, T0, 1, 0
BFD09B7A  02FC004C   MTC0 V0, Status
BFD09B7C  000002FC   SLL S7, GP, 0
BFD09B7E  18000000   SLL ZERO, ZERO, 3
BFD09B80  0FBE1800   SB ZERO, 4030(ZERO)
BFD09C96  0008FC5E   LW V0, 8(S8)
BFD09C98  004C0008   INS ZERO, T0, 1, 0
BFD09C9A  02FC004C   MTC0 V0, Status
BFD09C9C  000002FC   SLL S7, GP, 0
BFD09C9E  18000000   SLL ZERO, ZERO, 3
BFD09CA0  0FBE1800   SB ZERO, 4030(ZERO)
BFD09D96  0008FC5E   LW V0, 8(S8)
BFD09D98  004C0008   INS ZERO, T0, 1, 0
BFD09D9A  02FC004C   MTC0 V0, Status
BFD09D9C  000002FC   SLL S7, GP, 0
BFD09D9E  18000000   SLL ZERO, ZERO, 3
BFD09DA0  0FBE1800   SB ZERO, 4030(ZERO)
142:                 			"\n\t"
143:                 			"mtc0 %0,$12,0      \n\t"
144:                 			"ehb                \n\t"
145:                 			:
146:                 			:"r" ( new_status ) : );
147:                 }
BFD09B82      0FBE   MOVE SP, S8
BFD09B84      4BC1   LW S8, 4(SP)
BFD09B86      459F   JR16 RA
BFD09B88      4C05   ADDIU SP, SP, 8
BFD09CA2      0FBE   MOVE SP, S8
BFD09CA4      4BC1   LW S8, 4(SP)
BFD09CA6      459F   JR16 RA
BFD09CA8      4C05   ADDIU SP, SP, 8
BFD09DA2      0FBE   MOVE SP, S8
BFD09DA4      4BC1   LW S8, 4(SP)
BFD09DA6      459F   JR16 RA
BFD09DA8      4C05   ADDIU SP, SP, 8
148:                 /*-----------------------------------------------------------*/
149:                 
150:                 static inline uint32_t ulPortGetCP0Cause( void )
151:                 {
BFD09B8C      4FF9   ADDIU SP, SP, -16
BFD09B8E      CBC3   SW S8, 12(SP)
BFD09B90      CA02   SW S0, 8(SP)
BFD09B92      0FDD   MOVE S8, SP
BFD09BCC      4FF9   ADDIU SP, SP, -16
BFD09BCE      CBC3   SW S8, 12(SP)
BFD09BD0      CA02   SW S0, 8(SP)
BFD09BD2      0FDD   MOVE S8, SP
BFD09C2C      4FF9   ADDIU SP, SP, -16
BFD09C2E      CBC3   SW S8, 12(SP)
BFD09C30      CA02   SW S0, 8(SP)
BFD09C32      0FDD   MOVE S8, SP
BFD09CAC      4FF9   ADDIU SP, SP, -16
BFD09CAE      CBC3   SW S8, 12(SP)
BFD09CB0      CA02   SW S0, 8(SP)
BFD09CB2      0FDD   MOVE S8, SP
BFD09CEC      4FF9   ADDIU SP, SP, -16
BFD09CEE      CBC3   SW S8, 12(SP)
BFD09CF0      CA02   SW S0, 8(SP)
BFD09CF2      0FDD   MOVE S8, SP
152:                 uint32_t rv;
153:                 
154:                 	__asm volatile(
BFD09B94  00FC020D   MFC0 S0, Cause
BFD09B98  0000FA1E   SW S0, 0(S8)
BFD09BD4  00FC020D   MFC0 S0, Cause
BFD09BD8  0000FA1E   SW S0, 0(S8)
BFD09C34  00FC020D   MFC0 S0, Cause
BFD09C38  0000FA1E   SW S0, 0(S8)
BFD09CB4  00FC020D   MFC0 S0, Cause
BFD09CB8  0000FA1E   SW S0, 0(S8)
BFD09CF4  00FC020D   MFC0 S0, Cause
BFD09CF8  0000FA1E   SW S0, 0(S8)
155:                 			"\n\t"
156:                 			"mfc0 %0,$13,0      \n\t"
157:                 			: "=r" ( rv ) :: );
158:                 
159:                     return rv;
BFD09B9C  0000FC5E   LW V0, 0(S8)
BFD09BDC  0000FC5E   LW V0, 0(S8)
BFD09C3C  0000FC5E   LW V0, 0(S8)
BFD09CBC  0000FC5E   LW V0, 0(S8)
BFD09CFC  0000FC5E   LW V0, 0(S8)
160:                 }
BFD09BA0      0FBE   MOVE SP, S8
BFD09BA2      4BC3   LW S8, 12(SP)
BFD09BA4      4A02   LW S0, 8(SP)
BFD09BA6      459F   JR16 RA
BFD09BA8      4C09   ADDIU SP, SP, 16
BFD09BE0      0FBE   MOVE SP, S8
BFD09BE2      4BC3   LW S8, 12(SP)
BFD09BE4      4A02   LW S0, 8(SP)
BFD09BE6      459F   JR16 RA
BFD09BE8      4C09   ADDIU SP, SP, 16
BFD09C40      0FBE   MOVE SP, S8
BFD09C42      4BC3   LW S8, 12(SP)
BFD09C44      4A02   LW S0, 8(SP)
BFD09C46      459F   JR16 RA
BFD09C48      4C09   ADDIU SP, SP, 16
BFD09CC0      0FBE   MOVE SP, S8
BFD09CC2      4BC3   LW S8, 12(SP)
BFD09CC4      4A02   LW S0, 8(SP)
BFD09CC6      459F   JR16 RA
BFD09CC8      4C09   ADDIU SP, SP, 16
BFD09D00      0FBE   MOVE SP, S8
BFD09D02      4BC3   LW S8, 12(SP)
BFD09D04      4A02   LW S0, 8(SP)
BFD09D06      459F   JR16 RA
BFD09D08      4C09   ADDIU SP, SP, 16
161:                 /*-----------------------------------------------------------*/
162:                 
163:                 static inline void vPortSetCP0Cause( uint32_t new_cause )
164:                 {
BFD09BAC      4FB0   ADDIU SP, SP, -8
BFD09BAE      CBC1   SW S8, 4(SP)
BFD09BB0      0FDD   MOVE S8, SP
BFD09BB2  0008F89E   SW A0, 8(S8)
BFD09BEC      4FB0   ADDIU SP, SP, -8
BFD09BEE      CBC1   SW S8, 4(SP)
BFD09BF0      0FDD   MOVE S8, SP
BFD09BF2  0008F89E   SW A0, 8(S8)
BFD09C4C      4FB0   ADDIU SP, SP, -8
BFD09C4E      CBC1   SW S8, 4(SP)
BFD09C50      0FDD   MOVE S8, SP
BFD09C52  0008F89E   SW A0, 8(S8)
BFD09CCC      4FB0   ADDIU SP, SP, -8
BFD09CCE      CBC1   SW S8, 4(SP)
BFD09CD0      0FDD   MOVE S8, SP
BFD09CD2  0008F89E   SW A0, 8(S8)
BFD09D0C      4FB0   ADDIU SP, SP, -8
BFD09D0E      CBC1   SW S8, 4(SP)
BFD09D10      0FDD   MOVE S8, SP
BFD09D12  0008F89E   SW A0, 8(S8)
165:                 	( void ) new_cause;
166:                 
167:                 	__asm__ __volatile__(
BFD09BB6  0008FC5E   LW V0, 8(S8)
BFD09BB8  004D0008   ADDQH.PH ZERO, T0, ZERO
BFD09BBA  02FC004D   MTC0 V0, Cause
BFD09BBC  000002FC   SLL S7, GP, 0
BFD09BBE  18000000   SLL ZERO, ZERO, 3
BFD09BC0  0FBE1800   SB ZERO, 4030(ZERO)
BFD09BF6  0008FC5E   LW V0, 8(S8)
BFD09BF8  004D0008   ADDQH.PH ZERO, T0, ZERO
BFD09BFA  02FC004D   MTC0 V0, Cause
BFD09BFC  000002FC   SLL S7, GP, 0
BFD09BFE  18000000   SLL ZERO, ZERO, 3
BFD09C00  0FBE1800   SB ZERO, 4030(ZERO)
BFD09C56  0008FC5E   LW V0, 8(S8)
BFD09C58  004D0008   ADDQH.PH ZERO, T0, ZERO
BFD09C5A  02FC004D   MTC0 V0, Cause
BFD09C5C  000002FC   SLL S7, GP, 0
BFD09C5E  18000000   SLL ZERO, ZERO, 3
BFD09C60  0FBE1800   SB ZERO, 4030(ZERO)
BFD09CD6  0008FC5E   LW V0, 8(S8)
BFD09CD8  004D0008   ADDQH.PH ZERO, T0, ZERO
BFD09CDA  02FC004D   MTC0 V0, Cause
BFD09CDC  000002FC   SLL S7, GP, 0
BFD09CDE  18000000   SLL ZERO, ZERO, 3
BFD09CE0  0FBE1800   SB ZERO, 4030(ZERO)
BFD09D16  0008FC5E   LW V0, 8(S8)
BFD09D18  004D0008   ADDQH.PH ZERO, T0, ZERO
BFD09D1A  02FC004D   MTC0 V0, Cause
BFD09D1C  000002FC   SLL S7, GP, 0
BFD09D1E  18000000   SLL ZERO, ZERO, 3
BFD09D20  0FBE1800   SB ZERO, 4030(ZERO)
168:                 			"\n\t"
169:                 			"mtc0 %0,$13,0      \n\t"
170:                 			"ehb                \n\t"
171:                 			:
172:                 			:"r" ( new_cause ) : );
173:                 }
BFD09BC2      0FBE   MOVE SP, S8
BFD09BC4      4BC1   LW S8, 4(SP)
BFD09BC6      459F   JR16 RA
BFD09BC8      4C05   ADDIU SP, SP, 8
BFD09C02      0FBE   MOVE SP, S8
BFD09C04      4BC1   LW S8, 4(SP)
BFD09C06      459F   JR16 RA
BFD09C08      4C05   ADDIU SP, SP, 8
BFD09C62      0FBE   MOVE SP, S8
BFD09C64      4BC1   LW S8, 4(SP)
BFD09C66      459F   JR16 RA
BFD09C68      4C05   ADDIU SP, SP, 8
BFD09CE2      0FBE   MOVE SP, S8
BFD09CE4      4BC1   LW S8, 4(SP)
BFD09CE6      459F   JR16 RA
BFD09CE8      4C05   ADDIU SP, SP, 8
BFD09D22      0FBE   MOVE SP, S8
BFD09D24      4BC1   LW S8, 4(SP)
BFD09D26      459F   JR16 RA
BFD09D28      4C05   ADDIU SP, SP, 8
174:                 /*-----------------------------------------------------------*/
175:                 
176:                 /* This clears the IPL bits, then sets them to
177:                 configMAX_SYSCALL_INTERRUPT_PRIORITY.  An extra check is performed if
178:                 configASSERT() is defined to ensure an assertion handler does not inadvertently
179:                 attempt to lower the IPL when the call to assert was triggered because the IPL
180:                 value was found to be above configMAX_SYSCALL_INTERRUPT_PRIORITY when an ISR
181:                 safe FreeRTOS API function was executed.  ISR safe FreeRTOS API functions are
182:                 those that end in FromISR.  FreeRTOS maintains a separate interrupt API to
183:                 ensure API function and interrupt entry is as fast and as simple as possible. */
184:                 #ifdef configASSERT
185:                     #define portDISABLE_INTERRUPTS() 																			\
186:                 	{ 																											\
187:                 	uint32_t ulStatus; 																							\
188:                 		/* Mask interrupts at and below the kernel interrupt priority. */  										\
189:                 		ulStatus = ulPortGetCP0Status(); 																		\
190:                 		/* Is the current IPL below configMAX_SYSCALL_INTERRUPT_PRIORITY? */ 									\
191:                 		if( ( ( ulStatus & portALL_IPL_BITS ) >> portIPL_SHIFT ) < configMAX_SYSCALL_INTERRUPT_PRIORITY ) 		\
192:                 		{ 																										\
193:                 			ulStatus &= ~portALL_IPL_BITS;  																	\
194:                 			vPortSetCP0Status( ( ulStatus | ( configMAX_SYSCALL_INTERRUPT_PRIORITY << portIPL_SHIFT ) ) ); 		\
195:                 		} 																										\
196:                     }
197:                 #else /* configASSERT */
198:                 	#define portDISABLE_INTERRUPTS() 																			\
199:                 	{ 																											\
200:                 	uint32_t ulStatus;  																						\
201:                 		/* Mask interrupts at and below the kernel interrupt priority. */ 										\
202:                 		ulStatus = ulPortGetCP0Status(); 																		\
203:                 		ulStatus &= ~portALL_IPL_BITS; 																			\
204:                 		vPortSetCP0Status( ( ulStatus | ( configMAX_SYSCALL_INTERRUPT_PRIORITY << portIPL_SHIFT ) ) ); 			\
205:                 	}
206:                 #endif /* configASSERT */
207:                 
208:                 #define portENABLE_INTERRUPTS() 			\
209:                 { 											\
210:                 uint32_t ulStatus; 							\
211:                 	/* Unmask all interrupts. */ 			\
212:                 	ulStatus = ulPortGetCP0Status(); 		\
213:                 	ulStatus &= ~portALL_IPL_BITS; 			\
214:                 	vPortSetCP0Status( ulStatus ); 			\
215:                 }
216:                 
217:                 
218:                 extern void vTaskEnterCritical( void );
219:                 extern void vTaskExitCritical( void );
220:                 #define portCRITICAL_NESTING_IN_TCB	1
221:                 #define portENTER_CRITICAL()		vTaskEnterCritical()
222:                 #define portEXIT_CRITICAL()			vTaskExitCritical()
223:                 
224:                 extern UBaseType_t uxPortSetInterruptMaskFromISR();
225:                 extern void vPortClearInterruptMaskFromISR( UBaseType_t );
226:                 #define portSET_INTERRUPT_MASK_FROM_ISR() uxPortSetInterruptMaskFromISR()
227:                 #define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusRegister ) vPortClearInterruptMaskFromISR( uxSavedStatusRegister )
228:                 
229:                 #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
230:                 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
231:                 #endif
232:                 
233:                 #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
234:                 
235:                 	/* Check the configuration. */
236:                 	#if( configMAX_PRIORITIES > 32 )
237:                 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
238:                 	#endif
239:                 
240:                 	/* Store/clear the ready priorities in a bit map. */
241:                 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
242:                 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
243:                 
244:                 	/*-----------------------------------------------------------*/
245:                 
246:                 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31 - _clz( ( uxReadyPriorities ) ) )
247:                 
248:                 #endif /* taskRECORD_READY_PRIORITY */
249:                 
250:                 /*-----------------------------------------------------------*/
251:                 
252:                 /* Task utilities. */
253:                 
254:                 #define portYIELD() 						\
255:                 { 											\
256:                 uint32_t ulCause; 							\
257:                     /* Trigger software interrupt. */ 		\
258:                     ulCause = ulPortGetCP0Cause(); 			\
259:                     ulCause |= portSW0_BIT; 				\
260:                     vPortSetCP0Cause( ulCause ); 			\
261:                 }
262:                 
263:                 extern volatile UBaseType_t uxInterruptNesting;
264:                 #define portASSERT_IF_IN_ISR() configASSERT( uxInterruptNesting == 0 )
265:                 
266:                 #define portNOP() __asm volatile ( "nop" )
267:                 
268:                 /*-----------------------------------------------------------*/
269:                 
270:                 /* Task function macros as described on the FreeRTOS.org WEB site. */
271:                 #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters ) __attribute__((noreturn))
272:                 #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
273:                 /*-----------------------------------------------------------*/
274:                 
275:                 #define portEND_SWITCHING_ISR( xSwitchRequired ) 	if( xSwitchRequired )	\
276:                 													{ 						\
277:                 														portYIELD();		\
278:                 													}
279:                 
280:                 /* Required by the kernel aware debugger. */
281:                 #ifdef __DEBUG
282:                     #define portREMOVE_STATIC_QUALIFIER
283:                 #endif
284:                 
285:                 #ifdef __cplusplus
286:                 }
287:                 #endif
288:                 
289:                 #endif /* PORTMACRO_H */
290:                 
---  c:/e/dev/freertos/workingcopy/freertos/source/portable/mplab/pic32mec14xx/port.c  ------------------
1:                   /*
2:                       FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /*-----------------------------------------------------------
71:                   * Implementation of functions defined in portable.h for the PIC32MZ port.
72:                    *----------------------------------------------------------*/
73:                  
74:                  #include <xc.h>
75:                  #include <cp0defs.h>
76:                  
77:                  /* Scheduler include files. */
78:                  #include "FreeRTOS.h"
79:                  #include "task.h"
80:                  
81:                  #if !defined(__MEC__)
82:                      #error This port is designed to work with XC32 on MEC14xx.  Please update your C compiler version or settings.
83:                  #endif
84:                  
85:                  #if( ( configMAX_SYSCALL_INTERRUPT_PRIORITY >= 0x7 ) || ( configMAX_SYSCALL_INTERRUPT_PRIORITY == 0 ) )
86:                  	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must be less than 7 and greater than 0
87:                  #endif
88:                  
89:                  /* Hardware specifics. */
90:                  #define portTIMER_PRESCALE	8
91:                  #define portPRESCALE_BITS	1
92:                  
93:                  /* Bits within various registers. */
94:                  #define portIE_BIT					( 0x00000001 )
95:                  #define portEXL_BIT					( 0x00000002 )
96:                  #define portMX_BIT					( 0x01000000 ) /* Allow access to DSP instructions. */
97:                  
98:                  /* Bits within the CAUSE register. */
99:                  #define portCORE_SW_0				( 0x00000100 )
100:                 #define portCORE_SW_1				( 0x00000200 )
101:                 
102:                 /* The EXL bit is set to ensure interrupts do not occur while the context of
103:                 the first task is being restored. */
104:                 /* MEC14xx does not have DSP HW */
105:                 #define portINITIAL_SR				( portIE_BIT | portEXL_BIT )
106:                 
107:                 /* MEC14xx RTOS Timer MMCR's */
108:                 #define portMMCR_RTMR_PRELOAD	*((volatile uint32_t *)(0xA0007404ul))
109:                 #define portMMCR_RTMR_CONTROL	*((volatile uint32_t *)(0xA0007408ul))
110:                 
111:                 /* MEC14xx JTVIC external interrupt controller
112:                  * is mapped to M14K closely-coupled peripheral space.
113:                  */
114:                 #define portGIRQ23_RTOS_TIMER_BITPOS	(4)
115:                 #define portGIRQ23_RTOS_TIMER_MASK		(1ul << (portGIRQ23_RTOS_TIMER_BITPOS))
116:                 #define portMMCR_JTVIC_GIRQ23_SRC		*((volatile uint32_t *)(0xBFFFC0F0ul))
117:                 #define portMMCR_JTVIC_GIRQ23_SETEN		*((volatile uint32_t *)(0xBFFFC0F4ul))
118:                 #define portMMCR_JTVIC_GIRQ23_CLREN		*((volatile uint32_t *)(0xBFFFC0F8ul))
119:                 #define portMMCR_JTVIC_GIRQ23_RESULT	*((volatile uint32_t *)(0xBFFFC0FCul))
120:                 #define portMMCR_JTVIC_GIRQ23_AGCTRL	*((volatile uint32_t *)(0xBFFFC23Cul))
121:                 #define portMMCR_JTVIC_GIRQ23_PRIA		*((volatile uint32_t *)(0xBFFFC3F0ul))
122:                 #define portMMCR_JTVIC_GIRQ23_PRIB		*((volatile uint32_t *)(0xBFFFC3F4ul))
123:                 #define portMMCR_JTVIC_GIRQ23_PRIC		*((volatile uint32_t *)(0xBFFFC3F8ul))
124:                 #define portMMCR_JTVIC_GIRQ23_PRID		*((volatile uint32_t *)(0xBFFFC3FCul))
125:                 
126:                 /* MIPS Software Interrupts are routed through JTVIC GIRQ24 */
127:                 #define portGIRQ24_M14K_SOFTIRQ0_BITPOS	(1)
128:                 #define portGIRQ24_M14K_SOFTIRQ0_MASK	(1ul << (portGIRQ24_M14K_SOFTIRQ0_BITPOS))
129:                 #define portMMCR_JTVIC_GIRQ24_SRC		*((volatile uint32_t *)(0xBFFFC100ul))
130:                 #define portMMCR_JTVIC_GIRQ24_SETEN		*((volatile uint32_t *)(0xBFFFC104ul))
131:                 #define portMMCR_JTVIC_GIRQ24_CLREN		*((volatile uint32_t *)(0xBFFFC108ul))
132:                 #define portMMCR_JTVIC_GIRQ24_RESULT	*((volatile uint32_t *)(0xBFFFC10Cul))
133:                 #define portMMCR_JTVIC_GIRQ24_AGCTRL	*((volatile uint32_t *)(0xBFFFC240ul))
134:                 #define portMMCR_JTVIC_GIRQ24_PRIA		*((volatile uint32_t *)(0xBFFFC400ul))
135:                 #define portMMCR_JTVIC_GIRQ24_PRIB		*((volatile uint32_t *)(0xBFFFC404ul))
136:                 #define portMMCR_JTVIC_GIRQ24_PRIC		*((volatile uint32_t *)(0xBFFFC408ul))
137:                 #define portMMCR_JTVIC_GIRQ24_PRID		*((volatile uint32_t *)(0xBFFFC40Cul))
138:                 
139:                 /*
140:                 By default port.c generates its tick interrupt from TIMER1.  The user can
141:                 override this behaviour by:
142:                 	1: Providing their own implementation of vApplicationSetupTickTimerInterrupt(),
143:                 	   which is the function that configures the timer.  The function is defined
144:                 	   as a weak symbol in this file so if the same function name is used in the
145:                 	   application code then the version in the application code will be linked
146:                 	   into the application in preference to the version defined in this file.
147:                 	2: Define configTICK_INTERRUPT_VECTOR to the vector number of the timer used
148:                 	   to generate the tick interrupt.  For example, when timer 1 is used then
149:                 	   configTICK_INTERRUPT_VECTOR is set to _TIMER_1_VECTOR.
150:                 	   configTICK_INTERRUPT_VECTOR should be defined in FreeRTOSConfig.h.
151:                 	3: Define configCLEAR_TICK_TIMER_INTERRUPT() to clear the interrupt in the
152:                 	   timer used to generate the tick interrupt.  For example, when timer 1 is
153:                 	   used configCLEAR_TICK_TIMER_INTERRUPT() is defined to
154:                 	   IFS0CLR = _IFS0_T1IF_MASK.
155:                 */
156:                 #ifndef configTICK_INTERRUPT_VECTOR
157:                 	#define configTICK_INTERRUPT_VECTOR girq23_b4
158:                 	#define configCLEAR_TICK_TIMER_INTERRUPT() portMMCR_JTVIC_GIRQ23_SRC = portGIRQ23_RTOS_TIMER_MASK
159:                 #else
160:                 	#ifndef configCLEAR_TICK_TIMER_INTERRUPT
161:                 		#error If configTICK_INTERRUPT_VECTOR is defined in application code then configCLEAR_TICK_TIMER_INTERRUPT must also be defined in application code.
162:                 	#endif
163:                 #endif
164:                 
165:                 /* Let the user override the pre-loading of the initial RA with the address of
166:                 prvTaskExitError() in case is messes up unwinding of the stack in the
167:                 debugger - in which case configTASK_RETURN_ADDRESS can be defined as 0 (NULL). */
168:                 #ifdef configTASK_RETURN_ADDRESS
169:                 	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
170:                 #else
171:                 	#define portTASK_RETURN_ADDRESS	prvTaskExitError
172:                 #endif
173:                 
174:                 /* Set configCHECK_FOR_STACK_OVERFLOW to 3 to add ISR stack checking to task
175:                 stack checking.  A problem in the ISR stack will trigger an assert, not call the
176:                 stack overflow hook function (because the stack overflow hook is specific to a
177:                 task stack, not the ISR stack). */
178:                 #if( configCHECK_FOR_STACK_OVERFLOW > 2 )
179:                 
180:                     /* Don't use 0xa5 as the stack fill bytes as that is used by the kernerl for
181:                        the task stacks, and so will legitimately appear in many positions within
182:                        the ISR stack. */
183:                     #define portISR_STACK_FILL_BYTE	0xee
184:                 
185:                 	static const uint8_t ucExpectedStackBytes[] = {
186:                 							portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
187:                 							portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
188:                 							portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
189:                 							portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
190:                 							portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE };	\
191:                 
192:                 	#define portCHECK_ISR_STACK() configASSERT( ( memcmp( ( void * ) xISRStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) == 0 ) )
193:                 #else
194:                 	/* Define the function away. */
195:                 	#define portCHECK_ISR_STACK()
196:                 #endif /* configCHECK_FOR_STACK_OVERFLOW > 2 */
197:                 
198:                 
199:                 /*-----------------------------------------------------------*/
200:                 
201:                 /*
202:                  * Used to catch tasks that attempt to return from their implementing function.
203:                  */
204:                 static void prvTaskExitError( void );
205:                 
206:                 /*-----------------------------------------------------------*/
207:                 
208:                 /* Records the interrupt nesting depth.  This is initialised to one as it is
209:                 decremented to 0 when the first task starts. */
210:                 volatile UBaseType_t uxInterruptNesting = 0x01;
211:                 
212:                 /* Stores the task stack pointer when a switch is made to use the system stack. */
213:                 UBaseType_t uxSavedTaskStackPointer = 0;
214:                 
215:                 /* The stack used by interrupt service routines that cause a context switch. */
216:                 StackType_t xISRStack[ configISR_STACK_SIZE ] = { 0 };
217:                 
218:                 /* The top of stack value ensures there is enough space to store 6 registers on
219:                 the callers stack, as some functions seem to want to do this. */
220:                 const StackType_t * const xISRStackTop = &( xISRStack[ configISR_STACK_SIZE - 7 ] );
221:                 
222:                 /*-----------------------------------------------------------*/
223:                 
224:                 /* Local inline assembly routines to read/write MIPS M14K CP0 registers.  Avoids
225:                 the need for compiler intrinsics which vary with compiler. */
226:                 static uint32_t prvDisableInterrupt( void )
227:                 {
BFD09A98      4FF9   ADDIU SP, SP, -16
BFD09A9A      CBC3   SW S8, 12(SP)
BFD09A9C      CA02   SW S0, 8(SP)
BFD09A9E      0FDD   MOVE S8, SP
228:                 uint32_t prev_state;
229:                 
230:                 	__asm volatile( "di %0; ehb" : "=r" ( prev_state ) :: "memory" );
BFD09AA0  477C0010   DI S0
BFD09AA4  18000000   SLL ZERO, ZERO, 3
BFD09AA6  FA1E1800   SB ZERO, -1506(ZERO)
BFD09AA8  0000FA1E   SW S0, 0(S8)
231:                 	return prev_state;
BFD09AAC  0000FC5E   LW V0, 0(S8)
232:                 }
BFD09AB0      0FBE   MOVE SP, S8
BFD09AB2      4BC3   LW S8, 12(SP)
BFD09AB4      4A02   LW S0, 8(SP)
BFD09AB6      459F   JR16 RA
BFD09AB8      4C09   ADDIU SP, SP, 16
233:                 
234:                 
235:                 /*
236:                  * See header file for description.
237:                  */
238:                 StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
239:                 {
BFD05630      4FF5   ADDIU SP, SP, -24
BFD05632      CBE5   SW RA, 20(SP)
BFD05634      CBC4   SW S8, 16(SP)
BFD05636      0FDD   MOVE S8, SP
BFD05638  0018F89E   SW A0, 24(S8)
BFD0563C  001CF8BE   SW A1, 28(S8)
BFD05640  0020F8DE   SW A2, 32(S8)
240:                 	/* Ensure byte alignment is maintained when leaving this function. */
241:                 	pxTopOfStack--;
BFD05644  0018FC5E   LW V0, 24(S8)
BFD05646  4C580018   MOVZ T1, T8, ZERO
BFD05648      4C58   ADDIU V0, V0, -4
BFD0564A  0018F85E   SW V0, 24(S8)
242:                 
243:                 	*pxTopOfStack = (StackType_t) 0xDEADBEEF;
BFD0564E  0018FC5E   LW V0, 24(S8)
BFD05652  DEAD41A3   LUI V1, 0xDEAD
BFD05656  BEEF5063   ORI V1, V1, -16657
BFD05658  E9A0BEEF   LDC1 F23, -5728(T7)
BFD0565A      E9A0   SW V1, 0(V0)
244:                 	pxTopOfStack--;
BFD0565C  0018FC5E   LW V0, 24(S8)
BFD0565E  4C580018   MOVZ T1, T8, ZERO
BFD05660      4C58   ADDIU V0, V0, -4
BFD05662  0018F85E   SW V0, 24(S8)
245:                 
246:                 	*pxTopOfStack = (StackType_t) 0x12345678;	/* Word to which the stack pointer will be left pointing after context restore. */
BFD05666  0018FC5E   LW V0, 24(S8)
BFD0566A  123441A3   LUI V1, 0x1234
BFD0566C  50631234   ADDI S1, S4, 20579
BFD0566E  56785063   ORI V1, V1, 22136
BFD05670  E9A05678   PREFX 29, 19(T8)
BFD05672      E9A0   SW V1, 0(V0)
247:                 	pxTopOfStack--;
BFD05674  0018FC5E   LW V0, 24(S8)
BFD05676  4C580018   MOVZ T1, T8, ZERO
BFD05678      4C58   ADDIU V0, V0, -4
BFD0567A  0018F85E   SW V0, 24(S8)
248:                 
249:                 	*pxTopOfStack = (StackType_t) ulPortGetCP0Cause();
BFD0567E  4DC677E8   JALS ulPortGetCP0Cause
BFD05680      4DC6   ADDIU T6, T6, 3
BFD05682      0C00   NOP
BFD05684      0C62   MOVE V1, V0
BFD05686  0018FC5E   LW V0, 24(S8)
BFD0568A      E9A0   SW V1, 0(V0)
250:                 	pxTopOfStack--;
BFD0568C  0018FC5E   LW V0, 24(S8)
BFD0568E  4C580018   MOVZ T1, T8, ZERO
BFD05690      4C58   ADDIU V0, V0, -4
BFD05692  0018F85E   SW V0, 24(S8)
251:                 
252:                 	*pxTopOfStack = (StackType_t) portINITIAL_SR;	/* CP0_STATUS */
BFD05696  0018FC5E   LW V0, 24(S8)
BFD0569A      ED83   LI V1, 3
BFD0569C      E9A0   SW V1, 0(V0)
253:                 	pxTopOfStack--;
BFD0569E  0018FC5E   LW V0, 24(S8)
BFD056A0  4C580018   MOVZ T1, T8, ZERO
BFD056A2      4C58   ADDIU V0, V0, -4
BFD056A4  0018F85E   SW V0, 24(S8)
254:                 
255:                 	*pxTopOfStack = (StackType_t) pxCode; 		/* CP0_EPC */
BFD056A8  001CFC7E   LW V1, 28(S8)
BFD056AC  0018FC5E   LW V0, 24(S8)
BFD056B0      E9A0   SW V1, 0(V0)
256:                 	pxTopOfStack--;
BFD056B2  0018FC5E   LW V0, 24(S8)
BFD056B4  4C580018   MOVZ T1, T8, ZERO
BFD056B6      4C58   ADDIU V0, V0, -4
BFD056B8  0018F85E   SW V0, 24(S8)
257:                 
258:                 	*pxTopOfStack = (StackType_t) portTASK_RETURN_ADDRESS;	/* ra */
BFD056BC  BFD041A2   LUI V0, 0xBFD0
BFD056BE  3062BFD0   LDC1 F30, 12386(S0)
BFD056C0  7BBD3062   ADDIU V1, V0, 31677
BFD056C2  FC5E7BBD   ADDIUPC A3, 4062302
BFD056C4  0018FC5E   LW V0, 24(S8)
BFD056C8      E9A0   SW V1, 0(V0)
259:                 	pxTopOfStack -= 15;
BFD056CA  0018FC5E   LW V0, 24(S8)
BFD056CE  FFC43042   ADDIU V0, V0, -60
BFD056D0  F85EFFC4   LW S8, -1954(A0)
BFD056D2  0018F85E   SW V0, 24(S8)
260:                 
261:                 	*pxTopOfStack = (StackType_t) pvParameters; /* Parameters to pass in. */
BFD056D6  0020FC7E   LW V1, 32(S8)
BFD056DA  0018FC5E   LW V0, 24(S8)
BFD056DE      E9A0   SW V1, 0(V0)
262:                 	pxTopOfStack -= 15;
BFD056E0  0018FC5E   LW V0, 24(S8)
BFD056E4  FFC43042   ADDIU V0, V0, -60
BFD056E6  F85EFFC4   LW S8, -1954(A0)
BFD056E8  0018F85E   SW V0, 24(S8)
263:                 
264:                 	return pxTopOfStack;
BFD056EC  0018FC5E   LW V0, 24(S8)
265:                 }
BFD056F0      0FBE   MOVE SP, S8
BFD056F2      4BE5   LW RA, 20(SP)
BFD056F4      4BC4   LW S8, 16(SP)
BFD056F6      4C0D   ADDIU SP, SP, 24
BFD056F8      459F   JR16 RA
BFD056FA      0C00   NOP
266:                 /*-----------------------------------------------------------*/
267:                 
268:                 static void prvTaskExitError( void )
269:                 {
BFD07BBC      4FF1   ADDIU SP, SP, -32
BFD07BBE      CBE7   SW RA, 28(SP)
BFD07BC0      CBC6   SW S8, 24(SP)
BFD07BC2      0FDD   MOVE S8, SP
270:                 	/* A function that implements a task must not exit or attempt to return to
271:                 	its caller as there is nothing to return to.  If a task wants to exit it
272:                 	should instead call vTaskDelete( NULL ).
273:                 
274:                 	Artificially force an assert() to be triggered if configASSERT() is
275:                 	defined, then stop here so application writers can catch the error. */
276:                 	configASSERT( uxSavedTaskStackPointer == 0UL );
BFD07BC4  802CFC5C   LW V0, -32724(GP)
BFD07BC8  000940E2   BEQZC V0, 0xBFD07BDE
BFD07BCC  BFD141A2   LUI V0, 0xBFD1
BFD07BCE  3082BFD1   LDC1 F30, 12418(S1)
BFD07BD0  8AAC3082   ADDIU A0, V0, -30036
BFD07BD2      8AAC   SB A1, 12(V0)
BFD07BD4  011430A0   ADDIU A1, ZERO, 276
BFD07BD8  4B7E77E8   JALS vAssertCalled
BFD07BDA      4B7E   LW K1, 120(SP)
BFD07BDC      0C00   NOP
277:                 	portDISABLE_INTERRUPTS();
BFD07BDE  4DA677E8   JALS ulPortGetCP0Status
BFD07BE0      4DA6   ADDIU T5, T5, 3
BFD07BE2      0C00   NOP
BFD07BE4  0010F85E   SW V0, 16(S8)
BFD07BE8  0010FC7E   LW V1, 16(S8)
BFD07BEC  000141A2   LUI V0, 0x1
BFD07BF0  FC005042   ORI V0, V0, -1024
BFD07BF2  4493FC00   LW ZERO, 17555(ZERO)
BFD07BF4      4493   AND16 V0, V1
BFD07BF6  50400042   SRL V0, V0, 10
BFD07BF8  B0425040   ORI V0, ZERO, -20414
BFD07BFA  0003B042   SLTIU V0, V0, 3
BFD07BFE  001140E2   BEQZC V0, 0xBFD07C24
BFD07C02  0010FC7E   LW V1, 16(S8)
BFD07C06  FFFE41A2   LUI V0, 0xFFFE
BFD07C08  5042FFFE   LW RA, 20546(S8)
BFD07C0A  03FF5042   ORI V0, V0, 1023
BFD07C0E      4493   AND16 V0, V1
BFD07C10  0010F85E   SW V0, 16(S8)
BFD07C14  0010FC5E   LW V0, 16(S8)
BFD07C18  0C005042   ORI V0, V0, 3072
BFD07C1A      0C00   NOP
BFD07C1C      0C82   MOVE A0, V0
BFD07C1E  4DB677E8   JALS vPortSetCP0Status
BFD07C20      4DB6   ADDIU T5, T5, -5
BFD07C22      0C00   NOP
278:                 	for( ;; );
BFD07C24      CFFF   B 0xBFD07C24
BFD07C26      0C00   NOP
279:                 }
280:                 /*-----------------------------------------------------------*/
281:                 
282:                 /*
283:                  * Setup a timer for a regular tick.  This function uses peripheral timer 1.
284:                  * The function is declared weak so an application writer can use a different
285:                  * timer by redefining this implementation.  If a different timer is used then
286:                  * configTICK_INTERRUPT_VECTOR must also be defined in FreeRTOSConfig.h to
287:                  * ensure the RTOS provided tick interrupt handler is installed on the correct
288:                  * vector number.  When Timer 1 is used the vector number is defined as
289:                  * _TIMER_1_VECTOR.
290:                  */
291:                 __attribute__(( weak )) void vApplicationSetupTickTimerInterrupt( void )
292:                 {
BFD06284      4FF1   ADDIU SP, SP, -32
BFD06286      CBE7   SW RA, 28(SP)
BFD06288      CBC6   SW S8, 24(SP)
BFD0628A      0FDD   MOVE S8, SP
293:                 	/* MEC14xx RTOS Timer whose input clock is 32KHz */
294:                 	const uint32_t preload = ( 32768ul / ( configTICK_RATE_HZ ) );
BFD0628C      ED20   LI V0, 32
BFD0628E  0010F85E   SW V0, 16(S8)
295:                 	configASSERT( preload != 0UL );
BFD06292  0010FC5E   LW V0, 16(S8)
BFD06296  000940A2   BNEZC V0, 0xBFD062AC
BFD0629A  BFD141A2   LUI V0, 0xBFD1
BFD0629C  3082BFD1   LDC1 F30, 12418(S1)
BFD0629E  8AAC3082   ADDIU A0, V0, -30036
BFD062A0      8AAC   SB A1, 12(V0)
BFD062A2  012730A0   ADDIU A1, ZERO, 295
BFD062A6  4B7E77E8   JALS vAssertCalled
BFD062A8      4B7E   LW K1, 120(SP)
BFD062AA      0C00   NOP
296:                 
297:                 	portMMCR_RTMR_CONTROL = 0ul;
BFD062AC  A00041A2   LUI V0, 0xA000
BFD062B0  74085042   ORI V0, V0, 29704
BFD062B2  E8207408   JALS 0xB811D040
BFD062B4      E820   SW S0, 0(V0)
298:                 	portMMCR_RTMR_PRELOAD = preload;
BFD062B6  A00041A2   LUI V0, 0xA000
BFD062BA  74045042   ORI V0, V0, 29700
BFD062BC  FC7E7404   JALS 0xB809F8FC
BFD062BE  0010FC7E   LW V1, 16(S8)
BFD062C2      E9A0   SW V1, 0(V0)
299:                 
300:                 	portMMCR_JTVIC_GIRQ23_SRC = ( portGIRQ23_RTOS_TIMER_MASK );
BFD062C4  BFFF41A2   LUI V0, 0xBFFF
BFD062C6  5042BFFF   LDC1 F31, 20546(RA)
BFD062C8  C0F05042   ORI V0, V0, -16144
BFD062CC      ED90   LI V1, 16
BFD062CE      E9A0   SW V1, 0(V0)
301:                 	portMMCR_JTVIC_GIRQ23_PRIA &= ~( 0x0Ful << 16 );
BFD062D0  BFFF41A2   LUI V0, 0xBFFF
BFD062D2  5042BFFF   LDC1 F31, 20546(RA)
BFD062D4  C3F05042   ORI V0, V0, -15376
BFD062D8  BFFF41A3   LUI V1, 0xBFFF
BFD062DA  5063BFFF   LDC1 F31, 20579(RA)
BFD062DC  C3F05063   ORI V1, V1, -15376
BFD062E0      6A30   LW A0, 0(V1)
BFD062E2  FFF041A3   LUI V1, 0xFFF0
BFD062E4  5063FFF0   LW RA, 20579(S0)
BFD062E6  FFFF5063   ORI V1, V1, -1
BFD062E8  449CFFFF   LW RA, 17564(RA)
BFD062EA      449C   AND16 V1, A0
BFD062EC      E9A0   SW V1, 0(V0)
302:                 	portMMCR_JTVIC_GIRQ23_PRIA |= ( ( configKERNEL_INTERRUPT_PRIORITY ) << 16 );
BFD062EE  BFFF41A2   LUI V0, 0xBFFF
BFD062F0  5042BFFF   LDC1 F31, 20546(RA)
BFD062F2  C3F05042   ORI V0, V0, -15376
BFD062F6  BFFF41A3   LUI V1, 0xBFFF
BFD062F8  5063BFFF   LDC1 F31, 20579(RA)
BFD062FA  C3F05063   ORI V1, V1, -15376
BFD062FE      69B0   LW V1, 0(V1)
BFD06300      E9A0   SW V1, 0(V0)
303:                 	portMMCR_JTVIC_GIRQ23_SETEN = ( portGIRQ23_RTOS_TIMER_MASK );
BFD06302  BFFF41A2   LUI V0, 0xBFFF
BFD06304  5042BFFF   LDC1 F31, 20546(RA)
BFD06306  C0F45042   ORI V0, V0, -16140
BFD0630A      ED90   LI V1, 16
BFD0630C      E9A0   SW V1, 0(V0)
304:                 
305:                 	portMMCR_RTMR_CONTROL = 0x0Fu;
BFD0630E  A00041A2   LUI V0, 0xA000
BFD06312  74085042   ORI V0, V0, 29704
BFD06314  ED8F7408   JALS 0xB811DB1E
BFD06316      ED8F   LI V1, 15
BFD06318      E9A0   SW V1, 0(V0)
306:                 }
BFD0631A      0FBE   MOVE SP, S8
BFD0631C      4BE7   LW RA, 28(SP)
BFD0631E      4BC6   LW S8, 24(SP)
BFD06320      4C11   ADDIU SP, SP, 32
BFD06322      459F   JR16 RA
BFD06324      0C00   NOP
307:                 /*-----------------------------------------------------------*/
308:                 
309:                 void vPortEndScheduler(void)
310:                 {
BFD097A8      4FF5   ADDIU SP, SP, -24
BFD097AA      CBE5   SW RA, 20(SP)
BFD097AC      CBC4   SW S8, 16(SP)
BFD097AE      0FDD   MOVE S8, SP
311:                 	/* Not implemented in ports where there is nothing to return to.
312:                 	Artificially force an assert. */
313:                 	configASSERT( uxInterruptNesting == 1000UL );
BFD097B0  8014FC7C   LW V1, -32748(GP)
BFD097B4  03E83040   ADDIU V0, ZERO, 1000
BFD097B8  000A9443   BEQ V1, V0, 0xBFD097D0
BFD097BA  0C00000A   SLL ZERO, T2, 1
BFD097BC      0C00   NOP
BFD097BE  BFD141A2   LUI V0, 0xBFD1
BFD097C0  3082BFD1   LDC1 F30, 12418(S1)
BFD097C2  8AAC3082   ADDIU A0, V0, -30036
BFD097C4      8AAC   SB A1, 12(V0)
BFD097C6  013930A0   ADDIU A1, ZERO, 313
BFD097CA  4B7E77E8   JALS vAssertCalled
BFD097CC      4B7E   LW K1, 120(SP)
BFD097CE      0C00   NOP
314:                 }
BFD097D0      0FBE   MOVE SP, S8
BFD097D2      4BE5   LW RA, 20(SP)
BFD097D4      4BC4   LW S8, 16(SP)
BFD097D6      4C0D   ADDIU SP, SP, 24
BFD097D8      459F   JR16 RA
BFD097DA      0C00   NOP
315:                 /*-----------------------------------------------------------*/
316:                 
317:                 BaseType_t xPortStartScheduler( void )
318:                 {
BFD06898      4FF5   ADDIU SP, SP, -24
BFD0689A      CBE5   SW RA, 20(SP)
BFD0689C      CBC4   SW S8, 16(SP)
BFD0689E      0FDD   MOVE S8, SP
319:                 extern void vPortStartFirstTask( void );
320:                 extern void *pxCurrentTCB;
321:                 
322:                 	#if ( configCHECK_FOR_STACK_OVERFLOW > 2 )
323:                 	{
324:                 		/* Fill the ISR stack to make it easy to asses how much is being used. */
325:                 		memset( ( void * ) xISRStack, portISR_STACK_FILL_BYTE, sizeof( xISRStack ) );
BFD068A0  BFD241A2   LUI V0, 0xBFD2
BFD068A2  3082BFD2   LDC1 F30, 12418(S2)
BFD068A4  AD683082   ADDIU A0, V0, -21144
BFD068A6      AD68   BNEZ V0, 0xBFD06978
BFD068A8  00EE30A0   ADDIU A1, ZERO, 238
BFD068AA  30C000EE   ROTR A3, T6, 6
BFD068AC  0BE030C0   ADDIU A2, ZERO, 3040
BFD068AE      0BE0   LBU A3, 0(A2)
BFD068B0  36F677E8   JALS 0xBFD06DEC
BFD068B2  0C0036F6   LHU S7, 3072(S6)
BFD068B4      0C00   NOP
326:                 	}
327:                 	#endif /* configCHECK_FOR_STACK_OVERFLOW > 2 */
328:                 
329:                 	/* Clear the software interrupt flag. */
330:                 	portMMCR_JTVIC_GIRQ24_SRC = (portGIRQ24_M14K_SOFTIRQ0_MASK);
BFD068B6  BFFF41A2   LUI V0, 0xBFFF
BFD068B8  5042BFFF   LDC1 F31, 20546(RA)
BFD068BA  C1005042   ORI V0, V0, -16128
BFD068BE      ED82   LI V1, 2
BFD068C0      E9A0   SW V1, 0(V0)
331:                 
332:                 	/* Set software timer priority.
333:                 	Each GIRQn has one nibble containing its priority */
334:                 	portMMCR_JTVIC_GIRQ24_PRIA &= ~(0xF0ul);
BFD068C2  BFFF41A2   LUI V0, 0xBFFF
BFD068C4  5042BFFF   LDC1 F31, 20546(RA)
BFD068C6  C4005042   ORI V0, V0, -15360
BFD068CA  BFFF41A3   LUI V1, 0xBFFF
BFD068CC  5063BFFF   LDC1 F31, 20579(RA)
BFD068CE  C4005063   ORI V1, V1, -15360
BFD068D2      6A30   LW A0, 0(V1)
BFD068D4  FF0F3060   ADDIU V1, ZERO, -241
BFD068D6  449CFF0F   LW T8, 17564(T7)
BFD068D8      449C   AND16 V1, A0
BFD068DA      E9A0   SW V1, 0(V0)
335:                 	portMMCR_JTVIC_GIRQ24_PRIA |= ( configKERNEL_INTERRUPT_PRIORITY << 4 );
BFD068DC  BFFF41A2   LUI V0, 0xBFFF
BFD068DE  5042BFFF   LDC1 F31, 20546(RA)
BFD068E0  C4005042   ORI V0, V0, -15360
BFD068E4  BFFF41A3   LUI V1, 0xBFFF
BFD068E6  5063BFFF   LDC1 F31, 20579(RA)
BFD068E8  C4005063   ORI V1, V1, -15360
BFD068EC      69B0   LW V1, 0(V1)
BFD068EE      E9A0   SW V1, 0(V0)
336:                 
337:                 	/* Enable software interrupt. */
338:                 	portMMCR_JTVIC_GIRQ24_SETEN = ( portGIRQ24_M14K_SOFTIRQ0_MASK );
BFD068F0  BFFF41A2   LUI V0, 0xBFFF
BFD068F2  5042BFFF   LDC1 F31, 20546(RA)
BFD068F4  C1045042   ORI V0, V0, -16124
BFD068F8      ED82   LI V1, 2
BFD068FA      E9A0   SW V1, 0(V0)
339:                 
340:                 	/* Setup the timer to generate the tick.  Interrupts will have been
341:                 	disabled by the time we get here. */
342:                 	vApplicationSetupTickTimerInterrupt();
BFD068FC  314277E8   JALS vApplicationSetupTickTimerInterrupt
BFD068FE  0C003142   ADDIU T2, V0, 3072
BFD06900      0C00   NOP
343:                 
344:                 	/* Kick off the highest priority task that has been created so far.
345:                 	Its stack location is loaded into uxSavedTaskStackPointer. */
346:                 	uxSavedTaskStackPointer = *( UBaseType_t * ) pxCurrentTCB;
BFD06902  8030FC5C   LW V0, -32720(GP)
BFD06906      6920   LW V0, 0(V0)
BFD06908  802CF85C   SW V0, -32724(GP)
347:                 	vPortStartFirstTask();
BFD0690C  055A77E8   JALS 0xBFD00AB4
BFD0690E      055A   ADDU V0, A1, A1
BFD06910      0C00   NOP
348:                 
349:                 	/* Should never get here as the tasks will now be executing!  Call the task
350:                 	exit error function to prevent compiler warnings about a static function
351:                 	not being called in the case that the application writer overrides this
352:                 	functionality by defining configTASK_RETURN_ADDRESS. */
353:                 	prvTaskExitError();
BFD06912  3DDE77E8   JALS prvTaskExitError
BFD06914  0C003DDE   LH T6, 3072(S8)
BFD06916      0C00   NOP
354:                 
355:                 	return pdFALSE;
BFD06918      0C40   MOVE V0, ZERO
356:                 }
BFD0691A      0FBE   MOVE SP, S8
BFD0691C      4BE5   LW RA, 20(SP)
BFD0691E      4BC4   LW S8, 16(SP)
BFD06920      4C0D   ADDIU SP, SP, 24
BFD06922      459F   JR16 RA
BFD06924      0C00   NOP
357:                 /*-----------------------------------------------------------*/
358:                 
359:                 void vPortIncrementTick( void )
360:                 {
BFD069B8      4FF1   ADDIU SP, SP, -32
BFD069BA      CBE7   SW RA, 28(SP)
BFD069BC      CBC6   SW S8, 24(SP)
BFD069BE      0FDD   MOVE S8, SP
361:                 UBaseType_t uxSavedStatus;
362:                 uint32_t ulCause;
363:                 
364:                 	uxSavedStatus = uxPortSetInterruptMaskFromISR();
BFD069C0  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD069C4      0C00   NOP
BFD069C6  0010F85E   SW V0, 16(S8)
365:                 	{
366:                 		if( xTaskIncrementTick() != pdFALSE )
BFD069CA  104077E8   JALS xTaskIncrementTick
BFD069CC  0C001040   ADDI V0, ZERO, 3072
BFD069CE      0C00   NOP
BFD069D0  001040E2   BEQZC V0, 0xBFD069F4
367:                 		{
368:                 			/* Pend a context switch. */
369:                 			ulCause = ulPortGetCP0Cause();
BFD069D4  4DC677E8   JALS ulPortGetCP0Cause
BFD069D6      4DC6   ADDIU T6, T6, 3
BFD069D8      0C00   NOP
BFD069DA  0014F85E   SW V0, 20(S8)
370:                 			ulCause |= ( 1ul << 8UL );
BFD069DE  0014FC5E   LW V0, 20(S8)
BFD069E2  01005042   ORI V0, V0, 256
BFD069E6  0014F85E   SW V0, 20(S8)
371:                 			vPortSetCP0Cause( ulCause );
BFD069EA  0014FC9E   LW A0, 20(S8)
BFD069EE  4DD677E8   JALS vPortSetCP0Cause
BFD069F0      4DD6   ADDIU T6, T6, -5
BFD069F2      0C00   NOP
372:                 		}
373:                 	}
374:                 	vPortClearInterruptMaskFromISR( uxSavedStatus );
BFD069F4  0010FC9E   LW A0, 16(S8)
BFD069F8  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD069FA      4D5E   ADDIU T2, T2, -1
BFD069FC      0C00   NOP
375:                 
376:                 	/* Look for the ISR stack getting near or past its limit. */
377:                 	portCHECK_ISR_STACK();
BFD069FE  BFD241A2   LUI V0, 0xBFD2
BFD06A00  3082BFD2   LDC1 F30, 12418(S2)
BFD06A02  AD683082   ADDIU A0, V0, -21144
BFD06A04      AD68   BNEZ V0, 0xBFD06AD6
BFD06A06  BFD141A2   LUI V0, 0xBFD1
BFD06A08  30A2BFD1   LDC1 F30, 12450(S1)
BFD06A0A  8A9430A2   ADDIU A1, V0, -30060
BFD06A0C      8A94   SB A1, 4(S1)
BFD06A0E      EF14   LI A2, 20
BFD06A10  3DA677E8   JALS 0xBFD07B4C
BFD06A12  0C003DA6   LH T5, 3072(A2)
BFD06A14      0C00   NOP
BFD06A16  000940E2   BEQZC V0, 0xBFD06A2C
BFD06A1A  BFD141A2   LUI V0, 0xBFD1
BFD06A1C  3082BFD1   LDC1 F30, 12418(S1)
BFD06A1E  8AAC3082   ADDIU A0, V0, -30036
BFD06A20      8AAC   SB A1, 12(V0)
BFD06A22  017930A0   ADDIU A1, ZERO, 377
BFD06A26  4B7E77E8   JALS vAssertCalled
BFD06A28      4B7E   LW K1, 120(SP)
BFD06A2A      0C00   NOP
378:                 
379:                 	/* Clear timer interrupt. */
380:                 	configCLEAR_TICK_TIMER_INTERRUPT();
BFD06A2C  BFFF41A2   LUI V0, 0xBFFF
BFD06A2E  5042BFFF   LDC1 F31, 20546(RA)
BFD06A30  C0F05042   ORI V0, V0, -16144
BFD06A34      ED90   LI V1, 16
BFD06A36      E9A0   SW V1, 0(V0)
381:                 }
BFD06A38      0FBE   MOVE SP, S8
BFD06A3A      4BE7   LW RA, 28(SP)
BFD06A3C      4BC6   LW S8, 24(SP)
BFD06A3E      4C11   ADDIU SP, SP, 32
BFD06A40      459F   JR16 RA
BFD06A42      0C00   NOP
382:                 /*-----------------------------------------------------------*/
383:                 
384:                 UBaseType_t uxPortSetInterruptMaskFromISR( void )
385:                 {
BFD08EBC      4FF1   ADDIU SP, SP, -32
BFD08EBE      CBE7   SW RA, 28(SP)
BFD08EC0      CBC6   SW S8, 24(SP)
BFD08EC2      0FDD   MOVE S8, SP
386:                 UBaseType_t uxSavedStatusRegister;
387:                 
388:                 	prvDisableInterrupt();
BFD08EC4  4D4C77E8   JALS prvDisableInterrupt
BFD08EC6      4D4C   ADDIU T2, T2, 6
BFD08EC8      0C00   NOP
389:                 	uxSavedStatusRegister = ulPortGetCP0Status() | 0x01;
BFD08ECA  4DA677E8   JALS ulPortGetCP0Status
BFD08ECC      4DA6   ADDIU T5, T5, 3
BFD08ECE      0C00   NOP
BFD08ED0  00015042   ORI V0, V0, 1
BFD08ED4  0010F85E   SW V0, 16(S8)
390:                 
391:                 	/* This clears the IPL bits, then sets them to
392:                 	configMAX_SYSCALL_INTERRUPT_PRIORITY.  This function should not be called
393:                 	from an interrupt that has a priority above
394:                 	configMAX_SYSCALL_INTERRUPT_PRIORITY so, when used correctly, the action
395:                 	can only result in the IPL being unchanged or raised, and therefore never
396:                 	lowered. */
397:                 	vPortSetCP0Status( ( ( uxSavedStatusRegister & ( ~portALL_IPL_BITS ) ) ) | ( configMAX_SYSCALL_INTERRUPT_PRIORITY << portIPL_SHIFT ) );
BFD08ED8  0010FC7E   LW V1, 16(S8)
BFD08EDC  FFFE41A2   LUI V0, 0xFFFE
BFD08EDE  5042FFFE   LW RA, 20546(S8)
BFD08EE0  03FF5042   ORI V0, V0, 1023
BFD08EE4      4493   AND16 V0, V1
BFD08EE6  0C005042   ORI V0, V0, 3072
BFD08EE8      0C00   NOP
BFD08EEA      0C82   MOVE A0, V0
BFD08EEC  4DB677E8   JALS vPortSetCP0Status
BFD08EEE      4DB6   ADDIU T5, T5, -5
BFD08EF0      0C00   NOP
398:                 
399:                 	return uxSavedStatusRegister;
BFD08EF2  0010FC5E   LW V0, 16(S8)
400:                 }
BFD08EF6      0FBE   MOVE SP, S8
BFD08EF8      4BE7   LW RA, 28(SP)
BFD08EFA      4BC6   LW S8, 24(SP)
BFD08EFC      4C11   ADDIU SP, SP, 32
BFD08EFE      459F   JR16 RA
BFD08F00      0C00   NOP
401:                 /*-----------------------------------------------------------*/
402:                 
403:                 void vPortClearInterruptMaskFromISR( UBaseType_t uxSavedStatusRegister )
404:                 {
BFD09ABC      4FF5   ADDIU SP, SP, -24
BFD09ABE      CBE5   SW RA, 20(SP)
BFD09AC0      CBC4   SW S8, 16(SP)
BFD09AC2      0FDD   MOVE S8, SP
BFD09AC4  0018F89E   SW A0, 24(S8)
405:                 	vPortSetCP0Status( uxSavedStatusRegister );
BFD09AC8  0018FC9E   LW A0, 24(S8)
BFD09ACC  4DB677E8   JALS vPortSetCP0Status
BFD09ACE      4DB6   ADDIU T5, T5, -5
BFD09AD0      0C00   NOP
406:                 }
BFD09AD2      0FBE   MOVE SP, S8
BFD09AD4      4BE5   LW RA, 20(SP)
BFD09AD6      4BC4   LW S8, 16(SP)
BFD09AD8      4C0D   ADDIU SP, SP, 24
BFD09ADA      459F   JR16 RA
BFD09ADC      0C00   NOP
407:                 /*-----------------------------------------------------------*/
408:                 
409:                 
410:                 
411:                 
412:                 
---  c:/e/dev/freertos/workingcopy/freertos/source/portable/memmang/heap_2.c  ---------------------------
1:                   /*
2:                       FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /*
71:                   * A sample implementation of pvPortMalloc() and vPortFree() that permits
72:                   * allocated blocks to be freed, but does not combine adjacent free blocks
73:                   * into a single larger block (and so will fragment memory).  See heap_4.c for
74:                   * an equivalent that does combine adjacent blocks into single larger blocks.
75:                   *
76:                   * See heap_1.c, heap_3.c and heap_4.c for alternative implementations, and the
77:                   * memory management pages of http://www.FreeRTOS.org for more information.
78:                   */
79:                  #include <stdlib.h>
80:                  
81:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
82:                  all the API functions to use the MPU wrappers.  That should only be done when
83:                  task.h is included from an application file. */
84:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
85:                  
86:                  #include "FreeRTOS.h"
87:                  #include "task.h"
88:                  
89:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
90:                  
91:                  /* A few bytes might be lost to byte aligning the heap start address. */
92:                  #define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
93:                  
94:                  /*
95:                   * Initialises the heap structures before their first use.
96:                   */
97:                  static void prvHeapInit( void );
98:                  
99:                  /* Allocate the memory for the heap. */
100:                 static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
101:                 
102:                 /* Define the linked list structure.  This is used to link free blocks in order
103:                 of their size. */
104:                 typedef struct A_BLOCK_LINK
105:                 {
106:                 	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
107:                 	size_t xBlockSize;						/*<< The size of the free block. */
108:                 } BlockLink_t;
109:                 
110:                 
111:                 static const uint16_t heapSTRUCT_SIZE	= ( ( sizeof ( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );
112:                 #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )
113:                 
114:                 /* Create a couple of list links to mark the start and end of the list. */
115:                 static BlockLink_t xStart, xEnd;
116:                 
117:                 /* Keeps track of the number of free bytes remaining, but says nothing about
118:                 fragmentation. */
119:                 static size_t xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;
120:                 
121:                 /* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */
122:                 
123:                 /*
124:                  * Insert a block into the list of free blocks - which is ordered by size of
125:                  * the block.  Small blocks at the start of the list and large blocks at the end
126:                  * of the list.
127:                  */
128:                 #define prvInsertBlockIntoFreeList( pxBlockToInsert )								\
129:                 {																					\
130:                 BlockLink_t *pxIterator;																\
131:                 size_t xBlockSize;																	\
132:                 																					\
133:                 	xBlockSize = pxBlockToInsert->xBlockSize;										\
134:                 																					\
135:                 	/* Iterate through the list until a block is found that has a larger size */	\
136:                 	/* than the block we are inserting. */											\
137:                 	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock->xBlockSize < xBlockSize; pxIterator = pxIterator->pxNextFreeBlock )	\
138:                 	{																				\
139:                 		/* There is nothing to do here - just iterate to the correct position. */	\
140:                 	}																				\
141:                 																					\
142:                 	/* Update the list to include the block being inserted in the correct */		\
143:                 	/* position. */																	\
144:                 	pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;					\
145:                 	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
146:                 }
147:                 /*-----------------------------------------------------------*/
148:                 
149:                 void *pvPortMalloc( size_t xWantedSize )
150:                 {
BFD0222C      4FE9   ADDIU SP, SP, -48
BFD0222E      CBEB   SW RA, 44(SP)
BFD02230      CBCA   SW S8, 40(SP)
BFD02232      0FDD   MOVE S8, SP
BFD02234  0030F89E   SW A0, 48(S8)
151:                 BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
152:                 static BaseType_t xHeapHasBeenInitialised = pdFALSE;
153:                 void *pvReturn = NULL;
BFD02238  0018F81E   SW ZERO, 24(S8)
154:                 
155:                 	vTaskSuspendAll();
BFD0223C  4EF477E8   JALS vTaskSuspendAll
BFD0223E      4EF4   ADDIU S7, S7, -6
BFD02240      0C00   NOP
156:                 	{
157:                 		/* If this is the first call to malloc then the heap will require
158:                 		initialisation to setup the list of free blocks. */
159:                 		if( xHeapHasBeenInitialised == pdFALSE )
BFD02242  8028FC5C   LW V0, -32728(GP)
BFD02246  000640A2   BNEZC V0, 0xBFD02256
160:                 		{
161:                 			prvHeapInit();
BFD0224A  425077E8   JALS prvHeapInit
BFD0224E      0C00   NOP
162:                 			xHeapHasBeenInitialised = pdTRUE;
BFD02250      ED01   LI V0, 1
BFD02252  8028F85C   SW V0, -32728(GP)
163:                 		}
164:                 
165:                 		/* The wanted size is increased so it can contain a BlockLink_t
166:                 		structure in addition to the requested amount of bytes. */
167:                 		if( xWantedSize > 0 )
BFD02256  0030FC5E   LW V0, 48(S8)
BFD0225A  001640E2   BEQZC V0, 0xBFD0228A
168:                 		{
169:                 			xWantedSize += heapSTRUCT_SIZE;
BFD0225E  BFD141A2   LUI V0, 0xBFD1
BFD02260  3442BFD1   LDC1 F30, 13378(S1)
BFD02262  9F2C3442   LHU V0, -24788(V0)
BFD02264  FC7E9F2C   LWC1 F25, -898(T4)
BFD02266  0030FC7E   LW V1, 48(S8)
BFD0226A      0526   ADDU V0, V1, V0
BFD0226C  0030F85E   SW V0, 48(S8)
170:                 
171:                 			/* Ensure that blocks are always aligned to the required number of bytes. */
172:                 			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
BFD02270  0030FC5E   LW V0, 48(S8)
BFD02274      2D25   ANDI V0, V0, 0x7
BFD02276  000840E2   BEQZC V0, 0xBFD0228A
173:                 			{
174:                 				/* Byte alignment required. */
175:                 				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
BFD0227A  0030FC7E   LW V1, 48(S8)
BFD0227C  30400030   SRL AT, S0, 6
BFD0227E  FFF83040   ADDIU V0, ZERO, -8
BFD02280  4493FFF8   LW RA, 17555(T8)
BFD02282      4493   AND16 V0, V1
BFD02284      6D24   ADDIU V0, V0, 8
BFD02286  0030F85E   SW V0, 48(S8)
176:                 			}
177:                 		}
178:                 
179:                 		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
BFD0228A  0030FC5E   LW V0, 48(S8)
BFD0228E  008F40E2   BEQZC V0, 0xBFD023B0
BFD02292  0030FC5E   LW V0, 48(S8)
BFD02296  1FF8B042   SLTIU V0, V0, 8184
BFD02298  40E21FF8   LB RA, 16610(T8)
BFD0229A  008940E2   BEQZC V0, 0xBFD023B0
180:                 		{
181:                 			/* Blocks are stored in byte order - traverse the list from the start
182:                 			(smallest) block until one of adequate size is found. */
183:                 			pxPreviousBlock = &xStart;
BFD0229E  8018305C   ADDIU V0, GP, -32744
BFD022A2  0014F85E   SW V0, 20(S8)
184:                 			pxBlock = xStart.pxNextFreeBlock;
BFD022A6  8018FC5C   LW V0, -32744(GP)
BFD022AA  0010F85E   SW V0, 16(S8)
185:                 			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
BFD022AE      CC0A   B 0xBFD022C4
BFD022B0      0C00   NOP
BFD022C4  0010FC5E   LW V0, 16(S8)
BFD022C8      69A1   LW V1, 4(V0)
BFD022CA  0030FC5E   LW V0, 48(S8)
BFD022CE  13900043   SLTU V0, V1, V0
BFD022D0  40E21390   ADDI GP, S0, 16610
BFD022D2  000540E2   BEQZC V0, 0xBFD022E0
BFD022D6  0010FC5E   LW V0, 16(S8)
BFD022DA      6920   LW V0, 0(V0)
BFD022DC  FFE940A2   BNEZC V0, 0xBFD022B2
BFD022DE  FC7EFFE9   LW RA, -898(T1)
186:                 			{
187:                 				pxPreviousBlock = pxBlock;
BFD022B2  0010FC5E   LW V0, 16(S8)
BFD022B6  0014F85E   SW V0, 20(S8)
188:                 				pxBlock = pxBlock->pxNextFreeBlock;
BFD022BA  0010FC5E   LW V0, 16(S8)
BFD022BE      6920   LW V0, 0(V0)
BFD022C0  0010F85E   SW V0, 16(S8)
189:                 			}
190:                 
191:                 			/* If we found the end marker then a block of adequate size was not found. */
192:                 			if( pxBlock != &xEnd )
BFD022E0  0010FC7E   LW V1, 16(S8)
BFD022E4  8020305C   ADDIU V0, GP, -32736
BFD022E8  00629443   BEQ V1, V0, 0xBFD023B0
BFD022EA  0C000062   SLL V1, V0, 1
BFD022EC      0C00   NOP
193:                 			{
194:                 				/* Return the memory space - jumping over the BlockLink_t structure
195:                 				at its start. */
196:                 				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
BFD022EE  0014FC5E   LW V0, 20(S8)
BFD022F2      69A0   LW V1, 0(V0)
BFD022F4  BFD141A2   LUI V0, 0xBFD1
BFD022F6  3442BFD1   LDC1 F30, 13378(S1)
BFD022F8  9F2C3442   LHU V0, -24788(V0)
BFD022FA  05269F2C   LWC1 F25, 1318(T4)
BFD022FC      0526   ADDU V0, V1, V0
BFD022FE  0018F85E   SW V0, 24(S8)
197:                 
198:                 				/* This block is being returned for use so must be taken out of the
199:                 				list of free blocks. */
200:                 				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
BFD02302  0010FC5E   LW V0, 16(S8)
BFD02306      69A0   LW V1, 0(V0)
BFD02308  0014FC5E   LW V0, 20(S8)
BFD0230C      E9A0   SW V1, 0(V0)
201:                 
202:                 				/* If the block is larger than required it can be split into two. */
203:                 				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
BFD0230E  0010FC5E   LW V0, 16(S8)
BFD02312      69A1   LW V1, 4(V0)
BFD02314  0030FC5E   LW V0, 48(S8)
BFD02318      05A7   SUBU V1, V1, V0
BFD0231A  BFD141A2   LUI V0, 0xBFD1
BFD0231C  3442BFD1   LDC1 F30, 13378(S1)
BFD0231E  9F2C3442   LHU V0, -24788(V0)
BFD02320  25229F2C   LWC1 F25, 9506(T4)
BFD02322      2522   SLL V0, V0, 1
BFD02324  13900062   SLTU V0, V0, V1
BFD02326  40E21390   ADDI GP, S0, 16610
BFD02328  003A40E2   BEQZC V0, 0xBFD023A0
204:                 				{
205:                 					/* This block is to be split into two.  Create a new block
206:                 					following the number of bytes requested. The void cast is
207:                 					used to prevent byte alignment warnings from the compiler. */
208:                 					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
BFD0232C  0010FC7E   LW V1, 16(S8)
BFD02330  0030FC5E   LW V0, 48(S8)
BFD02334      0526   ADDU V0, V1, V0
BFD02336  0020F85E   SW V0, 32(S8)
209:                 
210:                 					/* Calculate the sizes of two blocks split from the single
211:                 					block. */
212:                 					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
BFD0233A  0010FC5E   LW V0, 16(S8)
BFD0233E      69A1   LW V1, 4(V0)
BFD02340  0030FC5E   LW V0, 48(S8)
BFD02344      05A7   SUBU V1, V1, V0
BFD02346  0020FC5E   LW V0, 32(S8)
BFD0234A      E9A1   SW V1, 4(V0)
213:                 					pxBlock->xBlockSize = xWantedSize;
BFD0234C  0010FC5E   LW V0, 16(S8)
BFD02350  0030FC7E   LW V1, 48(S8)
BFD02354      E9A1   SW V1, 4(V0)
214:                 
215:                 					/* Insert the new block into the list of free blocks. */
216:                 					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
BFD02356  0020FC5E   LW V0, 32(S8)
BFD0235A      6921   LW V0, 4(V0)
BFD0235C  0024F85E   SW V0, 36(S8)
BFD02360  8018305C   ADDIU V0, GP, -32744
BFD02364  001CF85E   SW V0, 28(S8)
BFD02368      CC06   B 0xBFD02376
BFD0236A      0C00   NOP
BFD0236C  001CFC5E   LW V0, 28(S8)
BFD02370      6920   LW V0, 0(V0)
BFD02372  001CF85E   SW V0, 28(S8)
BFD02376  001CFC5E   LW V0, 28(S8)
BFD0237A      6920   LW V0, 0(V0)
BFD0237C      69A1   LW V1, 4(V0)
BFD0237E  0024FC5E   LW V0, 36(S8)
BFD02382  13900043   SLTU V0, V1, V0
BFD02384  40A21390   ADDI GP, S0, 16546
BFD02386  FFF140A2   BNEZC V0, 0xBFD0236C
BFD02388  FC5EFFF1   LW RA, -930(S1)
BFD0238A  001CFC5E   LW V0, 28(S8)
BFD0238E      69A0   LW V1, 0(V0)
BFD02390  0020FC5E   LW V0, 32(S8)
BFD02394      E9A0   SW V1, 0(V0)
BFD02396  001CFC5E   LW V0, 28(S8)
BFD0239A  0020FC7E   LW V1, 32(S8)
BFD0239E      E9A0   SW V1, 0(V0)
217:                 				}
218:                 
219:                 				xFreeBytesRemaining -= pxBlock->xBlockSize;
BFD023A0  8010FC7C   LW V1, -32752(GP)
BFD023A4  0010FC5E   LW V0, 16(S8)
BFD023A8      6921   LW V0, 4(V0)
BFD023AA      0527   SUBU V0, V1, V0
BFD023AC  8010F85C   SW V0, -32752(GP)
220:                 			}
221:                 		}
222:                 
223:                 		traceMALLOC( pvReturn, xWantedSize );
224:                 	}
225:                 	( void ) xTaskResumeAll();
BFD023B0  158E77E8   JALS xTaskResumeAll
BFD023B2  0C00158E   LBU T4, 3072(T6)
BFD023B4      0C00   NOP
226:                 
227:                 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
228:                 	{
229:                 		if( pvReturn == NULL )
BFD023B6  0018FC5E   LW V0, 24(S8)
BFD023BA  000340A2   BNEZC V0, 0xBFD023C4
230:                 		{
231:                 			extern void vApplicationMallocFailedHook( void );
232:                 			vApplicationMallocFailedHook();
BFD023BE  448077E8   JALS vApplicationMallocFailedHook
BFD023C0      4480   AND16 S0, S0
BFD023C2      0C00   NOP
233:                 		}
234:                 	}
235:                 	#endif
236:                 
237:                 	return pvReturn;
BFD023C4  0018FC5E   LW V0, 24(S8)
238:                 }
BFD023C8      0FBE   MOVE SP, S8
BFD023CA      4BEB   LW RA, 44(SP)
BFD023CC      4BCA   LW S8, 40(SP)
BFD023CE      4C19   ADDIU SP, SP, 48
BFD023D0      459F   JR16 RA
BFD023D2      0C00   NOP
239:                 /*-----------------------------------------------------------*/
240:                 
241:                 void vPortFree( void *pv )
242:                 {
BFD05FD4      4FED   ADDIU SP, SP, -40
BFD05FD6      CBE9   SW RA, 36(SP)
BFD05FD8      CBC8   SW S8, 32(SP)
BFD05FDA      0FDD   MOVE S8, SP
BFD05FDC  0028F89E   SW A0, 40(S8)
243:                 uint8_t *puc = ( uint8_t * ) pv;
BFD05FE0  0028FC5E   LW V0, 40(S8)
BFD05FE4  0014F85E   SW V0, 20(S8)
244:                 BlockLink_t *pxLink;
245:                 
246:                 	if( pv != NULL )
BFD05FE8  0028FC5E   LW V0, 40(S8)
BFD05FEC  004240E2   BEQZC V0, 0xBFD06074
247:                 	{
248:                 		/* The memory being freed will have an BlockLink_t structure immediately
249:                 		before it. */
250:                 		puc -= heapSTRUCT_SIZE;
BFD05FF0  BFD141A2   LUI V0, 0xBFD1
BFD05FF2  3442BFD1   LDC1 F30, 13378(S1)
BFD05FF4  9F2C3442   LHU V0, -24788(V0)
BFD05FF6  00409F2C   LWC1 F25, 64(T4)
BFD05FF8  11D00040   SUBU V0, ZERO, V0
BFD05FFA  FC7E11D0   ADDI T6, S0, -898
BFD05FFC  0014FC7E   LW V1, 20(S8)
BFD06000      0526   ADDU V0, V1, V0
BFD06002  0014F85E   SW V0, 20(S8)
251:                 
252:                 		/* This unexpected casting is to keep some compilers from issuing
253:                 		byte alignment warnings. */
254:                 		pxLink = ( void * ) puc;
BFD06006  0014FC5E   LW V0, 20(S8)
BFD0600A  0018F85E   SW V0, 24(S8)
255:                 
256:                 		vTaskSuspendAll();
BFD0600E  4EF477E8   JALS vTaskSuspendAll
BFD06010      4EF4   ADDIU S7, S7, -6
BFD06012      0C00   NOP
257:                 		{
258:                 			/* Add this block to the list of free blocks. */
259:                 			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
BFD06014  0018FC5E   LW V0, 24(S8)
BFD06018      6921   LW V0, 4(V0)
BFD0601A  001CF85E   SW V0, 28(S8)
BFD0601E  8018305C   ADDIU V0, GP, -32744
BFD06022  0010F85E   SW V0, 16(S8)
BFD06026      CC06   B 0xBFD06034
BFD06028      0C00   NOP
BFD0602A  0010FC5E   LW V0, 16(S8)
BFD0602E      6920   LW V0, 0(V0)
BFD06030  0010F85E   SW V0, 16(S8)
BFD06034  0010FC5E   LW V0, 16(S8)
BFD06038      6920   LW V0, 0(V0)
BFD0603A      69A1   LW V1, 4(V0)
BFD0603C  001CFC5E   LW V0, 28(S8)
BFD06040  13900043   SLTU V0, V1, V0
BFD06042  40A21390   ADDI GP, S0, 16546
BFD06044  FFF140A2   BNEZC V0, 0xBFD0602A
BFD06046  FC5EFFF1   LW RA, -930(S1)
BFD06048  0010FC5E   LW V0, 16(S8)
BFD0604C      69A0   LW V1, 0(V0)
BFD0604E  0018FC5E   LW V0, 24(S8)
BFD06052      E9A0   SW V1, 0(V0)
BFD06054  0010FC5E   LW V0, 16(S8)
BFD06058  0018FC7E   LW V1, 24(S8)
BFD0605C      E9A0   SW V1, 0(V0)
260:                 			xFreeBytesRemaining += pxLink->xBlockSize;
BFD0605E  0018FC5E   LW V0, 24(S8)
BFD06062      69A1   LW V1, 4(V0)
BFD06064  8010FC5C   LW V0, -32752(GP)
BFD06068      0526   ADDU V0, V1, V0
BFD0606A  8010F85C   SW V0, -32752(GP)
261:                 			traceFREE( pv, pxLink->xBlockSize );
262:                 		}
263:                 		( void ) xTaskResumeAll();
BFD0606E  158E77E8   JALS xTaskResumeAll
BFD06070  0C00158E   LBU T4, 3072(T6)
BFD06072      0C00   NOP
264:                 	}
265:                 }
BFD06074      0FBE   MOVE SP, S8
BFD06076      4BE9   LW RA, 36(SP)
BFD06078      4BC8   LW S8, 32(SP)
BFD0607A      4C15   ADDIU SP, SP, 40
BFD0607C      459F   JR16 RA
BFD0607E      0C00   NOP
266:                 /*-----------------------------------------------------------*/
267:                 
268:                 size_t xPortGetFreeHeapSize( void )
269:                 {
BFD09E84      4FB0   ADDIU SP, SP, -8
BFD09E86      CBC1   SW S8, 4(SP)
BFD09E88      0FDD   MOVE S8, SP
270:                 	return xFreeBytesRemaining;
BFD09E8A  8010FC5C   LW V0, -32752(GP)
271:                 }
BFD09E8E      0FBE   MOVE SP, S8
BFD09E90      4BC1   LW S8, 4(SP)
BFD09E92      4C05   ADDIU SP, SP, 8
BFD09E94      459F   JR16 RA
BFD09E96      0C00   NOP
272:                 /*-----------------------------------------------------------*/
273:                 
274:                 void vPortInitialiseBlocks( void )
275:                 {
BFD09ED4      4FB0   ADDIU SP, SP, -8
BFD09ED6      CBC1   SW S8, 4(SP)
BFD09ED8      0FDD   MOVE S8, SP
276:                 	/* This just exists to keep the linker quiet. */
277:                 }
BFD09EDA      0FBE   MOVE SP, S8
BFD09EDC      4BC1   LW S8, 4(SP)
BFD09EDE      4C05   ADDIU SP, SP, 8
BFD09EE0      459F   JR16 RA
BFD09EE2      0C00   NOP
278:                 /*-----------------------------------------------------------*/
279:                 
280:                 static void prvHeapInit( void )
281:                 {
BFD084A0      4FF9   ADDIU SP, SP, -16
BFD084A2      CBC3   SW S8, 12(SP)
BFD084A4      0FDD   MOVE S8, SP
282:                 BlockLink_t *pxFirstFreeBlock;
283:                 uint8_t *pucAlignedHeap;
284:                 
285:                 	/* Ensure the heap starts on a correctly aligned boundary. */
286:                 	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
BFD084A6  BFD241A2   LUI V0, 0xBFD2
BFD084A8  3062BFD2   LDC1 F30, 12386(S2)
BFD084AA  8D703062   ADDIU V1, V0, -29328
BFD084AC      8D70   BEQZ V0, 0xBFD0858E
BFD084AE  FFF83040   ADDIU V0, ZERO, -8
BFD084B0  4493FFF8   LW RA, 17555(T8)
BFD084B2      4493   AND16 V0, V1
BFD084B4  0000F85E   SW V0, 0(S8)
287:                 
288:                 	/* xStart is used to hold a pointer to the first item in the list of free
289:                 	blocks.  The void cast is used to prevent compiler warnings. */
290:                 	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
BFD084B8  0000FC5E   LW V0, 0(S8)
BFD084BC  8018F85C   SW V0, -32744(GP)
291:                 	xStart.xBlockSize = ( size_t ) 0;
BFD084C0  801CF81C   SW ZERO, -32740(GP)
292:                 
293:                 	/* xEnd is used to mark the end of the list of free blocks. */
294:                 	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
BFD084C4  1FF83040   ADDIU V0, ZERO, 8184
BFD084C6  F85C1FF8   LB RA, -1956(T8)
BFD084C8  8024F85C   SW V0, -32732(GP)
295:                 	xEnd.pxNextFreeBlock = NULL;
BFD084CC  8020F81C   SW ZERO, -32736(GP)
296:                 
297:                 	/* To start with there is a single free block that is sized to take up the
298:                 	entire heap space. */
299:                 	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
BFD084D0  0000FC5E   LW V0, 0(S8)
BFD084D4  0004F85E   SW V0, 4(S8)
300:                 	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
BFD084D8  0004FC5E   LW V0, 4(S8)
BFD084DC  1FF83060   ADDIU V1, ZERO, 8184
BFD084DE  E9A11FF8   LB RA, -5727(T8)
BFD084E0      E9A1   SW V1, 4(V0)
301:                 	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
BFD084E2  0004FC5E   LW V0, 4(S8)
BFD084E4  307C0004   MTLO A0, 0
BFD084E6  8020307C   ADDIU V1, GP, -32736
BFD084EA      E9A0   SW V1, 0(V0)
302:                 }
BFD084EC      0FBE   MOVE SP, S8
BFD084EE      4BC3   LW S8, 12(SP)
BFD084F0      4C09   ADDIU SP, SP, 16
BFD084F2      459F   JR16 RA
BFD084F4      0C00   NOP
303:                 /*-----------------------------------------------------------*/
---  c:/e/dev/freertos/workingcopy/freertos/source/list.c  ----------------------------------------------
1:                   /*
2:                       FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  
71:                  #include <stdlib.h>
72:                  #include "FreeRTOS.h"
73:                  #include "list.h"
74:                  
75:                  /*-----------------------------------------------------------
76:                   * PUBLIC LIST API documented in list.h
77:                   *----------------------------------------------------------*/
78:                  
79:                  void vListInitialise( List_t * const pxList )
80:                  {
BFD08AE0      4FB0   ADDIU SP, SP, -8
BFD08AE2      CBC1   SW S8, 4(SP)
BFD08AE4      0FDD   MOVE S8, SP
BFD08AE6  0008F89E   SW A0, 8(S8)
81:                  	/* The list structure contains a list item which is used to mark the
82:                  	end of the list.  To initialise the list the list end is inserted
83:                  	as the only list entry. */
84:                  	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
BFD08AEA  0008FC5E   LW V0, 8(S8)
BFD08AEE      6D24   ADDIU V0, V0, 8
BFD08AF0      0C62   MOVE V1, V0
BFD08AF2  0008FC5E   LW V0, 8(S8)
BFD08AF6      E9A1   SW V1, 4(V0)
85:                  
86:                  	/* The list end value is the highest possible value in the list to
87:                  	ensure it remains at the end of the list. */
88:                  	pxList->xListEnd.xItemValue = portMAX_DELAY;
BFD08AF8  0008FC5E   LW V0, 8(S8)
BFD08AFC      EDFF   LI V1, -1
BFD08AFE      E9A2   SW V1, 8(V0)
89:                  
90:                  	/* The list end next and previous pointers point to itself so we know
91:                  	when the list is empty. */
92:                  	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
BFD08B00  0008FC5E   LW V0, 8(S8)
BFD08B04      6D24   ADDIU V0, V0, 8
BFD08B06      0C62   MOVE V1, V0
BFD08B08  0008FC5E   LW V0, 8(S8)
BFD08B0C      E9A3   SW V1, 12(V0)
93:                  	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
BFD08B0E  0008FC5E   LW V0, 8(S8)
BFD08B12      6D24   ADDIU V0, V0, 8
BFD08B14      0C62   MOVE V1, V0
BFD08B16  0008FC5E   LW V0, 8(S8)
BFD08B1A      E9A4   SW V1, 16(V0)
94:                  
95:                  	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
BFD08B1C  0008FC5E   LW V0, 8(S8)
BFD08B20      E820   SW S0, 0(V0)
96:                  
97:                  	/* Write known values into the list if
98:                  	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
99:                  	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
100:                 	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
101:                 }
BFD08B22      0FBE   MOVE SP, S8
BFD08B24      4BC1   LW S8, 4(SP)
BFD08B26      4C05   ADDIU SP, SP, 8
BFD08B28      459F   JR16 RA
BFD08B2A      0C00   NOP
102:                 /*-----------------------------------------------------------*/
103:                 
104:                 void vListInitialiseItem( ListItem_t * const pxItem )
105:                 {
BFD09DCC      4FB0   ADDIU SP, SP, -8
BFD09DCE      CBC1   SW S8, 4(SP)
BFD09DD0      0FDD   MOVE S8, SP
BFD09DD2  0008F89E   SW A0, 8(S8)
106:                 	/* Make sure the list item is not recorded as being on a list. */
107:                 	pxItem->pvContainer = NULL;
BFD09DD6  0008FC5E   LW V0, 8(S8)
BFD09DDA      E824   SW S0, 16(V0)
108:                 
109:                 	/* Write known values into the list item if
110:                 	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
111:                 	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
112:                 	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
113:                 }
BFD09DDC      0FBE   MOVE SP, S8
BFD09DDE      4BC1   LW S8, 4(SP)
BFD09DE0      4C05   ADDIU SP, SP, 8
BFD09DE2      459F   JR16 RA
BFD09DE4      0C00   NOP
114:                 /*-----------------------------------------------------------*/
115:                 
116:                 void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
117:                 {
BFD07C94      4FF9   ADDIU SP, SP, -16
BFD07C96      CBC3   SW S8, 12(SP)
BFD07C98      0FDD   MOVE S8, SP
BFD07C9A  0010F89E   SW A0, 16(S8)
BFD07C9E  0014F8BE   SW A1, 20(S8)
118:                 ListItem_t * const pxIndex = pxList->pxIndex;
BFD07CA2  0010FC5E   LW V0, 16(S8)
BFD07CA6      6921   LW V0, 4(V0)
BFD07CA8  0000F85E   SW V0, 0(S8)
119:                 
120:                 	/* Only effective when configASSERT() is also defined, these tests may catch
121:                 	the list data structures being overwritten in memory.  They will not catch
122:                 	data errors caused by incorrect configuration or use of FreeRTOS. */
123:                 	listTEST_LIST_INTEGRITY( pxList );
124:                 	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
125:                 
126:                 	/* Insert a new list item into pxList, but rather than sort the list,
127:                 	makes the new list item the last item to be removed by a call to
128:                 	listGET_OWNER_OF_NEXT_ENTRY(). */
129:                 	pxNewListItem->pxNext = pxIndex;
BFD07CAC  0014FC5E   LW V0, 20(S8)
BFD07CB0  0000FC7E   LW V1, 0(S8)
BFD07CB4      E9A1   SW V1, 4(V0)
130:                 	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
BFD07CB6  0000FC5E   LW V0, 0(S8)
BFD07CBA      69A2   LW V1, 8(V0)
BFD07CBC  0014FC5E   LW V0, 20(S8)
BFD07CC0      E9A2   SW V1, 8(V0)
131:                 
132:                 	/* Only used during decision coverage testing. */
133:                 	mtCOVERAGE_TEST_DELAY();
134:                 
135:                 	pxIndex->pxPrevious->pxNext = pxNewListItem;
BFD07CC2  0000FC5E   LW V0, 0(S8)
BFD07CC6      6922   LW V0, 8(V0)
BFD07CC8  0014FC7E   LW V1, 20(S8)
BFD07CCC      E9A1   SW V1, 4(V0)
136:                 	pxIndex->pxPrevious = pxNewListItem;
BFD07CCE  0000FC5E   LW V0, 0(S8)
BFD07CD2  0014FC7E   LW V1, 20(S8)
BFD07CD6      E9A2   SW V1, 8(V0)
137:                 
138:                 	/* Remember which list the item is in. */
139:                 	pxNewListItem->pvContainer = ( void * ) pxList;
BFD07CD8  0014FC5E   LW V0, 20(S8)
BFD07CDC  0010FC7E   LW V1, 16(S8)
BFD07CE0      E9A4   SW V1, 16(V0)
140:                 
141:                 	( pxList->uxNumberOfItems )++;
BFD07CE2  0010FC5E   LW V0, 16(S8)
BFD07CE6      6920   LW V0, 0(V0)
BFD07CE8      6DA0   ADDIU V1, V0, 1
BFD07CEA  0010FC5E   LW V0, 16(S8)
BFD07CEE      E9A0   SW V1, 0(V0)
142:                 }
BFD07CF0      0FBE   MOVE SP, S8
BFD07CF2      4BC3   LW S8, 12(SP)
BFD07CF4      4C09   ADDIU SP, SP, 16
BFD07CF6      459F   JR16 RA
BFD07CF8      0C00   NOP
143:                 /*-----------------------------------------------------------*/
144:                 
145:                 void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
146:                 {
BFD06080      4FF9   ADDIU SP, SP, -16
BFD06082      CBC3   SW S8, 12(SP)
BFD06084      0FDD   MOVE S8, SP
BFD06086  0010F89E   SW A0, 16(S8)
BFD0608A  0014F8BE   SW A1, 20(S8)
147:                 ListItem_t *pxIterator;
148:                 const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
BFD0608E  0014FC5E   LW V0, 20(S8)
BFD06092      6920   LW V0, 0(V0)
BFD06094  0004F85E   SW V0, 4(S8)
149:                 
150:                 	/* Only effective when configASSERT() is also defined, these tests may catch
151:                 	the list data structures being overwritten in memory.  They will not catch
152:                 	data errors caused by incorrect configuration or use of FreeRTOS. */
153:                 	listTEST_LIST_INTEGRITY( pxList );
154:                 	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
155:                 
156:                 	/* Insert the new list item into the list, sorted in xItemValue order.
157:                 
158:                 	If the list already contains a list item with the same item value then the
159:                 	new list item should be placed after it.  This ensures that TCB's which are
160:                 	stored in ready lists (all of which have the same xItemValue value) get a
161:                 	share of the CPU.  However, if the xItemValue is the same as the back marker
162:                 	the iteration loop below will not end.  Therefore the value is checked
163:                 	first, and the algorithm slightly modified if necessary. */
164:                 	if( xValueOfInsertion == portMAX_DELAY )
BFD06098  0004FC7E   LW V1, 4(S8)
BFD0609C      ED7F   LI V0, -1
BFD0609E  0008B443   BNE V1, V0, 0xBFD060B2
BFD060A0  0C000008   SLL ZERO, T0, 1
BFD060A2      0C00   NOP
165:                 	{
166:                 		pxIterator = pxList->xListEnd.pxPrevious;
BFD060A4  0010FC5E   LW V0, 16(S8)
BFD060A8      6924   LW V0, 16(V0)
BFD060AA  0000F85E   SW V0, 0(S8)
BFD060AE      CC17   B 0xBFD060DE
BFD060B0      0C00   NOP
167:                 	}
168:                 	else
169:                 	{
170:                 		/* *** NOTE ***********************************************************
171:                 		If you find your application is crashing here then likely causes are
172:                 		listed below.  In addition see http://www.freertos.org/FAQHelp.html for
173:                 		more tips, and ensure configASSERT() is defined!
174:                 		http://www.freertos.org/a00110.html#configASSERT
175:                 
176:                 			1) Stack overflow -
177:                 			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
178:                 			2) Incorrect interrupt priority assignment, especially on Cortex-M
179:                 			   parts where numerically high priority values denote low actual
180:                 			   interrupt priorities, which can seem counter intuitive.  See
181:                 			   http://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
182:                 			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
183:                 			   http://www.freertos.org/a00110.html
184:                 			3) Calling an API function from within a critical section or when
185:                 			   the scheduler is suspended, or calling an API function that does
186:                 			   not end in "FromISR" from an interrupt.
187:                 			4) Using a queue or semaphore before it has been initialised or
188:                 			   before the scheduler has been started (are interrupts firing
189:                 			   before vTaskStartScheduler() has been called?).
190:                 		**********************************************************************/
191:                 
192:                 		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
BFD060B2  0010FC5E   LW V0, 16(S8)
BFD060B6      6D24   ADDIU V0, V0, 8
BFD060B8  0000F85E   SW V0, 0(S8)
BFD060BC      CC06   B 0xBFD060CA
BFD060BE      0C00   NOP
BFD060C0  0000FC5E   LW V0, 0(S8)
BFD060C4      6921   LW V0, 4(V0)
BFD060C6  0000F85E   SW V0, 0(S8)
BFD060CA  0000FC5E   LW V0, 0(S8)
BFD060CE      6921   LW V0, 4(V0)
BFD060D0      69A0   LW V1, 0(V0)
BFD060D2  0004FC5E   LW V0, 4(S8)
BFD060D6  13900062   SLTU V0, V0, V1
BFD060D8  40E21390   ADDI GP, S0, 16610
BFD060DA  FFF140E2   BEQZC V0, 0xBFD060C0
BFD060DC  FC5EFFF1   LW RA, -930(S1)
193:                 		{
194:                 			/* There is nothing to do here, just iterating to the wanted
195:                 			insertion position. */
196:                 		}
197:                 	}
198:                 
199:                 	pxNewListItem->pxNext = pxIterator->pxNext;
BFD060DE  0000FC5E   LW V0, 0(S8)
BFD060E2      69A1   LW V1, 4(V0)
BFD060E4  0014FC5E   LW V0, 20(S8)
BFD060E8      E9A1   SW V1, 4(V0)
200:                 	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
BFD060EA  0014FC5E   LW V0, 20(S8)
BFD060EE      6921   LW V0, 4(V0)
BFD060F0  0014FC7E   LW V1, 20(S8)
BFD060F4      E9A2   SW V1, 8(V0)
201:                 	pxNewListItem->pxPrevious = pxIterator;
BFD060F6  0014FC5E   LW V0, 20(S8)
BFD060FA  0000FC7E   LW V1, 0(S8)
BFD060FE      E9A2   SW V1, 8(V0)
202:                 	pxIterator->pxNext = pxNewListItem;
BFD06100  0000FC5E   LW V0, 0(S8)
BFD06104  0014FC7E   LW V1, 20(S8)
BFD06108      E9A1   SW V1, 4(V0)
203:                 
204:                 	/* Remember which list the item is in.  This allows fast removal of the
205:                 	item later. */
206:                 	pxNewListItem->pvContainer = ( void * ) pxList;
BFD0610A  0014FC5E   LW V0, 20(S8)
BFD0610E  0010FC7E   LW V1, 16(S8)
BFD06112      E9A4   SW V1, 16(V0)
207:                 
208:                 	( pxList->uxNumberOfItems )++;
BFD06114  0010FC5E   LW V0, 16(S8)
BFD06118      6920   LW V0, 0(V0)
BFD0611A      6DA0   ADDIU V1, V0, 1
BFD0611C  0010FC5E   LW V0, 16(S8)
BFD06120      E9A0   SW V1, 0(V0)
209:                 }
BFD06122      0FBE   MOVE SP, S8
BFD06124      4BC3   LW S8, 12(SP)
BFD06126      4C09   ADDIU SP, SP, 16
BFD06128      459F   JR16 RA
BFD0612A      0C00   NOP
210:                 /*-----------------------------------------------------------*/
211:                 
212:                 UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
213:                 {
BFD00190      4FF9   ADDIU SP, SP, -16
BFD00192      CBC3   SW S8, 12(SP)
BFD00194      0FDD   MOVE S8, SP
BFD00196  0010F89E   SW A0, 16(S8)
214:                 /* The list item knows which list it is in.  Obtain the list from the list
215:                 item. */
216:                 List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
BFD0019A  0010FC5E   LW V0, 16(S8)
BFD0019E      6924   LW V0, 16(V0)
BFD001A0  0000F85E   SW V0, 0(S8)
217:                 
218:                 	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
BFD001A4  0010FC5E   LW V0, 16(S8)
BFD001A8      6921   LW V0, 4(V0)
BFD001AA  0010FC7E   LW V1, 16(S8)
BFD001AE      69B2   LW V1, 8(V1)
BFD001B0      E9A2   SW V1, 8(V0)
219:                 	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
BFD001B2  0010FC5E   LW V0, 16(S8)
BFD001B6      6922   LW V0, 8(V0)
BFD001B8  0010FC7E   LW V1, 16(S8)
BFD001BC      69B1   LW V1, 4(V1)
BFD001BE      E9A1   SW V1, 4(V0)
220:                 
221:                 	/* Only used during decision coverage testing. */
222:                 	mtCOVERAGE_TEST_DELAY();
223:                 
224:                 	/* Make sure the index is left pointing to a valid item. */
225:                 	if( pxList->pxIndex == pxItemToRemove )
BFD001C0  0000FC5E   LW V0, 0(S8)
BFD001C4      69A1   LW V1, 4(V0)
BFD001C6  0010FC5E   LW V0, 16(S8)
BFD001CA  0007B443   BNE V1, V0, 0xBFD001DC
BFD001CC  0C000007   SLL ZERO, A3, 1
BFD001CE      0C00   NOP
226:                 	{
227:                 		pxList->pxIndex = pxItemToRemove->pxPrevious;
BFD001D0  0010FC5E   LW V0, 16(S8)
BFD001D4      69A2   LW V1, 8(V0)
BFD001D6  0000FC5E   LW V0, 0(S8)
BFD001DA      E9A1   SW V1, 4(V0)
228:                 	}
229:                 	else
230:                 	{
231:                 		mtCOVERAGE_TEST_MARKER();
232:                 	}
233:                 
234:                 	pxItemToRemove->pvContainer = NULL;
BFD001DC  0010FC5E   LW V0, 16(S8)
BFD001E0      E824   SW S0, 16(V0)
235:                 	( pxList->uxNumberOfItems )--;
BFD001E2  0000FC5E   LW V0, 0(S8)
BFD001E6      6920   LW V0, 0(V0)
BFD001E8      6DAE   ADDIU V1, V0, -1
BFD001EA  0000FC5E   LW V0, 0(S8)
BFD001EE      E9A0   SW V1, 0(V0)
236:                 
237:                 	return pxList->uxNumberOfItems;
BFD001F0  0000FC5E   LW V0, 0(S8)
BFD001F4      6920   LW V0, 0(V0)
238:                 }
BFD001F6      0FBE   MOVE SP, S8
BFD001F8      4BC3   LW S8, 12(SP)
BFD001FA      4C09   ADDIU SP, SP, 16
BFD001FC      459F   JR16 RA
BFD001FE      0C00   NOP
239:                 /*-----------------------------------------------------------*/
240:                 
---  c:/e/dev/freertos/workingcopy/freertos/source/event_groups.c  --------------------------------------
1:                   /*
2:                       FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /* Standard includes. */
71:                  #include <stdlib.h>
72:                  
73:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
74:                  all the API functions to use the MPU wrappers.  That should only be done when
75:                  task.h is included from an application file. */
76:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
77:                  
78:                  /* FreeRTOS includes. */
79:                  #include "FreeRTOS.h"
80:                  #include "task.h"
81:                  #include "timers.h"
82:                  #include "event_groups.h"
83:                  
84:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
85:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
86:                  header files above, but not in this file, in order to generate the correct
87:                  privileged Vs unprivileged linkage and placement. */
88:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
89:                  
90:                  #if ( INCLUDE_xEventGroupSetBitsFromISR == 1 ) && ( configUSE_TIMERS == 0 )
91:                  	#error configUSE_TIMERS must be set to 1 to make the xEventGroupSetBitFromISR() function available.
92:                  #endif
93:                  
94:                  #if ( INCLUDE_xEventGroupSetBitsFromISR == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 0 )
95:                  	#error INCLUDE_xTimerPendFunctionCall must also be set to one to make the xEventGroupSetBitFromISR() function available.
96:                  #endif
97:                  
98:                  /* The following bit fields convey control information in a task's event list
99:                  item value.  It is important they don't clash with the
100:                 taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
101:                 #if configUSE_16_BIT_TICKS == 1
102:                 	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
103:                 	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
104:                 	#define eventWAIT_FOR_ALL_BITS			0x0400U
105:                 	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
106:                 #else
107:                 	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
108:                 	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
109:                 	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
110:                 	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
111:                 #endif
112:                 
113:                 typedef struct xEventGroupDefinition
114:                 {
115:                 	EventBits_t uxEventBits;
116:                 	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
117:                 
118:                 	#if( configUSE_TRACE_FACILITY == 1 )
119:                 		UBaseType_t uxEventGroupNumber;
120:                 	#endif
121:                 
122:                 } EventGroup_t;
123:                 
124:                 /*-----------------------------------------------------------*/
125:                 
126:                 /*
127:                  * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
128:                  * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
129:                  * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
130:                  * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
131:                  * wait condition is met if any of the bits set in uxBitsToWait for are also set
132:                  * in uxCurrentEventBits.
133:                  */
134:                 static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );
135:                 
136:                 /*-----------------------------------------------------------*/
137:                 
138:                 EventGroupHandle_t xEventGroupCreate( void )
139:                 {
BFD09320      4FF1   ADDIU SP, SP, -32
BFD09322      CBE7   SW RA, 28(SP)
BFD09324      CBC6   SW S8, 24(SP)
BFD09326      0FDD   MOVE S8, SP
140:                 EventGroup_t *pxEventBits;
141:                 
142:                 	pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
BFD09328      EE18   LI A0, 24
BFD0932A  111677E8   JALS pvPortMalloc
BFD0932C  0C001116   ADDI T0, S6, 3072
BFD0932E      0C00   NOP
BFD09330  0010F85E   SW V0, 16(S8)
143:                 	if( pxEventBits != NULL )
BFD09334  0010FC5E   LW V0, 16(S8)
BFD09338  000A40E2   BEQZC V0, 0xBFD09350
144:                 	{
145:                 		pxEventBits->uxEventBits = 0;
BFD0933C  0010FC5E   LW V0, 16(S8)
BFD09340      E820   SW S0, 0(V0)
146:                 		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
BFD09342  0010FC5E   LW V0, 16(S8)
BFD09346      6D22   ADDIU V0, V0, 4
BFD09348      0C82   MOVE A0, V0
BFD0934A  457077E8   JALS vListInitialise
BFD0934C      4570   SWM16 0x3, 0(SP)
BFD0934E      0C00   NOP
147:                 		traceEVENT_GROUP_CREATE( pxEventBits );
148:                 	}
149:                 	else
150:                 	{
151:                 		traceEVENT_GROUP_CREATE_FAILED();
152:                 	}
153:                 
154:                 	return ( EventGroupHandle_t ) pxEventBits;
BFD09350  0010FC5E   LW V0, 16(S8)
155:                 }
BFD09354      0FBE   MOVE SP, S8
BFD09356      4BE7   LW RA, 28(SP)
BFD09358      4BC6   LW S8, 24(SP)
BFD0935A      4C11   ADDIU SP, SP, 32
BFD0935C      459F   JR16 RA
BFD0935E      0C00   NOP
156:                 /*-----------------------------------------------------------*/
157:                 
158:                 EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
159:                 {
BFD01B0C      4FE9   ADDIU SP, SP, -48
BFD01B0E      CBEB   SW RA, 44(SP)
BFD01B10      CBCA   SW S8, 40(SP)
BFD01B12      0FDD   MOVE S8, SP
BFD01B14  0030F89E   SW A0, 48(S8)
BFD01B18  0034F8BE   SW A1, 52(S8)
BFD01B1C  0038F8DE   SW A2, 56(S8)
BFD01B20  003CF8FE   SW A3, 60(S8)
160:                 EventBits_t uxOriginalBitValue, uxReturn;
161:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
BFD01B24  0030FC5E   LW V0, 48(S8)
BFD01B28  0014F85E   SW V0, 20(S8)
162:                 BaseType_t xAlreadyYielded;
163:                 BaseType_t xTimeoutOccurred = pdFALSE;
BFD01B2C  0018F81E   SW ZERO, 24(S8)
164:                 
165:                 	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
BFD01B30  0038FC7E   LW V1, 56(S8)
BFD01B34  FF0041A2   LUI V0, 0xFF00
BFD01B36  4493FF00   LW T8, 17555(ZERO)
BFD01B38      4493   AND16 V0, V1
BFD01B3A  000940E2   BEQZC V0, 0xBFD01B50
BFD01B3E  BFD141A2   LUI V0, 0xBFD1
BFD01B40  3082BFD1   LDC1 F30, 12418(S1)
BFD01B42  9C0C3082   ADDIU A0, V0, -25588
BFD01B44  30A09C0C   LWC1 F0, 12448(T4)
BFD01B46  00A530A0   ADDIU A1, ZERO, 165
BFD01B4A  4B7E77E8   JALS vAssertCalled
BFD01B4C      4B7E   LW K1, 120(SP)
BFD01B4E      0C00   NOP
166:                 	configASSERT( uxBitsToWaitFor != 0 );
BFD01B50  0038FC5E   LW V0, 56(S8)
BFD01B54  000940A2   BNEZC V0, 0xBFD01B6A
BFD01B58  BFD141A2   LUI V0, 0xBFD1
BFD01B5A  3082BFD1   LDC1 F30, 12418(S1)
BFD01B5C  9C0C3082   ADDIU A0, V0, -25588
BFD01B5E  30A09C0C   LWC1 F0, 12448(T4)
BFD01B60  00A630A0   ADDIU A1, ZERO, 166
BFD01B64  4B7E77E8   JALS vAssertCalled
BFD01B66      4B7E   LW K1, 120(SP)
BFD01B68      0C00   NOP
167:                 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
168:                 	{
169:                 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
BFD01B6A  4A8E77E8   JALS xTaskGetSchedulerState
BFD01B6C      4A8E   LW S4, 56(SP)
BFD01B6E      0C00   NOP
BFD01B70  000440A2   BNEZC V0, 0xBFD01B7C
BFD01B74  003CFC5E   LW V0, 60(S8)
BFD01B78  000340A2   BNEZC V0, 0xBFD01B82
BFD01B7C      ED01   LI V0, 1
BFD01B7E      CC02   B 0xBFD01B84
BFD01B80      0C00   NOP
BFD01B82      0C40   MOVE V0, ZERO
BFD01B84  000940A2   BNEZC V0, 0xBFD01B9A
BFD01B88  BFD141A2   LUI V0, 0xBFD1
BFD01B8A  3082BFD1   LDC1 F30, 12418(S1)
BFD01B8C  9C0C3082   ADDIU A0, V0, -25588
BFD01B8E  30A09C0C   LWC1 F0, 12448(T4)
BFD01B90  00A930A0   ADDIU A1, ZERO, 169
BFD01B94  4B7E77E8   JALS vAssertCalled
BFD01B96      4B7E   LW K1, 120(SP)
BFD01B98      0C00   NOP
170:                 	}
171:                 	#endif
172:                 
173:                 	vTaskSuspendAll();
BFD01B9A  4EF477E8   JALS vTaskSuspendAll
BFD01B9C      4EF4   ADDIU S7, S7, -6
BFD01B9E      0C00   NOP
174:                 	{
175:                 		uxOriginalBitValue = pxEventBits->uxEventBits;
BFD01BA0  0014FC5E   LW V0, 20(S8)
BFD01BA4      6920   LW V0, 0(V0)
BFD01BA6  001CF85E   SW V0, 28(S8)
176:                 
177:                 		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
BFD01BAA  0030FC9E   LW A0, 48(S8)
BFD01BAE  0034FCBE   LW A1, 52(S8)
BFD01BB2  12B477E8   JALS xEventGroupSetBits
BFD01BB4  0C0012B4   ADDI S5, S4, 3072
BFD01BB6      0C00   NOP
178:                 
179:                 		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
BFD01BB8  001CFC7E   LW V1, 28(S8)
BFD01BBC  0034FC5E   LW V0, 52(S8)
BFD01BC0      44DA   OR16 V1, V0
BFD01BC2  0038FC5E   LW V0, 56(S8)
BFD01BC6      449A   AND16 V1, V0
BFD01BC8  0038FC5E   LW V0, 56(S8)
BFD01BCC  0016B443   BNE V1, V0, 0xBFD01BFC
BFD01BCE  0C000016   SLL ZERO, S6, 1
BFD01BD0      0C00   NOP
180:                 		{
181:                 			/* All the rendezvous bits are now set - no need to block. */
182:                 			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
BFD01BD2  001CFC7E   LW V1, 28(S8)
BFD01BD6  0034FC5E   LW V0, 52(S8)
BFD01BDA      44D3   OR16 V0, V1
BFD01BDC  0010F85E   SW V0, 16(S8)
183:                 
184:                 			/* Rendezvous always clear the bits.  They will have been cleared
185:                 			already unless this is the only task in the rendezvous. */
186:                 			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
BFD01BE0  0014FC5E   LW V0, 20(S8)
BFD01BE4      69A0   LW V1, 0(V0)
BFD01BE6  0038FC5E   LW V0, 56(S8)
BFD01BEA      4412   NOT16 V0, V0
BFD01BEC      449A   AND16 V1, V0
BFD01BEE  0014FC5E   LW V0, 20(S8)
BFD01BF2      E9A0   SW V1, 0(V0)
187:                 
188:                 			xTicksToWait = 0;
BFD01BF4  003CF81E   SW ZERO, 60(S8)
BFD01BF6  CC1D003C   SHILO null, 60
BFD01BF8      CC1D   B 0xBFD01C34
BFD01BFA      0C00   NOP
189:                 		}
190:                 		else
191:                 		{
192:                 			if( xTicksToWait != ( TickType_t ) 0 )
BFD01BFC  003CFC5E   LW V0, 60(S8)
BFD01C00  001340E2   BEQZC V0, 0xBFD01C2A
193:                 			{
194:                 				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
195:                 
196:                 				/* Store the bits that the calling task is waiting for in the
197:                 				task's event list item so the kernel knows when a match is
198:                 				found.  Then enter the blocked state. */
199:                 				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
BFD01C04  0014FC5E   LW V0, 20(S8)
BFD01C08      6DA2   ADDIU V1, V0, 4
BFD01C0A  0038FC9E   LW A0, 56(S8)
BFD01C0E  050041A2   LUI V0, 0x500
BFD01C10      0500   ADDU V0, S0, S0
BFD01C12      44D4   OR16 V0, A0
BFD01C14      0C83   MOVE A0, V1
BFD01C16      0CA2   MOVE A1, V0
BFD01C18  003CFCDE   LW A2, 60(S8)
BFD01C1C  248277E8   JALS vTaskPlaceOnUnorderedEventList
BFD01C1E      2482   SLL S1, S0, 1
BFD01C20      0C00   NOP
200:                 
201:                 				/* This assignment is obsolete as uxReturn will get set after
202:                 				the task unblocks, but some compilers mistakenly generate a
203:                 				warning about uxReturn being returned without being set if the
204:                 				assignment is omitted. */
205:                 				uxReturn = 0;
BFD01C22  0010F81E   SW ZERO, 16(S8)
BFD01C26      CC06   B 0xBFD01C34
BFD01C28      0C00   NOP
206:                 			}
207:                 			else
208:                 			{
209:                 				/* The rendezvous bits were not set, but no block time was
210:                 				specified - just return the current event bit value. */
211:                 				uxReturn = pxEventBits->uxEventBits;
BFD01C2A  0014FC5E   LW V0, 20(S8)
BFD01C2E      6920   LW V0, 0(V0)
BFD01C30  0010F85E   SW V0, 16(S8)
212:                 			}
213:                 		}
214:                 	}
215:                 	xAlreadyYielded = xTaskResumeAll();
BFD01C34  158E77E8   JALS xTaskResumeAll
BFD01C36  0C00158E   LBU T4, 3072(T6)
BFD01C38      0C00   NOP
BFD01C3A  0020F85E   SW V0, 32(S8)
216:                 
217:                 	if( xTicksToWait != ( TickType_t ) 0 )
BFD01C3E  003CFC5E   LW V0, 60(S8)
BFD01C42  004840E2   BEQZC V0, 0xBFD01CD6
218:                 	{
219:                 		if( xAlreadyYielded == pdFALSE )
BFD01C46  0020FC5E   LW V0, 32(S8)
BFD01C4A  001040A2   BNEZC V0, 0xBFD01C6E
220:                 		{
221:                 			portYIELD_WITHIN_API();
BFD01C4E  4DE677E8   JALS ulPortGetCP0Cause
BFD01C50      4DE6   ADDIU T7, T7, 3
BFD01C52      0C00   NOP
BFD01C54  0024F85E   SW V0, 36(S8)
BFD01C58  0024FC5E   LW V0, 36(S8)
BFD01C5C  01005042   ORI V0, V0, 256
BFD01C60  0024F85E   SW V0, 36(S8)
BFD01C64  0024FC9E   LW A0, 36(S8)
BFD01C68  4DF677E8   JALS vPortSetCP0Cause
BFD01C6A      4DF6   ADDIU T7, T7, -5
BFD01C6C      0C00   NOP
222:                 		}
223:                 		else
224:                 		{
225:                 			mtCOVERAGE_TEST_MARKER();
226:                 		}
227:                 
228:                 		/* The task blocked to wait for its required bits to be set - at this
229:                 		point either the required bits were set or the block time expired.  If
230:                 		the required bits were set they will have been stored in the task's
231:                 		event list item, and they should now be retrieved then cleared. */
232:                 		uxReturn = uxTaskResetEventItemValue();
BFD01C6E  4C8677E8   JALS uxTaskResetEventItemValue
BFD01C70      4C86   ADDIU A0, A0, 3
BFD01C72      0C00   NOP
BFD01C74  0010F85E   SW V0, 16(S8)
233:                 
234:                 		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
BFD01C78  0010FC7E   LW V1, 16(S8)
BFD01C7C  020041A2   LUI V0, 0x200
BFD01C80      4493   AND16 V0, V1
BFD01C82  002240A2   BNEZC V0, 0xBFD01CCA
235:                 		{
236:                 			/* The task timed out, just return the current event bit value. */
237:                 			taskENTER_CRITICAL();
BFD01C86  33B877E8   JALS vTaskEnterCritical
BFD01C88  0C0033B8   ADDIU SP, T8, 3072
BFD01C8A      0C00   NOP
238:                 			{
239:                 				uxReturn = pxEventBits->uxEventBits;
BFD01C8C  0014FC5E   LW V0, 20(S8)
BFD01C90      6920   LW V0, 0(V0)
BFD01C92  0010F85E   SW V0, 16(S8)
240:                 
241:                 				/* Although the task got here because it timed out before the
242:                 				bits it was waiting for were set, it is possible that since it
243:                 				unblocked another task has set the bits.  If this is the case
244:                 				then it needs to clear the bits before exiting. */
245:                 				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
BFD01C96  0010FC7E   LW V1, 16(S8)
BFD01C9A  0038FC5E   LW V0, 56(S8)
BFD01C9E      449A   AND16 V1, V0
BFD01CA0  0038FC5E   LW V0, 56(S8)
BFD01CA4  000BB443   BNE V1, V0, 0xBFD01CBE
BFD01CA6  0C00000B   SLL ZERO, T3, 1
BFD01CA8      0C00   NOP
246:                 				{
247:                 					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
BFD01CAA  0014FC5E   LW V0, 20(S8)
BFD01CAE      69A0   LW V1, 0(V0)
BFD01CB0  0038FC5E   LW V0, 56(S8)
BFD01CB4      4412   NOT16 V0, V0
BFD01CB6      449A   AND16 V1, V0
BFD01CB8  0014FC5E   LW V0, 20(S8)
BFD01CBC      E9A0   SW V1, 0(V0)
248:                 				}
249:                 				else
250:                 				{
251:                 					mtCOVERAGE_TEST_MARKER();
252:                 				}
253:                 			}
254:                 			taskEXIT_CRITICAL();
BFD01CBE  40AA77E8   JALS vTaskExitCritical
BFD01CC0  0C0040AA   BNEZC T2, 0xBFD034C4
BFD01CC2      0C00   NOP
255:                 
256:                 			xTimeoutOccurred = pdTRUE;
BFD01CC4      ED01   LI V0, 1
BFD01CC6  0018F85E   SW V0, 24(S8)
257:                 		}
258:                 		else
259:                 		{
260:                 			/* The task unblocked because the bits were set. */
261:                 		}
262:                 
263:                 		/* Control bits might be set as the task had blocked should not be
264:                 		returned. */
265:                 		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
BFD01CCA  0010FC5E   LW V0, 16(S8)
BFD01CCE  B82C0042   EXT V0, V0, 0, 24
BFD01CD0  F85EB82C   SDC1 F1, -1954(T4)
BFD01CD2  0010F85E   SW V0, 16(S8)
266:                 	}
267:                 
268:                 	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
269:                 
270:                 	return uxReturn;
BFD01CD6  0010FC5E   LW V0, 16(S8)
271:                 }
BFD01CDA      0FBE   MOVE SP, S8
BFD01CDC      4BEB   LW RA, 44(SP)
BFD01CDE      4BCA   LW S8, 40(SP)
BFD01CE0      4C19   ADDIU SP, SP, 48
BFD01CE2      459F   JR16 RA
BFD01CE4      0C00   NOP
272:                 /*-----------------------------------------------------------*/
273:                 
274:                 EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
275:                 {
BFD01310      4FE5   ADDIU SP, SP, -56
BFD01312      CBED   SW RA, 52(SP)
BFD01314      CBCC   SW S8, 48(SP)
BFD01316      0FDD   MOVE S8, SP
BFD01318  0038F89E   SW A0, 56(S8)
BFD0131C  003CF8BE   SW A1, 60(S8)
BFD01320  0040F8DE   SW A2, 64(S8)
BFD01324  0044F8FE   SW A3, 68(S8)
276:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
BFD01328  0038FC5E   LW V0, 56(S8)
BFD0132C  0018F85E   SW V0, 24(S8)
277:                 EventBits_t uxReturn, uxControlBits = 0;
BFD01330  0014F81E   SW ZERO, 20(S8)
278:                 BaseType_t xWaitConditionMet, xAlreadyYielded;
279:                 BaseType_t xTimeoutOccurred = pdFALSE;
BFD01334  001CF81E   SW ZERO, 28(S8)
280:                 
281:                 	/* Check the user is not attempting to wait on the bits used by the kernel
282:                 	itself, and that at least one bit is being requested. */
283:                 	configASSERT( xEventGroup );
BFD01338  0038FC5E   LW V0, 56(S8)
BFD0133C  000940A2   BNEZC V0, 0xBFD01352
BFD01340  BFD141A2   LUI V0, 0xBFD1
BFD01342  3082BFD1   LDC1 F30, 12418(S1)
BFD01344  9C0C3082   ADDIU A0, V0, -25588
BFD01346  30A09C0C   LWC1 F0, 12448(T4)
BFD01348  011B30A0   ADDIU A1, ZERO, 283
BFD0134C  4B7E77E8   JALS vAssertCalled
BFD0134E      4B7E   LW K1, 120(SP)
BFD01350      0C00   NOP
284:                 	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
BFD01352  003CFC7E   LW V1, 60(S8)
BFD01356  FF0041A2   LUI V0, 0xFF00
BFD01358  4493FF00   LW T8, 17555(ZERO)
BFD0135A      4493   AND16 V0, V1
BFD0135C  000940E2   BEQZC V0, 0xBFD01372
BFD01360  BFD141A2   LUI V0, 0xBFD1
BFD01362  3082BFD1   LDC1 F30, 12418(S1)
BFD01364  9C0C3082   ADDIU A0, V0, -25588
BFD01366  30A09C0C   LWC1 F0, 12448(T4)
BFD01368  011C30A0   ADDIU A1, ZERO, 284
BFD0136C  4B7E77E8   JALS vAssertCalled
BFD0136E      4B7E   LW K1, 120(SP)
BFD01370      0C00   NOP
285:                 	configASSERT( uxBitsToWaitFor != 0 );
BFD01372  003CFC5E   LW V0, 60(S8)
BFD01376  000940A2   BNEZC V0, 0xBFD0138C
BFD0137A  BFD141A2   LUI V0, 0xBFD1
BFD0137C  3082BFD1   LDC1 F30, 12418(S1)
BFD0137E  9C0C3082   ADDIU A0, V0, -25588
BFD01380  30A09C0C   LWC1 F0, 12448(T4)
BFD01382  011D30A0   ADDIU A1, ZERO, 285
BFD01386  4B7E77E8   JALS vAssertCalled
BFD01388      4B7E   LW K1, 120(SP)
BFD0138A      0C00   NOP
286:                 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
287:                 	{
288:                 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
BFD0138C  4A8E77E8   JALS xTaskGetSchedulerState
BFD0138E      4A8E   LW S4, 56(SP)
BFD01390      0C00   NOP
BFD01392  000440A2   BNEZC V0, 0xBFD0139E
BFD01396  0048FC5E   LW V0, 72(S8)
BFD0139A  000340A2   BNEZC V0, 0xBFD013A4
BFD0139E      ED01   LI V0, 1
BFD013A0      CC02   B 0xBFD013A6
BFD013A2      0C00   NOP
BFD013A4      0C40   MOVE V0, ZERO
BFD013A6  000940A2   BNEZC V0, 0xBFD013BC
BFD013AA  BFD141A2   LUI V0, 0xBFD1
BFD013AC  3082BFD1   LDC1 F30, 12418(S1)
BFD013AE  9C0C3082   ADDIU A0, V0, -25588
BFD013B0  30A09C0C   LWC1 F0, 12448(T4)
BFD013B2  012030A0   ADDIU A1, ZERO, 288
BFD013B6  4B7E77E8   JALS vAssertCalled
BFD013B8      4B7E   LW K1, 120(SP)
BFD013BA      0C00   NOP
289:                 	}
290:                 	#endif
291:                 
292:                 	vTaskSuspendAll();
BFD013BC  4EF477E8   JALS vTaskSuspendAll
BFD013BE      4EF4   ADDIU S7, S7, -6
BFD013C0      0C00   NOP
293:                 	{
294:                 		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
BFD013C2  0018FC5E   LW V0, 24(S8)
BFD013C6      6920   LW V0, 0(V0)
BFD013C8  0020F85E   SW V0, 32(S8)
295:                 
296:                 		/* Check to see if the wait condition is already met or not. */
297:                 		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
BFD013CC  0020FC9E   LW A0, 32(S8)
BFD013D0  003CFCBE   LW A1, 60(S8)
BFD013D4  0044FCDE   LW A2, 68(S8)
BFD013D8  407A77E8   JALS prvTestWaitCondition
BFD013DA  0C00407A   BGEZAL K0, 0xBFD02BDE
BFD013DC      0C00   NOP
BFD013DE  0024F85E   SW V0, 36(S8)
298:                 
299:                 		if( xWaitConditionMet != pdFALSE )
BFD013E2  0024FC5E   LW V0, 36(S8)
BFD013E6  001640E2   BEQZC V0, 0xBFD01416
300:                 		{
301:                 			/* The wait condition has already been met so there is no need to
302:                 			block. */
303:                 			uxReturn = uxCurrentEventBits;
BFD013EA  0020FC5E   LW V0, 32(S8)
BFD013EE  0010F85E   SW V0, 16(S8)
304:                 			xTicksToWait = ( TickType_t ) 0;
BFD013F2  0048F81E   SW ZERO, 72(S8)
305:                 
306:                 			/* Clear the wait bits if requested to do so. */
307:                 			if( xClearOnExit != pdFALSE )
BFD013F6  0040FC5E   LW V0, 64(S8)
BFD013FA  003D40E2   BEQZC V0, 0xBFD01478
308:                 			{
309:                 				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
BFD013FE  0018FC5E   LW V0, 24(S8)
BFD01402      69A0   LW V1, 0(V0)
BFD01404  003CFC5E   LW V0, 60(S8)
BFD01408      4412   NOT16 V0, V0
BFD0140A      449A   AND16 V1, V0
BFD0140C  0018FC5E   LW V0, 24(S8)
BFD01410      E9A0   SW V1, 0(V0)
BFD01412      CC32   B 0xBFD01478
BFD01414      0C00   NOP
310:                 			}
311:                 			else
312:                 			{
313:                 				mtCOVERAGE_TEST_MARKER();
314:                 			}
315:                 		}
316:                 		else if( xTicksToWait == ( TickType_t ) 0 )
BFD01416  0048FC5E   LW V0, 72(S8)
BFD0141A  000640A2   BNEZC V0, 0xBFD0142A
317:                 		{
318:                 			/* The wait condition has not been met, but no block time was
319:                 			specified, so just return the current value. */
320:                 			uxReturn = uxCurrentEventBits;
BFD0141E  0020FC5E   LW V0, 32(S8)
BFD01422  0010F85E   SW V0, 16(S8)
BFD01426      CC28   B 0xBFD01478
BFD01428      0C00   NOP
321:                 		}
322:                 		else
323:                 		{
324:                 			/* The task is going to block to wait for its required bits to be
325:                 			set.  uxControlBits are used to remember the specified behaviour of
326:                 			this call to xEventGroupWaitBits() - for use when the event bits
327:                 			unblock the task. */
328:                 			if( xClearOnExit != pdFALSE )
BFD0142A  0040FC5E   LW V0, 64(S8)
BFD0142E  000740E2   BEQZC V0, 0xBFD01440
329:                 			{
330:                 				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
BFD01432  0014FC7E   LW V1, 20(S8)
BFD01436  010041A2   LUI V0, 0x100
BFD0143A      44D3   OR16 V0, V1
BFD0143C  0014F85E   SW V0, 20(S8)
331:                 			}
332:                 			else
333:                 			{
334:                 				mtCOVERAGE_TEST_MARKER();
335:                 			}
336:                 
337:                 			if( xWaitForAllBits != pdFALSE )
BFD01440  0044FC5E   LW V0, 68(S8)
BFD01444  000740E2   BEQZC V0, 0xBFD01456
338:                 			{
339:                 				uxControlBits |= eventWAIT_FOR_ALL_BITS;
BFD01448  0014FC7E   LW V1, 20(S8)
BFD0144C  040041A2   LUI V0, 0x400
BFD0144E      0400   ADDU S0, S0, S0
BFD01450      44D3   OR16 V0, V1
BFD01452  0014F85E   SW V0, 20(S8)
340:                 			}
341:                 			else
342:                 			{
343:                 				mtCOVERAGE_TEST_MARKER();
344:                 			}
345:                 
346:                 			/* Store the bits that the calling task is waiting for in the
347:                 			task's event list item so the kernel knows when a match is
348:                 			found.  Then enter the blocked state. */
349:                 			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
BFD01456  0018FC5E   LW V0, 24(S8)
BFD0145A      6DA2   ADDIU V1, V0, 4
BFD0145C  003CFC9E   LW A0, 60(S8)
BFD01460  0014FC5E   LW V0, 20(S8)
BFD01464      44D4   OR16 V0, A0
BFD01466      0C83   MOVE A0, V1
BFD01468      0CA2   MOVE A1, V0
BFD0146A  0048FCDE   LW A2, 72(S8)
BFD0146E  248277E8   JALS vTaskPlaceOnUnorderedEventList
BFD01470      2482   SLL S1, S0, 1
BFD01472      0C00   NOP
350:                 
351:                 			/* This is obsolete as it will get set after the task unblocks, but
352:                 			some compilers mistakenly generate a warning about the variable
353:                 			being returned without being set if it is not done. */
354:                 			uxReturn = 0;
BFD01474  0010F81E   SW ZERO, 16(S8)
355:                 
356:                 			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
357:                 		}
358:                 	}
359:                 	xAlreadyYielded = xTaskResumeAll();
BFD01478  158E77E8   JALS xTaskResumeAll
BFD0147A  0C00158E   LBU T4, 3072(T6)
BFD0147C      0C00   NOP
BFD0147E  0028F85E   SW V0, 40(S8)
360:                 
361:                 	if( xTicksToWait != ( TickType_t ) 0 )
BFD01482  0048FC5E   LW V0, 72(S8)
BFD01486  004C40E2   BEQZC V0, 0xBFD01522
362:                 	{
363:                 		if( xAlreadyYielded == pdFALSE )
BFD0148A  0028FC5E   LW V0, 40(S8)
BFD0148E  001040A2   BNEZC V0, 0xBFD014B2
364:                 		{
365:                 			portYIELD_WITHIN_API();
BFD01492  4DE677E8   JALS ulPortGetCP0Cause
BFD01494      4DE6   ADDIU T7, T7, 3
BFD01496      0C00   NOP
BFD01498  002CF85E   SW V0, 44(S8)
BFD0149C  002CFC5E   LW V0, 44(S8)
BFD014A0  01005042   ORI V0, V0, 256
BFD014A4  002CF85E   SW V0, 44(S8)
BFD014A8  002CFC9E   LW A0, 44(S8)
BFD014AC  4DF677E8   JALS vPortSetCP0Cause
BFD014AE      4DF6   ADDIU T7, T7, -5
BFD014B0      0C00   NOP
366:                 		}
367:                 		else
368:                 		{
369:                 			mtCOVERAGE_TEST_MARKER();
370:                 		}
371:                 
372:                 		/* The task blocked to wait for its required bits to be set - at this
373:                 		point either the required bits were set or the block time expired.  If
374:                 		the required bits were set they will have been stored in the task's
375:                 		event list item, and they should now be retrieved then cleared. */
376:                 		uxReturn = uxTaskResetEventItemValue();
BFD014B2  4C8677E8   JALS uxTaskResetEventItemValue
BFD014B4      4C86   ADDIU A0, A0, 3
BFD014B6      0C00   NOP
BFD014B8  0010F85E   SW V0, 16(S8)
377:                 
378:                 		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
BFD014BC  0010FC7E   LW V1, 16(S8)
BFD014C0  020041A2   LUI V0, 0x200
BFD014C4      4493   AND16 V0, V1
BFD014C6  002640A2   BNEZC V0, 0xBFD01516
379:                 		{
380:                 			taskENTER_CRITICAL();
BFD014CA  33B877E8   JALS vTaskEnterCritical
BFD014CC  0C0033B8   ADDIU SP, T8, 3072
BFD014CE      0C00   NOP
381:                 			{
382:                 				/* The task timed out, just return the current event bit value. */
383:                 				uxReturn = pxEventBits->uxEventBits;
BFD014D0  0018FC5E   LW V0, 24(S8)
BFD014D4      6920   LW V0, 0(V0)
BFD014D6  0010F85E   SW V0, 16(S8)
384:                 
385:                 				/* It is possible that the event bits were updated between this
386:                 				task leaving the Blocked state and running again. */
387:                 				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
BFD014DA  0010FC9E   LW A0, 16(S8)
BFD014DE  003CFCBE   LW A1, 60(S8)
BFD014E2  0044FCDE   LW A2, 68(S8)
BFD014E6  407A77E8   JALS prvTestWaitCondition
BFD014E8  0C00407A   BGEZAL K0, 0xBFD02CEC
BFD014EA      0C00   NOP
BFD014EC  000E40E2   BEQZC V0, 0xBFD0150C
388:                 				{
389:                 					if( xClearOnExit != pdFALSE )
BFD014F0  0040FC5E   LW V0, 64(S8)
BFD014F4  000A40E2   BEQZC V0, 0xBFD0150C
390:                 					{
391:                 						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
BFD014F8  0018FC5E   LW V0, 24(S8)
BFD014FC      69A0   LW V1, 0(V0)
BFD014FE  003CFC5E   LW V0, 60(S8)
BFD01502      4412   NOT16 V0, V0
BFD01504      449A   AND16 V1, V0
BFD01506  0018FC5E   LW V0, 24(S8)
BFD0150A      E9A0   SW V1, 0(V0)
392:                 					}
393:                 					else
394:                 					{
395:                 						mtCOVERAGE_TEST_MARKER();
396:                 					}
397:                 				}
398:                 				else
399:                 				{
400:                 					mtCOVERAGE_TEST_MARKER();
401:                 				}
402:                 			}
403:                 			taskEXIT_CRITICAL();
BFD0150C  40AA77E8   JALS vTaskExitCritical
BFD0150E  0C0040AA   BNEZC T2, 0xBFD02D12
BFD01510      0C00   NOP
404:                 
405:                 			/* Prevent compiler warnings when trace macros are not used. */
406:                 			xTimeoutOccurred = pdFALSE;
BFD01512  001CF81E   SW ZERO, 28(S8)
407:                 		}
408:                 		else
409:                 		{
410:                 			/* The task unblocked because the bits were set. */
411:                 		}
412:                 
413:                 		/* The task blocked so control bits may have been set. */
414:                 		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
BFD01516  0010FC5E   LW V0, 16(S8)
BFD0151A  B82C0042   EXT V0, V0, 0, 24
BFD0151C  F85EB82C   SDC1 F1, -1954(T4)
BFD0151E  0010F85E   SW V0, 16(S8)
415:                 	}
416:                 	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
417:                 
418:                 	return uxReturn;
BFD01522  0010FC5E   LW V0, 16(S8)
419:                 }
BFD01526      0FBE   MOVE SP, S8
BFD01528      4BED   LW RA, 52(SP)
BFD0152A      4BCC   LW S8, 48(SP)
BFD0152C      4C1D   ADDIU SP, SP, 56
BFD0152E      459F   JR16 RA
BFD01530      0C00   NOP
420:                 /*-----------------------------------------------------------*/
421:                 
422:                 EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
423:                 {
BFD06A44      4FF1   ADDIU SP, SP, -32
BFD06A46      CBE7   SW RA, 28(SP)
BFD06A48      CBC6   SW S8, 24(SP)
BFD06A4A      0FDD   MOVE S8, SP
BFD06A4C  0020F89E   SW A0, 32(S8)
BFD06A50  0024F8BE   SW A1, 36(S8)
424:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
BFD06A54  0020FC5E   LW V0, 32(S8)
BFD06A58  0010F85E   SW V0, 16(S8)
425:                 EventBits_t uxReturn;
426:                 
427:                 	/* Check the user is not attempting to clear the bits used by the kernel
428:                 	itself. */
429:                 	configASSERT( xEventGroup );
BFD06A5C  0020FC5E   LW V0, 32(S8)
BFD06A60  000940A2   BNEZC V0, 0xBFD06A76
BFD06A64  BFD141A2   LUI V0, 0xBFD1
BFD06A66  3082BFD1   LDC1 F30, 12418(S1)
BFD06A68  9C0C3082   ADDIU A0, V0, -25588
BFD06A6A  30A09C0C   LWC1 F0, 12448(T4)
BFD06A6C  01AD30A0   ADDIU A1, ZERO, 429
BFD06A70  4B7E77E8   JALS vAssertCalled
BFD06A72      4B7E   LW K1, 120(SP)
BFD06A74      0C00   NOP
430:                 	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
BFD06A76  0024FC7E   LW V1, 36(S8)
BFD06A7A  FF0041A2   LUI V0, 0xFF00
BFD06A7C  4493FF00   LW T8, 17555(ZERO)
BFD06A7E      4493   AND16 V0, V1
BFD06A80  000940E2   BEQZC V0, 0xBFD06A96
BFD06A84  BFD141A2   LUI V0, 0xBFD1
BFD06A86  3082BFD1   LDC1 F30, 12418(S1)
BFD06A88  9C0C3082   ADDIU A0, V0, -25588
BFD06A8A  30A09C0C   LWC1 F0, 12448(T4)
BFD06A8C  01AE30A0   ADDIU A1, ZERO, 430
BFD06A90  4B7E77E8   JALS vAssertCalled
BFD06A92      4B7E   LW K1, 120(SP)
BFD06A94      0C00   NOP
431:                 
432:                 	taskENTER_CRITICAL();
BFD06A96  33B877E8   JALS vTaskEnterCritical
BFD06A98  0C0033B8   ADDIU SP, T8, 3072
BFD06A9A      0C00   NOP
433:                 	{
434:                 		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
435:                 
436:                 		/* The value returned is the event group value prior to the bits being
437:                 		cleared. */
438:                 		uxReturn = pxEventBits->uxEventBits;
BFD06A9C  0010FC5E   LW V0, 16(S8)
BFD06AA0      6920   LW V0, 0(V0)
BFD06AA2  0014F85E   SW V0, 20(S8)
439:                 
440:                 		/* Clear the bits. */
441:                 		pxEventBits->uxEventBits &= ~uxBitsToClear;
BFD06AA6  0010FC5E   LW V0, 16(S8)
BFD06AAA      69A0   LW V1, 0(V0)
BFD06AAC  0024FC5E   LW V0, 36(S8)
BFD06AB0      4412   NOT16 V0, V0
BFD06AB2      449A   AND16 V1, V0
BFD06AB4  0010FC5E   LW V0, 16(S8)
BFD06AB8      E9A0   SW V1, 0(V0)
442:                 	}
443:                 	taskEXIT_CRITICAL();
BFD06ABA  40AA77E8   JALS vTaskExitCritical
BFD06ABC  0C0040AA   BNEZC T2, 0xBFD082C0
BFD06ABE      0C00   NOP
444:                 
445:                 	return uxReturn;
BFD06AC0  0014FC5E   LW V0, 20(S8)
446:                 }
BFD06AC4      0FBE   MOVE SP, S8
BFD06AC6      4BE7   LW RA, 28(SP)
BFD06AC8      4BC6   LW S8, 24(SP)
BFD06ACA      4C11   ADDIU SP, SP, 32
BFD06ACC      459F   JR16 RA
BFD06ACE      0C00   NOP
447:                 /*-----------------------------------------------------------*/
448:                 
449:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
450:                 
451:                 	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
452:                 	{
453:                 		BaseType_t xReturn;
454:                 
455:                 		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
456:                 		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
457:                 
458:                 		return xReturn;
459:                 	}
460:                 
461:                 #endif
462:                 /*-----------------------------------------------------------*/
463:                 
464:                 EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
465:                 {
BFD09144      4FED   ADDIU SP, SP, -40
BFD09146      CBE9   SW RA, 36(SP)
BFD09148      CBC8   SW S8, 32(SP)
BFD0914A      0FDD   MOVE S8, SP
BFD0914C  0028F89E   SW A0, 40(S8)
466:                 UBaseType_t uxSavedInterruptStatus;
467:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
BFD09150  0028FC5E   LW V0, 40(S8)
BFD09154  0010F85E   SW V0, 16(S8)
468:                 EventBits_t uxReturn;
469:                 
470:                 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
BFD09158  475E77E8   JALS uxPortSetInterruptMaskFromISR
BFD0915C      0C00   NOP
BFD0915E  0014F85E   SW V0, 20(S8)
471:                 	{
472:                 		uxReturn = pxEventBits->uxEventBits;
BFD09162  0010FC5E   LW V0, 16(S8)
BFD09166      6920   LW V0, 0(V0)
BFD09168  0018F85E   SW V0, 24(S8)
473:                 	}
474:                 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
BFD0916C  0014FC9E   LW A0, 20(S8)
BFD09170  4D5E77E8   JALS vPortClearInterruptMaskFromISR
BFD09172      4D5E   ADDIU T2, T2, -1
BFD09174      0C00   NOP
475:                 
476:                 	return uxReturn;
BFD09176  0018FC5E   LW V0, 24(S8)
477:                 }
BFD0917A      0FBE   MOVE SP, S8
BFD0917C      4BE9   LW RA, 36(SP)
BFD0917E      4BC8   LW S8, 32(SP)
BFD09180      4C15   ADDIU SP, SP, 40
BFD09182      459F   JR16 RA
BFD09184      0C00   NOP
478:                 /*-----------------------------------------------------------*/
479:                 
480:                 EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
481:                 {
BFD02568      4FE1   ADDIU SP, SP, -64
BFD0256A      CBEF   SW RA, 60(SP)
BFD0256C      CBCE   SW S8, 56(SP)
BFD0256E      0FDD   MOVE S8, SP
BFD02570  0040F89E   SW A0, 64(S8)
BFD02574  0044F8BE   SW A1, 68(S8)
482:                 ListItem_t *pxListItem, *pxNext;
483:                 ListItem_t const *pxListEnd;
484:                 List_t *pxList;
485:                 EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
BFD02578  0014F81E   SW ZERO, 20(S8)
486:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
BFD0257C  0040FC5E   LW V0, 64(S8)
BFD02580  001CF85E   SW V0, 28(S8)
487:                 BaseType_t xMatchFound = pdFALSE;
BFD02584  0018F81E   SW ZERO, 24(S8)
488:                 
489:                 	/* Check the user is not attempting to set the bits used by the kernel
490:                 	itself. */
491:                 	configASSERT( xEventGroup );
BFD02588  0040FC5E   LW V0, 64(S8)
BFD0258C  000940A2   BNEZC V0, 0xBFD025A2
BFD02590  BFD141A2   LUI V0, 0xBFD1
BFD02592  3082BFD1   LDC1 F30, 12418(S1)
BFD02594  9C0C3082   ADDIU A0, V0, -25588
BFD02596  30A09C0C   LWC1 F0, 12448(T4)
BFD02598  01EB30A0   ADDIU A1, ZERO, 491
BFD0259C  4B7E77E8   JALS vAssertCalled
BFD0259E      4B7E   LW K1, 120(SP)
BFD025A0      0C00   NOP
492:                 	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
BFD025A2  0044FC7E   LW V1, 68(S8)
BFD025A6  FF0041A2   LUI V0, 0xFF00
BFD025A8  4493FF00   LW T8, 17555(ZERO)
BFD025AA      4493   AND16 V0, V1
BFD025AC  000940E2   BEQZC V0, 0xBFD025C2
BFD025B0  BFD141A2   LUI V0, 0xBFD1
BFD025B2  3082BFD1   LDC1 F30, 12418(S1)
BFD025B4  9C0C3082   ADDIU A0, V0, -25588
BFD025B6  30A09C0C   LWC1 F0, 12448(T4)
BFD025B8  01EC30A0   ADDIU A1, ZERO, 492
BFD025BC  4B7E77E8   JALS vAssertCalled
BFD025BE      4B7E   LW K1, 120(SP)
BFD025C0      0C00   NOP
493:                 
494:                 	pxList = &( pxEventBits->xTasksWaitingForBits );
BFD025C2  001CFC5E   LW V0, 28(S8)
BFD025C6      6D22   ADDIU V0, V0, 4
BFD025C8  0020F85E   SW V0, 32(S8)
495:                 	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
BFD025CC  0020FC5E   LW V0, 32(S8)
BFD025D0      6D24   ADDIU V0, V0, 8
BFD025D2  0024F85E   SW V0, 36(S8)
496:                 	vTaskSuspendAll();
BFD025D6  4EF477E8   JALS vTaskSuspendAll
BFD025D8      4EF4   ADDIU S7, S7, -6
BFD025DA      0C00   NOP
497:                 	{
498:                 		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
499:                 
500:                 		pxListItem = listGET_HEAD_ENTRY( pxList );
BFD025DC  0020FC5E   LW V0, 32(S8)
BFD025E0      6923   LW V0, 12(V0)
BFD025E2  0010F85E   SW V0, 16(S8)
501:                 
502:                 		/* Set the bits. */
503:                 		pxEventBits->uxEventBits |= uxBitsToSet;
BFD025E6  001CFC5E   LW V0, 28(S8)
BFD025EA      69A0   LW V1, 0(V0)
BFD025EC  0044FC5E   LW V0, 68(S8)
BFD025F0      44DA   OR16 V1, V0
BFD025F2  001CFC5E   LW V0, 28(S8)
BFD025F6      E9A0   SW V1, 0(V0)
504:                 
505:                 		/* See if the new bit value should unblock any tasks. */
506:                 		while( pxListItem != pxListEnd )
BFD025F8      CC5E   B 0xBFD026B6
BFD025FA      0C00   NOP
BFD026B6  0010FC7E   LW V1, 16(S8)
BFD026BA  0024FC5E   LW V0, 36(S8)
BFD026BE  FF9DB443   BNE V1, V0, 0xBFD025FC
BFD026C0  0C00FF9D   LW GP, 3072(SP)
BFD026C2      0C00   NOP
507:                 		{
508:                 			pxNext = listGET_NEXT( pxListItem );
BFD025FC  0010FC5E   LW V0, 16(S8)
BFD02600      6921   LW V0, 4(V0)
BFD02602  0028F85E   SW V0, 40(S8)
509:                 			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
BFD02606  0010FC5E   LW V0, 16(S8)
BFD0260A      6920   LW V0, 0(V0)
BFD0260C  002CF85E   SW V0, 44(S8)
510:                 			xMatchFound = pdFALSE;
BFD02610  0018F81E   SW ZERO, 24(S8)
511:                 
512:                 			/* Split the bits waited for from the control bits. */
513:                 			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
BFD02614  002CFC7E   LW V1, 44(S8)
BFD02618  FF0041A2   LUI V0, 0xFF00
BFD0261A  4493FF00   LW T8, 17555(ZERO)
BFD0261C      4493   AND16 V0, V1
BFD0261E  0030F85E   SW V0, 48(S8)
514:                 			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
BFD02622  002CFC5E   LW V0, 44(S8)
BFD02626  B82C0042   EXT V0, V0, 0, 24
BFD02628  F85EB82C   SDC1 F1, -1954(T4)
BFD0262A  002CF85E   SW V0, 44(S8)
515:                 
516:                 			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
BFD0262E  0030FC7E   LW V1, 48(S8)
BFD02632  040041A2   LUI V0, 0x400
BFD02634      0400   ADDU S0, S0, S0
BFD02636      4493   AND16 V0, V1
BFD02638  000D40A2   BNEZC V0, 0xBFD02656
517:                 			{
518:                 				/* Just looking for single bit being set. */
519:                 				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
BFD0263C  001CFC5E   LW V0, 28(S8)
BFD02640      69A0   LW V1, 0(V0)
BFD02642  002CFC5E   LW V0, 44(S8)
BFD02646      4493   AND16 V0, V1
BFD02648  001340E2   BEQZC V0, 0xBFD02672
520:                 				{
521:                 					xMatchFound = pdTRUE;
BFD0264C      ED01   LI V0, 1
BFD0264E  0018F85E   SW V0, 24(S8)
BFD02652      CC0F   B 0xBFD02672
BFD02654      0C00   NOP
522:                 				}
523:                 				else
524:                 				{
525:                 					mtCOVERAGE_TEST_MARKER();
526:                 				}
527:                 			}
528:                 			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
BFD02656  001CFC5E   LW V0, 28(S8)
BFD0265A      69A0   LW V1, 0(V0)
BFD0265C  002CFC5E   LW V0, 44(S8)
BFD02660      449A   AND16 V1, V0
BFD02662  002CFC5E   LW V0, 44(S8)
BFD02666  0004B443   BNE V1, V0, 0xBFD02672
BFD02668  0C000004   SLL ZERO, A0, 1
BFD0266A      0C00   NOP
529:                 			{
530:                 				/* All bits are set. */
531:                 				xMatchFound = pdTRUE;
BFD0266C      ED01   LI V0, 1
BFD0266E  0018F85E   SW V0, 24(S8)
532:                 			}
533:                 			else
534:                 			{
535:                 				/* Need all bits to be set, but not all the bits were set. */
536:                 			}
537:                 
538:                 			if( xMatchFound != pdFALSE )
BFD02672  0018FC5E   LW V0, 24(S8)
BFD02676  001A40E2   BEQZC V0, 0xBFD026AE
539:                 			{
540:                 				/* The bits match.  Should the bits be cleared on exit? */
541:                 				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
BFD0267A  0030FC7E   LW V1, 48(S8)
BFD0267E  010041A2   LUI V0, 0x100
BFD02682      4493   AND16 V0, V1
BFD02684  000740E2   BEQZC V0, 0xBFD02696
542:                 				{
543:                 					uxBitsToClear |= uxBitsWaitedFor;
BFD02688  0014FC7E   LW V1, 20(S8)
BFD0268C  002CFC5E   LW V0, 44(S8)
BFD02690      44D3   OR16 V0, V1
BFD02692  0014F85E   SW V0, 20(S8)
544:                 				}
545:                 				else
546:                 				{
547:                 					mtCOVERAGE_TEST_MARKER();
548:                 				}
549:                 
550:                 				/* Store the actual event flag value in the task's event list
551:                 				item before removing the task from the event list.  The
552:                 				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
553:                 				that is was unblocked due to its required bits matching, rather
554:                 				than because it timed out. */
555:                 				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
BFD02696  001CFC5E   LW V0, 28(S8)
BFD0269A      69A0   LW V1, 0(V0)
BFD0269C  020041A2   LUI V0, 0x200
BFD026A0      44D3   OR16 V0, V1
BFD026A2  0010FC9E   LW A0, 16(S8)
BFD026A6      0CA2   MOVE A1, V0
BFD026A8  216277E8   JALS xTaskRemoveFromUnorderedEventList
BFD026AA  0C002162   LWC2 T3, 3072(V0)
BFD026AC      0C00   NOP
556:                 			}
557:                 
558:                 			/* Move onto the next list item.  Note pxListItem->pxNext is not
559:                 			used here as the list item may have been removed from the event list
560:                 			and inserted into the ready/pending reading list. */
561:                 			pxListItem = pxNext;
BFD026AE  0028FC5E   LW V0, 40(S8)
BFD026B2  0010F85E   SW V0, 16(S8)
562:                 		}
563:                 
564:                 		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
565:                 		bit was set in the control word. */
566:                 		pxEventBits->uxEventBits &= ~uxBitsToClear;
BFD026C4  001CFC5E   LW V0, 28(S8)
BFD026C8      69A0   LW V1, 0(V0)
BFD026CA  0014FC5E   LW V0, 20(S8)
BFD026CE      4412   NOT16 V0, V0
BFD026D0      449A   AND16 V1, V0
BFD026D2  001CFC5E   LW V0, 28(S8)
BFD026D6      E9A0   SW V1, 0(V0)
567:                 	}
568:                 	( void ) xTaskResumeAll();
BFD026D8  158E77E8   JALS xTaskResumeAll
BFD026DA  0C00158E   LBU T4, 3072(T6)
BFD026DC      0C00   NOP
569:                 
570:                 	return pxEventBits->uxEventBits;
BFD026DE  001CFC5E   LW V0, 28(S8)
BFD026E2      6920   LW V0, 0(V0)
571:                 }
BFD026E4      0FBE   MOVE SP, S8
BFD026E6      4BEF   LW RA, 60(SP)
BFD026E8      4BCE   LW S8, 56(SP)
BFD026EA      4C21   ADDIU SP, SP, 64
BFD026EC      459F   JR16 RA
BFD026EE      0C00   NOP
572:                 /*-----------------------------------------------------------*/
573:                 
574:                 void vEventGroupDelete( EventGroupHandle_t xEventGroup )
575:                 {
BFD06C70      4FF1   ADDIU SP, SP, -32
BFD06C72      CBE7   SW RA, 28(SP)
BFD06C74      CBC6   SW S8, 24(SP)
BFD06C76      0FDD   MOVE S8, SP
BFD06C78  0020F89E   SW A0, 32(S8)
576:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
BFD06C7C  0020FC5E   LW V0, 32(S8)
BFD06C80  0010F85E   SW V0, 16(S8)
577:                 const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
BFD06C84  0010FC5E   LW V0, 16(S8)
BFD06C88      6D22   ADDIU V0, V0, 4
BFD06C8A  0014F85E   SW V0, 20(S8)
578:                 
579:                 	vTaskSuspendAll();
BFD06C8E  4EF477E8   JALS vTaskSuspendAll
BFD06C90      4EF4   ADDIU S7, S7, -6
BFD06C92      0C00   NOP
580:                 	{
581:                 		traceEVENT_GROUP_DELETE( xEventGroup );
582:                 
583:                 		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
BFD06C94      CC1C   B 0xBFD06CCE
BFD06C96      0C00   NOP
BFD06CCE  0014FC5E   LW V0, 20(S8)
BFD06CD2      6920   LW V0, 0(V0)
BFD06CD4  FFE040A2   BNEZC V0, 0xBFD06C98
BFD06CD6  FC9EFFE0   LW RA, -866(ZERO)
584:                 		{
585:                 			/* Unblock the task, returning 0 as the event list is being deleted
586:                 			and	cannot therefore have any bits set. */
587:                 			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
BFD06C98  0014FC5E   LW V0, 20(S8)
BFD06C9C      69A3   LW V1, 12(V0)
BFD06C9E  0014FC5E   LW V0, 20(S8)
BFD06CA2      6D24   ADDIU V0, V0, 8
BFD06CA4  000AB443   BNE V1, V0, 0xBFD06CBC
BFD06CA6  0C00000A   SLL ZERO, T2, 1
BFD06CA8      0C00   NOP
BFD06CAA  BFD141A2   LUI V0, 0xBFD1
BFD06CAC  3082BFD1   LDC1 F30, 12418(S1)
BFD06CAE  9C0C3082   ADDIU A0, V0, -25588
BFD06CB0  30A09C0C   LWC1 F0, 12448(T4)
BFD06CB2  024B30A0   ADDIU A1, ZERO, 587
BFD06CB6  4B7E77E8   JALS vAssertCalled
BFD06CB8      4B7E   LW K1, 120(SP)
BFD06CBA      0C00   NOP
588:                 			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
BFD06CBC  0014FC5E   LW V0, 20(S8)
BFD06CC0      6923   LW V0, 12(V0)
BFD06CC2      0C82   MOVE A0, V0
BFD06CC4  020041A5   LUI A1, 0x200
BFD06CC8  216277E8   JALS xTaskRemoveFromUnorderedEventList
BFD06CCA  0C002162   LWC2 T3, 3072(V0)
BFD06CCC      0C00   NOP
589:                 		}
590:                 
591:                 		vPortFree( pxEventBits );
BFD06CD8  0010FC9E   LW A0, 16(S8)
BFD06CDC  2FEA77E8   JALS vPortFree
BFD06CDE      2FEA   ANDI A3, A2, 0x20
BFD06CE0      0C00   NOP
592:                 	}
593:                 	( void ) xTaskResumeAll();
BFD06CE2  158E77E8   JALS xTaskResumeAll
BFD06CE4  0C00158E   LBU T4, 3072(T6)
BFD06CE6      0C00   NOP
594:                 }
BFD06CE8      0FBE   MOVE SP, S8
BFD06CEA      4BE7   LW RA, 28(SP)
BFD06CEC      4BC6   LW S8, 24(SP)
BFD06CEE      4C11   ADDIU SP, SP, 32
BFD06CF0      459F   JR16 RA
BFD06CF2      0C00   NOP
595:                 /*-----------------------------------------------------------*/
596:                 
597:                 /* For internal use only - execute a 'set bits' command that was pended from
598:                 an interrupt. */
599:                 void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
600:                 {
BFD0993C      4FF5   ADDIU SP, SP, -24
BFD0993E      CBE5   SW RA, 20(SP)
BFD09940      CBC4   SW S8, 16(SP)
BFD09942      0FDD   MOVE S8, SP
BFD09944  0018F89E   SW A0, 24(S8)
BFD09948  001CF8BE   SW A1, 28(S8)
601:                 	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
BFD0994C  0018FC9E   LW A0, 24(S8)
BFD09950  001CFCBE   LW A1, 28(S8)
BFD09954  12B477E8   JALS xEventGroupSetBits
BFD09956  0C0012B4   ADDI S5, S4, 3072
BFD09958      0C00   NOP
602:                 }
BFD0995A      0FBE   MOVE SP, S8
BFD0995C      4BE5   LW RA, 20(SP)
BFD0995E      4BC4   LW S8, 16(SP)
BFD09960      4C0D   ADDIU SP, SP, 24
BFD09962      459F   JR16 RA
BFD09964      0C00   NOP
603:                 /*-----------------------------------------------------------*/
604:                 
605:                 /* For internal use only - execute a 'clear bits' command that was pended from
606:                 an interrupt. */
607:                 void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
608:                 {
BFD09968      4FF5   ADDIU SP, SP, -24
BFD0996A      CBE5   SW RA, 20(SP)
BFD0996C      CBC4   SW S8, 16(SP)
BFD0996E      0FDD   MOVE S8, SP
BFD09970  0018F89E   SW A0, 24(S8)
BFD09974  001CF8BE   SW A1, 28(S8)
609:                 	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
BFD09978  0018FC9E   LW A0, 24(S8)
BFD0997C  001CFCBE   LW A1, 28(S8)
BFD09980  352277E8   JALS xEventGroupClearBits
BFD09982  0C003522   LHU T1, 3072(V0)
BFD09984      0C00   NOP
610:                 }
BFD09986      0FBE   MOVE SP, S8
BFD09988      4BE5   LW RA, 20(SP)
BFD0998A      4BC4   LW S8, 16(SP)
BFD0998C      4C0D   ADDIU SP, SP, 24
BFD0998E      459F   JR16 RA
BFD09990      0C00   NOP
611:                 /*-----------------------------------------------------------*/
612:                 
613:                 static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
614:                 {
BFD080F4      4FF9   ADDIU SP, SP, -16
BFD080F6      CBC3   SW S8, 12(SP)
BFD080F8      0FDD   MOVE S8, SP
BFD080FA  0010F89E   SW A0, 16(S8)
BFD080FE  0014F8BE   SW A1, 20(S8)
BFD08102  0018F8DE   SW A2, 24(S8)
615:                 BaseType_t xWaitConditionMet = pdFALSE;
BFD08106  0000F81E   SW ZERO, 0(S8)
616:                 
617:                 	if( xWaitForAllBits == pdFALSE )
BFD0810A  0018FC5E   LW V0, 24(S8)
BFD0810E  000C40A2   BNEZC V0, 0xBFD0812A
618:                 	{
619:                 		/* Task only has to wait for one bit within uxBitsToWaitFor to be
620:                 		set.  Is one already set? */
621:                 		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
BFD08112  0010FC7E   LW V1, 16(S8)
BFD08116  0014FC5E   LW V0, 20(S8)
BFD0811A      4493   AND16 V0, V1
BFD0811C  001240E2   BEQZC V0, 0xBFD08144
622:                 		{
623:                 			xWaitConditionMet = pdTRUE;
BFD08120      ED01   LI V0, 1
BFD08122  0000F85E   SW V0, 0(S8)
BFD08126      CC0E   B 0xBFD08144
BFD08128      0C00   NOP
624:                 		}
625:                 		else
626:                 		{
627:                 			mtCOVERAGE_TEST_MARKER();
628:                 		}
629:                 	}
630:                 	else
631:                 	{
632:                 		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
633:                 		Are they set already? */
634:                 		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
BFD0812A  0010FC7E   LW V1, 16(S8)
BFD0812E  0014FC5E   LW V0, 20(S8)
BFD08132      449A   AND16 V1, V0
BFD08134  0014FC5E   LW V0, 20(S8)
BFD08138  0004B443   BNE V1, V0, 0xBFD08144
BFD0813A  0C000004   SLL ZERO, A0, 1
BFD0813C      0C00   NOP
635:                 		{
636:                 			xWaitConditionMet = pdTRUE;
BFD0813E      ED01   LI V0, 1
BFD08140  0000F85E   SW V0, 0(S8)
637:                 		}
638:                 		else
639:                 		{
640:                 			mtCOVERAGE_TEST_MARKER();
641:                 		}
642:                 	}
643:                 
644:                 	return xWaitConditionMet;
BFD08144  0000FC5E   LW V0, 0(S8)
645:                 }
BFD08148      0FBE   MOVE SP, S8
BFD0814A      4BC3   LW S8, 12(SP)
BFD0814C      4C09   ADDIU SP, SP, 16
BFD0814E      459F   JR16 RA
BFD08150      0C00   NOP
646:                 /*-----------------------------------------------------------*/
647:                 
648:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
649:                 
650:                 	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
651:                 	{
652:                 	BaseType_t xReturn;
653:                 
654:                 		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
655:                 		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
656:                 
657:                 		return xReturn;
658:                 	}
659:                 
660:                 #endif
661:                 /*-----------------------------------------------------------*/
662:                 
663:                 #if (configUSE_TRACE_FACILITY == 1)
664:                 
665:                 	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
666:                 	{
667:                 	UBaseType_t xReturn;
668:                 	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
669:                 
670:                 		if( xEventGroup == NULL )
671:                 		{
672:                 			xReturn = 0;
673:                 		}
674:                 		else
675:                 		{
676:                 			xReturn = pxEventBits->uxEventGroupNumber;
677:                 		}
678:                 
679:                 		return xReturn;
680:                 	}
681:                 
682:                 #endif
683:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/startup/mplab/on_reset.c  
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file on_reset.c
22:                   *MEC14xx XC32 M14K Startup code _on_reset handler
23:                   */
24:                  /** @defgroup MEC14xx Startup
25:                   *  @{
26:                   */
27:                  
28:                  
29:                  #include "appcfg.h"
30:                  #include "platform.h"
31:                  #include "MEC14xx/mec14xx.h"
32:                  #include "MEC14xx/mec14xx_pcr.h"
33:                  
34:                  /*
35:                   * From linker command file
36:                   */
37:                  extern uint32_t _ebase_address[];
38:                  
39:                  
40:                  /** _on_reset - Very early HW initialization.
41:                   * @note XC32 startup code has initialized SP & GP. No other
42:                   * C features have been initialized (before .bss clear and
43:                   * global data init.) NOTE: MIPS M14K is still in Boot-Strap 
44:                   * mode and EBASE has not been programmed. Any exception or 
45:                   * interrupts will vector to the BEV Exception handler! 
46:                   */
47:                  void
48:                  __attribute__((nomips16)) _on_reset (void)
49:                  {
BFD091CC      4FB0   ADDIU SP, SP, -8
BFD091CE      CBC1   SW S8, 4(SP)
BFD091D0      0FDD   MOVE S8, SP
50:                      /* Enable JTAG */
51:                      ECS_REG->JTAG_ENABLE |= 1u;
BFD091D2  A00041A2   LUI V0, 0xA000
BFD091D6  FC205042   ORI V0, V0, -992
BFD091D8  41A3FC20   LW AT, 16803(ZERO)
BFD091DA  A00041A3   LUI V1, 0xA000
BFD091DE  FC205063   ORI V1, V1, -992
BFD091E0  69B0FC20   LW AT, 27056(ZERO)
BFD091E2      69B0   LW V1, 0(V1)
BFD091E4  00015063   ORI V1, V1, 1
BFD091E8      E9A0   SW V1, 0(V0)
52:                  
53:                      /* Disable WDT */
54:                      WDT->CONTROL = 0u;
BFD091EA  A00041A2   LUI V0, 0xA000
BFD091EE  04005042   ORI V0, V0, 1024
BFD091F0      0400   ADDU S0, S0, S0
BFD091F2      8824   SB S0, 4(V0)
55:                  
56:                      /* Set CPU clock divider specified in appcfg.h */
57:                      PCR->PROC_CLOCK_CNTRL = ( PCR_CLOCK_DIVIDER );
BFD091F4  A00841A2   LUI V0, 0xA008
BFD091F8  01005042   ORI V0, V0, 256
BFD091FC      ED81   LI V1, 1
BFD091FE      E9A8   SW V1, 32(V0)
58:                      __EHB();
BFD09200  18000000   SLL ZERO, ZERO, 3
BFD09202  00001800   SB ZERO, 0(ZERO)
59:                      CPU_NOP();
BFD09204  08000000   SSNOP
BFD09206      0800   LBU S0, 0(S0)
60:                  
61:                  }
BFD09208      0FBE   MOVE SP, S8
BFD0920A      4BC1   LW S8, 4(SP)
BFD0920C      459F   JR16 RA
BFD0920E      4C05   ADDIU SP, SP, 8
62:                  
63:                  
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/startup/mplab/default-on-bootstrap.c
1:                   /*********************************************************************
2:                    *
3:                    *              Default _on_bootstrap Implementation
4:                    *
5:                    *********************************************************************
6:                    * Filename:        default-on-bootstrap.c
7:                    *
8:                    * Processor:       PIC32
9:                    *
10:                   * Compiler:        MPLAB C Compiler for PIC32 MCUs
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * The software supplied herewith by Microchip Technology Incorporated
17:                   * (the 'Company') for its PIC32/PIC24F Microcontroller is intended
18:                   * and supplied to you, the Company's customer, for use solely and
19:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
20:                   * The software is owned by the Company and/or its supplier, and is
21:                   * protected under applicable copyright laws. All rights are reserved.
22:                   * Any use in violation of the foregoing restrictions may subject the
23:                   * user to criminal sanctions under applicable laws, as well as to
24:                   * civil liability for the breach of the terms and conditions of this
25:                   * license.
26:                   *
27:                   * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
28:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
29:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
30:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
31:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
32:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
33:                   *
34:                   ********************************************************************/
35:                  /* This is a default definition of an _on_bootstrap() function.
36:                   * It does nothing and just goes returns. If the user
37:                   * application supplies a handler function, this function will not be
38:                   * referenced and thus not pulled in from the library.
39:                   */
40:                  void 
41:                  _on_bootstrap (void)
42:                  {
BFD09EE4      4FB0   ADDIU SP, SP, -8
BFD09EE6      CBC1   SW S8, 4(SP)
BFD09EE8      0FDD   MOVE S8, SP
43:                  }
BFD09EEA      0FBE   MOVE SP, S8
BFD09EEC      4BC1   LW S8, 4(SP)
BFD09EEE      4C05   ADDIU SP, SP, 8
BFD09EF0      459F   JR16 RA
BFD09EF2      0C00   NOP
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/mec14xx_timers.c  -------
1:                   /*****************************************************************************
2:                   *  2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  
22:                  /** @file mec14xx_timers.c
23:                   *MEC14xx Timers 
24:                   */
25:                  /** @defgroup MEC14xx Peripherals Timers
26:                   *  @{
27:                   */
28:                  
29:                  
30:                  #include "appcfg.h"
31:                  #include "platform.h"
32:                  #include "MEC14xx/mec14xx.h"
33:                  #include "MEC14xx/mec14xx_pcr.h"
34:                  #include "MEC14xx/mec14xx_timers.h"
35:                  
36:                  
37:                  // pairs of bytes (sleep reg, bit position)
38:                  // sleep reg = 0 for EC_SLEEP_EN or 1 for EC_SLEEP_EN2
39:                  //
40:                  struct btmr_sleep_info_s {
41:                      uint8_t slp_reg;
42:                      uint8_t bit_pos;
43:                  };
44:                  
45:                  static const struct btmr_sleep_info_s btmr_slp_info[BTMR_MAX_INSTANCE] = {
46:                      { 0, PCR_EC_TIMER0_SLP_BITPOS },
47:                      { 0, PCR_EC_TIMER1_SLP_BITPOS },
48:                      { 1, PCR_EC2_TIMER2_SLP_BITPOS },
49:                      { 1, PCR_EC2_TIMER3_SLP_BITPOS }
50:                   };
51:                  
52:                  
53:                  #ifdef MEC14XX_BTIMER_CHECK_ID
54:                  
55:                  /**
56:                   * tmr_valid - Local helper that checks if logical Timer ID is 
57:                   * valid. 
58:                   * 
59:                   * @author sworley 
60:                   * 
61:                   * @param tmr_id 0-based Timer ID
62:                   * 
63:                   * @return uint8_t Non-zero(VALID), 0(Invalid)
64:                   */
65:                  static uint8_t btmr_valid(uint8_t tmr_id)
66:                  {
BFD09A44      4FB0   ADDIU SP, SP, -8
BFD09A46      CBC1   SW S8, 4(SP)
BFD09A48      0FDD   MOVE S8, SP
BFD09A4A      0C44   MOVE V0, A0
BFD09A4C  0008185E   SB V0, 8(S8)
67:                      if ( tmr_id < (BTMR_ID_MAX ) ) {
BFD09A50  0008145E   LBU V0, 8(S8)
BFD09A54  0004B042   SLTIU V0, V0, 4
BFD09A58  000340E2   BEQZC V0, 0xBFD09A62
68:                          return true;
BFD09A5C      ED01   LI V0, 1
BFD09A5E      CC02   B 0xBFD09A64
BFD09A60      0C00   NOP
69:                      }
70:                      return false;
BFD09A62      0C40   MOVE V0, ZERO
71:                  }
BFD09A64      0FBE   MOVE SP, S8
BFD09A66      4BC1   LW S8, 4(SP)
BFD09A68      4C05   ADDIU SP, SP, 8
BFD09A6A      459F   JR16 RA
BFD09A6C      0C00   NOP
72:                  
73:                  #else
74:                  
75:                  /**
76:                   * @brief - This version of tmr_valid skips checking always 
77:                   *        returning TRUE. Compiler may optimize it out.
78:                   * 
79:                   */
80:                  static uint8_t btmr_valid(uint8_t tmr_id) 
81:                  { 
82:                      (void) tmr_id;
83:                      return true; 
84:                  }
85:                  
86:                  #endif
87:                  
88:                  uint32_t btmr_get_hw_addr(uint8_t btmr_id)
89:                  {
BFD09A70      4FB0   ADDIU SP, SP, -8
BFD09A72      CBC1   SW S8, 4(SP)
BFD09A74      0FDD   MOVE S8, SP
BFD09A76      0C44   MOVE V0, A0
BFD09A78  0008185E   SB V0, 8(S8)
90:                      return (uint32_t)(BTMR0_BASE) + 
BFD09A82  A00041A2   LUI V0, 0xA000
BFD09A86  0C005042   ORI V0, V0, 3072
BFD09A88      0C00   NOP
BFD09A8A      0526   ADDU V0, V1, V0
91:                             ((uint32_t)(btmr_id) << (BTMR_INSTANCE_BITPOS));
BFD09A7C  0008145E   LBU V0, 8(S8)
BFD09A80      25AA   SLL V1, V0, 5
92:                  }
BFD09A8C      0FBE   MOVE SP, S8
BFD09A8E      4BC1   LW S8, 4(SP)
BFD09A90      4C05   ADDIU SP, SP, 8
BFD09A92      459F   JR16 RA
BFD09A94      0C00   NOP
93:                  
94:                  /**
95:                   * btmr_sleep_en - Enable/Disable clock gating on idle of a 
96:                   * timer 
97:                   * 
98:                   * @author sworley (8/16/2013)
99:                   * 
100:                  * @param tmr_id zero based timer ID.
101:                  * @param pwr_on boolean true=ON, false=OFF
102:                  */
103:                 void btmr_sleep_en(uint8_t tmr_id, uint8_t sleep_en)
104:                 {
BFD05DC0      4FF1   ADDIU SP, SP, -32
BFD05DC2      CBE7   SW RA, 28(SP)
BFD05DC4      CBC6   SW S8, 24(SP)
BFD05DC6      0FDD   MOVE S8, SP
BFD05DC8      0C64   MOVE V1, A0
BFD05DCA      0C45   MOVE V0, A1
BFD05DCC  0020187E   SB V1, 32(S8)
BFD05DD0  0024185E   SB V0, 36(S8)
105:                     uint32_t sleep_mask;
106:                     uint32_t volatile * p;
107:                     
108:                     sleep_mask = 0ul;
BFD05DD4  0014F81E   SW ZERO, 20(S8)
109:                     if ( btmr_valid(tmr_id) ) {
BFD05DD8  0020145E   LBU V0, 32(S8)
BFD05DDC      0C82   MOVE A0, V0
BFD05DDE  4D2277E8   JALS btmr_valid
BFD05DE0      4D22   ADDIU T1, T1, 1
BFD05DE2      0C00   NOP
BFD05DE4  004040E2   BEQZC V0, 0xBFD05E68
110:                         if (btmr_slp_info[tmr_id].slp_reg) {
BFD05DE8  0020147E   LBU V1, 32(S8)
BFD05DEC  BFD141A2   LUI V0, 0xBFD1
BFD05DEE  25B2BFD1   LDC1 F30, 9650(S1)
BFD05DF0      25B2   SLL V1, V1, 1
BFD05DF2  9F243042   ADDIU V0, V0, -24796
BFD05DF4  05269F24   LWC1 F25, 1318(A0)
BFD05DF6      0526   ADDU V0, V1, V0
BFD05DF8      0920   LBU V0, 0(V0)
BFD05DFA  000840E2   BEQZC V0, 0xBFD05E0E
111:                             p = (uint32_t volatile *)&(PCR->EC_SLEEP_EN2);
BFD05DFE  A00841A2   LUI V0, 0xA008
BFD05E02  01245042   ORI V0, V0, 292
BFD05E06  0010F85E   SW V0, 16(S8)
BFD05E08  CC070010   BREAK
BFD05E0A      CC07   B 0xBFD05E1A
BFD05E0C      0C00   NOP
112:                         } else {
113:                             p = (uint32_t volatile *)&(PCR->EC_SLEEP_EN);
BFD05E0E  A00841A2   LUI V0, 0xA008
BFD05E12  01085042   ORI V0, V0, 264
BFD05E16  0010F85E   SW V0, 16(S8)
114:                         }
115:                         sleep_mask = (1ul << btmr_slp_info[tmr_id].bit_pos);
BFD05E1A  0020147E   LBU V1, 32(S8)
BFD05E1E  BFD141A2   LUI V0, 0xBFD1
BFD05E20  25B2BFD1   LDC1 F30, 9650(S1)
BFD05E22      25B2   SLL V1, V1, 1
BFD05E24  9F243042   ADDIU V0, V0, -24796
BFD05E26  05269F24   LWC1 F25, 1318(A0)
BFD05E28      0526   ADDU V0, V1, V0
BFD05E2A      0921   LBU V0, 1(V0)
BFD05E2C      ED81   LI V1, 1
BFD05E2E  10100062   SLLV V0, V0, V1
BFD05E30  F85E1010   ADDI ZERO, S0, -1954
BFD05E32  0014F85E   SW V0, 20(S8)
116:                         if (sleep_en) {
BFD05E36  0024145E   LBU V0, 36(S8)
BFD05E3A  000B40E2   BEQZC V0, 0xBFD05E54
117:                             *p |= (sleep_mask);
BFD05E3E  0010FC5E   LW V0, 16(S8)
BFD05E42      69A0   LW V1, 0(V0)
BFD05E44  0014FC5E   LW V0, 20(S8)
BFD05E48      44DA   OR16 V1, V0
BFD05E4A  0010FC5E   LW V0, 16(S8)
BFD05E4E      E9A0   SW V1, 0(V0)
BFD05E50      CC0B   B 0xBFD05E68
BFD05E52      0C00   NOP
118:                         } else {
119:                             *p &= ~(sleep_mask);
BFD05E54  0010FC5E   LW V0, 16(S8)
BFD05E58      69A0   LW V1, 0(V0)
BFD05E5A  0014FC5E   LW V0, 20(S8)
BFD05E5E      4412   NOT16 V0, V0
BFD05E60      449A   AND16 V1, V0
BFD05E62  0010FC5E   LW V0, 16(S8)
BFD05E66      E9A0   SW V1, 0(V0)
120:                         }
121:                     }
122:                 }
BFD05E68      0FBE   MOVE SP, S8
BFD05E6A      4BE7   LW RA, 28(SP)
BFD05E6C      4BC6   LW S8, 24(SP)
BFD05E6E      4C11   ADDIU SP, SP, 32
BFD05E70      459F   JR16 RA
BFD05E72      0C00   NOP
123:                 
124:                 /**
125:                  * btmr_reset - Peform soft reset of specified timer.
126:                  * 
127:                  * @author sworley 
128:                  * 
129:                  * @param tmr_id 0-based Timer ID 
130:                  * @note Soft reset set all registers to POR values.
131:                  * Spins 256 times waiting on hardware to clear reset bit. 
132:                  */
133:                 void btmr_reset(uint8_t tmr_id)
134:                 {
BFD07988      4FF1   ADDIU SP, SP, -32
BFD0798A      CBE7   SW RA, 28(SP)
BFD0798C      CBC6   SW S8, 24(SP)
BFD0798E      0FDD   MOVE S8, SP
BFD07990      0C44   MOVE V0, A0
BFD07992  0020185E   SB V0, 32(S8)
135:                    BTMR_TypeDef * p;
136:                    uint32_t wait_cnt;
137:                 
138:                    if (btmr_valid(tmr_id)) {
BFD07996  0020145E   LBU V0, 32(S8)
BFD0799A      0C82   MOVE A0, V0
BFD0799C  4D2277E8   JALS btmr_valid
BFD0799E      4D22   ADDIU T1, T1, 1
BFD079A0      0C00   NOP
BFD079A2  002540E2   BEQZC V0, 0xBFD079F0
139:                       p = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD079A6  0020145E   LBU V0, 32(S8)
BFD079AA      0C82   MOVE A0, V0
BFD079AC  4D3877E8   JALS btmr_get_hw_addr
BFD079AE      4D38   ADDIU T1, T1, -4
BFD079B0      0C00   NOP
BFD079B2  0014F85E   SW V0, 20(S8)
140:                 
141:                       p->CONTROL = (BTMR_CNTL_SOFT_RESET);
BFD079B6  0014FC5E   LW V0, 20(S8)
BFD079B8  ED900014   SUB SP, S4, ZERO
BFD079BA      ED90   LI V1, 16
BFD079BC      E9A4   SW V1, 16(V0)
142:                 
143:                       wait_cnt = 256ul;
BFD079BE  01003040   ADDIU V0, ZERO, 256
BFD079C2  0010F85E   SW V0, 16(S8)
144:                       do {
145:                           if ( 0ul == (p->CONTROL & BTMR_CNTL_SOFT_RESET) ) {
BFD079C6  0014FC5E   LW V0, 20(S8)
BFD079CA      6924   LW V0, 16(V0)
BFD079CC      2D28   ANDI V0, V0, 0x10
BFD079CE  000E40E2   BEQZC V0, 0xBFD079EE
146:                               break;
BFD079EE      0C00   NOP
147:                           }
148:                       } 
149:                       while ( wait_cnt-- ); 
BFD079D2  0010FC5E   LW V0, 16(S8)
BFD079D4  00400010   SRL ZERO, S0, 0
BFD079D6  13900040   SLTU V0, ZERO, V0
BFD079D8  2D2D1390   ADDI GP, S0, 11565
BFD079DA      2D2D   ANDI V0, V0, 0xFF
BFD079DC  0010FC7E   LW V1, 16(S8)
BFD079E0      6DBE   ADDIU V1, V1, -1
BFD079E2  0010F87E   SW V1, 16(S8)
BFD079E6  FFEE40A2   BNEZC V0, 0xBFD079C6
BFD079E8  CC02FFEE   LW RA, -13310(T6)
BFD079EA      CC02   B 0xBFD079F0
BFD079EC      0C00   NOP
150:                    }      
151:                 }
BFD079F0      0FBE   MOVE SP, S8
BFD079F2      4BE7   LW RA, 28(SP)
BFD079F4      4BC6   LW S8, 24(SP)
BFD079F6      4C11   ADDIU SP, SP, 32
BFD079F8      459F   JR16 RA
BFD079FA      0C00   NOP
152:                 
153:                 /**
154:                  * btmr_init - Initialize specified timer
155:                  * @param zero based timer ID
156:                  * @param tmr_cntl b[15:0] = timer configuration flags.
157:                  * @param initial_count 
158:                  * @param preload_count 
159:                  * @note performs a soft reset of the timer before 
160:                  *       configuration.
161:                  */
162:                 void btmr_init(uint8_t tmr_id, 
163:                                uint16_t tmr_cntl,
164:                                uint16_t prescaler,
165:                                uint32_t initial_count,
166:                                uint32_t preload_count)
167:                 {
BFD056FC      4FF1   ADDIU SP, SP, -32
BFD056FE      CBE7   SW RA, 28(SP)
BFD05700      CBC6   SW S8, 24(SP)
BFD05702      0FDD   MOVE S8, SP
BFD05704      0C65   MOVE V1, A1
BFD05706      0C46   MOVE V0, A2
BFD05708  002CF8FE   SW A3, 44(S8)
BFD0570C  0020189E   SB A0, 32(S8)
BFD05710  0024387E   SH V1, 36(S8)
BFD05714  0028385E   SH V0, 40(S8)
168:                     BTMR_TypeDef * pTMR;
169:                 
170:                     pTMR = NULL;
BFD05718  0010F81E   SW ZERO, 16(S8)
171:                 
172:                     if (btmr_valid(tmr_id)) {
BFD0571C  0020145E   LBU V0, 32(S8)
BFD05720      0C82   MOVE A0, V0
BFD05722  4D2277E8   JALS btmr_valid
BFD05724      4D22   ADDIU T1, T1, 1
BFD05726      0C00   NOP
BFD05728  004840E2   BEQZC V0, 0xBFD057BC
173:                         btmr_reset(tmr_id);
BFD0572C  0020145E   LBU V0, 32(S8)
BFD05730      0C82   MOVE A0, V0
BFD05732  3CC477E8   JALS btmr_reset
BFD05734  0C003CC4   LH A2, 3072(A0)
BFD05736      0C00   NOP
174:                         
175:                         pTMR = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD05738  0020145E   LBU V0, 32(S8)
BFD0573C      0C82   MOVE A0, V0
BFD0573E  4D3877E8   JALS btmr_get_hw_addr
BFD05740      4D38   ADDIU T1, T1, -4
BFD05742      0C00   NOP
BFD05744  0010F85E   SW V0, 16(S8)
176:                         
177:                         // Ungate timer clocks and program prescale
178:                         pTMR->CONTROL = ((uint32_t)prescaler << 16) + (BTMR_CNTL_ENABLE);
BFD05748  0028345E   LHU V0, 40(S8)
BFD0574C  80000042   SLL V0, V0, 16
BFD05750      6DA0   ADDIU V1, V0, 1
BFD05752  0010FC5E   LW V0, 16(S8)
BFD05756      E9A4   SW V1, 16(V0)
179:                         
180:                         // Program Preload & initial counter value
181:                         pTMR->PRELOAD = preload_count;
BFD05758  0010FC5E   LW V0, 16(S8)
BFD0575C  0030FC7E   LW V1, 48(S8)
BFD05760      E9A1   SW V1, 4(V0)
182:                         pTMR->COUNT = initial_count;
BFD05762  0010FC5E   LW V0, 16(S8)
BFD05766  002CFC7E   LW V1, 44(S8)
BFD0576A      E9A0   SW V1, 0(V0)
183:                         
184:                         // Program control register, interrupt enable, and clear status
185:                         if (tmr_cntl & BTMR_COUNT_UP) {
BFD0576C  0024345E   LHU V0, 36(S8)
BFD05770      2D24   ANDI V0, V0, 0x4
BFD05772  000840E2   BEQZC V0, 0xBFD05786
186:                             pTMR->CONTROL |= BTMR_CNTL_COUNT_UP;  
BFD05776  0010FC5E   LW V0, 16(S8)
BFD0577A      6924   LW V0, 16(V0)
BFD0577C  00045062   ORI V1, V0, 4
BFD05780  0010FC5E   LW V0, 16(S8)
BFD05784      E9A4   SW V1, 16(V0)
187:                         }
188:                         if (tmr_cntl & BTMR_AUTO_RESTART) {
BFD05786  0024345E   LHU V0, 36(S8)
BFD0578A      2D26   ANDI V0, V0, 0x8
BFD0578C  000840E2   BEQZC V0, 0xBFD057A0
189:                             pTMR->CONTROL |= BTMR_CNTL_AUTO_RESTART; 
BFD05790  0010FC5E   LW V0, 16(S8)
BFD05794      6924   LW V0, 16(V0)
BFD05796  00085062   ORI V1, V0, 8
BFD0579A  0010FC5E   LW V0, 16(S8)
BFD0579E      E9A4   SW V1, 16(V0)
190:                         }
191:                         
192:                         if (tmr_cntl & BTMR_INT_EN) {
BFD057A0  0024345E   LHU V0, 36(S8)
BFD057A4      2D21   ANDI V0, V0, 0x1
BFD057A6      2D2D   ANDI V0, V0, 0xFF
BFD057A8  000840E2   BEQZC V0, 0xBFD057BC
193:                             pTMR->INTEN = 0x01u;    // enable first
BFD057AC  0010FC5E   LW V0, 16(S8)
BFD057B0      ED81   LI V1, 1
BFD057B2      89AC   SB V1, 12(V0)
194:                             pTMR->STATUS = 0x01u;   // clear status
BFD057B4  0010FC5E   LW V0, 16(S8)
BFD057B8      ED81   LI V1, 1
BFD057BA      89A8   SB V1, 8(V0)
195:                         }
196:                     }
197:                 }
BFD057BC      0FBE   MOVE SP, S8
BFD057BE      4BE7   LW RA, 28(SP)
BFD057C0      4BC6   LW S8, 24(SP)
BFD057C2      4C11   ADDIU SP, SP, 32
BFD057C4      459F   JR16 RA
BFD057C6      0C00   NOP
198:                 
199:                 /**
200:                  * btmr_ien - Enable specified timer's interrupt.
201:                  * 
202:                  * @author sworley 
203:                  * 
204:                  * @param tmr_id zero based timer ID.
205:                  * @param ien Non-zero enable interrupt in timer block, 0 
206:                  *            disable.
207:                  * @note Write 0 or 1 to timer's INTEN register.
208:                  */
209:                 void btmr_ien(uint8_t tmr_id, uint8_t ien)
210:                 {
BFD08330      4FF1   ADDIU SP, SP, -32
BFD08332      CBE7   SW RA, 28(SP)
BFD08334      CBC6   SW S8, 24(SP)
BFD08336      0FDD   MOVE S8, SP
BFD08338      0C64   MOVE V1, A0
BFD0833A      0C45   MOVE V0, A1
BFD0833C  0020187E   SB V1, 32(S8)
BFD08340  0024185E   SB V0, 36(S8)
211:                     BTMR_TypeDef * p;
212:                 
213:                     if (btmr_valid(tmr_id)) {
BFD08344  0020145E   LBU V0, 32(S8)
BFD08348      0C82   MOVE A0, V0
BFD0834A  4D2277E8   JALS btmr_valid
BFD0834C      4D22   ADDIU T1, T1, 1
BFD0834E      0C00   NOP
BFD08350  001540E2   BEQZC V0, 0xBFD0837E
214:                         p = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD08354  0020145E   LBU V0, 32(S8)
BFD08358      0C82   MOVE A0, V0
BFD0835A  4D3877E8   JALS btmr_get_hw_addr
BFD0835C      4D38   ADDIU T1, T1, -4
BFD0835E      0C00   NOP
BFD08360  0010F85E   SW V0, 16(S8)
215:                 
216:                         if (ien) {
BFD08364  0024145E   LBU V0, 36(S8)
BFD08368  000640E2   BEQZC V0, 0xBFD08378
217:                              p->INTEN = (BTMR_INTEN); 
BFD0836C  0010FC5E   LW V0, 16(S8)
BFD08370      ED81   LI V1, 1
BFD08372      89AC   SB V1, 12(V0)
BFD08374      CC04   B 0xBFD0837E
BFD08376      0C00   NOP
218:                         } else {
219:                              p->INTEN = (BTMR_INTDIS); 
BFD08378  0010FC5E   LW V0, 16(S8)
BFD0837A  882C0010   EXT ZERO, S0, 0, 18
BFD0837C      882C   SB S0, 12(V0)
220:                         }
221:                     }
222:                 }
BFD0837E      0FBE   MOVE SP, S8
BFD08380      4BE7   LW RA, 28(SP)
BFD08382      4BC6   LW S8, 24(SP)
BFD08384      4C11   ADDIU SP, SP, 32
BFD08386      459F   JR16 RA
BFD08388      0C00   NOP
223:                 
224:                 /**
225:                  * tmr_get_clr_ists - Read Timer interrupt status and clear if
226:                  * set. 
227:                  * 
228:                  * @author sworley 
229:                  * 
230:                  * @param tmr_id zero based timer ID.
231:                  * 
232:                  * @return uint8_t true (Timer interrupt status set) else false. 
233:                  * @note If timer interrupt status is set then clear it before 
234:                  *       returning.
235:                  */
236:                 uint8_t btmr_get_clr_ists(uint8_t tmr_id)
237:                 {
BFD0838C      4FF1   ADDIU SP, SP, -32
BFD0838E      CBE7   SW RA, 28(SP)
BFD08390      CBC6   SW S8, 24(SP)
BFD08392      0FDD   MOVE S8, SP
BFD08394      0C44   MOVE V0, A0
BFD08396  0020185E   SB V0, 32(S8)
238:                     BTMR_TypeDef * p;
239:                     uint8_t rc;
240:                 
241:                     rc = (MEC14XX_FALSE);
BFD0839A  0010181E   SB ZERO, 16(S8)
242:                     if (btmr_valid(tmr_id)) {
BFD0839E  0020145E   LBU V0, 32(S8)
BFD083A2      0C82   MOVE A0, V0
BFD083A4  4D2277E8   JALS btmr_valid
BFD083A6      4D22   ADDIU T1, T1, 1
BFD083A8      0C00   NOP
BFD083AA  001540E2   BEQZC V0, 0xBFD083D8
243:                         p = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD083AE  0020145E   LBU V0, 32(S8)
BFD083B2      0C82   MOVE A0, V0
BFD083B4  4D3877E8   JALS btmr_get_hw_addr
BFD083B6      4D38   ADDIU T1, T1, -4
BFD083B8      0C00   NOP
BFD083BA  0014F85E   SW V0, 20(S8)
244:                 
245:                         if ( p->STATUS ) {
BFD083BE  0014FC5E   LW V0, 20(S8)
BFD083C2      0928   LBU V0, 8(V0)
BFD083C4      2D2D   ANDI V0, V0, 0xFF
BFD083C6  000740E2   BEQZC V0, 0xBFD083D8
246:                             p->STATUS = (BTMR_STATUS_ACTIVE);
BFD083CA  0014FC5E   LW V0, 20(S8)
BFD083CE      ED81   LI V1, 1
BFD083D0      89A8   SB V1, 8(V0)
247:                             rc = true;
BFD083D2      ED01   LI V0, 1
BFD083D4  0010185E   SB V0, 16(S8)
248:                         }
249:                     }
250:                     return rc;
BFD083D8  0010145E   LBU V0, 16(S8)
251:                 }
BFD083DC      0FBE   MOVE SP, S8
BFD083DE      4BE7   LW RA, 28(SP)
BFD083E0      4BC6   LW S8, 24(SP)
BFD083E2      4C11   ADDIU SP, SP, 32
BFD083E4      459F   JR16 RA
BFD083E6      0C00   NOP
252:                 
253:                 /**
254:                  * btmr_reload - Force timer to reload counter from preload 
255:                  * register. 
256:                  * 
257:                  * @param tmr_id zero based timer ID. 
258:                  * @note Hardware will only reload counter if timer is running. 
259:                  */
260:                 void btmr_reload(uint8_t tmr_id)
261:                 {
BFD086B0      4FF1   ADDIU SP, SP, -32
BFD086B2      CBE7   SW RA, 28(SP)
BFD086B4      CBC6   SW S8, 24(SP)
BFD086B6      0FDD   MOVE S8, SP
BFD086B8      0C44   MOVE V0, A0
BFD086BA  0020185E   SB V0, 32(S8)
262:                     BTMR_TypeDef * p;
263:                 
264:                     if ( btmr_valid(tmr_id) ) {
BFD086BE  0020145E   LBU V0, 32(S8)
BFD086C2      0C82   MOVE A0, V0
BFD086C4  4D2277E8   JALS btmr_valid
BFD086C6      4D22   ADDIU T1, T1, 1
BFD086C8      0C00   NOP
BFD086CA  001640E2   BEQZC V0, 0xBFD086FA
265:                         p = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD086CE  0020145E   LBU V0, 32(S8)
BFD086D2      0C82   MOVE A0, V0
BFD086D4  4D3877E8   JALS btmr_get_hw_addr
BFD086D6      4D38   ADDIU T1, T1, -4
BFD086D8      0C00   NOP
BFD086DA  0010F85E   SW V0, 16(S8)
266:                 
267:                         if (p->CONTROL & BTMR_CNTL_START) {
BFD086DE  0010FC5E   LW V0, 16(S8)
BFD086E2      6924   LW V0, 16(V0)
BFD086E4      2D2A   ANDI V0, V0, 0x20
BFD086E6  000840E2   BEQZC V0, 0xBFD086FA
268:                             p->CONTROL |= BTMR_CNTL_RELOAD;
BFD086EA  0010FC5E   LW V0, 16(S8)
BFD086EE      6924   LW V0, 16(V0)
BFD086F0  00405062   ORI V1, V0, 64
BFD086F4  0010FC5E   LW V0, 16(S8)
BFD086F8      E9A4   SW V1, 16(V0)
269:                         }
270:                     }
271:                 }
BFD086FA      0FBE   MOVE SP, S8
BFD086FC      4BE7   LW RA, 28(SP)
BFD086FE      4BC6   LW S8, 24(SP)
BFD08700      4C11   ADDIU SP, SP, 32
BFD08702      459F   JR16 RA
BFD08704      0C00   NOP
272:                 
273:                 /**
274:                  * btmr_set_count - Program timer's counter register.
275:                  * 
276:                  * @author sworley 
277:                  * 
278:                  * @param tmr_id zero based timer ID
279:                  * @param count new counter value 
280:                  * @note Timer hardware may implement a 16-bit or 32-bit 
281:                  *       hardware counter. If the timer is 16-bit only the lower
282:                  *       16-bits of the count paramter are used.
283:                  */
284:                 void btmr_set_count(uint8_t tmr_id, uint32_t count)
285:                 {
BFD090FC      4FF1   ADDIU SP, SP, -32
BFD090FE      CBE7   SW RA, 28(SP)
BFD09100      CBC6   SW S8, 24(SP)
BFD09102      0FDD   MOVE S8, SP
BFD09104      0C44   MOVE V0, A0
BFD09106  0024F8BE   SW A1, 36(S8)
BFD0910A  0020185E   SB V0, 32(S8)
286:                     BTMR_TypeDef * p;
287:                 
288:                     if (btmr_valid(tmr_id)) {
BFD0910E  0020145E   LBU V0, 32(S8)
BFD09112      0C82   MOVE A0, V0
BFD09114  4D2277E8   JALS btmr_valid
BFD09116      4D22   ADDIU T1, T1, 1
BFD09118      0C00   NOP
BFD0911A  000D40E2   BEQZC V0, 0xBFD09138
289:                         p = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD0911E  0020145E   LBU V0, 32(S8)
BFD09122      0C82   MOVE A0, V0
BFD09124  4D3877E8   JALS btmr_get_hw_addr
BFD09126      4D38   ADDIU T1, T1, -4
BFD09128      0C00   NOP
BFD0912A  0010F85E   SW V0, 16(S8)
290:                 
291:                         p->COUNT = count;
BFD0912E  0010FC5E   LW V0, 16(S8)
BFD09132  0024FC7E   LW V1, 36(S8)
BFD09136      E9A0   SW V1, 0(V0)
292:                     }
293:                 }
BFD09138      0FBE   MOVE SP, S8
BFD0913A      4BE7   LW RA, 28(SP)
BFD0913C      4BC6   LW S8, 24(SP)
BFD0913E      4C11   ADDIU SP, SP, 32
BFD09140      459F   JR16 RA
BFD09142      0C00   NOP
294:                 
295:                 /**
296:                  * btmr_count - Return current value of timer's count register.
297:                  * 
298:                  * @author sworley 
299:                  * 
300:                  * @param tmr_id zero based timer ID.
301:                  * 
302:                  * @return uint32_t timer count may be 32 or 16 bits depending 
303:                  *         upon the hardware.  On MEC1322 Timers 0-3 are 16-bit
304:                  *         and Timers 4-5 are 32-bit.
305:                  */
306:                 uint32_t btmr_count(uint8_t tmr_id)
307:                 {
BFD08D40      4FF1   ADDIU SP, SP, -32
BFD08D42      CBE7   SW RA, 28(SP)
BFD08D44      CBC6   SW S8, 24(SP)
BFD08D46      0FDD   MOVE S8, SP
BFD08D48      0C44   MOVE V0, A0
BFD08D4A  0020185E   SB V0, 32(S8)
308:                     BTMR_TypeDef * p;
309:                     uint32_t cnt;
310:                     
311:                     cnt = 0ul;
BFD08D4E  0010F81E   SW ZERO, 16(S8)
312:                     if ( btmr_valid(tmr_id) ) {
BFD08D52  0020145E   LBU V0, 32(S8)
BFD08D56      0C82   MOVE A0, V0
BFD08D58  4D2277E8   JALS btmr_valid
BFD08D5A      4D22   ADDIU T1, T1, 1
BFD08D5C      0C00   NOP
BFD08D5E  000D40E2   BEQZC V0, 0xBFD08D7C
313:                         p = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD08D62  0020145E   LBU V0, 32(S8)
BFD08D66      0C82   MOVE A0, V0
BFD08D68  4D3877E8   JALS btmr_get_hw_addr
BFD08D6A      4D38   ADDIU T1, T1, -4
BFD08D6C      0C00   NOP
BFD08D6E  0014F85E   SW V0, 20(S8)
314:                         cnt = (uint32_t)(p->COUNT);
BFD08D72  0014FC5E   LW V0, 20(S8)
BFD08D76      6920   LW V0, 0(V0)
BFD08D78  0010F85E   SW V0, 16(S8)
315:                     }
316:                     
317:                     return cnt;
BFD08D7C  0010FC5E   LW V0, 16(S8)
318:                 }
BFD08D80      0FBE   MOVE SP, S8
BFD08D82      4BE7   LW RA, 28(SP)
BFD08D84      4BC6   LW S8, 24(SP)
BFD08D86      4C11   ADDIU SP, SP, 32
BFD08D88      459F   JR16 RA
BFD08D8A      0C00   NOP
319:                 
320:                 /**
321:                  * btmr_start - Start timer counting.
322:                  * 
323:                  * @author sworley 
324:                  * 
325:                  * @param tmr_id zero based timer ID.
326:                  */
327:                 void btmr_start(uint8_t btmr_id)
328:                 {
BFD08D8C      4FF1   ADDIU SP, SP, -32
BFD08D8E      CBE7   SW RA, 28(SP)
BFD08D90      CBC6   SW S8, 24(SP)
BFD08D92      0FDD   MOVE S8, SP
BFD08D94      0C44   MOVE V0, A0
BFD08D96  0020185E   SB V0, 32(S8)
329:                     BTMR_TypeDef * p;
330:                 
331:                     if ( btmr_valid(btmr_id) ) {
BFD08D9A  0020145E   LBU V0, 32(S8)
BFD08D9E      0C82   MOVE A0, V0
BFD08DA0  4D2277E8   JALS btmr_valid
BFD08DA2      4D22   ADDIU T1, T1, 1
BFD08DA4      0C00   NOP
BFD08DA6  001040E2   BEQZC V0, 0xBFD08DCA
332:                         p = (BTMR_TypeDef *)btmr_get_hw_addr(btmr_id);
BFD08DAA  0020145E   LBU V0, 32(S8)
BFD08DAE      0C82   MOVE A0, V0
BFD08DB0  4D3877E8   JALS btmr_get_hw_addr
BFD08DB2      4D38   ADDIU T1, T1, -4
BFD08DB4      0C00   NOP
BFD08DB6  0010F85E   SW V0, 16(S8)
333:                         p->CONTROL |= BTMR_CNTL_START;
BFD08DBA  0010FC5E   LW V0, 16(S8)
BFD08DBE      6924   LW V0, 16(V0)
BFD08DC0  00205062   ORI V1, V0, 32
BFD08DC4  0010FC5E   LW V0, 16(S8)
BFD08DC8      E9A4   SW V1, 16(V0)
334:                     }
335:                 }
BFD08DCA      0FBE   MOVE SP, S8
BFD08DCC      4BE7   LW RA, 28(SP)
BFD08DCE      4BC6   LW S8, 24(SP)
BFD08DD0      4C11   ADDIU SP, SP, 32
BFD08DD2      459F   JR16 RA
BFD08DD4      0C00   NOP
336:                 
337:                 /**
338:                  * btmr_stop - Stop timer.
339:                  * 
340:                  * @author sworley 
341:                  * 
342:                  * @param tmr_id zero based timer ID. 
343:                  * @note When a stopped timer is started again it will reload 
344:                  *       the count register from preload value.
345:                  */
346:                 void btmr_stop(uint8_t tmr_id)
347:                 {
BFD08DD8      4FF1   ADDIU SP, SP, -32
BFD08DDA      CBE7   SW RA, 28(SP)
BFD08DDC      CBC6   SW S8, 24(SP)
BFD08DDE      0FDD   MOVE S8, SP
BFD08DE0      0C44   MOVE V0, A0
BFD08DE2  0020185E   SB V0, 32(S8)
348:                     BTMR_TypeDef * p;
349:                 
350:                     if (btmr_valid(tmr_id)) {
BFD08DE6  0020145E   LBU V0, 32(S8)
BFD08DEA      0C82   MOVE A0, V0
BFD08DEC  4D2277E8   JALS btmr_valid
BFD08DEE      4D22   ADDIU T1, T1, 1
BFD08DF0      0C00   NOP
BFD08DF2  001140E2   BEQZC V0, 0xBFD08E18
351:                         p = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD08DF6  0020145E   LBU V0, 32(S8)
BFD08DFA      0C82   MOVE A0, V0
BFD08DFC  4D3877E8   JALS btmr_get_hw_addr
BFD08DFE      4D38   ADDIU T1, T1, -4
BFD08E00      0C00   NOP
BFD08E02  0010F85E   SW V0, 16(S8)
352:                         p->CONTROL &= ~(BTMR_CNTL_START);
BFD08E06  0010FC5E   LW V0, 16(S8)
BFD08E0A      69A4   LW V1, 16(V0)
BFD08E0C  FFDF3040   ADDIU V0, ZERO, -33
BFD08E0E  449AFFDF   LW S8, 17562(RA)
BFD08E10      449A   AND16 V1, V0
BFD08E12  0010FC5E   LW V0, 16(S8)
BFD08E16      E9A4   SW V1, 16(V0)
353:                     }
354:                 }
BFD08E18      0FBE   MOVE SP, S8
BFD08E1A      4BE7   LW RA, 28(SP)
BFD08E1C      4BC6   LW S8, 24(SP)
BFD08E1E      4C11   ADDIU SP, SP, 32
BFD08E20      459F   JR16 RA
BFD08E22      0C00   NOP
355:                 
356:                 /**
357:                  * btmr_is_stopped - Return state of timer's START bit.
358:                  * 
359:                  * @author sworley 
360:                  * 
361:                  * @param tmr_id zero based timer ID.
362:                  * 
363:                  * @return uint8_t false(timer not started), true(timer started)
364:                  */
365:                 uint8_t btmr_is_stopped(uint8_t tmr_id)
366:                 {
BFD083E8      4FF1   ADDIU SP, SP, -32
BFD083EA      CBE7   SW RA, 28(SP)
BFD083EC      CBC6   SW S8, 24(SP)
BFD083EE      0FDD   MOVE S8, SP
BFD083F0      0C44   MOVE V0, A0
BFD083F2  0020185E   SB V0, 32(S8)
367:                     BTMR_TypeDef * p;
368:                     uint8_t rc;
369:                     
370:                     rc = (MEC14XX_TRUE);
BFD083F6      ED01   LI V0, 1
BFD083F8  0010185E   SB V0, 16(S8)
371:                     if (btmr_valid(tmr_id)) {
BFD083FC  0020145E   LBU V0, 32(S8)
BFD08400      0C82   MOVE A0, V0
BFD08402  4D2277E8   JALS btmr_valid
BFD08404      4D22   ADDIU T1, T1, 1
BFD08406      0C00   NOP
BFD08408  001340E2   BEQZC V0, 0xBFD08432
372:                         rc = (MEC14XX_FALSE);
BFD0840C  0010181E   SB ZERO, 16(S8)
373:                         p = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD08410  0020145E   LBU V0, 32(S8)
BFD08414      0C82   MOVE A0, V0
BFD08416  4D3877E8   JALS btmr_get_hw_addr
BFD08418      4D38   ADDIU T1, T1, -4
BFD0841A      0C00   NOP
BFD0841C  0014F85E   SW V0, 20(S8)
374:                         if ((p->CONTROL & BTMR_CNTL_START) == 0) {
BFD08420  0014FC5E   LW V0, 20(S8)
BFD08424      6924   LW V0, 16(V0)
BFD08426      2D2A   ANDI V0, V0, 0x20
BFD08428  000340A2   BNEZC V0, 0xBFD08432
375:                             rc = (MEC14XX_TRUE);
BFD0842C      ED01   LI V0, 1
BFD0842E  0010185E   SB V0, 16(S8)
376:                         }
377:                     }
378:                     return rc;
BFD08432  0010145E   LBU V0, 16(S8)
379:                 }
BFD08436      0FBE   MOVE SP, S8
BFD08438      4BE7   LW RA, 28(SP)
BFD0843A      4BC6   LW S8, 24(SP)
BFD0843C      4C11   ADDIU SP, SP, 32
BFD0843E      459F   JR16 RA
BFD08440      0C00   NOP
380:                 
381:                 
382:                 /**
383:                  * btmr_halt - Halt timer counting with no reload on unhalt. 
384:                  * 
385:                  * @author sworley 
386:                  * 
387:                  * @param tmr_id zero based timer ID. 
388:                  * @note A halted timer will not reload the count register when 
389:                  *       unhalted, it will continue counting from the current
390:                  *       count value.
391:                  */
392:                 void btmr_halt(uint8_t tmr_id)
393:                 {
BFD08E24      4FF1   ADDIU SP, SP, -32
BFD08E26      CBE7   SW RA, 28(SP)
BFD08E28      CBC6   SW S8, 24(SP)
BFD08E2A      0FDD   MOVE S8, SP
BFD08E2C      0C44   MOVE V0, A0
BFD08E2E  0020185E   SB V0, 32(S8)
394:                     BTMR_TypeDef * p;
395:                 
396:                     if ( btmr_valid(tmr_id) ) {
BFD08E32  0020145E   LBU V0, 32(S8)
BFD08E36      0C82   MOVE A0, V0
BFD08E38  4D2277E8   JALS btmr_valid
BFD08E3A      4D22   ADDIU T1, T1, 1
BFD08E3C      0C00   NOP
BFD08E3E  001040E2   BEQZC V0, 0xBFD08E62
397:                         p = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD08E42  0020145E   LBU V0, 32(S8)
BFD08E46      0C82   MOVE A0, V0
BFD08E48  4D3877E8   JALS btmr_get_hw_addr
BFD08E4A      4D38   ADDIU T1, T1, -4
BFD08E4C      0C00   NOP
BFD08E4E  0010F85E   SW V0, 16(S8)
398:                         p->CONTROL |= (BTMR_CNTL_HALT);
BFD08E52  0010FC5E   LW V0, 16(S8)
BFD08E56      6924   LW V0, 16(V0)
BFD08E58  00805062   ORI V1, V0, 128
BFD08E5C  0010FC5E   LW V0, 16(S8)
BFD08E60      E9A4   SW V1, 16(V0)
399:                     }
400:                 }
BFD08E62      0FBE   MOVE SP, S8
BFD08E64      4BE7   LW RA, 28(SP)
BFD08E66      4BC6   LW S8, 24(SP)
BFD08E68      4C11   ADDIU SP, SP, 32
BFD08E6A      459F   JR16 RA
BFD08E6C      0C00   NOP
401:                 
402:                 
403:                 /**
404:                  * btmr_unhalt - Unhalt timer counting.
405:                  * 
406:                  * @author sworley 
407:                  * 
408:                  * @param tmr_id zero based timer ID.
409:                  */
410:                 void btmr_unhalt(uint8_t tmr_id)
411:                 {
BFD08E70      4FF1   ADDIU SP, SP, -32
BFD08E72      CBE7   SW RA, 28(SP)
BFD08E74      CBC6   SW S8, 24(SP)
BFD08E76      0FDD   MOVE S8, SP
BFD08E78      0C44   MOVE V0, A0
BFD08E7A  0020185E   SB V0, 32(S8)
412:                     BTMR_TypeDef * p;
413:                 
414:                     if ( btmr_valid(tmr_id) ) {
BFD08E7E  0020145E   LBU V0, 32(S8)
BFD08E82      0C82   MOVE A0, V0
BFD08E84  4D2277E8   JALS btmr_valid
BFD08E86      4D22   ADDIU T1, T1, 1
BFD08E88      0C00   NOP
BFD08E8A  001140E2   BEQZC V0, 0xBFD08EB0
415:                         p = (BTMR_TypeDef *)btmr_get_hw_addr(tmr_id);
BFD08E8E  0020145E   LBU V0, 32(S8)
BFD08E92      0C82   MOVE A0, V0
BFD08E94  4D3877E8   JALS btmr_get_hw_addr
BFD08E96      4D38   ADDIU T1, T1, -4
BFD08E98      0C00   NOP
BFD08E9A  0010F85E   SW V0, 16(S8)
416:                         p->CONTROL &= ~(BTMR_CNTL_HALT);
BFD08E9E  0010FC5E   LW V0, 16(S8)
BFD08EA2      69A4   LW V1, 16(V0)
BFD08EA4  FF7F3040   ADDIU V0, ZERO, -129
BFD08EA6  449AFF7F   LW K1, 17562(RA)
BFD08EA8      449A   AND16 V1, V0
BFD08EAA  0010FC5E   LW V0, 16(S8)
BFD08EAE      E9A4   SW V1, 16(V0)
417:                     }
418:                 }
BFD08EB0      0FBE   MOVE SP, S8
BFD08EB2      4BE7   LW RA, 28(SP)
BFD08EB4      4BC6   LW S8, 24(SP)
BFD08EB6      4C11   ADDIU SP, SP, 32
BFD08EB8      459F   JR16 RA
BFD08EBA      0C00   NOP
419:                 
420:                 
421:                 /* end mec14xx_timers.c */
422:                 /**   @}
423:                  */
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/mec14xx_tfdp.c  ---------
1:                   /*****************************************************************************
2:                   *  2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file mec14xx_tfdp.c
22:                   *MEC14xx Trace FIFO Data Port hardware access
23:                   */
24:                  /** @defgroup MEC14xx Peripherals TFDP
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_pcr.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #ifdef ENABLE_TFDP_TRACE
37:                  
38:                  #undef TFDP_PIN_1
39:                  #undef TFDP_PIN_2
40:                  
41:                  
42:                  #define TFDP_PIN_1 (GPIO_0116_ID)   // Func1 PullUp enabled
43:                  #define TFDP_PIN_2 (GPIO_0117_ID)   // Func1 PullUp enabled
44:                  
45:                  
46:                  
47:                  static void tfdp_xmit_header(uint16_t nbr)
48:                  {
BFD0906C      4FB0   ADDIU SP, SP, -8
BFD0906E      CBC1   SW S8, 4(SP)
BFD09070      0FDD   MOVE S8, SP
BFD09072      0C44   MOVE V0, A0
BFD09074  0008385E   SH V0, 8(S8)
49:                      TFDP->DATA = TFDP_FRAME_START;
BFD09078  A00041A2   LUI V0, 0xA000
BFD0907C  8C005042   ORI V0, V0, -29696
BFD0907E      8C00   BEQZ S0, 0xBFD09080
BFD09080  FFFD3060   ADDIU V1, ZERO, -3
BFD09082  89A0FFFD   LW RA, -30304(SP)
BFD09084      89A0   SB V1, 0(V0)
50:                      TFDP_DELAY();
51:                  
52:                      TFDP->DATA = (uint8_t)nbr;
BFD09086  A00041A2   LUI V0, 0xA000
BFD0908A  8C005042   ORI V0, V0, -29696
BFD0908C      8C00   BEQZ S0, 0xBFD0908E
BFD0908E  0008347E   LHU V1, 8(S8)
BFD09092      2DBD   ANDI V1, V1, 0xFF
BFD09094      89A0   SB V1, 0(V0)
53:                      TFDP_DELAY();
54:                      TFDP->DATA = (uint8_t)(nbr >> 8);
BFD09096  A00041A2   LUI V0, 0xA000
BFD0909A  8C005042   ORI V0, V0, -29696
BFD0909C      8C00   BEQZ S0, 0xBFD0909E
BFD0909E  0008347E   LHU V1, 8(S8)
BFD090A2      25B1   SRL V1, V1, 8
BFD090A4      2DBF   ANDI V1, V1, 0xFFFF
BFD090A6      2DBD   ANDI V1, V1, 0xFF
BFD090A8      89A0   SB V1, 0(V0)
55:                      TFDP_DELAY();
56:                  }
BFD090AA      0FBE   MOVE SP, S8
BFD090AC      4BC1   LW S8, 4(SP)
BFD090AE      4C05   ADDIU SP, SP, 8
BFD090B0      459F   JR16 RA
BFD090B2      0C00   NOP
57:                  
58:                  
59:                  static void tfdp_xmit_hword(uint16_t hword)
60:                  {
BFD09648      4FB0   ADDIU SP, SP, -8
BFD0964A      CBC1   SW S8, 4(SP)
BFD0964C      0FDD   MOVE S8, SP
BFD0964E      0C44   MOVE V0, A0
BFD09650  0008385E   SH V0, 8(S8)
61:                      TFDP->DATA = (uint8_t)hword;
BFD09654  A00041A2   LUI V0, 0xA000
BFD09658  8C005042   ORI V0, V0, -29696
BFD0965A      8C00   BEQZ S0, 0xBFD0965C
BFD0965C  0008347E   LHU V1, 8(S8)
BFD09660      2DBD   ANDI V1, V1, 0xFF
BFD09662      89A0   SB V1, 0(V0)
62:                      TFDP_DELAY();
63:                      TFDP->DATA = (uint8_t)(hword >> 8);
BFD09664  A00041A2   LUI V0, 0xA000
BFD09668  8C005042   ORI V0, V0, -29696
BFD0966A      8C00   BEQZ S0, 0xBFD0966C
BFD0966C  0008347E   LHU V1, 8(S8)
BFD09670      25B1   SRL V1, V1, 8
BFD09672      2DBF   ANDI V1, V1, 0xFFFF
BFD09674      2DBD   ANDI V1, V1, 0xFF
BFD09676      89A0   SB V1, 0(V0)
64:                      TFDP_DELAY();
65:                  }
BFD09678      0FBE   MOVE SP, S8
BFD0967A      4BC1   LW S8, 4(SP)
BFD0967C      4C05   ADDIU SP, SP, 8
BFD0967E      459F   JR16 RA
BFD09680      0C00   NOP
66:                  
67:                  
68:                  static void tfdp_xmit_word(uint32_t word)
69:                  {
BFD08CF4      4FF9   ADDIU SP, SP, -16
BFD08CF6      CBC3   SW S8, 12(SP)
BFD08CF8      0FDD   MOVE S8, SP
BFD08CFA  0010F89E   SW A0, 16(S8)
70:                      uint8_t i;
71:                  
72:                      for (i = 0u; i < 4; i++) {
BFD08CFE  0000181E   SB ZERO, 0(S8)
BFD08D02      CC13   B 0xBFD08D2A
BFD08D04      0C00   NOP
BFD08D20  0000145E   LBU V0, 0(S8)
BFD08D24      6D20   ADDIU V0, V0, 1
BFD08D26  0000185E   SB V0, 0(S8)
BFD08D2A  0000145E   LBU V0, 0(S8)
BFD08D2E  0004B042   SLTIU V0, V0, 4
BFD08D32  FFE840A2   BNEZC V0, 0xBFD08D06
BFD08D34  0FBEFFE8   LW RA, 4030(T0)
73:                          TFDP->DATA = (uint8_t)word;
BFD08D06  A00041A2   LUI V0, 0xA000
BFD08D0A  8C005042   ORI V0, V0, -29696
BFD08D0C      8C00   BEQZ S0, 0xBFD08D0E
BFD08D0E  0010FC7E   LW V1, 16(S8)
BFD08D12      2DBD   ANDI V1, V1, 0xFF
BFD08D14      89A0   SB V1, 0(V0)
74:                          word >>= 8; 
BFD08D16  0010FC5E   LW V0, 16(S8)
BFD08D1A      2521   SRL V0, V0, 8
BFD08D1C  0010F85E   SW V0, 16(S8)
75:                          TFDP_DELAY();
76:                      }
77:                  }
BFD08D36      0FBE   MOVE SP, S8
BFD08D38      4BC3   LW S8, 12(SP)
BFD08D3A      4C09   ADDIU SP, SP, 16
BFD08D3C      459F   JR16 RA
BFD08D3E      0C00   NOP
78:                  
79:                  
80:                  /**
81:                   * tfdp_sleep_en - Gate clocks On/Off to TFDP block when idle
82:                   * 
83:                   * @author C21969 (2/4/2014)
84:                   * 
85:                   * @param sleep_en (1=Gate clocks when idle), (0=Do not gate 
86:                   *                 clocks when idle)
87:                   */
88:                  void tfdp_sleep_en(uint8_t sleep_en)
89:                  {
BFD088AC      4FB0   ADDIU SP, SP, -8
BFD088AE      CBC1   SW S8, 4(SP)
BFD088B0      0FDD   MOVE S8, SP
BFD088B2      0C44   MOVE V0, A0
BFD088B4  0008185E   SB V0, 8(S8)
90:                      if ( sleep_en ) {
BFD088B8  0008145E   LBU V0, 8(S8)
BFD088BC  000E40E2   BEQZC V0, 0xBFD088DC
91:                          PCR->EC_SLEEP_EN |= (PCR_EC_TFDP_SLP_CLK);
BFD088C0  A00841A2   LUI V0, 0xA008
BFD088C4  01005042   ORI V0, V0, 256
BFD088C8  A00841A3   LUI V1, 0xA008
BFD088CC  01005063   ORI V1, V1, 256
BFD088D0      69B2   LW V1, 8(V1)
BFD088D2  00805063   ORI V1, V1, 128
BFD088D6      E9A2   SW V1, 8(V0)
BFD088D8      CC0E   B 0xBFD088F6
BFD088DA      0C00   NOP
92:                      } else {
93:                          PCR->EC_SLEEP_EN &= ~(PCR_EC_TFDP_SLP_CLK);
BFD088DC  A00841A2   LUI V0, 0xA008
BFD088E0  01005042   ORI V0, V0, 256
BFD088E4  A00841A3   LUI V1, 0xA008
BFD088E8  01005063   ORI V1, V1, 256
BFD088EC      6A32   LW A0, 8(V1)
BFD088EE  FF7F3060   ADDIU V1, ZERO, -129
BFD088F0  449CFF7F   LW K1, 17564(RA)
BFD088F2      449C   AND16 V1, A0
BFD088F4      E9A2   SW V1, 8(V0)
94:                      }
95:                  }
BFD088F6      0FBE   MOVE SP, S8
BFD088F8      4BC1   LW S8, 4(SP)
BFD088FA      4C05   ADDIU SP, SP, 8
BFD088FC      459F   JR16 RA
BFD088FE      0C00   NOP
96:                  
97:                  
98:                  /**
99:                   * tfdp_enable - Init Trace FIFO Data Port
100:                  * @param boolean true=enable TFDP, false=disable TFDP 
101:                  * @param boolean true=change TFDP pin configuration. 
102:                  * If TFDP is enabled then GPIO103/104 set to Alt. Func. 1 
103:                  * Else GPIO103/104 set to GPIO input, internal PU enabled. 
104:                  * @note - 
105:                  */
106:                 void tfdp_enable(uint8_t en, uint8_t pin_cfg)
107:                 {
BFD032C4      4FF9   ADDIU SP, SP, -16
BFD032C6      CBC3   SW S8, 12(SP)
BFD032C8      0FDD   MOVE S8, SP
BFD032CA      0C64   MOVE V1, A0
BFD032CC      0C45   MOVE V0, A1
BFD032CE  0010187E   SB V1, 16(S8)
BFD032D2  0014185E   SB V0, 20(S8)
108:                     uint32_t delay;
109:                 
110:                     if (en) {
BFD032D6  0010145E   LBU V0, 16(S8)
BFD032DA  007240E2   BEQZC V0, 0xBFD033C2
111:                         
112:                         if (pin_cfg) {
BFD032DE  0014145E   LBU V0, 20(S8)
BFD032E2  006740E2   BEQZC V0, 0xBFD033B4
113:                             // Input with AltOut=1 to drive high when switched to output
114:                             GPIO_CTRL->REG[TFDP_PIN_1].w = (1ul << 16);
BFD032E6  A00841A2   LUI V0, 0xA008
BFD032EA  10005042   ORI V0, V0, 4096
BFD032EC  41A31000   ADDI ZERO, ZERO, 16803
BFD032EE  000141A3   LUI V1, 0x1
BFD032F2  0138F862   SW V1, 312(V0)
115:                             GPIO_CTRL->REG[TFDP_PIN_2].w = (1ul << 16);
BFD032F6  A00841A2   LUI V0, 0xA008
BFD032FA  10005042   ORI V0, V0, 4096
BFD032FC  41A31000   ADDI ZERO, ZERO, 16803
BFD032FE  000141A3   LUI V1, 0x1
BFD03302  013CF862   SW V1, 316(V0)
BFD03304  3040013C   SRL T1, GP, 6
116:                 
117:                             delay = 128;
BFD03306  00803040   ADDIU V0, ZERO, 128
BFD0330A  0000F85E   SW V0, 0(S8)
118:                             while ( delay-- )
BFD0330E      CC03   B 0xBFD03316
BFD03310      0C00   NOP
BFD03316  0000FC5E   LW V0, 0(S8)
BFD03318  00400000   SRL ZERO, ZERO, 0
BFD0331A  13900040   SLTU V0, ZERO, V0
BFD0331C  2D2D1390   ADDI GP, S0, 11565
BFD0331E      2D2D   ANDI V0, V0, 0xFF
BFD03320  0000FC7E   LW V1, 0(S8)
BFD03324      6DBE   ADDIU V1, V1, -1
BFD03326  0000F87E   SW V1, 0(S8)
BFD0332A  FFF240A2   BNEZC V0, 0xBFD03312
BFD0332C  41A2FFF2   LW RA, 16802(S2)
119:                             {
120:                                 CPU_NOP();
BFD03312  08000000   SSNOP
BFD03314      0800   LBU S0, 0(S0)
121:                             }
122:                 
123:                             // GPIO Output enabled (drive based on above settings)
124:                             GPIO_CTRL->REG[TFDP_PIN_1].w |= (1ul << 9);
BFD0332E  A00841A2   LUI V0, 0xA008
BFD03332  10005042   ORI V0, V0, 4096
BFD03334  41A31000   ADDI ZERO, ZERO, 16803
BFD03336  A00841A3   LUI V1, 0xA008
BFD0333A  10005063   ORI V1, V1, 4096
BFD0333C  FC631000   ADDI ZERO, ZERO, -925
BFD0333E  0138FC63   LW V1, 312(V1)
BFD03342  02005063   ORI V1, V1, 512
BFD03346  0138F862   SW V1, 312(V0)
125:                             GPIO_CTRL->REG[TFDP_PIN_2].w |= (1ul << 9);
BFD0334A  A00841A2   LUI V0, 0xA008
BFD0334E  10005042   ORI V0, V0, 4096
BFD03350  41A31000   ADDI ZERO, ZERO, 16803
BFD03352  A00841A3   LUI V1, 0xA008
BFD03356  10005063   ORI V1, V1, 4096
BFD03358  FC631000   ADDI ZERO, ZERO, -925
BFD0335A  013CFC63   LW V1, 316(V1)
BFD0335E  02005063   ORI V1, V1, 512
BFD03362  013CF862   SW V1, 316(V0)
BFD03364  3040013C   SRL T1, GP, 6
126:                 
127:                             delay = 128;
BFD03366  00803040   ADDIU V0, ZERO, 128
128:                             while ( delay-- )
BFD0336A      CC04   B 0xBFD03374
BFD0336C  0000F85E   SW V0, 0(S8)
BFD0336E  00000000   NOP
BFD03374  0000FC5E   LW V0, 0(S8)
BFD03376  00400000   SRL ZERO, ZERO, 0
BFD03378  13900040   SLTU V0, ZERO, V0
BFD0337A  2D2D1390   ADDI GP, S0, 11565
BFD0337C      2D2D   ANDI V0, V0, 0xFF
BFD0337E  0000FC7E   LW V1, 0(S8)
BFD03382      6DBE   ADDIU V1, V1, -1
BFD03384  0000F87E   SW V1, 0(S8)
BFD03388  FFF240A2   BNEZC V0, 0xBFD03370
BFD0338A  41A2FFF2   LW RA, 16802(S2)
129:                             {
130:                                 CPU_NOP();
BFD03370  08000000   SSNOP
BFD03372      0800   LBU S0, 0(S0)
131:                             }
132:                 
133:                             // Switch to Function 1 (TFDP mode b[13:12]=01b)
134:                             GPIO_CTRL->REG[TFDP_PIN_1].w = (1ul << 16) + (1ul << 12);
BFD0338C  A00841A2   LUI V0, 0xA008
BFD03390  10005042   ORI V0, V0, 4096
BFD03392  41A31000   ADDI ZERO, ZERO, 16803
BFD03394  000141A3   LUI V1, 0x1
BFD03398  10005063   ORI V1, V1, 4096
BFD0339A  F8621000   ADDI ZERO, ZERO, -1950
BFD0339C  0138F862   SW V1, 312(V0)
135:                             GPIO_CTRL->REG[TFDP_PIN_2].w = (1ul << 16) + (1ul << 12);
BFD033A0  A00841A2   LUI V0, 0xA008
BFD033A4  10005042   ORI V0, V0, 4096
BFD033A6  41A31000   ADDI ZERO, ZERO, 16803
BFD033A8  000141A3   LUI V1, 0x1
BFD033AC  10005063   ORI V1, V1, 4096
BFD033AE  F8621000   ADDI ZERO, ZERO, -1950
BFD033B0  013CF862   SW V1, 316(V0)
136:                 
137:                         }
138:                         /* b[0]=1(Enable)
139:                          * b[1]=0(Shift data out on rising edge) 
140:                          * b[3:2]=00b TFDP shift clocks = AHB_CLK/2
141:                          * b[6:4]=000b 1 clock inter-packet delay
142:                          */
143:                         TFDP->CONTROL = 0x01u;
BFD033B4  A00041A2   LUI V0, 0xA000
BFD033B8  8C005042   ORI V0, V0, -29696
BFD033BA      8C00   BEQZ S0, 0xBFD033BC
BFD033BC      ED81   LI V1, 1
BFD033BE      CC16   B 0xBFD033EC
BFD033C0      89A4   SB V1, 4(V0)
144:                 
145:                     } 
146:                     else
147:                     {
148:                         TFDP->CONTROL = 0x00u;
BFD033C2  A00041A2   LUI V0, 0xA000
BFD033C6  8C005042   ORI V0, V0, -29696
BFD033C8      8C00   BEQZ S0, 0xBFD033CA
BFD033CA      8824   SB S0, 4(V0)
149:                         if (pin_cfg) 
BFD033CC  0014145E   LBU V0, 20(S8)
BFD033D0  000C40E2   BEQZC V0, 0xBFD033EC
150:                         { /* Set to POR value (tri-stated input) */
151:                             GPIO_CTRL->REG[TFDP_PIN_1].w = 0;
BFD033D4  A00841A2   LUI V0, 0xA008
BFD033D8  10005042   ORI V0, V0, 4096
BFD033DA  F8021000   ADDI ZERO, ZERO, -2046
BFD033DC  0138F802   SW ZERO, 312(V0)
152:                             GPIO_CTRL->REG[TFDP_PIN_2].w = 0;
BFD033E0  A00841A2   LUI V0, 0xA008
BFD033E4  10005042   ORI V0, V0, 4096
BFD033E6  F8021000   ADDI ZERO, ZERO, -2046
BFD033E8  013CF802   SW ZERO, 316(V0)
153:                         }
154:                     }
155:                 } // end tfdp_enable()
BFD033EC      0FBE   MOVE SP, S8
BFD033EE      4BC3   LW S8, 12(SP)
BFD033F0      459F   JR16 RA
BFD033F2      4C09   ADDIU SP, SP, 16
156:                 
157:                 
158:                 /**
159:                  * TFDPTrace0 - TRACE0: transmit 16-bit trace number lsb first 
160:                  * over TFDP. 
161:                  * 
162:                  * @author sworley 
163:                  * 
164:                  * @param nbr 16-bit trace number 
165:                  * @param b unused
166:                  * 
167:                  * @return uint8_t always TRUE 
168:                  * @note Function implements critical section. 
169:                  * Uses tool kit __disable_irq()/__enable_irq() pair which may use 
170:                  * priviledged Cortex-Mx instructions. 
171:                  */
172:                 void TFDPTrace0 ( uint16_t nbr, uint8_t b )
173:                 {
BFD09A18      4FF5   ADDIU SP, SP, -24
BFD09A1A      CBE5   SW RA, 20(SP)
BFD09A1C      CBC4   SW S8, 16(SP)
BFD09A1E      0FDD   MOVE S8, SP
BFD09A20      0C64   MOVE V1, A0
BFD09A22      0C45   MOVE V0, A1
BFD09A24  0018387E   SH V1, 24(S8)
BFD09A28  001C185E   SB V0, 28(S8)
174:                 #ifdef ENABLE_TRACE_MASK_IRQ
175:                     uint32_t isave;
176:                 
177:                     isave = mips32r2_dis_intr();
178:                 #endif
179:                 
180:                     (void)b;
181:                     tfdp_xmit_header(nbr);
BFD09A2C  0018345E   LHU V0, 24(S8)
BFD09A30      0C82   MOVE A0, V0
BFD09A32  483677E8   JALS tfdp_xmit_header
BFD09A34      4836   LW AT, 88(SP)
BFD09A36      0C00   NOP
182:                 
183:                 #ifdef ENABLE_TRACE_MASK_IRQ
184:                      mips32r2_restore_intr(isave);
185:                 #endif
186:                 }
BFD09A38      0FBE   MOVE SP, S8
BFD09A3A      4BE5   LW RA, 20(SP)
BFD09A3C      4BC4   LW S8, 16(SP)
BFD09A3E      4C0D   ADDIU SP, SP, 24
BFD09A40      459F   JR16 RA
BFD09A42      0C00   NOP
187:                 
188:                 
189:                 /**
190:                  * TRDPTrace1 - TRACE1: transmit 16-bit trace number lsb first 
191:                  * and 16-bit data lsb first over TFDP. 
192:                  * 
193:                  * @author sworley 
194:                  * 
195:                  * @param nbr 16-bit trace number 
196:                  * @param b unused 
197:                  * @param uint32_t p1 16-bit data1 in b[15:0]
198:                  * 
199:                  * @return uint8_t always TRUE 
200:                  * @note Function implements critical section. 
201:                  * Uses tool kit __disable_irq()/__enable_irq() pair which may use 
202:                  * priviledged Cortex-Mx instructions. 
203:                  */
204:                 void TFDPTrace1 ( uint16_t nbr, uint8_t b, uint32_t p1 )
205:                 {
BFD094A0      4FF5   ADDIU SP, SP, -24
BFD094A2      CBE5   SW RA, 20(SP)
BFD094A4      CBC4   SW S8, 16(SP)
BFD094A6      0FDD   MOVE S8, SP
BFD094A8      0C64   MOVE V1, A0
BFD094AA      0C45   MOVE V0, A1
BFD094AC  0020F8DE   SW A2, 32(S8)
BFD094B0  0018387E   SH V1, 24(S8)
BFD094B4  001C185E   SB V0, 28(S8)
206:                 #ifdef ENABLE_TRACE_MASK_IRQ
207:                     uint32_t isave;
208:                     
209:                     isave = mips32r2_dis_intr();
210:                 #endif
211:                     (void)b;
212:                     tfdp_xmit_header(nbr);
BFD094B8  0018345E   LHU V0, 24(S8)
BFD094BC      0C82   MOVE A0, V0
BFD094BE  483677E8   JALS tfdp_xmit_header
BFD094C0      4836   LW AT, 88(SP)
BFD094C2      0C00   NOP
213:                     tfdp_xmit_hword(p1);
BFD094C4  0020FC5E   LW V0, 32(S8)
BFD094C8      2D2F   ANDI V0, V0, 0xFFFF
BFD094CA      0C82   MOVE A0, V0
BFD094CC  4B2477E8   JALS tfdp_xmit_hword
BFD094CE      4B24   LW T9, 16(SP)
BFD094D0      0C00   NOP
214:                 
215:                 #ifdef ENABLE_TRACE_MASK_IRQ
216:                     mips32r2_restore_intr(isave);
217:                 #endif
218:                 }
BFD094D2      0FBE   MOVE SP, S8
BFD094D4      4BE5   LW RA, 20(SP)
BFD094D6      4BC4   LW S8, 16(SP)
BFD094D8      4C0D   ADDIU SP, SP, 24
BFD094DA      459F   JR16 RA
BFD094DC      0C00   NOP
219:                 
220:                 
221:                 /**
222:                  * TFDPTrace2 - TRACE2: transmit 16-bit trace number lsb first 
223:                  * and two 16-bit data parameters lsb first over TFDP.
224:                  * 
225:                  * @author sworley 
226:                  * 
227:                  * @param nbr trace number
228:                  * @param b unused
229:                  * @param uint32_t p1 16-bit data1 in b[15:0]
230:                  * @param uint32_t p2 16-bit data2 in b[15:0]
231:                  * 
232:                  * @return uint8_t always TRUE 
233:                  * @note Uses tool kit functions to save/disable/restore 
234:                  *       interrupts for critical section. These may use
235:                  *       priviledged instructions.
236:                  */
237:                 void TFDPTrace2 ( uint16_t nbr, uint8_t b, uint32_t p1, uint32_t p2 )
238:                 {
BFD08A44      4FF5   ADDIU SP, SP, -24
BFD08A46      CBE5   SW RA, 20(SP)
BFD08A48      CBC4   SW S8, 16(SP)
BFD08A4A      0FDD   MOVE S8, SP
BFD08A4C      0C64   MOVE V1, A0
BFD08A4E      0C45   MOVE V0, A1
BFD08A50  0020F8DE   SW A2, 32(S8)
BFD08A54  0024F8FE   SW A3, 36(S8)
BFD08A58  0018387E   SH V1, 24(S8)
BFD08A5C  001C185E   SB V0, 28(S8)
239:                 #ifdef ENABLE_TRACE_MASK_IRQ
240:                     uint32_t isave;
241:                     
242:                     isave = mips32r2_dis_intr();
243:                 #endif
244:                     (void)b;
245:                     tfdp_xmit_header(nbr);
BFD08A60  0018345E   LHU V0, 24(S8)
BFD08A64      0C82   MOVE A0, V0
BFD08A66  483677E8   JALS tfdp_xmit_header
BFD08A68      4836   LW AT, 88(SP)
BFD08A6A      0C00   NOP
246:                     tfdp_xmit_hword(p1);
BFD08A6C  0020FC5E   LW V0, 32(S8)
BFD08A70      2D2F   ANDI V0, V0, 0xFFFF
BFD08A72      0C82   MOVE A0, V0
BFD08A74  4B2477E8   JALS tfdp_xmit_hword
BFD08A76      4B24   LW T9, 16(SP)
BFD08A78      0C00   NOP
247:                     tfdp_xmit_hword(p2);
BFD08A7A  0024FC5E   LW V0, 36(S8)
BFD08A7E      2D2F   ANDI V0, V0, 0xFFFF
BFD08A80      0C82   MOVE A0, V0
BFD08A82  4B2477E8   JALS tfdp_xmit_hword
BFD08A84      4B24   LW T9, 16(SP)
BFD08A86      0C00   NOP
248:                 
249:                 #ifdef ENABLE_TRACE_MASK_IRQ
250:                     mips32r2_restore_intr(isave);
251:                 #endif
252:                 }
BFD08A88      0FBE   MOVE SP, S8
BFD08A8A      4BE5   LW RA, 20(SP)
BFD08A8C      4BC4   LW S8, 16(SP)
BFD08A8E      4C0D   ADDIU SP, SP, 24
BFD08A90      459F   JR16 RA
BFD08A92      0C00   NOP
253:                 
254:                 
255:                 /**
256:                  * TFDPTrace3 - TRACE3: transmit 16-bit trace number lsb first 
257:                  * and three 16-bit data parameters lsb first over TFDP.
258:                  * 
259:                  * @author sworley 
260:                  * 
261:                  * @param nbr trace number
262:                  * @param b unused
263:                  * @param uint32_t p1 16-bit data1 in b[15:0]
264:                  * @param uint32_t p2 16-bit data2 in b[15:0]
265:                  * @param uint32_t p3 16-bit data3 in b[15:0]
266:                  * 
267:                  * @return uint8_t always TRUE 
268:                  * @note Uses tool kit functions to save/disable/restore 
269:                  *       interrupts for critical section. These may use
270:                  *       priviledged instructions. 
271:                  */
272:                 void TFDPTrace3 ( uint16_t nbr, uint8_t b, uint32_t p1, uint32_t p2, uint32_t p3)
273:                 {
BFD08274      4FF5   ADDIU SP, SP, -24
BFD08276      CBE5   SW RA, 20(SP)
BFD08278      CBC4   SW S8, 16(SP)
BFD0827A      0FDD   MOVE S8, SP
BFD0827C      0C64   MOVE V1, A0
BFD0827E      0C45   MOVE V0, A1
BFD08280  0020F8DE   SW A2, 32(S8)
BFD08284  0024F8FE   SW A3, 36(S8)
BFD08288  0018387E   SH V1, 24(S8)
BFD0828C  001C185E   SB V0, 28(S8)
274:                 #ifdef ENABLE_TRACE_MASK_IRQ
275:                     uint32_t isave;
276:                     
277:                     isave = mips32r2_dis_intr();
278:                 #endif  
279:                     (void)b;
280:                     tfdp_xmit_header(nbr);
BFD08290  0018345E   LHU V0, 24(S8)
BFD08294      0C82   MOVE A0, V0
BFD08296  483677E8   JALS tfdp_xmit_header
BFD08298      4836   LW AT, 88(SP)
BFD0829A      0C00   NOP
281:                     tfdp_xmit_hword(p1);
BFD0829C  0020FC5E   LW V0, 32(S8)
BFD082A0      2D2F   ANDI V0, V0, 0xFFFF
BFD082A2      0C82   MOVE A0, V0
BFD082A4  4B2477E8   JALS tfdp_xmit_hword
BFD082A6      4B24   LW T9, 16(SP)
BFD082A8      0C00   NOP
282:                     tfdp_xmit_hword(p2);
BFD082AA  0024FC5E   LW V0, 36(S8)
BFD082AE      2D2F   ANDI V0, V0, 0xFFFF
BFD082B0      0C82   MOVE A0, V0
BFD082B2  4B2477E8   JALS tfdp_xmit_hword
BFD082B4      4B24   LW T9, 16(SP)
BFD082B6      0C00   NOP
283:                     tfdp_xmit_hword(p3);
BFD082B8  0028FC5E   LW V0, 40(S8)
BFD082BC      2D2F   ANDI V0, V0, 0xFFFF
BFD082BE      0C82   MOVE A0, V0
BFD082C0  4B2477E8   JALS tfdp_xmit_hword
BFD082C2      4B24   LW T9, 16(SP)
BFD082C4      0C00   NOP
284:                 
285:                 #ifdef ENABLE_TRACE_MASK_IRQ
286:                     if ( isave & (1ul<<0) )
287:                     {
288:                         mips32r2_en_intr();
289:                     }
290:                 #endif
291:                 }
BFD082C6      0FBE   MOVE SP, S8
BFD082C8      4BE5   LW RA, 20(SP)
BFD082CA      4BC4   LW S8, 16(SP)
BFD082CC      4C0D   ADDIU SP, SP, 24
BFD082CE      459F   JR16 RA
BFD082D0      0C00   NOP
292:                 
293:                 
294:                 /**
295:                  * TFDPTrace4 - TRACE3: transmit 16-bit trace number lsb first 
296:                  * and four 16-bit data parameters lsb first over TFDP.
297:                  * 
298:                  * @author sworley 
299:                  * 
300:                  * @param nbr trace number
301:                  * @param b unused
302:                  * @param uint32_t p1 16-bit data1 in b[15:0]
303:                  * @param uint32_t p2 16-bit data2 in b[15:0]
304:                  * @param uint32_t p3 16-bit data3 in b[15:0]
305:                  * @param uint32_t p4 16-bit data4 in b[15:0]
306:                  * 
307:                  * @return uint8_t always TRUE 
308:                  * @note Uses tool kit functions to save/disable/restore 
309:                  *       interrupts for critical section. These may use
310:                  *       priviledged instructions. 
311:                  */
312:                 void TFDPTrace4 ( uint16_t nbr, uint8_t b, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4)
313:                 {
BFD07C28      4FF5   ADDIU SP, SP, -24
BFD07C2A      CBE5   SW RA, 20(SP)
BFD07C2C      CBC4   SW S8, 16(SP)
BFD07C2E      0FDD   MOVE S8, SP
BFD07C30      0C64   MOVE V1, A0
BFD07C32      0C45   MOVE V0, A1
BFD07C34  0020F8DE   SW A2, 32(S8)
BFD07C38  0024F8FE   SW A3, 36(S8)
BFD07C3C  0018387E   SH V1, 24(S8)
BFD07C40  001C185E   SB V0, 28(S8)
314:                 #ifdef ENABLE_TRACE_MASK_IRQ
315:                     uint32_t isave;
316:                     
317:                     isave = mips32r2_dis_intr();
318:                 #endif
319:                     (void)b;
320:                     tfdp_xmit_header(nbr);
BFD07C44  0018345E   LHU V0, 24(S8)
BFD07C48      0C82   MOVE A0, V0
BFD07C4A  483677E8   JALS tfdp_xmit_header
BFD07C4C      4836   LW AT, 88(SP)
BFD07C4E      0C00   NOP
321:                     tfdp_xmit_hword(p1);
BFD07C50  0020FC5E   LW V0, 32(S8)
BFD07C54      2D2F   ANDI V0, V0, 0xFFFF
BFD07C56      0C82   MOVE A0, V0
BFD07C58  4B2477E8   JALS tfdp_xmit_hword
BFD07C5A      4B24   LW T9, 16(SP)
BFD07C5C      0C00   NOP
322:                     tfdp_xmit_hword(p2);
BFD07C5E  0024FC5E   LW V0, 36(S8)
BFD07C62      2D2F   ANDI V0, V0, 0xFFFF
BFD07C64      0C82   MOVE A0, V0
BFD07C66  4B2477E8   JALS tfdp_xmit_hword
BFD07C68      4B24   LW T9, 16(SP)
BFD07C6A      0C00   NOP
323:                     tfdp_xmit_hword(p3);
BFD07C6C  0028FC5E   LW V0, 40(S8)
BFD07C70      2D2F   ANDI V0, V0, 0xFFFF
BFD07C72      0C82   MOVE A0, V0
BFD07C74  4B2477E8   JALS tfdp_xmit_hword
BFD07C76      4B24   LW T9, 16(SP)
BFD07C78      0C00   NOP
324:                     tfdp_xmit_hword(p4);
BFD07C7A  002CFC5E   LW V0, 44(S8)
BFD07C7E      2D2F   ANDI V0, V0, 0xFFFF
BFD07C80      0C82   MOVE A0, V0
BFD07C82  4B2477E8   JALS tfdp_xmit_hword
BFD07C84      4B24   LW T9, 16(SP)
BFD07C86      0C00   NOP
325:                       
326:                 #ifdef ENABLE_TRACE_MASK_IRQ
327:                     if ( isave & (1ul<<0) )
328:                     {
329:                         mips32r2_en_intr();
330:                     }
331:                 #endif
332:                 }
BFD07C88      0FBE   MOVE SP, S8
BFD07C8A      4BE5   LW RA, 20(SP)
BFD07C8C      4BC4   LW S8, 16(SP)
BFD07C8E      4C0D   ADDIU SP, SP, 24
BFD07C90      459F   JR16 RA
BFD07C92      0C00   NOP
333:                 
334:                 
335:                 /** 
336:                  *  TFDPTrace11 - Transmit one 32-bit data item over TFDP 
337:                  * 
338:                  *  @param nbr trace number
339:                  *  @param b unused 
340:                  *  @param uint32_t p1 32-bit data to be transmitted
341:                  * 
342:                  */
343:                 void TFDPTrace11( uint16_t nbr, uint8_t b, uint32_t p1)
344:                 {
BFD09684      4FF5   ADDIU SP, SP, -24
BFD09686      CBE5   SW RA, 20(SP)
BFD09688      CBC4   SW S8, 16(SP)
BFD0968A      0FDD   MOVE S8, SP
BFD0968C      0C64   MOVE V1, A0
BFD0968E      0C45   MOVE V0, A1
BFD09690  0020F8DE   SW A2, 32(S8)
BFD09694  0018387E   SH V1, 24(S8)
BFD09698  001C185E   SB V0, 28(S8)
345:                 #ifdef ENABLE_TRACE_MASK_IRQ
346:                     uint32_t isave;
347:                     
348:                     isave = mips32r2_dis_intr();
349:                 #endif  
350:                     (void)b;
351:                     tfdp_xmit_header(nbr);
BFD0969C  0018345E   LHU V0, 24(S8)
BFD096A0      0C82   MOVE A0, V0
BFD096A2  483677E8   JALS tfdp_xmit_header
BFD096A4      4836   LW AT, 88(SP)
BFD096A6      0C00   NOP
352:                     tfdp_xmit_word(p1);
BFD096A8  0020FC9E   LW A0, 32(S8)
BFD096AC  467A77E8   JALS tfdp_xmit_word
BFD096B0      0C00   NOP
353:                     
354:                 #ifdef ENABLE_TRACE_MASK_IRQ
355:                     if ( isave & (1ul<<0) )
356:                     {
357:                         mips32r2_en_intr();
358:                     }
359:                 #endif
360:                 }
BFD096B2      0FBE   MOVE SP, S8
BFD096B4      4BE5   LW RA, 20(SP)
BFD096B6      4BC4   LW S8, 16(SP)
BFD096B8      4C0D   ADDIU SP, SP, 24
BFD096BA      459F   JR16 RA
BFD096BC      0C00   NOP
361:                 
362:                 
363:                 /** 
364:                  *  TFDPTrace12 - Transmit two 32-bit data items over TFDP 
365:                  * 
366:                  *  @param nbr trace number
367:                  *  @param b unused 
368:                  *  @param uint32_t p1 32-bit data1 to be transmitted
369:                  *  @param uint32_t p2 32-bit data2 to be transmitted
370:                  * 
371:                  */
372:                 void TFDPTrace12( uint16_t nbr, uint8_t b, uint32_t p1, uint32_t p2 )
373:                 {
BFD090B4      4FF5   ADDIU SP, SP, -24
BFD090B6      CBE5   SW RA, 20(SP)
BFD090B8      CBC4   SW S8, 16(SP)
BFD090BA      0FDD   MOVE S8, SP
BFD090BC      0C64   MOVE V1, A0
BFD090BE      0C45   MOVE V0, A1
BFD090C0  0020F8DE   SW A2, 32(S8)
BFD090C4  0024F8FE   SW A3, 36(S8)
BFD090C8  0018387E   SH V1, 24(S8)
BFD090CC  001C185E   SB V0, 28(S8)
374:                 #ifdef ENABLE_TRACE_MASK_IRQ
375:                     uint32_t isave;
376:                     
377:                     isave = mips32r2_dis_intr();
378:                 #endif  
379:                     (void)b;
380:                     tfdp_xmit_header(nbr);
BFD090D0  0018345E   LHU V0, 24(S8)
BFD090D4      0C82   MOVE A0, V0
BFD090D6  483677E8   JALS tfdp_xmit_header
BFD090D8      4836   LW AT, 88(SP)
BFD090DA      0C00   NOP
381:                     tfdp_xmit_word(p1);
BFD090DC  0020FC9E   LW A0, 32(S8)
BFD090E0  467A77E8   JALS tfdp_xmit_word
BFD090E4      0C00   NOP
382:                     tfdp_xmit_word(p2);
BFD090E6  0024FC9E   LW A0, 36(S8)
BFD090EA  467A77E8   JALS tfdp_xmit_word
BFD090EE      0C00   NOP
383:                 
384:                 #ifdef ENABLE_TRACE_MASK_IRQ
385:                     if ( isave & (1ul<<0) )
386:                     {
387:                         mips32r2_en_intr();
388:                     }
389:                 #endif
390:                 }
BFD090F0      0FBE   MOVE SP, S8
BFD090F2      4BE5   LW RA, 20(SP)
BFD090F4      4BC4   LW S8, 16(SP)
BFD090F6      4C0D   ADDIU SP, SP, 24
BFD090F8      459F   JR16 RA
BFD090FA      0C00   NOP
391:                 
392:                 #endif // #ifdef ENABLE_TFDP_TRACE
393:                 
394:                 
395:                 /* end mec14xx_tfdp.c */
396:                 /**   @}
397:                  */
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/mec14xx_system.c  -------
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file mec14xx_system.c
22:                   *MEC14xx system functions
23:                   */
24:                  /** @defgroup MEC14xx System
25:                   *  @{
26:                   */
27:                  
28:                  
29:                  
30:                  #include "appcfg.h"
31:                  #include "platform.h"
32:                  #include "MEC14xx/mec14xx.h"
33:                  #include "MEC14xx/mec14xx_system.h"
34:                  #include "MEC14xx/mec14xx_jtvic.h"
35:                  
36:                  
37:                  
38:                  
39:                  /**
40:                   * Initialize the system
41:                   *
42:                   * @param  none
43:                   * @return none
44:                   *
45:                   * @brief  Setup the microcontroller system.
46:                   *         Initialize the System.
47:                   */
48:                  void SystemInit (void)
49:                  {
BFD09E20      4FB0   ADDIU SP, SP, -8
BFD09E22      CBC1   SW S8, 4(SP)
BFD09E24      0FDD   MOVE S8, SP
50:                      
51:                      PCR->PROC_CLOCK_CNTRL = (PCR_CLOCK_DIVIDER);
BFD09E26  A00841A2   LUI V0, 0xA008
BFD09E2A  01005042   ORI V0, V0, 256
BFD09E2E      ED81   LI V1, 1
BFD09E30      E9A8   SW V1, 32(V0)
52:                      
53:                  }
BFD09E32      0FBE   MOVE SP, S8
BFD09E34      4BC1   LW S8, 4(SP)
BFD09E36      4C05   ADDIU SP, SP, 8
BFD09E38      459F   JR16 RA
BFD09E3A      0C00   NOP
54:                  /*---------------------------------------------------------------------------*/
55:                  
56:                  uint32_t sys_code_sram_base(void)
57:                  {
BFD09EAC      4FB0   ADDIU SP, SP, -8
BFD09EAE      CBC1   SW S8, 4(SP)
BFD09EB0      0FDD   MOVE S8, SP
58:                  #if MEC14XX_DEVID  == MEC1418_DEVID
59:                      return (uint32_t)(MEC1418_ICODE_PSRAM_BASE);
60:                  #else
61:                      return (uint32_t)(MEC1404_ICODE_PSRAM_BASE);
BFD09EB2  1FD041A2   LUI V0, 0x1FD0
BFD09EB4  0FBE1FD0   LB S8, 4030(S0)
62:                  #endif
63:                  }
BFD09EB6      0FBE   MOVE SP, S8
BFD09EB8      4BC1   LW S8, 4(SP)
BFD09EBA      4C05   ADDIU SP, SP, 8
BFD09EBC      459F   JR16 RA
BFD09EBE      0C00   NOP
64:                  /*---------------------------------------------------------------------------*/
65:                  
66:                  uint8_t sys_valid_sram_addr(void * const p)
67:                  {
BFD08CA8      4FF1   ADDIU SP, SP, -32
BFD08CAA      CBE7   SW RA, 28(SP)
BFD08CAC      CBC6   SW S8, 24(SP)
BFD08CAE      0FDD   MOVE S8, SP
BFD08CB0  0020F89E   SW A0, 32(S8)
68:                      uint32_t base;
69:                      
70:                      base = sys_code_sram_base();
BFD08CB4  4F5677E8   JALS sys_code_sram_base
BFD08CB6      4F56   ADDIU K0, K0, -5
BFD08CB8      0C00   NOP
BFD08CBA  0010F85E   SW V0, 16(S8)
71:                          
72:                      if ((uint32_t)p >= base) {
BFD08CBE  0020FC7E   LW V1, 32(S8)
BFD08CC2  0010FC5E   LW V0, 16(S8)
BFD08CC6  13900043   SLTU V0, V1, V0
BFD08CC8  40A21390   ADDI GP, S0, 16546
BFD08CCA  000B40A2   BNEZC V0, 0xBFD08CE4
73:                          if ((uint32_t)p < (MEC14XX_DCODE_VSRAM_LIMIT)) {
BFD08CCE  0020FC7E   LW V1, 32(S8)
BFD08CD2  BFD241A2   LUI V0, 0xBFD2
BFD08CD4  0043BFD2   LDC1 F30, 67(S2)
BFD08CD6  13900043   SLTU V0, V1, V0
BFD08CD8  40E21390   ADDI GP, S0, 16610
BFD08CDA  000340E2   BEQZC V0, 0xBFD08CE4
74:                              return 1u;
BFD08CDE      ED01   LI V0, 1
BFD08CE0      CC02   B 0xBFD08CE6
BFD08CE2      0C00   NOP
75:                          }
76:                      }
77:                      return 0u;
BFD08CE4      0C40   MOVE V0, ZERO
78:                  }
BFD08CE6      0FBE   MOVE SP, S8
BFD08CE8      4BE7   LW RA, 28(SP)
BFD08CEA      4BC6   LW S8, 24(SP)
BFD08CEC      4C11   ADDIU SP, SP, 32
BFD08CEE      459F   JR16 RA
BFD08CF0      0C00   NOP
79:                  /*---------------------------------------------------------------------------*/
80:                  
81:                  uint8_t sys_valid_sram_range(void * const p, const uint32_t byte_len)
82:                  {
BFD08858      4FF1   ADDIU SP, SP, -32
BFD0885A      CBE7   SW RA, 28(SP)
BFD0885C      CBC6   SW S8, 24(SP)
BFD0885E      0FDD   MOVE S8, SP
BFD08860  0020F89E   SW A0, 32(S8)
BFD08864  0024F8BE   SW A1, 36(S8)
83:                      uint32_t base;
84:                  
85:                      base = sys_code_sram_base();
BFD08868  4F5677E8   JALS sys_code_sram_base
BFD0886A      4F56   ADDIU K0, K0, -5
BFD0886C      0C00   NOP
BFD0886E  0010F85E   SW V0, 16(S8)
86:                  
87:                      if ((uint32_t)p >= base) {
BFD08872  0020FC7E   LW V1, 32(S8)
BFD08876  0010FC5E   LW V0, 16(S8)
BFD0887A  13900043   SLTU V0, V1, V0
BFD0887C  40A21390   ADDI GP, S0, 16546
BFD0887E  000E40A2   BNEZC V0, 0xBFD0889E
88:                          if (((uint32_t)p + byte_len) < (MEC14XX_DCODE_VSRAM_LIMIT)) {
BFD08882  0020FC7E   LW V1, 32(S8)
BFD08886  0024FC5E   LW V0, 36(S8)
BFD0888A      05A6   ADDU V1, V1, V0
BFD0888C  BFD241A2   LUI V0, 0xBFD2
BFD0888E  0043BFD2   LDC1 F30, 67(S2)
BFD08890  13900043   SLTU V0, V1, V0
BFD08892  40E21390   ADDI GP, S0, 16610
BFD08894  000340E2   BEQZC V0, 0xBFD0889E
89:                              return 1u;
BFD08898      ED01   LI V0, 1
BFD0889A      CC02   B 0xBFD088A0
BFD0889C      0C00   NOP
90:                          }
91:                      }
92:                      return 0u;
BFD0889E      0C40   MOVE V0, ZERO
93:                  }
BFD088A0      0FBE   MOVE SP, S8
BFD088A2      4BE7   LW RA, 28(SP)
BFD088A4      4BC6   LW S8, 24(SP)
BFD088A6      4C11   ADDIU SP, SP, 32
BFD088A8      459F   JR16 RA
BFD088AA      0C00   NOP
94:                  /*---------------------------------------------------------------------------*/
95:                  
96:                  void sys_cpu_en_timer(uint32_t counts, uint8_t ien)
97:                  {
BFD07570      4FF5   ADDIU SP, SP, -24
BFD07572      CBE5   SW RA, 20(SP)
BFD07574      CBC4   SW S8, 16(SP)
BFD07576      0FDD   MOVE S8, SP
BFD07578  0018F89E   SW A0, 24(S8)
BFD0757A  0C450018   CMP.LT.PH ZERO, T8
BFD0757C      0C45   MOVE V0, A1
BFD0757E  001C185E   SB V0, 28(S8)
98:                      /* Disable Counter by setting DC bit to 1 in CP0.Cause */
99:                      _CP0_BIS_CAUSE(_CP0_CAUSE_DC_MASK);
BFD07582  080041A2   LUI V0, 0x800
BFD07584      0800   LBU S0, 0(S0)
BFD07586  00FC006D   MFC0 V1, Cause
BFD07588  0C0000FC   SLL A3, GP, 1
BFD0758A      0C00   NOP
BFD0758C      44D3   OR16 V0, V1
BFD0758E  02FC004D   MTC0 V0, Cause
BFD07590  000002FC   SLL S7, GP, 0
BFD07592  18000000   SLL ZERO, ZERO, 3
BFD07594  FC5E1800   SB ZERO, -930(ZERO)
100:                 
101:                     _CP0_SET_COUNT(counts);
BFD07596  0018FC5E   LW V0, 24(S8)
BFD0759A  02FC0049   MTC0 V0, Count
BFD0759C  000002FC   SLL S7, GP, 0
BFD0759E  18000000   SLL ZERO, ZERO, 3
BFD075A0  145E1800   SB ZERO, 5214(ZERO)
102:                     if (ien) {
BFD075A2  001C145E   LBU V0, 28(S8)
BFD075A6  000840E2   BEQZC V0, 0xBFD075BA
BFD075A8  EE100008   MUL SP, T0, ZERO
103:                         jtvic_en_source(MEC14xx_GIRQ24_ID, 0, 0);
BFD075AA      EE10   LI A0, 16
BFD075AC      0CA0   MOVE A1, ZERO
BFD075AE      0CC0   MOVE A2, ZERO
BFD075B0  3A7C77E8   JALS jtvic_en_source
BFD075B2  0C003A7C   SH S3, 3072(GP)
BFD075B4      0C00   NOP
BFD075B6      CC07   B 0xBFD075C6
BFD075B8      0C00   NOP
104:                     } else {
105:                         jtvic_dis_clr_source(MEC14xx_GIRQ24_ID, 0, 1);
BFD075BA      EE10   LI A0, 16
BFD075BC      0CA0   MOVE A1, ZERO
BFD075BE      EF01   LI A2, 1
BFD075C0  3A4077E8   JALS jtvic_dis_clr_source
BFD075C2  0C003A40   SH S2, 3072(ZERO)
BFD075C4      0C00   NOP
106:                     }
107:                 
108:                     /* Enable Counter */
109:                     _CP0_BIC_CAUSE(_CP0_CAUSE_DC_MASK);
BFD075C6  080041A2   LUI V0, 0x800
BFD075C8      0800   LBU S0, 0(S0)
BFD075CA  00FC006D   MFC0 V1, Cause
BFD075CC  0C0000FC   SLL A3, GP, 1
BFD075CE      0C00   NOP
BFD075D0      4412   NOT16 V0, V0
BFD075D2      4493   AND16 V0, V1
BFD075D4  02FC004D   MTC0 V0, Cause
BFD075D6  000002FC   SLL S7, GP, 0
BFD075D8  18000000   SLL ZERO, ZERO, 3
BFD075DA  0FBE1800   SB ZERO, 4030(ZERO)
110:                 
111:                 }
BFD075DC      0FBE   MOVE SP, S8
BFD075DE      4BE5   LW RA, 20(SP)
BFD075E0      4BC4   LW S8, 16(SP)
BFD075E2      4C0D   ADDIU SP, SP, 24
BFD075E4      459F   JR16 RA
BFD075E6      0C00   NOP
112:                 /*---------------------------------------------------------------------------*/
113:                 
114:                 uint32_t cpu_microsecond_count(void)
115:                 {
BFD09EC0      4FB0   ADDIU SP, SP, -8
BFD09EC2      CBC1   SW S8, 4(SP)
BFD09EC4      0FDD   MOVE S8, SP
116:                     return _CP0_GET_COUNT();
BFD09EC6  00FC0049   MFC0 V0, Count
117:                 }
BFD09ECA      0FBE   MOVE SP, S8
BFD09ECC      4BC1   LW S8, 4(SP)
BFD09ECE      4C05   ADDIU SP, SP, 8
BFD09ED0      459F   JR16 RA
BFD09ED2      0C00   NOP
118:                 /*---------------------------------------------------------------------------*/
119:                 
120:                 /*
121:                  * Assumes M14K CPU is running at clock divide by 1 (48MHz)
122:                  * 1us = 48 counts. 
123:                  * NOTE: We need to find out from DE what the pipeline rate is. 
124:                  * M14K counter ticks at pipeline rate. 
125:                  */
126:                 uint32_t cpu_microsecond_interval(uint32_t start_count)
127:                 {
BFD07DCC      4FF9   ADDIU SP, SP, -16
BFD07DCE      CBC3   SW S8, 12(SP)
BFD07DD0      0FDD   MOVE S8, SP
BFD07DD2  0010F89E   SW A0, 16(S8)
128:                     uint32_t curr_count;
129:                     
130:                     curr_count = _CP0_GET_COUNT();
BFD07DD6  00FC0049   MFC0 V0, Count
BFD07DDA  0000F85E   SW V0, 0(S8)
131:                     if (curr_count >= start_count) {
BFD07DDE  0000FC7E   LW V1, 0(S8)
BFD07DE2  0010FC5E   LW V0, 16(S8)
BFD07DE6  13900043   SLTU V0, V1, V0
BFD07DE8  40A21390   ADDI GP, S0, 16546
BFD07DEA  000F40A2   BNEZC V0, 0xBFD07E0C
132:                         return ((curr_count - start_count) >> 4)/ 3ul;
BFD07DEE  0000FC7E   LW V1, 0(S8)
BFD07DF2  0010FC5E   LW V0, 16(S8)
BFD07DF6      0527   SUBU V0, V1, V0
BFD07DF8      25A9   SRL V1, V0, 4
BFD07DFA      ED03   LI V0, 3
BFD07DFC  BB3C0043   DIVU V0, V1
BFD07DFE  0002BB3C   SDC1 F25, 2(GP)
BFD07E00  703C0002   TEQ V0, ZERO
BFD07E02  4603703C   XORI AT, GP, 17923
BFD07E04      4603   MFHI V1
BFD07E06      4642   MFLO V0
BFD07E08      CC0F   B 0xBFD07E28
BFD07E0A      0C00   NOP
133:                     } else {
134:                         return (((0xFFFFFFFFul - start_count) + curr_count) >> 4) / 3ul;
BFD07E0C  0010FC5E   LW V0, 16(S8)
BFD07E10      441A   NOT16 V1, V0
BFD07E12  0000FC5E   LW V0, 0(S8)
BFD07E16      0526   ADDU V0, V1, V0
BFD07E18      25A9   SRL V1, V0, 4
BFD07E1A      ED03   LI V0, 3
BFD07E1C  BB3C0043   DIVU V0, V1
BFD07E1E  0002BB3C   SDC1 F25, 2(GP)
BFD07E20  703C0002   TEQ V0, ZERO
BFD07E22  4603703C   XORI AT, GP, 17923
BFD07E24      4603   MFHI V1
BFD07E26      4642   MFLO V0
135:                     }
136:                 }
BFD07E28      0FBE   MOVE SP, S8
BFD07E2A      4BC3   LW S8, 12(SP)
BFD07E2C      4C09   ADDIU SP, SP, 16
BFD07E2E      459F   JR16 RA
BFD07E30      0C00   NOP
137:                 /*---------------------------------------------------------------------------*/
138:                 
139:                 /* end mec14xx_system.c */
140:                 /**   @}
141:                  */
142:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/mec14xx_jtvic.c  --------
1:                   /*****************************************************************************
2:                   *  2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file mec14xx_jtvic.c
22:                   *MEC14xx JTVIC
23:                   */
24:                  /** @defgroup MEC14xx Peripherals JTVIC
25:                   *  @{
26:                   */
27:                  
28:                  
29:                  #include "appcfg.h"
30:                  #include "platform.h"
31:                  #include "MEC14xx/mec14xx.h"
32:                  #include "MEC14xx/mec14xx_jtvic.h"
33:                  
34:                  
35:                  void jtvic_init(const JTVIC_CFG *ih_table, uint32_t disagg_bitmap, uint32_t cflags)
36:                  {
BFD03644      4FF9   ADDIU SP, SP, -16
BFD03646      CBC3   SW S8, 12(SP)
BFD03648      0FDD   MOVE S8, SP
BFD0364A  0010F89E   SW A0, 16(S8)
BFD0364E  0014F8BE   SW A1, 20(S8)
BFD03652  0018F8DE   SW A2, 24(S8)
37:                      uint32_t d;
38:                      uint8_t i, j, pidx;
39:                  
40:                      JTVIC_CTRL->w = (1ul << 0);  // Soft-Reset
BFD03656  BFFF41A2   LUI V0, 0xBFFF
BFD03658  5042BFFF   LDC1 F31, 20546(RA)
BFD0365A  C5005042   ORI V0, V0, -15104
BFD0365E      ED81   LI V1, 1
BFD03660      E9A0   SW V1, 0(V0)
41:                      d = 0ul;
BFD03662  0000F81E   SW ZERO, 0(S8)
42:                      if ( cflags & (1ul << 0) ) 
BFD03666  0018FC5E   LW V0, 24(S8)
BFD0366A      2D21   ANDI V0, V0, 0x1
BFD0366C      2D2D   ANDI V0, V0, 0xFF
BFD0366E  000440E2   BEQZC V0, 0xBFD0367A
BFD03670  30400004   SRL ZERO, A0, 6
43:                      {
44:                          d = (1ul << 8);
BFD03672  01003040   ADDIU V0, ZERO, 256
BFD03676  0000F85E   SW V0, 0(S8)
45:                      }
46:                      JTVIC_CTRL->w = d;  // HW does not automatically clear Soft-Reset
BFD0367A  BFFF41A2   LUI V0, 0xBFFF
BFD0367C  5042BFFF   LDC1 F31, 20546(RA)
BFD0367E  C5005042   ORI V0, V0, -15104
BFD03682  0000FC7E   LW V1, 0(S8)
BFD03686      E9A0   SW V1, 0(V0)
47:                  
48:                      for (i = 0u; i < (MEC14xx_NUM_JTVIC_INTS); i++) {
BFD03688  0004181E   SB ZERO, 4(S8)
BFD0368C      CC5C   B 0xBFD03746
BFD0368E      0C00   NOP
BFD0373C  0004145E   LBU V0, 4(S8)
BFD03740      6D20   ADDIU V0, V0, 1
BFD03742  0004185E   SB V0, 4(S8)
BFD03746  0004145E   LBU V0, 4(S8)
BFD0374A  0013B042   SLTIU V0, V0, 19
BFD0374E  FF9F40A2   BNEZC V0, 0xBFD03690
BFD03750  41A2FF9F   LW GP, 16802(RA)
49:                          pidx = i << 2;
BFD03690  0004145E   LBU V0, 4(S8)
BFD03694      2524   SLL V0, V0, 2
BFD03696  0006185E   SB V0, 6(S8)
50:                          for (j = 0u; j < 4u; j++) {
BFD0369A  0005181E   SB ZERO, 5(S8)
BFD0369E      CC1F   B 0xBFD036DE
BFD036A0      0C00   NOP
BFD036D4  0005145E   LBU V0, 5(S8)
BFD036D8      6D20   ADDIU V0, V0, 1
BFD036DA  0005185E   SB V0, 5(S8)
BFD036DE  0005145E   LBU V0, 5(S8)
BFD036E2  0004B042   SLTIU V0, V0, 4
BFD036E6  FFDC40A2   BNEZC V0, 0xBFD036A2
BFD036E8  145EFFDC   LW S8, 5214(GP)
51:                              JTVIC_PRI->REG32[pidx+j] = (uint32_t)(ih_table[i].pri[j]);
BFD036A2  BFFF41A2   LUI V0, 0xBFFF
BFD036A4  5082BFFF   LDC1 F31, 20610(RA)
BFD036A6  C3005082   ORI A0, V0, -15616
BFD036AA  0006147E   LBU V1, 6(S8)
BFD036AE  0005145E   LBU V0, 5(S8)
BFD036B2      06A6   ADDU A1, V1, V0
BFD036B4  0004145E   LBU V0, 4(S8)
BFD036B8      2524   SLL V0, V0, 2
BFD036BA      25A4   SLL V1, V0, 2
BFD036BC      0534   ADDU V0, V0, V1
BFD036BE  0010FC7E   LW V1, 16(S8)
BFD036C2      05A6   ADDU V1, V1, V0
BFD036C4  0005145E   LBU V0, 5(S8)
BFD036C8      2524   SLL V0, V0, 2
BFD036CA      0526   ADDU V0, V1, V0
BFD036CC      69A1   LW V1, 4(V0)
BFD036CE      2554   SLL V0, A1, 2
BFD036D0      0528   ADDU V0, A0, V0
BFD036D2      E9A0   SW V1, 0(V0)
52:                          }
53:                          d = ih_table[i].isr_addr & ~(1ul << 0);
BFD036EA  0004145E   LBU V0, 4(S8)
BFD036EE      2524   SLL V0, V0, 2
BFD036F0      25A4   SLL V1, V0, 2
BFD036F2      0534   ADDU V0, V0, V1
BFD036F4  0010FC7E   LW V1, 16(S8)
BFD036F8      0526   ADDU V0, V1, V0
BFD036FA      69A0   LW V1, 0(V0)
BFD036FC  FFFE3040   ADDIU V0, ZERO, -2
BFD036FE  4493FFFE   LW RA, 17555(S8)
BFD03700      4493   AND16 V0, V1
BFD03702  0000F85E   SW V0, 0(S8)
54:                          if (disagg_bitmap & (1ul << i)) {
BFD03706  0004145E   LBU V0, 4(S8)
BFD0370A  0014FC7E   LW V1, 20(S8)
BFD0370E  10500062   SRLV V0, V0, V1
BFD03710  2D211050   ADDI V0, S0, 11553
BFD03712      2D21   ANDI V0, V0, 0x1
BFD03714      2D2D   ANDI V0, V0, 0xFF
BFD03716  000640E2   BEQZC V0, 0xBFD03726
55:                              d |= (1ul << 0);    // dis-aggregate this GIRQ
BFD0371A  0000FC5E   LW V0, 0(S8)
BFD0371E  00015042   ORI V0, V0, 1
BFD03722  0000F85E   SW V0, 0(S8)
56:                          }
57:                          JTVIC_ACTRL->REG32[i] = d;
BFD03726  BFFF41A2   LUI V0, 0xBFFF
BFD03728  5062BFFF   LDC1 F31, 20578(RA)
BFD0372A  C2005062   ORI V1, V0, -15872
BFD0372E  0004145E   LBU V0, 4(S8)
BFD03732      2524   SLL V0, V0, 2
BFD03734      0526   ADDU V0, V1, V0
BFD03736  0000FC7E   LW V1, 0(S8)
BFD0373A      E9A0   SW V1, 0(V0)
58:                      }
59:                      
60:                      JTVIC_GROUP_EN_SET->w = 0xFFFFFFFFul;   // Enable GIRQ08 - GIRQ18 (all)
BFD03752  BFFF41A2   LUI V0, 0xBFFF
BFD03754  5042BFFF   LDC1 F31, 20546(RA)
BFD03756  C5085042   ORI V0, V0, -15096
BFD0375A      EDFF   LI V1, -1
BFD0375C      E9A0   SW V1, 0(V0)
61:                      
62:                  }
BFD0375E      0FBE   MOVE SP, S8
BFD03760      4BC3   LW S8, 12(SP)
BFD03762      4C09   ADDIU SP, SP, 16
BFD03764      459F   JR16 RA
BFD03766      0C00   NOP
63:                  
64:                  /* Clear JTVIC GIRQn source bit
65:                   *
66:                   */
67:                  void jtvic_clr_source(uint8_t girq_num, uint8_t bit_num)
68:                  {
BFD089F4      4FB0   ADDIU SP, SP, -8
BFD089F6      CBC1   SW S8, 4(SP)
BFD089F8      0FDD   MOVE S8, SP
BFD089FA      0C64   MOVE V1, A0
BFD089FC      0C45   MOVE V0, A1
BFD089FE  0008187E   SB V1, 8(S8)
BFD08A02  000C185E   SB V0, 12(S8)
69:                      if (girq_num < (MEC14xx_NUM_JTVIC_INTS))
BFD08A06  0008145E   LBU V0, 8(S8)
BFD08A0A  0013B042   SLTIU V0, V0, 19
BFD08A0E  001340E2   BEQZC V0, 0xBFD08A38
70:                      {
71:                          bit_num &= 0x1Fu;
BFD08A12  000C145E   LBU V0, 12(S8)
BFD08A16      2D29   ANDI V0, V0, 0x1F
BFD08A18  000C185E   SB V0, 12(S8)
72:                          JTVIC_GIRQ->REGS[girq_num].SOURCE = (1ul << bit_num);
BFD08A1C  BFFF41A2   LUI V0, 0xBFFF
BFD08A1E  5082BFFF   LDC1 F31, 20610(RA)
BFD08A20  C0005082   ORI A0, V0, -16384
BFD08A24  0008145E   LBU V0, 8(S8)
BFD08A28  000C147E   LBU V1, 12(S8)
BFD08A2C      EE81   LI A1, 1
BFD08A2E  181000A3   SLLV V1, V1, A1
BFD08A30  25281810   SB ZERO, 9512(S0)
BFD08A32      2528   SLL V0, V0, 4
BFD08A34      0528   ADDU V0, A0, V0
BFD08A36      E9A0   SW V1, 0(V0)
73:                      }
74:                  }
BFD08A38      0FBE   MOVE SP, S8
BFD08A3A      4BC1   LW S8, 4(SP)
BFD08A3C      4C05   ADDIU SP, SP, 8
BFD08A3E      459F   JR16 RA
BFD08A40      0C00   NOP
75:                  
76:                  
77:                  /* Disable GIRQn source with optional clearing of source.
78:                   * girq_num = [0, 18], 0=GIRQ08, 1=GIRQ09, ..., 18=GIRQ26
79:                   * bit_num = [0, 31]
80:                   */
81:                  void jtvic_dis_clr_source(uint8_t girq_num, uint8_t bit_num, uint8_t clr_src)
82:                  {
BFD07480      4FB0   ADDIU SP, SP, -8
BFD07482      CBC1   SW S8, 4(SP)
BFD07484      0FDD   MOVE S8, SP
BFD07486      0C65   MOVE V1, A1
BFD07488      0C46   MOVE V0, A2
BFD0748A  0008189E   SB A0, 8(S8)
BFD0748E  000C187E   SB V1, 12(S8)
BFD07492  0010185E   SB V0, 16(S8)
83:                      if (girq_num < (MEC14xx_NUM_JTVIC_INTS))
BFD07496  0008145E   LBU V0, 8(S8)
BFD0749A  0013B042   SLTIU V0, V0, 19
BFD0749E  002540E2   BEQZC V0, 0xBFD074EC
84:                      {
85:                          bit_num &= 0x1Fu;
BFD074A2  000C145E   LBU V0, 12(S8)
BFD074A6      2D29   ANDI V0, V0, 0x1F
BFD074A8  000C185E   SB V0, 12(S8)
86:                          JTVIC_GIRQ->REGS[girq_num].EN_CLR = (1ul << bit_num);
BFD074AC  BFFF41A2   LUI V0, 0xBFFF
BFD074AE  5082BFFF   LDC1 F31, 20610(RA)
BFD074B0  C0005082   ORI A0, V0, -16384
BFD074B4  0008145E   LBU V0, 8(S8)
BFD074B8  000C147E   LBU V1, 12(S8)
BFD074BC      EE81   LI A1, 1
BFD074BE  181000A3   SLLV V1, V1, A1
BFD074C0  25281810   SB ZERO, 9512(S0)
BFD074C2      2528   SLL V0, V0, 4
BFD074C4      0528   ADDU V0, A0, V0
BFD074C6      E9A2   SW V1, 8(V0)
87:                          if ( 0 != clr_src )
BFD074C8  0010145E   LBU V0, 16(S8)
BFD074CC  000E40E2   BEQZC V0, 0xBFD074EC
88:                          {
89:                              JTVIC_GIRQ->REGS[girq_num].SOURCE = (1ul << bit_num);
BFD074D0  BFFF41A2   LUI V0, 0xBFFF
BFD074D2  5082BFFF   LDC1 F31, 20610(RA)
BFD074D4  C0005082   ORI A0, V0, -16384
BFD074D8  0008145E   LBU V0, 8(S8)
BFD074DC  000C147E   LBU V1, 12(S8)
BFD074E0      EE81   LI A1, 1
BFD074E2  181000A3   SLLV V1, V1, A1
BFD074E4  25281810   SB ZERO, 9512(S0)
BFD074E6      2528   SLL V0, V0, 4
BFD074E8      0528   ADDU V0, A0, V0
BFD074EA      E9A0   SW V1, 0(V0)
90:                          }
91:                      }
92:                  }
BFD074EC      0FBE   MOVE SP, S8
BFD074EE      4BC1   LW S8, 4(SP)
BFD074F0      4C05   ADDIU SP, SP, 8
BFD074F2      459F   JR16 RA
BFD074F4      0C00   NOP
93:                  
94:                  
95:                  /* Enable with optional source clear before enable.
96:                   * girq_num = [0, 18], 0=GIRQ08, 1=GIRQ09, ..., 18=GIRQ26
97:                   * bit_num = [0, 31]
98:                   */
99:                  void jtvic_en_source(uint8_t girq_num, uint8_t bit_num, uint8_t clr_src)
100:                 {
BFD074F8      4FB0   ADDIU SP, SP, -8
BFD074FA      CBC1   SW S8, 4(SP)
BFD074FC      0FDD   MOVE S8, SP
BFD074FE      0C65   MOVE V1, A1
BFD07500      0C46   MOVE V0, A2
BFD07502  0008189E   SB A0, 8(S8)
BFD07506  000C187E   SB V1, 12(S8)
BFD0750A  0010185E   SB V0, 16(S8)
101:                     if (girq_num < (MEC14xx_NUM_JTVIC_INTS))
BFD0750E  0008145E   LBU V0, 8(S8)
BFD07512  0013B042   SLTIU V0, V0, 19
BFD07516  002540E2   BEQZC V0, 0xBFD07564
102:                     {
103:                         bit_num &= 0x1Fu;
BFD0751A  000C145E   LBU V0, 12(S8)
BFD0751E      2D29   ANDI V0, V0, 0x1F
BFD07520  000C185E   SB V0, 12(S8)
104:                         if ( 0 != clr_src )
BFD07524  0010145E   LBU V0, 16(S8)
BFD07528  000E40E2   BEQZC V0, 0xBFD07548
105:                         {
106:                             JTVIC_GIRQ->REGS[girq_num].SOURCE = (1ul << bit_num);
BFD0752C  BFFF41A2   LUI V0, 0xBFFF
BFD0752E  5082BFFF   LDC1 F31, 20610(RA)
BFD07530  C0005082   ORI A0, V0, -16384
BFD07534  0008145E   LBU V0, 8(S8)
BFD07538  000C147E   LBU V1, 12(S8)
BFD0753C      EE81   LI A1, 1
BFD0753E  181000A3   SLLV V1, V1, A1
BFD07540  25281810   SB ZERO, 9512(S0)
BFD07542      2528   SLL V0, V0, 4
BFD07544      0528   ADDU V0, A0, V0
BFD07546      E9A0   SW V1, 0(V0)
107:                         }
108:                         JTVIC_GIRQ->REGS[girq_num].EN_SET = (1ul << bit_num);
BFD07548  BFFF41A2   LUI V0, 0xBFFF
BFD0754A  5082BFFF   LDC1 F31, 20610(RA)
BFD0754C  C0005082   ORI A0, V0, -16384
BFD07550  0008145E   LBU V0, 8(S8)
BFD07554  000C147E   LBU V1, 12(S8)
BFD07558      EE81   LI A1, 1
BFD0755A  181000A3   SLLV V1, V1, A1
BFD0755C  25281810   SB ZERO, 9512(S0)
BFD0755E      2528   SLL V0, V0, 4
BFD07560      0528   ADDU V0, A0, V0
BFD07562      E9A1   SW V1, 4(V0)
109:                     }
110:                 }
BFD07564      0FBE   MOVE SP, S8
BFD07566      4BC1   LW S8, 4(SP)
BFD07568      4C05   ADDIU SP, SP, 8
BFD0756A      459F   JR16 RA
BFD0756C      0C00   NOP
111:                 
112:                 
113:                 /* end mec14xx_jtvic.c */
114:                 /**   @}
115:                  */
116:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/mec14xx_gpio.c  ---------
1:                   /*****************************************************************************
2:                   *  2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  
22:                  /** @file mec14xx_gpio.c
23:                   *MEC14xx GPIO hardware access
24:                   */
25:                  /** @defgroup MEC14xx Peripherals GPIO
26:                   *  @{
27:                   */
28:                  
29:                  
30:                  #include "appcfg.h"
31:                  #include "platform.h"
32:                  #include "MEC14xx/mec14xx.h"
33:                  #include "MEC14xx/mec14xx_gpio.h"
34:                  
35:                  
36:                  
37:                  static uint32_t gpio_has_drv_str ( enum gpio_id_t gpio_id );
38:                  
39:                  
40:                  #ifdef ENABLE_GPIO_PIN_VALIDATION
41:                  
42:                  static const uint32_t gpio_port_bitmaps[NUM_GPIO_PORTS] = 
43:                  {
44:                      (GPIO_PORT_A_BITMAP),
45:                      (GPIO_PORT_B_BITMAP),
46:                      (GPIO_PORT_C_BITMAP),
47:                      (GPIO_PORT_D_BITMAP)
48:                  };
49:                  
50:                  #endif
51:                  
52:                  // 
53:                  // Drive Strength Register bitmap
54:                  //
55:                  static const uint32_t gpio_drv_str_bitmap[NUM_GPIO_PORTS] = 
56:                  {
57:                      (GPIO_PORT_A_DRVSTR_BITMAP),
58:                      (GPIO_PORT_B_DRVSTR_BITMAP),
59:                      (GPIO_PORT_C_DRVSTR_BITMAP),
60:                      (GPIO_PORT_D_DRVSTR_BITMAP)
61:                  };
62:                  
63:                  
64:                  struct gpio_cfg 
65:                  {
66:                     uint16_t bit_mask;
67:                     uint8_t bit_pos;
68:                  };
69:                  
70:                  static const struct gpio_cfg gpio_cfg_tbl[GPIO_PROP_MAX] = 
71:                  {
72:                     { 0x0003u, 0x00u },
73:                     { 0x000Cu, 0x02u },
74:                     { 0x00F0u, 0x04u },
75:                     { 0x0100u, 0x08u },
76:                     { 0x0200u, 0x09u },
77:                     { 0x0400u, 0x0Au },
78:                     { 0x0800u, 0x0Bu },
79:                     { 0x3000u, 0x0Cu },
80:                     { 0x3FFFu, 0x00u }
81:                  };
82:                  
83:                  static uint32_t gpio_pin_ctrl_addr(enum gpio_id_t gpio_id)
84:                  {
BFD09B28      4FB0   ADDIU SP, SP, -8
BFD09B2A      CBC1   SW S8, 4(SP)
BFD09B2C      0FDD   MOVE S8, SP
BFD09B2E  0008F89E   SW A0, 8(S8)
85:                      return ((uint32_t)(GPIO_BASE) + (uint32_t)(gpio_id << 2));
BFD09B32  0008FC5E   LW V0, 8(S8)
BFD09B36      25A4   SLL V1, V0, 2
BFD09B38  A00841A2   LUI V0, 0xA008
BFD09B3C  10005042   ORI V0, V0, 4096
BFD09B3E  05261000   ADDI ZERO, ZERO, 1318
BFD09B40      0526   ADDU V0, V1, V0
86:                  }
BFD09B42      0FBE   MOVE SP, S8
BFD09B44      4BC1   LW S8, 4(SP)
BFD09B46      4C05   ADDIU SP, SP, 8
BFD09B48      459F   JR16 RA
BFD09B4A      0C00   NOP
87:                  
88:                  #ifdef ENABLE_GPIO_PIN_VALIDATION
89:                  
90:                  /**
91:                   * gpio_is_valid - local helper checks if GPIO pin is 
92:                   * implemented in this hardware. 
93:                   * 
94:                   * @author sworley 
95:                   * 
96:                   * @param gpio_id 0-based GPIO ID
97:                   * 
98:                   * @return uint8_t Non-zero(GPIO Pin implemented), 0(not 
99:                   *         implemented).
100:                  */
101:                 static uint8_t gpio_is_valid ( enum gpio_id_t gpio_id )
102:                 {
BFD081B4      4FF9   ADDIU SP, SP, -16
BFD081B6      CBC3   SW S8, 12(SP)
BFD081B8      0FDD   MOVE S8, SP
BFD081BA  0010F89E   SW A0, 16(S8)
103:                    uint16_t gp_bank;
104:                 
105:                    gp_bank = 0;
BFD081BE  0000381E   SH ZERO, 0(S8)
106:                 
107:                    if ( (uint16_t)gpio_id < (uint16_t)(MAX_GPIO_ID) )
BFD081C2  0010FC5E   LW V0, 16(S8)
BFD081C6      2D2F   ANDI V0, V0, 0xFFFF
BFD081C8  0078B042   SLTIU V0, V0, 120
BFD081CC  001B40E2   BEQZC V0, 0xBFD08206
108:                    {
109:                       gp_bank = (uint16_t)gpio_id >> 5;
BFD081D0  0010FC5E   LW V0, 16(S8)
BFD081D4      2D2F   ANDI V0, V0, 0xFFFF
BFD081D6      252B   SRL V0, V0, 5
BFD081D8  0000385E   SH V0, 0(S8)
110:                       if ( gpio_port_bitmaps[gp_bank] & (1 << (gpio_id & 0x001Fu)) )
BFD081DC  0000347E   LHU V1, 0(S8)
BFD081E0  BFD141A2   LUI V0, 0xBFD1
BFD081E2  25B4BFD1   LDC1 F30, 9652(S1)
BFD081E4      25B4   SLL V1, V1, 2
BFD081E6  92543042   ADDIU V0, V0, -28076
BFD081E8  05269254   SLTI S2, S4, 1318
BFD081EA      0526   ADDU V0, V1, V0
BFD081EC      69A0   LW V1, 0(V0)
BFD081EE  0010FC5E   LW V0, 16(S8)
BFD081F2      2D29   ANDI V0, V0, 0x1F
BFD081F4      EE01   LI A0, 1
BFD081F6  10100082   SLLV V0, V0, A0
BFD081F8  44931010   ADDI ZERO, S0, 17555
BFD081FA      4493   AND16 V0, V1
BFD081FC  000340E2   BEQZC V0, 0xBFD08206
111:                       { 
112:                          return true;
BFD08200      ED01   LI V0, 1
BFD08202      CC02   B 0xBFD08208
BFD08204      0C00   NOP
113:                       }
114:                    }
115:                 
116:                    return false;
BFD08206      0C40   MOVE V0, ZERO
117:                 }
BFD08208      0FBE   MOVE SP, S8
BFD0820A      4BC3   LW S8, 12(SP)
BFD0820C      4C09   ADDIU SP, SP, 16
BFD0820E      459F   JR16 RA
BFD08210      0C00   NOP
118:                 
119:                 #else
120:                 static uint32_t gpio_is_valid(enum gpio_id_t gpio_id) { return true; }
121:                 
122:                 #endif
123:                 
124:                 static uint8_t gpio_bank_num(enum gpio_id_t gpio_id)
125:                 {
BFD09D2C      4FB0   ADDIU SP, SP, -8
BFD09D2E      CBC1   SW S8, 4(SP)
BFD09D30      0FDD   MOVE S8, SP
BFD09D32  0008F89E   SW A0, 8(S8)
126:                     return (uint8_t)(gpio_id) >> 5;
BFD09D36  0008FC5E   LW V0, 8(S8)
BFD09D3A      2D2D   ANDI V0, V0, 0xFF
BFD09D3C      252B   SRL V0, V0, 5
BFD09D3E      2D2D   ANDI V0, V0, 0xFF
127:                 }
BFD09D40      0FBE   MOVE SP, S8
BFD09D42      4BC1   LW S8, 4(SP)
BFD09D44      4C05   ADDIU SP, SP, 8
BFD09D46      459F   JR16 RA
BFD09D48      0C00   NOP
128:                 
129:                 
130:                 static uint8_t gpio_pin_num(enum gpio_id_t gpio_id)
131:                 {
BFD09D4C      4FB0   ADDIU SP, SP, -8
BFD09D4E      CBC1   SW S8, 4(SP)
BFD09D50      0FDD   MOVE S8, SP
BFD09D52  0008F89E   SW A0, 8(S8)
132:                     return (uint8_t)(gpio_id) & 0x1Fu;
BFD09D56  0008FC5E   LW V0, 8(S8)
BFD09D5A      2D2D   ANDI V0, V0, 0xFF
BFD09D5C      2D29   ANDI V0, V0, 0x1F
BFD09D5E      2D2D   ANDI V0, V0, 0xFF
133:                 }
BFD09D60      0FBE   MOVE SP, S8
BFD09D62      4BC1   LW S8, 4(SP)
BFD09D64      4C05   ADDIU SP, SP, 8
BFD09D66      459F   JR16 RA
BFD09D68      0C00   NOP
134:                 
135:                 
136:                 /**
137:                  * gpio_has_drv_str - Local helper to check if GPIO pin has 
138:                  * associated drive strength register. 
139:                  * 
140:                  * @author sworley 
141:                  * 
142:                  * @param gpio_id 0-based GPIO ID
143:                  * 
144:                  * @return uint32_t 0(No Drive Strength), Non-zero(Physical 
145:                  *         address of Drive Strength Register).
146:                  */
147:                 static uint32_t gpio_has_drv_str ( enum gpio_id_t gpio_id )
148:                 {
BFD06644      4FED   ADDIU SP, SP, -40
BFD06646      CBE9   SW RA, 36(SP)
BFD06648      CBC8   SW S8, 32(SP)
BFD0664A      0FDD   MOVE S8, SP
BFD0664C  0028F89E   SW A0, 40(S8)
149:                     uint32_t bank, bitpos, addr;
150:                     
151:                     addr = 0ul;
BFD06650  0010F81E   SW ZERO, 16(S8)
152:                     if ( gpio_id < MAX_GPIO_ID )
BFD06654  0028FC5E   LW V0, 40(S8)
BFD06658  0078B042   SLTIU V0, V0, 120
BFD0665C  003540E2   BEQZC V0, 0xBFD066CA
153:                     {
154:                         bank = gpio_bank_num(gpio_id);
BFD06660  0028FC9E   LW A0, 40(S8)
BFD06664  4E9677E8   JALS gpio_bank_num
BFD06666      4E96   ADDIU S4, S4, -5
BFD06668      0C00   NOP
BFD0666A  0014F85E   SW V0, 20(S8)
155:                         bitpos = gpio_pin_num(gpio_id);
BFD0666E  0028FC9E   LW A0, 40(S8)
BFD06672  4EA677E8   JALS gpio_pin_num
BFD06674      4EA6   ADDIU S5, S5, 3
BFD06676      0C00   NOP
BFD06678  0018F85E   SW V0, 24(S8)
156:                         if ( gpio_drv_str_bitmap[bank] & (1ul << bitpos) )
BFD0667C  BFD141A2   LUI V0, 0xBFD1
BFD0667E  FC7EBFD1   LDC1 F30, -898(S1)
BFD06680  0014FC7E   LW V1, 20(S8)
BFD06684      25B4   SLL V1, V1, 2
BFD06686  92643042   ADDIU V0, V0, -28060
BFD06688  05269264   SLTI S3, A0, 1318
BFD0668A      0526   ADDU V0, V1, V0
BFD0668C      69A0   LW V1, 0(V0)
BFD0668E  0018FC5E   LW V0, 24(S8)
BFD06692  10500062   SRLV V0, V0, V1
BFD06694  2D211050   ADDI V0, S0, 11553
BFD06696      2D21   ANDI V0, V0, 0x1
BFD06698      2D2D   ANDI V0, V0, 0xFF
BFD0669A  001640E2   BEQZC V0, 0xBFD066CA
157:                         {
158:                             addr = (GPIO_PCTRL2_BASE) + ((uint32_t)(gpio_id) << 2);
BFD0669E  0028FC5E   LW V0, 40(S8)
BFD066A2      25A4   SLL V1, V0, 2
BFD066A4  A00841A2   LUI V0, 0xA008
BFD066A8  15005042   ORI V0, V0, 5376
BFD066AA  05261500   LBU T0, 1318(ZERO)
BFD066AC      0526   ADDU V0, V1, V0
BFD066AE  0010F85E   SW V0, 16(S8)
159:                             if ( gpio_id > GPIO_0077_ID )
BFD066B2  0028FC5E   LW V0, 40(S8)
BFD066B6  0040B042   SLTIU V0, V0, 64
BFD066BA  000640A2   BNEZC V0, 0xBFD066CA
160:                             {
161:                                 addr -= 0x20ul;
BFD066BE  0010FC5E   LW V0, 16(S8)
BFD066C2  FFE03042   ADDIU V0, V0, -32
BFD066C4  F85EFFE0   LW RA, -1954(ZERO)
BFD066C6  0010F85E   SW V0, 16(S8)
162:                             }
163:                         }
164:                     }
165:                     
166:                     return addr;
BFD066CA  0010FC5E   LW V0, 16(S8)
167:                 }
BFD066CE      0FBE   MOVE SP, S8
BFD066D0      4BE9   LW RA, 36(SP)
BFD066D2      4BC8   LW S8, 32(SP)
BFD066D4      4C15   ADDIU SP, SP, 40
BFD066D6      459F   JR16 RA
BFD066D8      0C00   NOP
168:                 
169:                 
170:                 uint16_t GPIOGetConfig(enum gpio_id_t gpio_id)
171:                 {
BFD09558      4FF5   ADDIU SP, SP, -24
BFD0955A      CBE5   SW RA, 20(SP)
BFD0955C      CBC4   SW S8, 16(SP)
BFD0955E      0FDD   MOVE S8, SP
BFD09560  0018F89E   SW A0, 24(S8)
172:                     if (gpio_is_valid(gpio_id)) {
BFD09564  0018FC9E   LW A0, 24(S8)
BFD09568  40DA77E8   JALS gpio_is_valid
BFD0956A  0C0040DA   BGTZ K0, 0xBFD0AD6E
BFD0956C      0C00   NOP
BFD0956E  000940E2   BEQZC V0, 0xBFD09584
173:                         return  *((volatile uint16_t *)gpio_pin_ctrl_addr(gpio_id));
BFD09572  0018FC9E   LW A0, 24(S8)
BFD09576  4D9477E8   JALS gpio_pin_ctrl_addr
BFD09578      4D94   ADDIU T4, T4, -6
BFD0957A      0C00   NOP
BFD0957C      2920   LHU V0, 0(V0)
BFD0957E      2D2F   ANDI V0, V0, 0xFFFF
BFD09580      CC02   B 0xBFD09586
BFD09582      0C00   NOP
174:                     } else {
175:                         return 0u;
BFD09584      0C40   MOVE V0, ZERO
176:                     }
177:                 }
BFD09586      0FBE   MOVE SP, S8
BFD09588      4BE5   LW RA, 20(SP)
BFD0958A      4BC4   LW S8, 16(SP)
BFD0958C      4C0D   ADDIU SP, SP, 24
BFD0958E      459F   JR16 RA
BFD09590      0C00   NOP
178:                 
179:                 
180:                 void GPIOSetConfig(enum gpio_id_t gpio_id, uint16_t config)
181:                 {
BFD09298      4FF1   ADDIU SP, SP, -32
BFD0929A      CBE7   SW RA, 28(SP)
BFD0929C      CBC6   SW S8, 24(SP)
BFD0929E      0FDD   MOVE S8, SP
BFD092A0  0020F89E   SW A0, 32(S8)
BFD092A2  0C450020   CMP.LT.PH AT, ZERO
BFD092A4      0C45   MOVE V0, A1
BFD092A6  0024385E   SH V0, 36(S8)
182:                     volatile uint16_t * p;
183:                     
184:                     if (gpio_is_valid(gpio_id)) {
BFD092AA  0020FC9E   LW A0, 32(S8)
BFD092AE  40DA77E8   JALS gpio_is_valid
BFD092B0  0C0040DA   BGTZ K0, 0xBFD0AAB4
BFD092B2      0C00   NOP
BFD092B4  000C40E2   BEQZC V0, 0xBFD092D0
185:                         p = (volatile uint16_t *)gpio_pin_ctrl_addr(gpio_id);
BFD092B8  0020FC9E   LW A0, 32(S8)
BFD092BC  4D9477E8   JALS gpio_pin_ctrl_addr
BFD092BE      4D94   ADDIU T4, T4, -6
BFD092C0      0C00   NOP
BFD092C2  0010F85E   SW V0, 16(S8)
186:                         *p = config;
BFD092C6  0010FC5E   LW V0, 16(S8)
BFD092CA  0024347E   LHU V1, 36(S8)
BFD092CE      A9A0   SH V1, 0(V0)
187:                     }
188:                 }
BFD092D0      0FBE   MOVE SP, S8
BFD092D2      4BE7   LW RA, 28(SP)
BFD092D4      4BC6   LW S8, 24(SP)
BFD092D6      4C11   ADDIU SP, SP, 32
BFD092D8      459F   JR16 RA
BFD092DA      0C00   NOP
189:                 
190:                 
191:                 void GPIOConfigAndOr(enum gpio_id_t gpio_id, uint16_t and_mask, uint16_t or_mask)
192:                 {
BFD08214      4FF1   ADDIU SP, SP, -32
BFD08216      CBE7   SW RA, 28(SP)
BFD08218      CBC6   SW S8, 24(SP)
BFD0821A      0FDD   MOVE S8, SP
BFD0821C  0020F89E   SW A0, 32(S8)
BFD0821E  0C650020   MULEQ_S.W.PHR AT, ZERO, AT
BFD08220      0C65   MOVE V1, A1
BFD08222      0C46   MOVE V0, A2
BFD08224  0024387E   SH V1, 36(S8)
BFD08228  0028385E   SH V0, 40(S8)
193:                     volatile uint16_t * p;
194:                 
195:                 
196:                     if (gpio_is_valid(gpio_id)) {
BFD0822C  0020FC9E   LW A0, 32(S8)
BFD08230  40DA77E8   JALS gpio_is_valid
BFD08232  0C0040DA   BGTZ K0, 0xBFD09A36
BFD08234      0C00   NOP
BFD08236  001640E2   BEQZC V0, 0xBFD08266
197:                         p = (volatile uint16_t *)gpio_pin_ctrl_addr(gpio_id);
BFD0823A  0020FC9E   LW A0, 32(S8)
BFD0823E  4D9477E8   JALS gpio_pin_ctrl_addr
BFD08240      4D94   ADDIU T4, T4, -6
BFD08242      0C00   NOP
BFD08244  0010F85E   SW V0, 16(S8)
198:                         *p = (*p & and_mask) | or_mask;
BFD08248  0010FC5E   LW V0, 16(S8)
BFD0824C      2920   LHU V0, 0(V0)
BFD0824E      2DAF   ANDI V1, V0, 0xFFFF
BFD08250  0024345E   LHU V0, 36(S8)
BFD08254      4493   AND16 V0, V1
BFD08256      2DAF   ANDI V1, V0, 0xFFFF
BFD08258  0028345E   LHU V0, 40(S8)
BFD0825C      44D3   OR16 V0, V1
BFD0825E      2DAF   ANDI V1, V0, 0xFFFF
BFD08260  0010FC5E   LW V0, 16(S8)
BFD08264      A9A0   SH V1, 0(V0)
199:                     }
200:                 }
BFD08266      0FBE   MOVE SP, S8
BFD08268      4BE7   LW RA, 28(SP)
BFD0826A      4BC6   LW S8, 24(SP)
BFD0826C      4C11   ADDIU SP, SP, 32
BFD0826E      459F   JR16 RA
BFD08270      0C00   NOP
201:                 
202:                 
203:                 uint32_t GPIOGetControl(enum gpio_id_t gpio_id)
204:                 {
BFD09770      4FF5   ADDIU SP, SP, -24
BFD09772      CBE5   SW RA, 20(SP)
BFD09774      CBC4   SW S8, 16(SP)
BFD09776      0FDD   MOVE S8, SP
BFD09778  0018F89E   SW A0, 24(S8)
205:                     if (gpio_is_valid(gpio_id)) {
BFD0977C  0018FC9E   LW A0, 24(S8)
BFD09780  40DA77E8   JALS gpio_is_valid
BFD09782  0C0040DA   BGTZ K0, 0xBFD0AF86
BFD09784      0C00   NOP
BFD09786  000840E2   BEQZC V0, 0xBFD0979A
206:                         return *((volatile uint32_t *)gpio_pin_ctrl_addr(gpio_id));
BFD0978A  0018FC9E   LW A0, 24(S8)
BFD0978E  4D9477E8   JALS gpio_pin_ctrl_addr
BFD09790      4D94   ADDIU T4, T4, -6
BFD09792      0C00   NOP
BFD09794      6920   LW V0, 0(V0)
BFD09796      CC02   B 0xBFD0979C
BFD09798      0C00   NOP
207:                     } else {
208:                         return 0xFFFFFFFFul;
BFD0979A      ED7F   LI V0, -1
209:                     }
210:                 }
BFD0979C      0FBE   MOVE SP, S8
BFD0979E      4BE5   LW RA, 20(SP)
BFD097A0      4BC4   LW S8, 16(SP)
BFD097A2      4C0D   ADDIU SP, SP, 24
BFD097A4      459F   JR16 RA
BFD097A6      0C00   NOP
211:                 
212:                 
213:                 void GPIOSetControl(enum gpio_id_t gpio_id, uint32_t ctrl_val)
214:                 {
BFD092DC      4FF1   ADDIU SP, SP, -32
BFD092DE      CBE7   SW RA, 28(SP)
BFD092E0      CBC6   SW S8, 24(SP)
BFD092E2      0FDD   MOVE S8, SP
BFD092E4  0020F89E   SW A0, 32(S8)
BFD092E8  0024F8BE   SW A1, 36(S8)
215:                     volatile uint32_t * p;
216:                     
217:                     if (gpio_is_valid(gpio_id)) {
BFD092EC  0020FC9E   LW A0, 32(S8)
BFD092F0  40DA77E8   JALS gpio_is_valid
BFD092F2  0C0040DA   BGTZ K0, 0xBFD0AAF6
BFD092F4      0C00   NOP
BFD092F6  000C40E2   BEQZC V0, 0xBFD09312
218:                         p = (volatile uint32_t *)gpio_pin_ctrl_addr(gpio_id);
BFD092FA  0020FC9E   LW A0, 32(S8)
BFD092FE  4D9477E8   JALS gpio_pin_ctrl_addr
BFD09300      4D94   ADDIU T4, T4, -6
BFD09302      0C00   NOP
BFD09304  0010F85E   SW V0, 16(S8)
219:                         *p = ctrl_val;
BFD09308  0010FC5E   LW V0, 16(S8)
BFD0930C  0024FC7E   LW V1, 36(S8)
BFD09310      E9A0   SW V1, 0(V0)
220:                     }
221:                 }
BFD09312      0FBE   MOVE SP, S8
BFD09314      4BE7   LW RA, 28(SP)
BFD09316      4BC6   LW S8, 24(SP)
BFD09318      4C11   ADDIU SP, SP, 32
BFD0931A      459F   JR16 RA
BFD0931C      0C00   NOP
222:                 
223:                 
224:                 void GPIOControlAndOr(enum gpio_id_t gpio_id, uint32_t and_mask, uint32_t or_mask)
225:                 {
BFD08804      4FF1   ADDIU SP, SP, -32
BFD08806      CBE7   SW RA, 28(SP)
BFD08808      CBC6   SW S8, 24(SP)
BFD0880A      0FDD   MOVE S8, SP
BFD0880C  0020F89E   SW A0, 32(S8)
BFD08810  0024F8BE   SW A1, 36(S8)
BFD08814  0028F8DE   SW A2, 40(S8)
226:                     volatile uint32_t * p;
227:                 
228:                     if (gpio_is_valid(gpio_id)) {
BFD08818  0020FC9E   LW A0, 32(S8)
BFD0881C  40DA77E8   JALS gpio_is_valid
BFD0881E  0C0040DA   BGTZ K0, 0xBFD0A022
BFD08820      0C00   NOP
BFD08822  001340E2   BEQZC V0, 0xBFD0884C
229:                         p = (volatile uint32_t *)gpio_pin_ctrl_addr(gpio_id);
BFD08826  0020FC9E   LW A0, 32(S8)
BFD0882A  4D9477E8   JALS gpio_pin_ctrl_addr
BFD0882C      4D94   ADDIU T4, T4, -6
BFD0882E      0C00   NOP
BFD08830  0010F85E   SW V0, 16(S8)
230:                         *p = (*p & and_mask) | or_mask;
BFD08834  0010FC5E   LW V0, 16(S8)
BFD08838      69A0   LW V1, 0(V0)
BFD0883A  0024FC5E   LW V0, 36(S8)
BFD0883E      449A   AND16 V1, V0
BFD08840  0028FC5E   LW V0, 40(S8)
BFD08844      44DA   OR16 V1, V0
BFD08846  0010FC5E   LW V0, 16(S8)
BFD0884A      E9A0   SW V1, 0(V0)
231:                     }
232:                 }
BFD0884C      0FBE   MOVE SP, S8
BFD0884E      4BE7   LW RA, 28(SP)
BFD08850      4BC6   LW S8, 24(SP)
BFD08852      4C11   ADDIU SP, SP, 32
BFD08854      459F   JR16 RA
BFD08856      0C00   NOP
233:                 
234:                 
235:                 /**
236:                  * GPIOPropertySet - Program specified GPIO Pin configuration 
237:                  * item. 
238:                  * 
239:                  * @author sworley 
240:                  * 
241:                  * @param gpio_id 0-based GPIO ID
242:                  * @param gpio_prop enumerated GPIO Property(configuration item)
243:                  * @param prop_val new property value
244:                  */
245:                 void GPIOPropertySet ( enum gpio_id_t gpio_id, 
246:                                        enum gpio_prop_t gpio_prop,
247:                                        uint16_t prop_val
248:                                      )
249:                 {
BFD04B98      4FF1   ADDIU SP, SP, -32
BFD04B9A      CBE7   SW RA, 28(SP)
BFD04B9C      CBC6   SW S8, 24(SP)
BFD04B9E      0FDD   MOVE S8, SP
BFD04BA0  0020F89E   SW A0, 32(S8)
BFD04BA4  0024F8BE   SW A1, 36(S8)
BFD04BA8      0C46   MOVE V0, A2
BFD04BAA  0028385E   SH V0, 40(S8)
250:                     volatile uint16_t * p;
251:                     uint16_t gp_cfg;
252:                   
253:                     gp_cfg = 0u;
BFD04BAE  0010381E   SH ZERO, 16(S8)
254:                 
255:                     if ( gpio_is_valid(gpio_id) && ((uint16_t)gpio_prop < (uint16_t)GPIO_PROP_MAX) )
BFD04BB2  0020FC9E   LW A0, 32(S8)
BFD04BB6  40DA77E8   JALS gpio_is_valid
BFD04BB8  0C0040DA   BGTZ K0, 0xBFD063BC
BFD04BBA      0C00   NOP
BFD04BBC  005140E2   BEQZC V0, 0xBFD04C62
BFD04BC0  0024FC5E   LW V0, 36(S8)
BFD04BC4      2D2F   ANDI V0, V0, 0xFFFF
BFD04BC6  0009B042   SLTIU V0, V0, 9
BFD04BCA  004A40E2   BEQZC V0, 0xBFD04C62
256:                     {
257:                         p = (volatile uint16_t *)gpio_pin_ctrl_addr(gpio_id);
BFD04BCE  0020FC9E   LW A0, 32(S8)
BFD04BD2  4D9477E8   JALS gpio_pin_ctrl_addr
BFD04BD4      4D94   ADDIU T4, T4, -6
BFD04BD6      0C00   NOP
BFD04BD8  0014F85E   SW V0, 20(S8)
258:                         gp_cfg = *p;
BFD04BDC  0014FC5E   LW V0, 20(S8)
BFD04BE0      2920   LHU V0, 0(V0)
BFD04BE2  0010385E   SH V0, 16(S8)
259:                         gp_cfg &= ~(gpio_cfg_tbl[gpio_prop].bit_mask);
BFD04BE6  BFD141A2   LUI V0, 0xBFD1
BFD04BE8  FC7EBFD1   LDC1 F30, -898(S1)
BFD04BEA  0024FC7E   LW V1, 36(S8)
BFD04BEE      25B4   SLL V1, V1, 2
BFD04BF0  92743042   ADDIU V0, V0, -28044
BFD04BF2  05269274   SLTI S3, S4, 1318
BFD04BF4      0526   ADDU V0, V1, V0
BFD04BF6      2920   LHU V0, 0(V0)
BFD04BF8  3B3C0042   SEH V0, V0
BFD04BFA  44123B3C   SH T9, 17426(GP)
BFD04BFC      4412   NOT16 V0, V0
BFD04BFE  3B3C0062   SEH V1, V0
BFD04C00  3C5E3B3C   SH T9, 15454(GP)
BFD04C02  00103C5E   LH V0, 16(S8)
BFD04C06      4493   AND16 V0, V1
BFD04C08  3B3C0042   SEH V0, V0
BFD04C0A  385E3B3C   SH T9, 14430(GP)
BFD04C0C  0010385E   SH V0, 16(S8)
260:                         gp_cfg |= (prop_val << gpio_cfg_tbl[gpio_prop].bit_pos) & 
BFD04C10  0028347E   LHU V1, 40(S8)
BFD04C14  BFD141A2   LUI V0, 0xBFD1
BFD04C16  FC9EBFD1   LDC1 F30, -866(S1)
BFD04C18  0024FC9E   LW A0, 36(S8)
BFD04C1C      2644   SLL A0, A0, 2
BFD04C1E  92743042   ADDIU V0, V0, -28044
BFD04C20  05289274   SLTI S3, S4, 1320
BFD04C22      0528   ADDU V0, A0, V0
BFD04C24      0922   LBU V0, 2(V0)
BFD04C26  10100062   SLLV V0, V0, V1
BFD04C28  00621010   ADDI ZERO, S0, 98
BFD04C2A  3B3C0062   SEH V1, V0
BFD04C2C  41A23B3C   SH T9, 16802(GP)
BFD04C40  3B3C0042   SEH V0, V0
BFD04C42  44933B3C   SH T9, 17555(GP)
BFD04C44      4493   AND16 V0, V1
BFD04C46  3B3C0062   SEH V1, V0
BFD04C48  3C5E3B3C   SH T9, 15454(GP)
BFD04C4A  00103C5E   LH V0, 16(S8)
BFD04C4E      44D3   OR16 V0, V1
BFD04C50  3B3C0042   SEH V0, V0
BFD04C52  385E3B3C   SH T9, 14430(GP)
BFD04C54  0010385E   SH V0, 16(S8)
261:                                   gpio_cfg_tbl[gpio_prop].bit_mask; 
BFD04C2E  BFD141A2   LUI V0, 0xBFD1
BFD04C30  FC9EBFD1   LDC1 F30, -866(S1)
BFD04C32  0024FC9E   LW A0, 36(S8)
BFD04C36      2644   SLL A0, A0, 2
BFD04C38  92743042   ADDIU V0, V0, -28044
BFD04C3A  05289274   SLTI S3, S4, 1320
BFD04C3C      0528   ADDU V0, A0, V0
BFD04C3E      2920   LHU V0, 0(V0)
262:                         *p = gp_cfg;
BFD04C58  0014FC5E   LW V0, 20(S8)
BFD04C5C  0010347E   LHU V1, 16(S8)
BFD04C60      A9A0   SH V1, 0(V0)
263:                     }
264:                 }
BFD04C62      0FBE   MOVE SP, S8
BFD04C64      4BE7   LW RA, 28(SP)
BFD04C66      4BC6   LW S8, 24(SP)
BFD04C68      4C11   ADDIU SP, SP, 32
BFD04C6A      459F   JR16 RA
BFD04C6C      0C00   NOP
265:                 
266:                 
267:                 /**
268:                  * GPIOGetSlewRate - Return GPIO Pin Slew Rate
269:                  * 
270:                  * @author sworley 
271:                  * 
272:                  * @param gpio_id 0-based GPIO ID
273:                  * 
274:                  * @return uint8_t GPIO Pin Slew Rate: 0(Slow) or 1(Fast)
275:                  */
276:                 uint8_t GPIOGetSlewRate( enum gpio_id_t gpio_id )
277:                 {
BFD09024      4FF1   ADDIU SP, SP, -32
BFD09026      CBE7   SW RA, 28(SP)
BFD09028      CBC6   SW S8, 24(SP)
BFD0902A      0FDD   MOVE S8, SP
BFD0902C  0020F89E   SW A0, 32(S8)
278:                     uint32_t addr;
279:                     uint8_t slew;
280:                     
281:                     addr = gpio_has_drv_str(gpio_id);
BFD09030  0020FC9E   LW A0, 32(S8)
BFD09034  332277E8   JALS gpio_has_drv_str
BFD09036  0C003322   ADDIU T9, V0, 3072
BFD09038      0C00   NOP
BFD0903A  0014F85E   SW V0, 20(S8)
282:                     if ( 0ul != addr )
BFD0903E  0014FC5E   LW V0, 20(S8)
BFD09042  000940E2   BEQZC V0, 0xBFD09058
283:                     {
284:                         slew = ((*(volatile uint8_t *)addr) >> GPIO_DRV_SLEW_BITPOS) & 0x01u;
BFD09046  0014FC5E   LW V0, 20(S8)
BFD0904A      0920   LBU V0, 0(V0)
BFD0904C      2D2D   ANDI V0, V0, 0xFF
BFD0904E      2D21   ANDI V0, V0, 0x1
BFD09050  0010185E   SB V0, 16(S8)
BFD09054      CC03   B 0xBFD0905C
BFD09056      0C00   NOP
285:                     }
286:                     else
287:                     {
288:                         slew = 0u;
BFD09058  0010181E   SB ZERO, 16(S8)
289:                     }
290:                     
291:                     return slew;
BFD0905C  0010145E   LBU V0, 16(S8)
292:                 }
BFD09060      0FBE   MOVE SP, S8
BFD09062      4BE7   LW RA, 28(SP)
BFD09064      4BC6   LW S8, 24(SP)
BFD09066      4C11   ADDIU SP, SP, 32
BFD09068      459F   JR16 RA
BFD0906A      0C00   NOP
293:                 
294:                 
295:                 /**
296:                  * GPIOSetSlewRate - Program GPIO Pin's Slew Rate
297:                  * 
298:                  * @author sworley 
299:                  * 
300:                  * @param gpio_id 0-based GPIO ID
301:                  * @param slew_rate new slew rate: 0(Slow), Non-zero(Fast)
302:                  */
303:                 void GPIOSetSlewRate ( enum gpio_id_t gpio_id,
304:                                        enum gpio_slew_rate_t slew_rate )
305:                 {
BFD08600      4FF1   ADDIU SP, SP, -32
BFD08602      CBE7   SW RA, 28(SP)
BFD08604      CBC6   SW S8, 24(SP)
BFD08606      0FDD   MOVE S8, SP
BFD08608  0020F89E   SW A0, 32(S8)
BFD0860C  0024F8BE   SW A1, 36(S8)
306:                     uint32_t addr;
307:                     
308:                     addr = gpio_has_drv_str(gpio_id );
BFD08610  0020FC9E   LW A0, 32(S8)
BFD08614  332277E8   JALS gpio_has_drv_str
BFD08616  0C003322   ADDIU T9, V0, 3072
BFD08618      0C00   NOP
BFD0861A  0010F85E   SW V0, 16(S8)
309:                     if ( addr )
BFD0861E  0010FC5E   LW V0, 16(S8)
BFD08622  001240E2   BEQZC V0, 0xBFD0864A
310:                     {
311:                         *(volatile uint8_t *)addr = (*(volatile uint8_t *)addr & 
BFD08626  0010FC5E   LW V0, 16(S8)
BFD0862A  0010FC7E   LW V1, 16(S8)
BFD0862E      09B0   LBU V1, 0(V1)
BFD08630      2E3D   ANDI A0, V1, 0xFF
BFD08632  FFFE3060   ADDIU V1, ZERO, -2
BFD08634  449CFFFE   LW RA, 17564(S8)
BFD08636      449C   AND16 V1, A0
BFD08638      2E3D   ANDI A0, V1, 0xFF
BFD0863A  0024FC7E   LW V1, 36(S8)
BFD0863E      2DBD   ANDI V1, V1, 0xFF
BFD08640      2DB1   ANDI V1, V1, 0x1
BFD08642      2DBD   ANDI V1, V1, 0xFF
BFD08644      44DC   OR16 V1, A0
BFD08646      2DBD   ANDI V1, V1, 0xFF
BFD08648      89A0   SB V1, 0(V0)
312:                             ~(GPIO_DRV_SLEW_MASK)) | 
313:                             ((slew_rate << (GPIO_DRV_SLEW_BITPOS)) & (GPIO_DRV_SLEW_MASK));
314:                     }
315:                 }
BFD0864A      0FBE   MOVE SP, S8
BFD0864C      4BE7   LW RA, 28(SP)
BFD0864E      4BC6   LW S8, 24(SP)
BFD08650      4C11   ADDIU SP, SP, 32
BFD08652      459F   JR16 RA
BFD08654      0C00   NOP
316:                 
317:                 
318:                 /**
319:                  * GPIOGetDriveStr - Get GPIO Pin's Drive Strength 
320:                  * 
321:                  * @author sworley 
322:                  * 
323:                  * @param gpio_id 0-based GPIO ID
324:                  * 
325:                  * @return uint8_t Pin Drive Strength: 0=2mA, 1=4mA, 2=8mA, 
326:                  *         3=12mA.
327:                  */
328:                 uint8_t GPIOGetDriveStr ( enum gpio_id_t gpio_id )
329:                 {
BFD09594      4FF1   ADDIU SP, SP, -32
BFD09596      CBE7   SW RA, 28(SP)
BFD09598      CBC6   SW S8, 24(SP)
BFD0959A      0FDD   MOVE S8, SP
BFD0959C  0020F89E   SW A0, 32(S8)
330:                     uint32_t addr;
331:                     
332:                     addr = gpio_has_drv_str(gpio_id );
BFD095A0  0020FC9E   LW A0, 32(S8)
BFD095A4  332277E8   JALS gpio_has_drv_str
BFD095A6  0C003322   ADDIU T9, V0, 3072
BFD095A8      0C00   NOP
BFD095AA  0010F85E   SW V0, 16(S8)
333:                     if ( addr )
BFD095AE  0010FC5E   LW V0, 16(S8)
BFD095B2  000640E2   BEQZC V0, 0xBFD095C2
334:                     {
335:                         return ((*(volatile uint8_t *)addr) >> GPIO_DRV_STR_BITPOS) & (GPIO_DRV_STR_MASK);
BFD095B6  0010FC5E   LW V0, 16(S8)
BFD095BA      0920   LBU V0, 0(V0)
BFD095BC      0C40   MOVE V0, ZERO
BFD095BE      CC02   B 0xBFD095C4
BFD095C0      0C00   NOP
336:                     }
337:                     else
338:                     {
339:                         return 0u;
BFD095C2      0C40   MOVE V0, ZERO
340:                     }
341:                 }
BFD095C4      0FBE   MOVE SP, S8
BFD095C6      4BE7   LW RA, 28(SP)
BFD095C8      4BC6   LW S8, 24(SP)
BFD095CA      4C11   ADDIU SP, SP, 32
BFD095CC      459F   JR16 RA
BFD095CE      0C00   NOP
342:                 
343:                 
344:                 /**
345:                  * GPIOSetDriveStr - Program GPIO Pin's Drive Strength
346:                  * 
347:                  * @author sworley 
348:                  * 
349:                  * @param gpio_id 0-based GPIO ID
350:                  * @param drv_str enumerated drive strength: 0=2mA, 1=4mA, 
351:                  *                2=8mA, 3=12mA
352:                  */
353:                 void GPIOSetDriveStr ( enum gpio_id_t gpio_id,
354:                                        enum gpio_drv_str_t drv_str )
355:                 {
BFD07D64      4FF1   ADDIU SP, SP, -32
BFD07D66      CBE7   SW RA, 28(SP)
BFD07D68      CBC6   SW S8, 24(SP)
BFD07D6A      0FDD   MOVE S8, SP
BFD07D6C  0020F89E   SW A0, 32(S8)
BFD07D70  0024F8BE   SW A1, 36(S8)
356:                     uint32_t addr;
357:                     uint8_t r8;
358:                     
359:                     addr = gpio_has_drv_str(gpio_id);
BFD07D74  0020FC9E   LW A0, 32(S8)
BFD07D78  332277E8   JALS gpio_has_drv_str
BFD07D7A  0C003322   ADDIU T9, V0, 3072
BFD07D7C      0C00   NOP
BFD07D7E  0010F85E   SW V0, 16(S8)
360:                     if ( addr )
BFD07D82  0010FC5E   LW V0, 16(S8)
BFD07D86  001B40E2   BEQZC V0, 0xBFD07DC0
361:                     {
362:                         r8 = *(volatile uint8_t *)addr & ~(GPIO_DRV_STR_MASK);
BFD07D8A  0010FC5E   LW V0, 16(S8)
BFD07D8E      0920   LBU V0, 0(V0)
BFD07D90      2DAD   ANDI V1, V0, 0xFF
BFD07D92  FFCF3040   ADDIU V0, ZERO, -49
BFD07D94  4493FFCF   LW S8, 17555(T7)
BFD07D96      4493   AND16 V0, V1
BFD07D98  0014185E   SB V0, 20(S8)
363:                         r8 += ((drv_str << GPIO_DRV_STR_BITPOS) & GPIO_DRV_STR_MASK);
BFD07D9C  0024FC5E   LW V0, 36(S8)
BFD07DA0      2D2D   ANDI V0, V0, 0xFF
BFD07DA2      2528   SLL V0, V0, 4
BFD07DA4      2D2D   ANDI V0, V0, 0xFF
BFD07DA6  0030D042   ANDI V0, V0, 48
BFD07DAA      2DAD   ANDI V1, V0, 0xFF
BFD07DAC  0014145E   LBU V0, 20(S8)
BFD07DB0      0526   ADDU V0, V1, V0
BFD07DB2  0014185E   SB V0, 20(S8)
364:                         *(volatile uint8_t *)addr = r8;
BFD07DB6  0010FC5E   LW V0, 16(S8)
BFD07DBA  0014147E   LBU V1, 20(S8)
BFD07DBE      89A0   SB V1, 0(V0)
365:                     }
366:                 }
BFD07DC0      0FBE   MOVE SP, S8
BFD07DC2      4BE7   LW RA, 28(SP)
BFD07DC4      4BC6   LW S8, 24(SP)
BFD07DC6      4C11   ADDIU SP, SP, 32
BFD07DC8      459F   JR16 RA
BFD07DCA      0C00   NOP
367:                 
368:                 
369:                 /**
370:                  * GPIOGetDriveStrAndSlew - Return combined value representing 
371:                  * Drive Strength and Slew Rate. 
372:                  * 
373:                  * @author sworley 
374:                  * 
375:                  * @param gpio_id 0-based GPIO ID
376:                  * 
377:                  * @return uint8_t bit[0] = Slew Rate, bits[3:1]=0(Reserved), 
378:                  *         bits[5:4]=Drive Strength, bits[7:6]=0(Reserved)
379:                  */
380:                 uint8_t GPIOGetDriveStrAndSlew ( enum gpio_id_t gpio_id )
381:                 {
BFD095D0      4FF1   ADDIU SP, SP, -32
BFD095D2      CBE7   SW RA, 28(SP)
BFD095D4      CBC6   SW S8, 24(SP)
BFD095D6      0FDD   MOVE S8, SP
BFD095D8  0020F89E   SW A0, 32(S8)
382:                     uint32_t addr;
383:                     
384:                     addr = gpio_has_drv_str(gpio_id );
BFD095DC  0020FC9E   LW A0, 32(S8)
BFD095E0  332277E8   JALS gpio_has_drv_str
BFD095E2  0C003322   ADDIU T9, V0, 3072
BFD095E4      0C00   NOP
BFD095E6  0010F85E   SW V0, 16(S8)
385:                     if ( addr )
BFD095EA  0010FC5E   LW V0, 16(S8)
BFD095EE  000640E2   BEQZC V0, 0xBFD095FE
386:                     {
387:                         return (*(volatile uint8_t *)addr);
BFD095F2  0010FC5E   LW V0, 16(S8)
BFD095F6      0920   LBU V0, 0(V0)
BFD095F8      2D2D   ANDI V0, V0, 0xFF
BFD095FA      CC02   B 0xBFD09600
BFD095FC      0C00   NOP
388:                     }
389:                     else
390:                     {
391:                         return 0u;
BFD095FE      0C40   MOVE V0, ZERO
392:                     }
393:                 }
BFD09600      0FBE   MOVE SP, S8
BFD09602      4BE7   LW RA, 28(SP)
BFD09604      4BC6   LW S8, 24(SP)
BFD09606      4C11   ADDIU SP, SP, 32
BFD09608      459F   JR16 RA
BFD0960A      0C00   NOP
394:                 
395:                 
396:                 /**
397:                  * GPIOSetDriveStrAndSlew - Program GPIO Pin's drive strength 
398:                  * and slew rate. 
399:                  * 
400:                  * @author sworley 
401:                  * 
402:                  * @param gpio_id 0-based GPIO ID
403:                  * @param drv_and_slew bit[0] = Slew Rate, bits[3:1]=0(Reserved), 
404:                  *         bits[5:4]=Drive Strength, bits[7:6]=0(Reserved)
405:                  */
406:                 void GPIOSetDriveStrAndSlew ( enum gpio_id_t gpio_id,
407:                                               uint8_t drv_and_slew )
408:                 {
BFD0802C      4FF1   ADDIU SP, SP, -32
BFD0802E      CBE7   SW RA, 28(SP)
BFD08030      CBC6   SW S8, 24(SP)
BFD08032      0FDD   MOVE S8, SP
BFD08034  0020F89E   SW A0, 32(S8)
BFD08036  0C450020   CMP.LT.PH AT, ZERO
BFD08038      0C45   MOVE V0, A1
BFD0803A  0024185E   SB V0, 36(S8)
409:                     uint32_t addr;
410:                     uint8_t r8;
411:                     
412:                     addr = gpio_has_drv_str(gpio_id);
BFD0803E  0020FC9E   LW A0, 32(S8)
BFD08042  332277E8   JALS gpio_has_drv_str
BFD08044  0C003322   ADDIU T9, V0, 3072
BFD08046      0C00   NOP
BFD08048  0010F85E   SW V0, 16(S8)
413:                     if ( addr )
BFD0804C  0010FC5E   LW V0, 16(S8)
BFD08050  001840E2   BEQZC V0, 0xBFD08084
414:                     {
415:                         r8 = *(volatile uint8_t *)addr & ~(GPIO_DRV_SLEW_MASK + GPIO_DRV_STR_MASK);
BFD08054  0010FC5E   LW V0, 16(S8)
BFD08058      0920   LBU V0, 0(V0)
BFD0805A      2DAD   ANDI V1, V0, 0xFF
BFD0805C  FFCE3040   ADDIU V0, ZERO, -50
BFD0805E  4493FFCE   LW S8, 17555(T6)
BFD08060      4493   AND16 V0, V1
BFD08062  0014185E   SB V0, 20(S8)
416:                         r8 |= (drv_and_slew & (GPIO_DRV_SLEW_MASK + GPIO_DRV_STR_MASK));
BFD08066  0024145E   LBU V0, 36(S8)
BFD0806A  0031D042   ANDI V0, V0, 49
BFD0806E      2DAD   ANDI V1, V0, 0xFF
BFD08070  0014145E   LBU V0, 20(S8)
BFD08074      44D3   OR16 V0, V1
BFD08076  0014185E   SB V0, 20(S8)
417:                         *(volatile uint8_t *)addr = r8;
BFD0807A  0010FC5E   LW V0, 16(S8)
BFD0807E  0014147E   LBU V1, 20(S8)
BFD08082      89A0   SB V1, 0(V0)
418:                     }
419:                 }
BFD08084      0FBE   MOVE SP, S8
BFD08086      4BE7   LW RA, 28(SP)
BFD08088      4BC6   LW S8, 24(SP)
BFD0808A      4C11   ADDIU SP, SP, 32
BFD0808C      459F   JR16 RA
BFD0808E      0C00   NOP
420:                 
421:                 
422:                 /**
423:                  * GPIOSetOutput - Program GPIO Pin's output state using Pin 
424:                  * configuration register (not parallel output register). 
425:                  * 
426:                  * @author sworley 
427:                  * 
428:                  * @param gpio_id 0-based GPIO ID
429:                  * @param gpio_state pin state: actual pin state at pad will 
430:                  *                   depend upon GPIO Output invert
431:                  *                   configuration.
432:                  * @note peforms a byte wide write to byte offset 2 of the GPIO 
433:                  *       Pin's 32-bit configuration register. No
434:                  *       read-modify-write.
435:                  */
436:                 void GPIOSetOutput ( enum gpio_id_t gpio_id, 
437:                                      uint8_t gpio_state
438:                                      )
439:                 {
BFD08658      4FF1   ADDIU SP, SP, -32
BFD0865A      CBE7   SW RA, 28(SP)
BFD0865C      CBC6   SW S8, 24(SP)
BFD0865E      0FDD   MOVE S8, SP
BFD08660  0020F89E   SW A0, 32(S8)
BFD08662  0C450020   CMP.LT.PH AT, ZERO
BFD08664      0C45   MOVE V0, A1
BFD08666  0024185E   SB V0, 36(S8)
440:                     volatile uint8_t * p;
441:                     
442:                     if ( gpio_is_valid(gpio_id) )
BFD0866A  0020FC9E   LW A0, 32(S8)
BFD0866E  40DA77E8   JALS gpio_is_valid
BFD08670  0C0040DA   BGTZ K0, 0xBFD09E74
BFD08672      0C00   NOP
BFD08674  001540E2   BEQZC V0, 0xBFD086A2
443:                     {
444:                         p = (volatile uint8_t *)(gpio_pin_ctrl_addr(gpio_id) + 2ul);
BFD08678  0020FC9E   LW A0, 32(S8)
BFD0867C  4D9477E8   JALS gpio_pin_ctrl_addr
BFD0867E      4D94   ADDIU T4, T4, -6
BFD08680      0C00   NOP
BFD08682      4C44   ADDIU V0, V0, 2
BFD08684  0010F85E   SW V0, 16(S8)
445:                         if (gpio_state) {
BFD08688  0024145E   LBU V0, 36(S8)
BFD0868C  000640E2   BEQZC V0, 0xBFD0869C
446:                             *p = 0x01u;
BFD08690  0010FC5E   LW V0, 16(S8)
BFD08694      ED81   LI V1, 1
BFD08696      89A0   SB V1, 0(V0)
BFD08698      CC04   B 0xBFD086A2
BFD0869A      0C00   NOP
447:                         } else {
448:                             *p = 0u;
BFD0869C  0010FC5E   LW V0, 16(S8)
BFD086A0      8820   SB S0, 0(V0)
449:                         }
450:                     }
451:                 }
BFD086A2      0FBE   MOVE SP, S8
BFD086A4      4BE7   LW RA, 28(SP)
BFD086A6      4BC6   LW S8, 24(SP)
BFD086A8      4C11   ADDIU SP, SP, 32
BFD086AA      459F   JR16 RA
BFD086AC      0C00   NOP
452:                 
453:                 
454:                 void GPIOToggleOutput ( enum gpio_id_t gpio_id )
455:                 {
BFD08C5C      4FF1   ADDIU SP, SP, -32
BFD08C5E      CBE7   SW RA, 28(SP)
BFD08C60      CBC6   SW S8, 24(SP)
BFD08C62      0FDD   MOVE S8, SP
BFD08C64  0020F89E   SW A0, 32(S8)
456:                     volatile uint8_t * p;
457:                 
458:                     if ( gpio_is_valid(gpio_id) )
BFD08C68  0020FC9E   LW A0, 32(S8)
BFD08C6C  40DA77E8   JALS gpio_is_valid
BFD08C6E  0C0040DA   BGTZ K0, 0xBFD0A472
BFD08C70      0C00   NOP
BFD08C72  001240E2   BEQZC V0, 0xBFD08C9A
459:                     {
460:                         p = (volatile uint8_t *)(gpio_pin_ctrl_addr(gpio_id) + 2ul);
BFD08C76  0020FC9E   LW A0, 32(S8)
BFD08C7A  4D9477E8   JALS gpio_pin_ctrl_addr
BFD08C7C      4D94   ADDIU T4, T4, -6
BFD08C7E      0C00   NOP
BFD08C80      4C44   ADDIU V0, V0, 2
BFD08C82  0010F85E   SW V0, 16(S8)
461:                         *p ^= 0x01u;
BFD08C86  0010FC5E   LW V0, 16(S8)
BFD08C8A      0920   LBU V0, 0(V0)
BFD08C8C      2D2D   ANDI V0, V0, 0xFF
BFD08C8E  00017042   XORI V0, V0, 1
BFD08C92      2DAD   ANDI V1, V0, 0xFF
BFD08C94  0010FC5E   LW V0, 16(S8)
BFD08C98      89A0   SB V1, 0(V0)
462:                     }
463:                 }
BFD08C9A      0FBE   MOVE SP, S8
BFD08C9C      4BE7   LW RA, 28(SP)
BFD08C9E      4BC6   LW S8, 24(SP)
BFD08CA0      4C11   ADDIU SP, SP, 32
BFD08CA2      459F   JR16 RA
BFD08CA4      0C00   NOP
464:                 
465:                 
466:                 /**
467:                  * GPIOReadPin - Read GPIO Pin's Pad Input from configuration 
468:                  * register. 
469:                  * 
470:                  * @author sworley 
471:                  * 
472:                  * @param gpio_id 0-based GPIO ID.
473:                  * 
474:                  * @return uint8_t 0 or 1 depending upon the state of the GPIO 
475:                  *         pad.
476:                  * @note performs a byte read of offset 3 of the GPIO Pin's 
477:                  *       32-bit configuration register.
478:                  */
479:                 uint8_t GPIOReadPin( enum gpio_id_t gpio_id )
480:                 {
BFD0960C      4FF5   ADDIU SP, SP, -24
BFD0960E      CBE5   SW RA, 20(SP)
BFD09610      CBC4   SW S8, 16(SP)
BFD09612      0FDD   MOVE S8, SP
BFD09614  0018F89E   SW A0, 24(S8)
481:                     if ( gpio_is_valid(gpio_id) )
BFD09618  0018FC9E   LW A0, 24(S8)
BFD0961C  40DA77E8   JALS gpio_is_valid
BFD0961E  0C0040DA   BGTZ K0, 0xBFD0AE22
BFD09620      0C00   NOP
BFD09622  000A40E2   BEQZC V0, 0xBFD0963A
482:                     {
483:                         return *((volatile uint8_t *)(gpio_pin_ctrl_addr(gpio_id) + 3ul));
BFD09626  0018FC9E   LW A0, 24(S8)
BFD0962A  4D9477E8   JALS gpio_pin_ctrl_addr
BFD0962C      4D94   ADDIU T4, T4, -6
BFD0962E      0C00   NOP
BFD09630      4C46   ADDIU V0, V0, 3
BFD09632      0920   LBU V0, 0(V0)
BFD09634      2D2D   ANDI V0, V0, 0xFF
BFD09636      CC02   B 0xBFD0963C
BFD09638      0C00   NOP
484:                     } 
485:                     else 
486:                     {
487:                         return 0u;
BFD0963A      0C40   MOVE V0, ZERO
488:                     }
489:                 }
BFD0963C      0FBE   MOVE SP, S8
BFD0963E      4BE5   LW RA, 20(SP)
BFD09640      4BC4   LW S8, 16(SP)
BFD09642      4C0D   ADDIU SP, SP, 24
BFD09644      459F   JR16 RA
BFD09646      0C00   NOP
490:                 
491:                 
492:                 /** GPIOPinLock - Lock specified GPIO's control register.
493:                  *  @param enum gpio_id_t zero based GPIO ID
494:                  *  @note Lock bit is only cleared on POR. Lock registers
495:                  *  are in reverse order, first register is at top address.
496:                  *  GPIO_LOCK_BASE defined to top(first) register address.
497:                  *  */ 
498:                 void GPIOPinLock(enum gpio_id_t gpio_id)
499:                 {
BFD07ADC      4FF1   ADDIU SP, SP, -32
BFD07ADE      CBE7   SW RA, 28(SP)
BFD07AE0      CBC6   SW S8, 24(SP)
BFD07AE2      0FDD   MOVE S8, SP
BFD07AE4  0020F89E   SW A0, 32(S8)
500:                     uint32_t addr;
501:                     uint8_t bank, bitpos;
502:                 
503:                     if (gpio_is_valid(gpio_id)) {
BFD07AE8  0020FC9E   LW A0, 32(S8)
BFD07AEC  40DA77E8   JALS gpio_is_valid
BFD07AEE  0C0040DA   BGTZ K0, 0xBFD092F2
BFD07AF0      0C00   NOP
BFD07AF2  002440E2   BEQZC V0, 0xBFD07B3E
504:                         bank = gpio_bank_num(gpio_id);  // 0 - 4
BFD07AF6  0020FC9E   LW A0, 32(S8)
BFD07AFA  4E9677E8   JALS gpio_bank_num
BFD07AFC      4E96   ADDIU S4, S4, -5
BFD07AFE      0C00   NOP
BFD07B00  0010185E   SB V0, 16(S8)
505:                         bitpos = gpio_pin_num(gpio_id); // 0 - 31
BFD07B04  0020FC9E   LW A0, 32(S8)
BFD07B08  4EA677E8   JALS gpio_pin_num
BFD07B0A      4EA6   ADDIU S5, S5, 3
BFD07B0C      0C00   NOP
BFD07B0E  0011185E   SB V0, 17(S8)
506:                         addr = (uint32_t)(GPIO_LOCK_BASE) - (bank << 2);
BFD07B12  0010145E   LBU V0, 16(S8)
BFD07B16      2524   SLL V0, V0, 2
BFD07B18  A00841A3   LUI V1, 0xA008
BFD07B1C  13F05063   ORI V1, V1, 5104
BFD07B1E  052713F0   ADDI RA, S0, 1319
BFD07B20      0527   SUBU V0, V1, V0
BFD07B22  0014F85E   SW V0, 20(S8)
507:                         *(volatile uint32_t *)addr |= (1ul << bitpos);
BFD07B26  0014FC5E   LW V0, 20(S8)
BFD07B2A  0014FC7E   LW V1, 20(S8)
BFD07B2E      6A30   LW A0, 0(V1)
BFD07B30  0011147E   LBU V1, 17(S8)
BFD07B34      EE81   LI A1, 1
BFD07B36  181000A3   SLLV V1, V1, A1
BFD07B38  44DC1810   SB ZERO, 17628(S0)
BFD07B3A      44DC   OR16 V1, A0
BFD07B3C      E9A0   SW V1, 0(V0)
508:                     } 
509:                 }
BFD07B3E      0FBE   MOVE SP, S8
BFD07B40      4BE7   LW RA, 28(SP)
BFD07B42      4BC6   LW S8, 24(SP)
BFD07B44      4C11   ADDIU SP, SP, 32
BFD07B46      459F   JR16 RA
BFD07B48      0C00   NOP
510:                 
511:                 
512:                 /* end mec14xx_gpio.c */
513:                 /**   @}
514:                  */
515:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/mec14xx_bbled.c  --------
1:                   /*****************************************************************************
2:                   * Copyright 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file mec14xx_bbled.c
22:                   *MEC14xx Breating-Blinking LED definitions
23:                   */
24:                  /** @defgroup MEC14xx Peripherals BBLED
25:                   */
26:                  
27:                  #include "appcfg.h"
28:                  #include "platform.h"
29:                  #include "MEC14xx/mec14xx.h"
30:                  #include "MEC14xx/mec14xx_pcr.h"
31:                  #include "MEC14xx/mec14xx_bbled.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_bbled.h"
34:                  
35:                  #ifdef __cplusplus
36:                  extern "C" {
37:                  #endif
38:                  
39:                  
40:                  static uint32_t led_addr(uint8_t led_id) 
41:                  {
BFD09420      4FB0   ADDIU SP, SP, -8
BFD09422      CBC1   SW S8, 4(SP)
BFD09424      0FDD   MOVE S8, SP
BFD09426      0C44   MOVE V0, A0
BFD09428  0008185E   SB V0, 8(S8)
42:                      if (led_id < (LED_ID_MAX) )
BFD0942C  0008145E   LBU V0, 8(S8)
BFD09430  0003B042   SLTIU V0, V0, 3
BFD09434  000B40E2   BEQZC V0, 0xBFD0944E
43:                      {
44:                          return ((LED0_BASE) + (led_id << 8));
BFD09438  0008145E   LBU V0, 8(S8)
BFD0943C      2520   SLL V0, V0, 8
BFD0943E      0C62   MOVE V1, V0
BFD09440  A00041A2   LUI V0, 0xA000
BFD09444  B8005042   ORI V0, V0, -18432
BFD09446  0526B800   SDC1 F0, 1318(ZERO)
BFD09448      0526   ADDU V0, V1, V0
BFD0944A      CC05   B 0xBFD09456
BFD0944C      0C00   NOP
45:                      }
46:                      else
47:                      {
48:                          return (LED0_BASE);
BFD0944E  A00041A2   LUI V0, 0xA000
BFD09452  B8005042   ORI V0, V0, -18432
BFD09454  0FBEB800   SDC1 F0, 4030(ZERO)
49:                      }
50:                  }
BFD09456      0FBE   MOVE SP, S8
BFD09458      4BC1   LW S8, 4(SP)
BFD0945A      4C05   ADDIU SP, SP, 8
BFD0945C      459F   JR16 RA
BFD0945E      0C00   NOP
51:                  
52:                  #ifdef LED_ENABLE_VALID_CHECK
53:                  
54:                  static uint8_t led_is_valid(uint8_t led_id)
55:                  {
56:                      if (led_id < (LED_ID_MAX)) {
57:                          return true;
58:                      }
59:                      return false;
60:                  }
61:                  
62:                  #else
63:                  
64:                  static uint8_t led_is_valid(uint8_t led_id) { ( void ) led_id; return (MEC14XX_TRUE); }
BFD09E6C      4FB0   ADDIU SP, SP, -8
BFD09E6E      CBC1   SW S8, 4(SP)
BFD09E70      0FDD   MOVE S8, SP
BFD09E72      0C44   MOVE V0, A0
BFD09E74  0008185E   SB V0, 8(S8)
BFD09E78      ED01   LI V0, 1
BFD09E7A      0FBE   MOVE SP, S8
BFD09E7C      4BC1   LW S8, 4(SP)
BFD09E7E      4C05   ADDIU SP, SP, 8
BFD09E80      459F   JR16 RA
BFD09E82      0C00   NOP
65:                  
66:                  #endif
67:                  
68:                  
69:                  /** 
70:                      @brief MEC1404 LED are alternate functions of GPIO pins. 
71:                      @note - 
72:                          LED0 is GPIO157 Function 1
73:                          LED1 is GPIO156 Function 1
74:                          LED2 is GPIO104 Function 1
75:                  */
76:                  
77:                  static const uint8_t led_pcr_slp2_bitpos[LED_ID_MAX] = {
78:                      (PCR_EC2_LED0_SLP_BITPOS),
79:                      (PCR_EC2_LED1_SLP_BITPOS),
80:                      (PCR_EC2_LED2_SLP_BITPOS)
81:                  };
82:                  
83:                  
84:                  static const uint16_t led_gpio_tbl[LED_ID_MAX] = {
85:                      (((uint16_t)(GPIO_FUNC_1)<<8) + (uint16_t)GPIO_0157_ID),
86:                      (((uint16_t)(GPIO_FUNC_1)<<8) + (uint16_t)GPIO_0156_ID),
87:                      (((uint16_t)(GPIO_FUNC_1)<<8) + (uint16_t)GPIO_0104_ID)
88:                  };
89:                  
90:                  
91:                  
92:                  /**
93:                   * led_sleep_en - Enable/Disable gating of clocks on idle to the
94:                   * BBLED block 
95:                   *  
96:                   *
97:                   * @param uint8_t sleep_en (1=Enable sleep on idle), (0=No sleep
98:                   *                on idle).
99:                   * @param uint8_t LED ID (0-3)
100:                  * @note if LED ID > 3 no action taken.
101:                  */
102:                 void led_sleep_en(uint8_t led_id, uint8_t sleep_en)
103:                 {
BFD05D0C      4FF1   ADDIU SP, SP, -32
BFD05D0E      CBE7   SW RA, 28(SP)
BFD05D10      CBC6   SW S8, 24(SP)
BFD05D12      0FDD   MOVE S8, SP
BFD05D14      0C64   MOVE V1, A0
BFD05D16      0C45   MOVE V0, A1
BFD05D18  0020187E   SB V1, 32(S8)
BFD05D1C  0024185E   SB V0, 36(S8)
104:                     uint32_t slp_mask;
105:                     uint32_t laddr;
106:                     
107:                     slp_mask = 0ul;
BFD05D20  0010F81E   SW ZERO, 16(S8)
108:                     if ( led_is_valid(led_id) ) {
BFD05D24  0020145E   LBU V0, 32(S8)
BFD05D28      0C82   MOVE A0, V0
BFD05D2A  4F3677E8   JALS led_is_valid
BFD05D2C      4F36   ADDIU T9, T9, -5
BFD05D2E      0C00   NOP
BFD05D30  003F40E2   BEQZC V0, 0xBFD05DB2
109:                         slp_mask = (1ul << led_pcr_slp2_bitpos[led_id]);
BFD05D34  0020147E   LBU V1, 32(S8)
BFD05D38  BFD041A2   LUI V0, 0xBFD0
BFD05D3A  3042BFD0   LDC1 F30, 12354(S0)
BFD05D3C  01743042   ADDIU V0, V0, 372
BFD05D40      0526   ADDU V0, V1, V0
BFD05D42      0920   LBU V0, 0(V0)
BFD05D44      ED81   LI V1, 1
BFD05D46  10100062   SLLV V0, V0, V1
BFD05D48  F85E1010   ADDI ZERO, S0, -1954
BFD05D4A  0010F85E   SW V0, 16(S8)
110:                         if ( sleep_en ) {
BFD05D4E  0024145E   LBU V0, 36(S8)
BFD05D52  002040E2   BEQZC V0, 0xBFD05D96
111:                             PCR->EC_SLEEP_EN2 |= slp_mask;
BFD05D56  A00841A2   LUI V0, 0xA008
BFD05D5A  01005042   ORI V0, V0, 256
BFD05D5E  A00841A3   LUI V1, 0xA008
BFD05D62  01005063   ORI V1, V1, 256
BFD05D66      6A39   LW A0, 36(V1)
BFD05D68  0010FC7E   LW V1, 16(S8)
BFD05D6C      44DC   OR16 V1, A0
BFD05D6E      E9A9   SW V1, 36(V0)
112:                             laddr = led_addr(led_id);
BFD05D70  0020145E   LBU V0, 32(S8)
BFD05D74      0C82   MOVE A0, V0
BFD05D76  4A1077E8   JALS led_addr
BFD05D78      4A10   LW S0, 64(SP)
BFD05D7A      0C00   NOP
BFD05D7C  0014F85E   SW V0, 20(S8)
113:                             ((BBLED_TypeDef *)laddr)->CONFIG &= ~(0x03ul);
BFD05D80  0014FC5E   LW V0, 20(S8)
BFD05D84  0014FC7E   LW V1, 20(S8)
BFD05D88      6A30   LW A0, 0(V1)
BFD05D8A  FFFC3060   ADDIU V1, ZERO, -4
BFD05D8C  449CFFFC   LW RA, 17564(GP)
BFD05D8E      449C   AND16 V1, A0
BFD05D90      E9A0   SW V1, 0(V0)
BFD05D92      CC0F   B 0xBFD05DB2
BFD05D94      0C00   NOP
114:                         } else {
115:                             PCR->EC_SLEEP_EN2 &= ~(slp_mask);
BFD05D96  A00841A2   LUI V0, 0xA008
BFD05D9A  01005042   ORI V0, V0, 256
BFD05D9E  A00841A3   LUI V1, 0xA008
BFD05DA2  01005063   ORI V1, V1, 256
BFD05DA6      6A39   LW A0, 36(V1)
BFD05DA8  0010FC7E   LW V1, 16(S8)
BFD05DAC      441B   NOT16 V1, V1
BFD05DAE      449C   AND16 V1, A0
BFD05DB0      E9A9   SW V1, 36(V0)
116:                         }
117:                     }
118:                 }
BFD05DB2      0FBE   MOVE SP, S8
BFD05DB4      4BE7   LW RA, 28(SP)
BFD05DB6      4BC6   LW S8, 24(SP)
BFD05DB8      4C11   ADDIU SP, SP, 32
BFD05DBA      459F   JR16 RA
BFD05DBC      0C00   NOP
119:                 
120:                 
121:                 /**
122:                  * led_reset - Reset the specified LED hardware block.
123:                  * 
124:                  * @author sworley 
125:                  * 
126:                  * @param led_id 0-based LED ID 
127:                  * @note Sets the LED's soft reset bit and waits for hardware to 
128:                  *       clear it. Will wait up to 0x10000 times.
129:                  */
130:                 void led_reset(uint8_t led_id)
131:                 {
BFD07FC8      4FF1   ADDIU SP, SP, -32
BFD07FCA      CBE7   SW RA, 28(SP)
BFD07FCC      CBC6   SW S8, 24(SP)
BFD07FCE      0FDD   MOVE S8, SP
BFD07FD0      0C44   MOVE V0, A0
BFD07FD2  0020185E   SB V0, 32(S8)
132:                     uint32_t p;
133:                     uint32_t cnt;
134:                 
135:                     p = led_addr(led_id);
BFD07FD6  0020145E   LBU V0, 32(S8)
BFD07FDA      0C82   MOVE A0, V0
BFD07FDC  4A1077E8   JALS led_addr
BFD07FDE      4A10   LW S0, 64(SP)
BFD07FE0      0C00   NOP
BFD07FE2  0014F85E   SW V0, 20(S8)
136:                     ((BBLED_TypeDef *)p)->CONFIG = (LED_CFG_RESET);
BFD07FE6  0014FC5E   LW V0, 20(S8)
BFD07FEA  00803060   ADDIU V1, ZERO, 128
BFD07FEE      E9A0   SW V1, 0(V0)
137:                 
138:                     cnt = 0x100000UL;
BFD07FF0  001041A2   LUI V0, 0x10
BFD07FF4  0010F85E   SW V0, 16(S8)
139:                     while ( ((BBLED_TypeDef *)p)->CONFIG & (LED_CFG_RESET) ) {
BFD07FF8      CC0A   B 0xBFD0800E
BFD07FFA      0C00   NOP
BFD0800E  0014FC5E   LW V0, 20(S8)
BFD08012      6920   LW V0, 0(V0)
BFD08014      2D20   ANDI V0, V0, 0x80
BFD08016  FFF140A2   BNEZC V0, 0xBFD07FFC
BFD08018  CC02FFF1   LW RA, -13310(S1)
BFD0801A      CC02   B 0xBFD08020
BFD0801C      0C00   NOP
140:                         if ( cnt != 0UL ) {
BFD07FFC  0010FC5E   LW V0, 16(S8)
BFD08000  000D40E2   BEQZC V0, 0xBFD0801E
141:                             cnt--;
BFD08004  0010FC5E   LW V0, 16(S8)
BFD08008      6D2E   ADDIU V0, V0, -1
BFD0800A  0010F85E   SW V0, 16(S8)
142:                         } else {
143:                             break;
BFD0801E      0C00   NOP
144:                         }
145:                     }
146:                 } 
BFD08020      0FBE   MOVE SP, S8
BFD08022      4BE7   LW RA, 28(SP)
BFD08024      4BC6   LW S8, 24(SP)
BFD08026      4C11   ADDIU SP, SP, 32
BFD08028      459F   JR16 RA
BFD0802A      0C00   NOP
147:                 
148:                 
149:                 uint8_t led_get_gpio_num(uint8_t led_id)
150:                 {
BFD099EC      4FB0   ADDIU SP, SP, -8
BFD099EE      CBC1   SW S8, 4(SP)
BFD099F0      0FDD   MOVE S8, SP
BFD099F2      0C44   MOVE V0, A0
BFD099F4  0008185E   SB V0, 8(S8)
151:                     return led_gpio_tbl[(led_id & ((LED_ID_MAX)-1u))];
BFD099F8  0008145E   LBU V0, 8(S8)
BFD099FC      2DA2   ANDI V1, V0, 0x2
BFD099FE  BFD041A2   LUI V0, 0xBFD0
BFD09A00  25B2BFD0   LDC1 F30, 9650(S0)
BFD09A02      25B2   SLL V1, V1, 1
BFD09A04  01783042   ADDIU V0, V0, 376
BFD09A08      0526   ADDU V0, V1, V0
BFD09A0A      2920   LHU V0, 0(V0)
BFD09A0C      2D2D   ANDI V0, V0, 0xFF
152:                 }
BFD09A0E      0FBE   MOVE SP, S8
BFD09A10      4BC1   LW S8, 4(SP)
BFD09A12      4C05   ADDIU SP, SP, 8
BFD09A14      459F   JR16 RA
BFD09A16      0C00   NOP
153:                 
154:                 
155:                 /**
156:                  * led_init - Initialize the specified LED 
157:                  * 
158:                  * @author sworley 
159:                  * 
160:                  * @param led_id 0-based LED ID 
161:                  * @note Configures the LED's GPIO pin for LED function and then 
162:                  *       peforms a soft reset of the LED hardware.
163:                  */
164:                 void led_init(uint8_t led_id)
165:                 {
BFD07CFC      4FF1   ADDIU SP, SP, -32
BFD07CFE      CBE7   SW RA, 28(SP)
BFD07D00      CBC6   SW S8, 24(SP)
BFD07D02      0FDD   MOVE S8, SP
BFD07D04      0C44   MOVE V0, A0
BFD07D06  0020185E   SB V0, 32(S8)
166:                     uint16_t ledi;
167:                 
168:                     if ( led_id < LED_ID_MAX )
BFD07D0A  0020145E   LBU V0, 32(S8)
BFD07D0E  0003B042   SLTIU V0, V0, 3
BFD07D12  002040E2   BEQZC V0, 0xBFD07D56
169:                     {
170:                         /* bits[7:0] = GPIO_ID, bits[15:8] = GPIO Function */
171:                         ledi = led_gpio_tbl[led_id];
BFD07D16  0020147E   LBU V1, 32(S8)
BFD07D1A  BFD041A2   LUI V0, 0xBFD0
BFD07D1C  25B2BFD0   LDC1 F30, 9650(S0)
BFD07D1E      25B2   SLL V1, V1, 1
BFD07D20  01783042   ADDIU V0, V0, 376
BFD07D24      0526   ADDU V0, V1, V0
BFD07D26      2920   LHU V0, 0(V0)
BFD07D28  0010385E   SH V0, 16(S8)
172:                         GPIOPropertySet((ledi & 0xFF), GPIO_PROP_MUX_SEL, (ledi >> 8) & 0xFF);
BFD07D2C  0010345E   LHU V0, 16(S8)
BFD07D30      2D2D   ANDI V0, V0, 0xFF
BFD07D32      0C62   MOVE V1, V0
BFD07D34  0010345E   LHU V0, 16(S8)
BFD07D38      2521   SRL V0, V0, 8
BFD07D3A      2D2F   ANDI V0, V0, 0xFFFF
BFD07D3C      0C83   MOVE A0, V1
BFD07D3E      EE87   LI A1, 7
BFD07D40      0CC2   MOVE A2, V0
BFD07D42  25CC77E8   JALS GPIOPropertySet
BFD07D44      25CC   SLL V1, A0, 6
BFD07D46      0C00   NOP
173:                         led_reset(ledi & 0xFF);
BFD07D48  0010345E   LHU V0, 16(S8)
BFD07D4C      2D2D   ANDI V0, V0, 0xFF
BFD07D4E      0C82   MOVE A0, V0
BFD07D50  3FE477E8   JALS led_reset
BFD07D52  0C003FE4   LH RA, 3072(A0)
BFD07D54      0C00   NOP
174:                     }
175:                 }
BFD07D56      0FBE   MOVE SP, S8
BFD07D58      4BE7   LW RA, 28(SP)
BFD07D5A      4BC6   LW S8, 24(SP)
BFD07D5C      4C11   ADDIU SP, SP, 32
BFD07D5E      459F   JR16 RA
BFD07D60      0C00   NOP
176:                 
177:                 
178:                 /**
179:                  * led_mode_blink - Enable LED hardware blink
180:                  * 
181:                  * @author sworley 
182:                  * 
183:                  * @param led_id 0-based LED ID
184:                  * @param duty_cycle duty cycle (0x80 = 50%)
185:                  * @param prescale sets the blink frequency 
186:                  * @note Blink frequency is (32768 * 255)/(prescale + 1) Hz
187:                  */
188:                 void led_mode_blink(uint8_t led_id,
189:                                     uint8_t duty_cycle,
190:                                     uint16_t prescale)
191:                 {
BFD07914      4FF1   ADDIU SP, SP, -32
BFD07916      CBE7   SW RA, 28(SP)
BFD07918      CBC6   SW S8, 24(SP)
BFD0791A      0FDD   MOVE S8, SP
BFD0791C      0C65   MOVE V1, A1
BFD0791E      0C46   MOVE V0, A2
BFD07920  0020189E   SB A0, 32(S8)
BFD07924  0024187E   SB V1, 36(S8)
BFD07928  0028385E   SH V0, 40(S8)
192:                     uint32_t pLed;
193:                 
194:                     pLed = 0UL;
BFD0792C  0010F81E   SW ZERO, 16(S8)
195:                 
196:                     if (led_is_valid(led_id)) {
BFD07930  0020145E   LBU V0, 32(S8)
BFD07934      0C82   MOVE A0, V0
BFD07936  4F3677E8   JALS led_is_valid
BFD07938      4F36   ADDIU T9, T9, -5
BFD0793A      0C00   NOP
BFD0793C  001E40E2   BEQZC V0, 0xBFD0797C
197:                         pLed = led_addr(led_id);
BFD07940  0020145E   LBU V0, 32(S8)
BFD07944      0C82   MOVE A0, V0
BFD07946  4A1077E8   JALS led_addr
BFD07948      4A10   LW S0, 64(SP)
BFD0794A      0C00   NOP
BFD0794C  0010F85E   SW V0, 16(S8)
198:                 
199:                         ((BBLED_TypeDef *)pLed)->CONFIG = LED_CFG_CNTL_BLINK;
BFD07950  0010FC5E   LW V0, 16(S8)
BFD07954      ED82   LI V1, 2
BFD07956      E9A0   SW V1, 0(V0)
200:                         ((BBLED_TypeDef *)pLed)->LIMIT = (uint32_t)duty_cycle;
BFD07958  0010FC5E   LW V0, 16(S8)
BFD0795C  0024147E   LBU V1, 36(S8)
BFD07960      E9A1   SW V1, 4(V0)
201:                         ((BBLED_TypeDef *)pLed)->DELAY = (uint32_t)prescale;
BFD07962  0010FC5E   LW V0, 16(S8)
BFD07966  0028347E   LHU V1, 40(S8)
BFD0796A      E9A2   SW V1, 8(V0)
202:                         ((BBLED_TypeDef *)pLed)->CONFIG |= (LED_CFG_EN_UPDATE);
BFD0796C  0010FC5E   LW V0, 16(S8)
BFD07970  0010FC7E   LW V1, 16(S8)
BFD07974      69B0   LW V1, 0(V1)
BFD07976  00405063   ORI V1, V1, 64
BFD0797A      E9A0   SW V1, 0(V0)
203:                     }
204:                 }
BFD0797C      0FBE   MOVE SP, S8
BFD0797E      4BE7   LW RA, 28(SP)
BFD07980      4BC6   LW S8, 24(SP)
BFD07982      4C11   ADDIU SP, SP, 32
BFD07984      459F   JR16 RA
BFD07986      0C00   NOP
205:                 
206:                 
207:                 /**
208:                  * led_out_toggle - Toggle the LED output pin.
209:                  * 
210:                  * @author sworley 
211:                  * 
212:                  * @param led_id 0-based LED ID.
213:                  */
214:                 void led_out_toggle(uint8_t led_id)
215:                 {
BFD085A8      4FF1   ADDIU SP, SP, -32
BFD085AA      CBE7   SW RA, 28(SP)
BFD085AC      CBC6   SW S8, 24(SP)
BFD085AE      0FDD   MOVE S8, SP
BFD085B0      0C44   MOVE V0, A0
BFD085B2  0020185E   SB V0, 32(S8)
216:                     uint32_t p;
217:                 
218:                     if (led_is_valid(led_id)) {
BFD085B6  0020145E   LBU V0, 32(S8)
BFD085BA      0C82   MOVE A0, V0
BFD085BC  4F3677E8   JALS led_is_valid
BFD085BE      4F36   ADDIU T9, T9, -5
BFD085C0      0C00   NOP
BFD085C2  001740E2   BEQZC V0, 0xBFD085F4
219:                         p = led_addr(led_id);
BFD085C6  0020145E   LBU V0, 32(S8)
BFD085CA      0C82   MOVE A0, V0
BFD085CC  4A1077E8   JALS led_addr
BFD085CE      4A10   LW S0, 64(SP)
BFD085D0      0C00   NOP
BFD085D2  0010F85E   SW V0, 16(S8)
220:                 
221:                         if (((BBLED_TypeDef *)p)->CONFIG & LED_CFG_CNTL_MASK) {
BFD085D6  0010FC5E   LW V0, 16(S8)
BFD085DA      6920   LW V0, 0(V0)
BFD085DC      2D23   ANDI V0, V0, 0x3
BFD085DE  000540E2   BEQZC V0, 0xBFD085EC
222:                             ((BBLED_TypeDef *)p)->CONFIG = LED_CFG_CNTL_LO;
BFD085E2  0010FC5E   LW V0, 16(S8)
BFD085E6      E820   SW S0, 0(V0)
BFD085E8      CC05   B 0xBFD085F4
BFD085EA      0C00   NOP
223:                         } else {
224:                             ((BBLED_TypeDef *)p)->CONFIG = LED_CFG_CNTL_HI;
BFD085EC  0010FC5E   LW V0, 16(S8)
BFD085F0      ED83   LI V1, 3
BFD085F2      E9A0   SW V1, 0(V0)
225:                         }
226:                     }
227:                 }
BFD085F4      0FBE   MOVE SP, S8
BFD085F6      4BE7   LW RA, 28(SP)
BFD085F8      4BC6   LW S8, 24(SP)
BFD085FA      4C11   ADDIU SP, SP, 32
BFD085FC      459F   JR16 RA
BFD085FE      0C00   NOP
228:                 
229:                 
230:                 /**
231:                  * led_out_high - Set the LED block to drive the pin High
232:                  * 
233:                  * @author sworley 
234:                  * 
235:                  * @param led_id 0-based LED ID 
236:                  * @note The LED controller will drive the pin High. Depending 
237:                  *       upon the external circuit the LED may be in ON or OFF
238:                  *       state.
239:                  */
240:                 void led_out_high(uint8_t led_id)
241:                 {
BFD09210      4FF1   ADDIU SP, SP, -32
BFD09212      CBE7   SW RA, 28(SP)
BFD09214      CBC6   SW S8, 24(SP)
BFD09216      0FDD   MOVE S8, SP
BFD09218      0C44   MOVE V0, A0
BFD0921A  0020185E   SB V0, 32(S8)
242:                     uint32_t p;
243:                 
244:                     if (led_is_valid(led_id)) {
BFD0921E  0020145E   LBU V0, 32(S8)
BFD09222      0C82   MOVE A0, V0
BFD09224  4F3677E8   JALS led_is_valid
BFD09226      4F36   ADDIU T9, T9, -5
BFD09228      0C00   NOP
BFD0922A  000C40E2   BEQZC V0, 0xBFD09246
245:                         p = led_addr(led_id);
BFD0922E  0020145E   LBU V0, 32(S8)
BFD09232      0C82   MOVE A0, V0
BFD09234  4A1077E8   JALS led_addr
BFD09236      4A10   LW S0, 64(SP)
BFD09238      0C00   NOP
BFD0923A  0010F85E   SW V0, 16(S8)
246:                         ((BBLED_TypeDef *)p)->CONFIG = LED_CFG_CNTL_HI;
BFD0923E  0010FC5E   LW V0, 16(S8)
BFD09242      ED83   LI V1, 3
BFD09244      E9A0   SW V1, 0(V0)
247:                     }
248:                 }
BFD09246      0FBE   MOVE SP, S8
BFD09248      4BE7   LW RA, 28(SP)
BFD0924A      4BC6   LW S8, 24(SP)
BFD0924C      4C11   ADDIU SP, SP, 32
BFD0924E      459F   JR16 RA
BFD09250      0C00   NOP
249:                 
250:                 
251:                 /**
252:                  * led_out_low - Set the LED block to drive the pin Low
253:                  * 
254:                  * @author sworley 
255:                  * 
256:                  * @param led_id 0-based LED ID 
257:                  * @note The LED controller will drive the pin Low. Depending 
258:                  *       upon the external circuit the LED may be in ON or OFF
259:                  *       state.
260:                  */
261:                 void led_out_low(uint8_t led_id)
262:                 {
BFD09460      4FF1   ADDIU SP, SP, -32
BFD09462      CBE7   SW RA, 28(SP)
BFD09464      CBC6   SW S8, 24(SP)
BFD09466      0FDD   MOVE S8, SP
BFD09468      0C44   MOVE V0, A0
BFD0946A  0020185E   SB V0, 32(S8)
263:                     uint32_t p;
264:                 
265:                     if (led_is_valid(led_id)) {
BFD0946E  0020145E   LBU V0, 32(S8)
BFD09472      0C82   MOVE A0, V0
BFD09474  4F3677E8   JALS led_is_valid
BFD09476      4F36   ADDIU T9, T9, -5
BFD09478      0C00   NOP
BFD0947A  000B40E2   BEQZC V0, 0xBFD09494
266:                         p = led_addr(led_id);
BFD0947E  0020145E   LBU V0, 32(S8)
BFD09482      0C82   MOVE A0, V0
BFD09484  4A1077E8   JALS led_addr
BFD09486      4A10   LW S0, 64(SP)
BFD09488      0C00   NOP
BFD0948A  0010F85E   SW V0, 16(S8)
267:                         ((BBLED_TypeDef *)p)->CONFIG = LED_CFG_CNTL_LO;
BFD0948E  0010FC5E   LW V0, 16(S8)
BFD09492      E820   SW S0, 0(V0)
268:                     }
269:                 }
BFD09494      0FBE   MOVE SP, S8
BFD09496      4BE7   LW RA, 28(SP)
BFD09498      4BC6   LW S8, 24(SP)
BFD0949A      4C11   ADDIU SP, SP, 32
BFD0949C      459F   JR16 RA
BFD0949E      0C00   NOP
270:                 
271:                 
272:                 #ifdef __cplusplus
273:                 }
274:                 #endif
275:                 
276:                 /* end mec14xx_bbled.h */
277:                 /**   @}
278:                  */
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq26.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2013 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq26.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  
29:                  #include "appcfg.h"
30:                  #include "platform.h"
31:                  #include "MEC14xx/mec14xx.h"
32:                  #include "MEC14xx/mec14xx_girqs.h"
33:                  #include "MEC14xx/mec14xx_gpio.h"
34:                  #include "MEC14xx/mec14xx_trace_func.h"
35:                  
36:                  
37:                  #if GIRQ26_DISAGG == 0
38:                  
39:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
40:                  girq26_isr(void)
41:                  {
BFD07408  E17C03BD   RDPGPR SP, SP
BFD0740C  00FC036E   MFC0 K1, EPC
BFD0740E  034C00FC   INS A3, GP, 13, -12
BFD07410  10FC034C   MFC0 K0, SRSCtl
BFD07412  4FF110FC   ADDI A3, GP, 20465
BFD07414      4FF1   ADDIU SP, SP, -32
BFD07416      CB67   SW K1, 28(SP)
BFD07418  00FC036C   MFC0 K1, Status
BFD0741C      CB46   SW K0, 24(SP)
BFD0741E  00FC034D   MFC0 K0, Cause
BFD07422      CB65   SW K1, 20(SP)
BFD07424  5040035A   SRL K0, K0, 10
BFD07426  037A5040   ORI V0, ZERO, 890
BFD07428  7A8C037A   INS K1, K0, 10, 6
BFD0742A  03607A8C   ADDIUPC A1, 787296
BFD0742C  204C0360   INS K1, ZERO, 1, 4
BFD0742E  036C204C   LWC2 V0, 876(T4)
BFD07430  02FC036C   MTC0 K1, Status
BFD07434      C862   SW V1, 8(SP)
BFD07436      C841   SW V0, 4(SP)
BFD07438      4866   LW V1, 24(SP)
BFD0743A      2DB7   ANDI V1, V1, 0xF
BFD0743C      CBC3   SW S8, 12(SP)
BFD0743E      0FDD   MOVE S8, SP
42:                      JTVIC_GROUP_EN_CLR->w = (1ul<<16);
BFD07440  BFFF41A2   LUI V0, 0xBFFF
BFD07442  5042BFFF   LDC1 F31, 20546(RA)
BFD07444  C50C5042   ORI V0, V0, -15092
BFD07448  000141A3   LUI V1, 0x1
BFD0744C      E9A0   SW V1, 0(V0)
43:                  }
BFD0744E      0FBE   MOVE SP, S8
BFD07450      4846   LW V0, 24(SP)
BFD07452      2D27   ANDI V0, V0, 0xF
BFD07454      4BC3   LW S8, 12(SP)
BFD07456      4862   LW V1, 8(SP)
BFD07458      4841   LW V0, 4(SP)
BFD0745A  477C0000   DI ZERO
BFD0745E  18000000   SLL ZERO, ZERO, 3
BFD07460  4B471800   SB ZERO, 19271(ZERO)
BFD07462      4B47   LW K0, 28(SP)
BFD07464      4B65   LW K1, 20(SP)
BFD07466  02FC034E   MTC0 K0, EPC
BFD0746A      4B46   LW K0, 24(SP)
BFD0746C      4C11   ADDIU SP, SP, 32
BFD0746E  12FC034C   MTC0 K0, SRSCtl
BFD07470  03BD12FC   ADDI S7, GP, 957
BFD07472  F17C03BD   WRPGPR SP, SP
BFD07474  036CF17C   JALX 0xBDF00DB0
BFD07476  02FC036C   MTC0 K1, Status
BFD07478  000002FC   SLL S7, GP, 0
BFD0747A  F37C0000   ERET
BFD0747C  0C00F37C   JALX 0xBDF03000
44:                  
45:                  #else
46:                  
47:                  void __attribute__((weak, interrupt, nomips16))
48:                  girq26_b0(void)
49:                  {
50:                      jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 0);
51:                  }
52:                  
53:                  void __attribute__((weak, interrupt, nomips16))
54:                  girq26_b1(void)
55:                  {
56:                      jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 1);
57:                  }
58:                  
59:                  void __attribute__((weak, interrupt, nomips16))
60:                  girq26_b2(void)
61:                  {
62:                      jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 2);
63:                  }
64:                  
65:                  void __attribute__((weak, interrupt, nomips16))
66:                  girq26_b3(void)
67:                  {
68:                      jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 3);
69:                  }
70:                  
71:                  void __attribute__((weak, interrupt, nomips16))
72:                  girq26_b4(void)
73:                  {
74:                      jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 4);
75:                  }
76:                  
77:                  void __attribute__((weak, interrupt, nomips16))
78:                  girq26_b5(void)
79:                  {
80:                      jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 5);
81:                  }
82:                  
83:                  void __attribute__((weak, interrupt, nomips16))
84:                  girq26_b6(void)
85:                  {
86:                      jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 6);
87:                  }
88:                  
89:                  void __attribute__((weak, interrupt, nomips16))
90:                  girq26_b7(void)
91:                  {
92:                      jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 7);
93:                  }
94:                  
95:                  void __attribute__((weak, interrupt, nomips16))
96:                  girq26_b8(void)
97:                  {
98:                      jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 8);
99:                  }
100:                 
101:                 void __attribute__((weak, interrupt, nomips16))
102:                 girq26_b9(void)
103:                 {
104:                     jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 9);
105:                 }
106:                 
107:                 void __attribute__((weak, interrupt, nomips16))
108:                 girq26_b10(void)
109:                 {
110:                     jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 10);
111:                 }
112:                 
113:                 void __attribute__((weak, interrupt, nomips16))
114:                 girq26_b11(void)
115:                 {
116:                     jtvic_dis_clr_source(MEC14xx_GIRQ26_ID, 11);
117:                 }
118:                 
119:                 
120:                 #endif
121:                 
122:                 /* end girq26.c */
123:                 /**   @}
124:                  */
125:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq25.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2013 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq25.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #if GIRQ25_DISAGG == 0
37:                  
38:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
39:                  girq25_isr(void)
40:                  {
BFD07390  E17C03BD   RDPGPR SP, SP
BFD07394  00FC036E   MFC0 K1, EPC
BFD07396  034C00FC   INS A3, GP, 13, -12
BFD07398  10FC034C   MFC0 K0, SRSCtl
BFD0739A  4FF110FC   ADDI A3, GP, 20465
BFD0739C      4FF1   ADDIU SP, SP, -32
BFD0739E      CB67   SW K1, 28(SP)
BFD073A0  00FC036C   MFC0 K1, Status
BFD073A4      CB46   SW K0, 24(SP)
BFD073A6  00FC034D   MFC0 K0, Cause
BFD073AA      CB65   SW K1, 20(SP)
BFD073AC  5040035A   SRL K0, K0, 10
BFD073AE  037A5040   ORI V0, ZERO, 890
BFD073B0  7A8C037A   INS K1, K0, 10, 6
BFD073B2  03607A8C   ADDIUPC A1, 787296
BFD073B4  204C0360   INS K1, ZERO, 1, 4
BFD073B6  036C204C   LWC2 V0, 876(T4)
BFD073B8  02FC036C   MTC0 K1, Status
BFD073BC      C862   SW V1, 8(SP)
BFD073BE      C841   SW V0, 4(SP)
BFD073C0      4866   LW V1, 24(SP)
BFD073C2      2DB7   ANDI V1, V1, 0xF
BFD073C4      CBC3   SW S8, 12(SP)
BFD073C6      0FDD   MOVE S8, SP
41:                      JTVIC_GROUP_EN_CLR->w = (1ul<<15);
BFD073C8  BFFF41A2   LUI V0, 0xBFFF
BFD073CA  5042BFFF   LDC1 F31, 20546(RA)
BFD073CC  C50C5042   ORI V0, V0, -15092
BFD073D0  80005060   ORI V1, ZERO, -32768
BFD073D4      E9A0   SW V1, 0(V0)
42:                  }
BFD073D6      0FBE   MOVE SP, S8
BFD073D8      4846   LW V0, 24(SP)
BFD073DA      2D27   ANDI V0, V0, 0xF
BFD073DC      4BC3   LW S8, 12(SP)
BFD073DE      4862   LW V1, 8(SP)
BFD073E0      4841   LW V0, 4(SP)
BFD073E2  477C0000   DI ZERO
BFD073E6  18000000   SLL ZERO, ZERO, 3
BFD073E8  4B471800   SB ZERO, 19271(ZERO)
BFD073EA      4B47   LW K0, 28(SP)
BFD073EC      4B65   LW K1, 20(SP)
BFD073EE  02FC034E   MTC0 K0, EPC
BFD073F2      4B46   LW K0, 24(SP)
BFD073F4      4C11   ADDIU SP, SP, 32
BFD073F6  12FC034C   MTC0 K0, SRSCtl
BFD073F8  03BD12FC   ADDI S7, GP, 957
BFD073FA  F17C03BD   WRPGPR SP, SP
BFD073FC  036CF17C   JALX 0xBDF00DB0
BFD073FE  02FC036C   MTC0 K1, Status
BFD07400  000002FC   SLL S7, GP, 0
BFD07402  F37C0000   ERET
BFD07404  0C00F37C   JALX 0xBDF03000
43:                  
44:                  #else
45:                  
46:                  void __attribute__((weak, interrupt, nomips16))
47:                  girq25_b0(void)
48:                  {
49:                      jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 0);
50:                  }
51:                  
52:                  void __attribute__((weak, interrupt, nomips16))
53:                  girq25_b1(void)
54:                  {
55:                      jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 1);
56:                  }
57:                  
58:                  void __attribute__((weak, interrupt, nomips16))
59:                  girq25_b2(void)
60:                  {
61:                      jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 2);
62:                  }
63:                  
64:                  void __attribute__((weak, interrupt, nomips16))
65:                  girq25_b3(void)
66:                  {
67:                      jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 3);
68:                  }
69:                  
70:                  void __attribute__((weak, interrupt, nomips16))
71:                  girq25_b4(void)
72:                  {
73:                      jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 4);
74:                  }
75:                  
76:                  void __attribute__((weak, interrupt, nomips16))
77:                  girq25_b5(void)
78:                  {
79:                      jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 5);
80:                  }
81:                  
82:                  void __attribute__((weak, interrupt, nomips16))
83:                  girq25_b6(void)
84:                  {
85:                      jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 6);
86:                  }
87:                  
88:                  void __attribute__((weak, interrupt, nomips16))
89:                  girq25_b7(void)
90:                  {
91:                      jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 7);
92:                  }
93:                  
94:                  void __attribute__((weak, interrupt, nomips16))
95:                  girq25_b8(void)
96:                  {
97:                      jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 8);
98:                  }
99:                  
100:                 void __attribute__((weak, interrupt, nomips16))
101:                 girq25_b9(void)
102:                 {
103:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 9);
104:                 }
105:                 
106:                 void __attribute__((weak, interrupt, nomips16))
107:                 girq25_b10(void)
108:                 {
109:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 10);
110:                 }
111:                 
112:                 void __attribute__((weak, interrupt, nomips16))
113:                 girq25_b11(void)
114:                 {
115:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 11);
116:                 }
117:                 
118:                 void __attribute__((weak, interrupt, nomips16))
119:                 girq25_b12(void)
120:                 {
121:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 12);
122:                 }
123:                 
124:                 void __attribute__((weak, interrupt, nomips16))
125:                 girq25_b13(void)
126:                 {
127:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 13);
128:                 }
129:                 
130:                 void __attribute__((weak, interrupt, nomips16))
131:                 girq25_b14(void)
132:                 {
133:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 14);
134:                 }
135:                 
136:                 void __attribute__((weak, interrupt, nomips16))
137:                 girq25_b15(void)
138:                 {
139:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 15);
140:                 }
141:                 
142:                 void __attribute__((weak, interrupt, nomips16))
143:                 girq25_b16(void)
144:                 {
145:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 16);
146:                 }
147:                 
148:                 void __attribute__((weak, interrupt, nomips16))
149:                 girq25_b17(void)
150:                 {
151:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 17);
152:                 }
153:                 
154:                 void __attribute__((weak, interrupt, nomips16))
155:                 girq25_b18(void)
156:                 {
157:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 18);
158:                 }
159:                 
160:                 void __attribute__((weak, interrupt, nomips16))
161:                 girq25_b19(void)
162:                 {
163:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 19);
164:                 }
165:                 
166:                 void __attribute__((weak, interrupt, nomips16))
167:                 girq25_b20(void)
168:                 {
169:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 20);
170:                 }
171:                 
172:                 void __attribute__((weak, interrupt, nomips16))
173:                 girq25_b21(void)
174:                 {
175:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 21);
176:                 }
177:                 
178:                 void __attribute__((weak, interrupt, nomips16))
179:                 girq25_b22(void)
180:                 {
181:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 22);
182:                 }
183:                 
184:                 void __attribute__((weak, interrupt, nomips16))
185:                 girq25_b23(void)
186:                 {
187:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 23);
188:                 }
189:                 
190:                 void __attribute__((weak, interrupt, nomips16))
191:                 girq25_b24(void)
192:                 {
193:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 24);
194:                 }
195:                 
196:                 void __attribute__((weak, interrupt, nomips16))
197:                 girq25_b25(void)
198:                 {
199:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 25);
200:                 }
201:                 
202:                 void __attribute__((weak, interrupt, nomips16))
203:                 girq25_b26(void)
204:                 {
205:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 26);
206:                 }
207:                 
208:                 void __attribute__((weak, interrupt, nomips16))
209:                 girq25_b27(void)
210:                 {
211:                     jtvic_dis_clr_source(MEC14xx_GIRQ25_ID, 27);
212:                 }
213:                 
214:                 
215:                 #endif
216:                 
217:                 /* end girq25.c */
218:                 /**   @}
219:                  */
220:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq24.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq24.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_bbled.h"
34:                  #include "MEC14xx/mec14xx_trace_func.h"
35:                  
36:                  
37:                  typedef void (* GIRQ24_FPVU8)(uint8_t);
38:                  
39:                  
40:                  /* MIPS M14K internal counter is connected to GIRQ24 bit[0]
41:                   * It is a simple counter which fires an interrupt when its 
42:                   * count value is equal to a match value.
43:                   * 
44:                   */
45:                   
46:                  #if GIRQ24_DISAGG == 0
47:                  
48:                  
49:                  void girq24_dflt_handler(uint8_t inum)
50:                  {
51:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ24_ID].EN_CLR = (1ul << inum);
52:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ24_ID].SOURCE = (1ul << inum);
53:                  }
54:                  
55:                  void __attribute__((weak)) m14k_counter_handler(uint8_t inum)
56:                  {
57:                      uint32_t r;
58:                  
59:                      (void) inum;
60:                  
61:                      r = _CP0_GET_COUNT();
62:                      r += (M14K_TIMER_COMPARE);
63:                      /* Write of CP0.Compare clears status in M14K */
64:                      _CP0_SET_COUNT(r);
65:                  
66:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ24_ID].SOURCE = (1ul << 0);
67:                  
68:                  }
69:                  
70:                  /*
71:                   * TODO - FreeRTOS M14K Software Interrupt 0 handler
72:                   * is vPortYieldISR in port_asm.S
73:                   * vPortYieldISR was designed to be entered directly by the
74:                   * CPU not via a higher level ISR handler.
75:                   * One work-around is to modify vPortYieldISR to do the work
76:                   * of girq24_handler below. It must determine which GIRQ24 source
77:                   * was active: M14K counter, SoftIRQ0, or SoftIRQ1.
78:                   */
79:                  void __attribute__((weak)) m14k_soft_irq0(uint8_t inum)
80:                  {
81:                      (void) inum;
82:                  
83:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ24_ID].SOURCE = (1ul << 1);
84:                  
85:                  }
86:                  
87:                  void __attribute__((weak)) m14k_soft_irq1(uint8_t inum)
88:                  {
89:                      (void) inum;
90:                  
91:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ24_ID].SOURCE = (1ul << 2);
92:                      
93:                  }
94:                  
95:                  void girq24_b_0_2( void )
96:                  {
97:                      uint32_t d;
98:                  
99:                      d = JTVIC_GIRQ->REGS[MEC14xx_GIRQ24_ID].RESULT & (GIRQ24_SRC_MASK);
100:                 
101:                     if ( d & (1ul << 0) )
102:                     {
103:                         m14k_counter_handler(0);
104:                     }
105:                 
106:                     if ( d & (1ul << 2) )
107:                     {
108:                         m14k_soft_irq1(2);
109:                     }
110:                 }
111:                 
112:                 
113:                 const GIRQ24_FPVU8 girq24_htable[GIRQ24_NUM_SOURCES] =
114:                 {
115:                     m14k_counter_handler,   /* m14k_counter_handler, */
116:                     m14k_soft_irq0,         /* m14k_soft_irq0, */
117:                     m14k_soft_irq1,         /* m14k_soft_irq1 */
118:                 };
119:                 
120:                 void __attribute__((weak, interrupt, nomips16, section(".girqs")))
121:                 girq24_isr(void)
122:                 {
123:                     uint32_t d;
124:                     uint8_t bitpos;
125:                 
126:                     d = JTVIC_GIRQ->REGS[MEC14xx_GIRQ24_ID].RESULT & (GIRQ24_SRC_MASK);
127:                     while ( 0 != d )
128:                     {
129:                         bitpos = 31 - ((uint8_t)__builtin_clz(d) & 0x1F);
130:                         (girq24_htable[bitpos])(bitpos);
131:                         d &= ~(1ul << bitpos);
132:                     }
133:                 }
134:                 
135:                 #else
136:                 
137:                 void __attribute__((weak, interrupt, nomips16))
138:                 girq24_b0(void)
139:                 {
BFD065A8  E17C03BD   RDPGPR SP, SP
BFD065AC  00FC036E   MFC0 K1, EPC
BFD065AE  034C00FC   INS A3, GP, 13, -12
BFD065B0  10FC034C   MFC0 K0, SRSCtl
BFD065B2  4FED10FC   ADDI A3, GP, 20461
BFD065B4      4FED   ADDIU SP, SP, -40
BFD065B6      CB69   SW K1, 36(SP)
BFD065B8  00FC036C   MFC0 K1, Status
BFD065BC      CB48   SW K0, 32(SP)
BFD065BE  00FC034D   MFC0 K0, Cause
BFD065C2      CB67   SW K1, 28(SP)
BFD065C4  5040035A   SRL K0, K0, 10
BFD065C6  037A5040   ORI V0, ZERO, 890
BFD065C8  7A8C037A   INS K1, K0, 10, 6
BFD065CA  03607A8C   ADDIUPC A1, 787296
BFD065CC  204C0360   INS K1, ZERO, 1, 4
BFD065CE  036C204C   LWC2 V0, 876(T4)
BFD065D0  02FC036C   MTC0 K1, Status
BFD065D4      C864   SW V1, 16(SP)
BFD065D6      C843   SW V0, 12(SP)
BFD065D8      4868   LW V1, 32(SP)
BFD065DA      2DB7   ANDI V1, V1, 0xF
BFD065DC      CBC5   SW S8, 20(SP)
BFD065DE      0FDD   MOVE S8, SP
140:                     uint32_t r;
141:                     
142:                     r = _CP0_GET_COUNT();
BFD065E0  00FC0049   MFC0 V0, Count
BFD065E4  0000F85E   SW V0, 0(S8)
143:                     r += (M14K_TIMER_COMPARE);
BFD065E8  0000FC7E   LW V1, 0(S8)
BFD065EC  00B741A2   LUI V0, 0xB7
BFD065F0  1B005042   ORI V0, V0, 6912
BFD065F2  05261B00   SB T8, 1318(ZERO)
BFD065F4      0526   ADDU V0, V1, V0
BFD065F6  0000F85E   SW V0, 0(S8)
144:                     _CP0_SET_COUNT(r);
BFD065FA  0000FC5E   LW V0, 0(S8)
BFD065FE  02FC0049   MTC0 V0, Count
BFD06600  000002FC   SLL S7, GP, 0
BFD06602  18000000   SLL ZERO, ZERO, 3
BFD06604  41A21800   SB ZERO, 16802(ZERO)
145:                 
146:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ24_ID].SOURCE = (1ul << 0);    
BFD06606  BFFF41A2   LUI V0, 0xBFFF
BFD06608  5042BFFF   LDC1 F31, 20546(RA)
BFD0660A  C0005042   ORI V0, V0, -16384
BFD0660E      ED81   LI V1, 1
BFD06610  0100F862   SW V1, 256(V0)
147:                 }
BFD06614      0FBE   MOVE SP, S8
BFD06616      4848   LW V0, 32(SP)
BFD06618      2D27   ANDI V0, V0, 0xF
BFD0661A      4BC5   LW S8, 20(SP)
BFD0661C      4864   LW V1, 16(SP)
BFD0661E      4843   LW V0, 12(SP)
BFD06620  477C0000   DI ZERO
BFD06624  18000000   SLL ZERO, ZERO, 3
BFD06626  4B491800   SB ZERO, 19273(ZERO)
BFD06628      4B49   LW K0, 36(SP)
BFD0662A      4B67   LW K1, 28(SP)
BFD0662C  02FC034E   MTC0 K0, EPC
BFD06630      4B48   LW K0, 32(SP)
BFD06632      4C15   ADDIU SP, SP, 40
BFD06634  12FC034C   MTC0 K0, SRSCtl
BFD06636  03BD12FC   ADDI S7, GP, 957
BFD06638  F17C03BD   WRPGPR SP, SP
BFD0663A  036CF17C   JALX 0xBDF00DB0
BFD0663C  02FC036C   MTC0 K1, Status
BFD0663E  000002FC   SLL S7, GP, 0
BFD06640  F37C0000   ERET
BFD06642  4FEDF37C   JALX 0xBDF13FB4
148:                 
149:                 void __attribute__((weak, interrupt, nomips16))
150:                 girq24_b1(void)
151:                 {
BFD0465C  E17C03BD   RDPGPR SP, SP
BFD04660  00FC036E   MFC0 K1, EPC
BFD04662  034C00FC   INS A3, GP, 13, -12
BFD04664  10FC034C   MFC0 K0, SRSCtl
BFD04666  4FC510FC   ADDI A3, GP, 20421
BFD04668      4FC5   ADDIU SP, SP, -120
BFD0466A      CB7D   SW K1, 116(SP)
BFD0466C  00FC036C   MFC0 K1, Status
BFD04670      CB5C   SW K0, 112(SP)
BFD04672  00FC034D   MFC0 K0, Cause
BFD04676      CB7B   SW K1, 108(SP)
BFD04678  5040035A   SRL K0, K0, 10
BFD0467A  037A5040   ORI V0, ZERO, 890
BFD0467C  7A8C037A   INS K1, K0, 10, 6
BFD0467E  03607A8C   ADDIUPC A1, 787296
BFD04680  204C0360   INS K1, ZERO, 1, 4
BFD04682  036C204C   LWC2 V0, 876(T4)
BFD04684  02FC036C   MTC0 K1, Status
BFD04688      C867   SW V1, 28(SP)
BFD0468A      C846   SW V0, 24(SP)
BFD0468C      487C   LW V1, 112(SP)
BFD0468E      2DB7   ANDI V1, V1, 0xF
BFD04690  001140A3   BNEZC V1, 0xBFD046B6
BFD04694      CBF7   SW RA, 92(SP)
BFD04696      CBD6   SW S8, 88(SP)
BFD04698      CB35   SW T9, 84(SP)
BFD0469A      CB14   SW T8, 80(SP)
BFD0469C      C9F3   SW T7, 76(SP)
BFD0469E      C9D2   SW T6, 72(SP)
BFD046A0      C9B1   SW T5, 68(SP)
BFD046A2      C990   SW T4, 64(SP)
BFD046A4      C96F   SW T3, 60(SP)
BFD046A6      C94E   SW T2, 56(SP)
BFD046A8      C92D   SW T1, 52(SP)
BFD046AA      C90C   SW T0, 48(SP)
BFD046AC      C8EB   SW A3, 44(SP)
BFD046AE      C8CA   SW A2, 40(SP)
BFD046B0      C8A9   SW A1, 36(SP)
BFD046B2      C888   SW A0, 32(SP)
BFD046B4      C825   SW AT, 20(SP)
BFD046B6      4642   MFLO V0
BFD046B8      C859   SW V0, 100(SP)
BFD046BA      4603   MFHI V1
BFD046BC      C878   SW V1, 96(SP)
BFD046BE      0FDD   MOVE S8, SP
152:                 
153:                     _CP0_BIC_CAUSE(0x100ul);
BFD046C0  01003040   ADDIU V0, ZERO, 256
BFD046C2  006D0100   PRECR.QB.PH ZERO, ZERO, T0
BFD046C4  00FC006D   MFC0 V1, Cause
BFD046C6  0C0000FC   SLL A3, GP, 1
BFD046C8      0C00   NOP
BFD046CA      4412   NOT16 V0, V0
BFD046CC      4493   AND16 V0, V1
BFD046CE  02FC004D   MTC0 V0, Cause
BFD046D0  000002FC   SLL S7, GP, 0
BFD046D2  18000000   SLL ZERO, ZERO, 3
BFD046D4  EE101800   SB ZERO, -4592(ZERO)
154:                  
155:                     jtvic_clr_source(MEC14xx_GIRQ24_ID, 1);
BFD046D6      EE10   LI A0, 16
BFD046D8      EE81   LI A1, 1
BFD046DA  44FA77E8   JALS jtvic_clr_source
BFD046DC      44FA   OR16 A3, V0
BFD046DE      0C00   NOP
156:                 }
BFD046E0      0FBE   MOVE SP, S8
BFD046E2      4859   LW V0, 100(SP)
BFD046E4  3D7C0002   MTLO V0
BFD046E6  48783D7C   LH T3, 18552(GP)
BFD046E8      4878   LW V1, 96(SP)
BFD046EA  2D7C0003   MTHI V1
BFD046EC      2D7C   ANDI V0, A3, 0x40
BFD046EE      485C   LW V0, 112(SP)
BFD046F0      2D27   ANDI V0, V0, 0xF
BFD046F2  001340A2   BNEZC V0, 0xBFD0471C
BFD046F6      4BF7   LW RA, 92(SP)
BFD046F8      4BD6   LW S8, 88(SP)
BFD046FA      4B35   LW T9, 84(SP)
BFD046FC      4B14   LW T8, 80(SP)
BFD046FE      49F3   LW T7, 76(SP)
BFD04700      49D2   LW T6, 72(SP)
BFD04702      49B1   LW T5, 68(SP)
BFD04704      4990   LW T4, 64(SP)
BFD04706      496F   LW T3, 60(SP)
BFD04708      494E   LW T2, 56(SP)
BFD0470A      492D   LW T1, 52(SP)
BFD0470C      490C   LW T0, 48(SP)
BFD0470E      48EB   LW A3, 44(SP)
BFD04710      48CA   LW A2, 40(SP)
BFD04712      48A9   LW A1, 36(SP)
BFD04714      4888   LW A0, 32(SP)
BFD04716      4867   LW V1, 28(SP)
BFD04718      4846   LW V0, 24(SP)
BFD0471A      4825   LW AT, 20(SP)
BFD0471C  477C0000   DI ZERO
BFD04720  18000000   SLL ZERO, ZERO, 3
BFD04722  4B5D1800   SB ZERO, 19293(ZERO)
BFD04724      4B5D   LW K0, 116(SP)
BFD04726      4B7B   LW K1, 108(SP)
BFD04728  02FC034E   MTC0 K0, EPC
BFD0472C      4B5C   LW K0, 112(SP)
BFD0472E      4C3D   ADDIU SP, SP, 120
BFD04730  12FC034C   MTC0 K0, SRSCtl
BFD04732  03BD12FC   ADDI S7, GP, 957
BFD04734  F17C03BD   WRPGPR SP, SP
BFD04736  036CF17C   JALX 0xBDF00DB0
BFD04738  02FC036C   MTC0 K1, Status
BFD0473A  000002FC   SLL S7, GP, 0
BFD0473C  F37C0000   ERET
BFD0473E  03BDF37C   JALX 0xBDF00EF4
157:                 
158:                 void __attribute__((weak, interrupt, nomips16))
159:                 girq24_b2(void)
160:                 {
BFD04740  E17C03BD   RDPGPR SP, SP
BFD04744  00FC036E   MFC0 K1, EPC
BFD04746  034C00FC   INS A3, GP, 13, -12
BFD04748  10FC034C   MFC0 K0, SRSCtl
BFD0474A  4FC510FC   ADDI A3, GP, 20421
BFD0474C      4FC5   ADDIU SP, SP, -120
BFD0474E      CB7D   SW K1, 116(SP)
BFD04750  00FC036C   MFC0 K1, Status
BFD04754      CB5C   SW K0, 112(SP)
BFD04756  00FC034D   MFC0 K0, Cause
BFD0475A      CB7B   SW K1, 108(SP)
BFD0475C  5040035A   SRL K0, K0, 10
BFD0475E  037A5040   ORI V0, ZERO, 890
BFD04760  7A8C037A   INS K1, K0, 10, 6
BFD04762  03607A8C   ADDIUPC A1, 787296
BFD04764  204C0360   INS K1, ZERO, 1, 4
BFD04766  036C204C   LWC2 V0, 876(T4)
BFD04768  02FC036C   MTC0 K1, Status
BFD0476C      C867   SW V1, 28(SP)
BFD0476E      C846   SW V0, 24(SP)
BFD04770      487C   LW V1, 112(SP)
BFD04772      2DB7   ANDI V1, V1, 0xF
BFD04774  001140A3   BNEZC V1, 0xBFD0479A
BFD04778      CBF7   SW RA, 92(SP)
BFD0477A      CBD6   SW S8, 88(SP)
BFD0477C      CB35   SW T9, 84(SP)
BFD0477E      CB14   SW T8, 80(SP)
BFD04780      C9F3   SW T7, 76(SP)
BFD04782      C9D2   SW T6, 72(SP)
BFD04784      C9B1   SW T5, 68(SP)
BFD04786      C990   SW T4, 64(SP)
BFD04788      C96F   SW T3, 60(SP)
BFD0478A      C94E   SW T2, 56(SP)
BFD0478C      C92D   SW T1, 52(SP)
BFD0478E      C90C   SW T0, 48(SP)
BFD04790      C8EB   SW A3, 44(SP)
BFD04792      C8CA   SW A2, 40(SP)
BFD04794      C8A9   SW A1, 36(SP)
BFD04796      C888   SW A0, 32(SP)
BFD04798      C825   SW AT, 20(SP)
BFD0479A      4642   MFLO V0
BFD0479C      C859   SW V0, 100(SP)
BFD0479E      4603   MFHI V1
BFD047A0      C878   SW V1, 96(SP)
BFD047A2      0FDD   MOVE S8, SP
161:                 
162:                     _CP0_BIC_CAUSE(0x200ul);
BFD047A4  02003040   ADDIU V0, ZERO, 512
BFD047A6  006D0200   PRECR.QB.PH ZERO, ZERO, S0
BFD047A8  00FC006D   MFC0 V1, Cause
BFD047AA  0C0000FC   SLL A3, GP, 1
BFD047AC      0C00   NOP
BFD047AE      4412   NOT16 V0, V0
BFD047B0      4493   AND16 V0, V1
BFD047B2  02FC004D   MTC0 V0, Cause
BFD047B4  000002FC   SLL S7, GP, 0
BFD047B6  18000000   SLL ZERO, ZERO, 3
BFD047B8  EE101800   SB ZERO, -4592(ZERO)
163:                 
164:                     jtvic_clr_source(MEC14xx_GIRQ24_ID, 2);
BFD047BA      EE10   LI A0, 16
BFD047BC      EE82   LI A1, 2
BFD047BE  44FA77E8   JALS jtvic_clr_source
BFD047C0      44FA   OR16 A3, V0
BFD047C2      0C00   NOP
165:                 }
BFD047C4      0FBE   MOVE SP, S8
BFD047C6      4859   LW V0, 100(SP)
BFD047C8  3D7C0002   MTLO V0
BFD047CA  48783D7C   LH T3, 18552(GP)
BFD047CC      4878   LW V1, 96(SP)
BFD047CE  2D7C0003   MTHI V1
BFD047D0      2D7C   ANDI V0, A3, 0x40
BFD047D2      485C   LW V0, 112(SP)
BFD047D4      2D27   ANDI V0, V0, 0xF
BFD047D6  001340A2   BNEZC V0, 0xBFD04800
BFD047DA      4BF7   LW RA, 92(SP)
BFD047DC      4BD6   LW S8, 88(SP)
BFD047DE      4B35   LW T9, 84(SP)
BFD047E0      4B14   LW T8, 80(SP)
BFD047E2      49F3   LW T7, 76(SP)
BFD047E4      49D2   LW T6, 72(SP)
BFD047E6      49B1   LW T5, 68(SP)
BFD047E8      4990   LW T4, 64(SP)
BFD047EA      496F   LW T3, 60(SP)
BFD047EC      494E   LW T2, 56(SP)
BFD047EE      492D   LW T1, 52(SP)
BFD047F0      490C   LW T0, 48(SP)
BFD047F2      48EB   LW A3, 44(SP)
BFD047F4      48CA   LW A2, 40(SP)
BFD047F6      48A9   LW A1, 36(SP)
BFD047F8      4888   LW A0, 32(SP)
BFD047FA      4867   LW V1, 28(SP)
BFD047FC      4846   LW V0, 24(SP)
BFD047FE      4825   LW AT, 20(SP)
BFD04800  477C0000   DI ZERO
BFD04804  18000000   SLL ZERO, ZERO, 3
BFD04806  4B5D1800   SB ZERO, 19293(ZERO)
BFD04808      4B5D   LW K0, 116(SP)
BFD0480A      4B7B   LW K1, 108(SP)
BFD0480C  02FC034E   MTC0 K0, EPC
BFD04810      4B5C   LW K0, 112(SP)
BFD04812      4C3D   ADDIU SP, SP, 120
BFD04814  12FC034C   MTC0 K0, SRSCtl
BFD04816  03BD12FC   ADDI S7, GP, 957
BFD04818  F17C03BD   WRPGPR SP, SP
BFD0481A  036CF17C   JALX 0xBDF00DB0
BFD0481C  02FC036C   MTC0 K1, Status
BFD0481E  000002FC   SLL S7, GP, 0
BFD04820  F37C0000   ERET
BFD04822  4FEDF37C   JALX 0xBDF13FB4
166:                 
167:                 #endif
168:                 
169:                 /* end girq24.c */
170:                 /**   @}
171:                  */
172:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq23.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq23.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_bbled.h"
34:                  #include "MEC14xx/mec14xx_trace_func.h"
35:                  
36:                  
37:                  typedef void (* GIRQ23_FPVU8)(uint8_t);
38:                  
39:                  #if GIRQ23_DISAGG == 0
40:                  
41:                  /*
42:                   * FreeRTOS ISR for HW timer used as RTOS tick.
43:                   * Implemented in MEC14xx FreeRTOS porting layer, port_asm.S
44:                   * It save/restores CPU context and clears HW timer interrupt 
45:                   * status in JTVIC. On each timer tick it checks if any task 
46:                   * requires service. If yes then it triggers the PendSV low 
47:                   * priority software interrupt.
48:                   * Issue:
49:                   * When aggregated girq23_isr save CPU context but this context 
50:                   * is not the same as a FreeRTOS context save. If the RTOS timer 
51:                   * is active then girq23_isr would call vPortTickInterruptHandler 
52:                   * which uses FreeRTOS portSAVE_CONTEXT macro to save RTOS + CPU 
53:                   * context. At this point you have two context saves on the stack.
54:                   * There is a problem:
55:                   * vPortTickInterruptHandler does not return but exits using 
56:                   * portRESTORE_CONTEXT. This means the context save performed 
57:                   * by aggregated girq23_isr is left on the stack. Eventually 
58:                   * a stack overflow will occur.
59:                   * 
60:                   * Solutions:
61:                   * 1. vPortTickInterruptHandler must be modified to handle scan 
62:                   *    GIRQ23 Result bits and all the respective handler. All 
63:                   *    other GIRQ23 source are called as hook functions.
64:                   *  
65:                   * 2. Do not use vPortTickInterruptHandler.
66:                   *    Modify girq23_isr here to use FreeRTOS portSAVE_CONTEXT 
67:                   *    and portRESTORE_CONTEXT macros. 
68:                   *    If RTOS timer is active interrupt then call vPortIncrementTick 
69:                   *    as vPortTickInterruptHandler does.
70:                   *    For all other GIRQ23 sources call the respective handlers.
71:                   *  
72:                   *  NOTE: for both of the above solutions a we must either:
73:                   *  A. Service one source only resulting in GIRQ23 firing multiple 
74:                   *     times if more than one source is active.
75:                   *  B. Service all active sources with RTOS Timer checked first.
76:                   *  
77:                   *  We will implement 1A with a single hook for all other sources.
78:                   *  
79:                   */
80:                  
81:                  extern void vPortIncrementTick(void);
82:                  
83:                  void girq23_dflt_handler(uint8_t inum)
84:                  {
85:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ23_ID].EN_CLR = (1ul << inum);
86:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ23_ID].SOURCE = (1ul << inum);
87:                  }
88:                  
89:                  void __attribute__((weak)) rtos_tmr_handler(uint8_t inum)
90:                  {
91:                      (void) inum;
92:                  
93:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ23_ID].SOURCE = (1ul << 4);
94:                  }
95:                  
96:                  const GIRQ23_FPVU8 girq23_htable[GIRQ23_NUM_SOURCES] =
97:                  {
98:                      girq23_dflt_handler,    /* btmr0_handler, */
99:                      girq23_dflt_handler,    /* btmr1_handler, */
100:                     girq23_dflt_handler,    /* btmr2_handler, */
101:                     girq23_dflt_handler,    /* btmr3_handler, */
102:                     vPortIncrementTick,
103:                     girq23_dflt_handler,    /* hib_tmr_handler, */
104:                     girq23_dflt_handler,    /* week_tmr_handler, */
105:                     girq23_dflt_handler,    /* week_tmr_handler, */
106:                     girq23_dflt_handler,    /* week_tmr_handler, */
107:                     girq23_dflt_handler,    /* week_tmr_handler, */
108:                     girq23_dflt_handler,    /* week_tmr_handler, */
109:                     girq23_dflt_handler,    /* vci_handler, */
110:                     girq23_dflt_handler,    /* vci_handler, */
111:                     girq23_dflt_handler,    /* vci_handler, */
112:                 };
113:                 
114:                 /* Called by FreeRTOS vPortTickInterruptHandler(girq23_isr) 
115:                  * after saving FreeRTOS context 
116:                  */
117:                 void girq23_handler(void)
118:                 {
119:                     uint32_t d;
120:                     uint8_t bitpos;
121:                 
122:                     d = JTVIC_GIRQ->REGS[MEC14xx_GIRQ23_ID].RESULT & (GIRQ23_SRC_MASK);
123:                     while ( 0 != d )
124:                     {
125:                         bitpos = 31 - ((uint8_t)__builtin_clz(d) & 0x1F);
126:                         (girq23_htable[bitpos])(bitpos);
127:                         d &= ~(1ul << bitpos);
128:                     }
129:                 }
130:                 
131:                 void __attribute__((weak, interrupt, nomips16, section(".girqs")))
132:                 girq23_isr(void)
133:                 {
134:                     uint32_t d;
135:                     uint8_t bitpos;
136:                 
137:                     d = JTVIC_GIRQ->REGS[MEC14xx_GIRQ23_ID].RESULT & (GIRQ23_SRC_MASK);
138:                     while ( 0 != d )
139:                     {
140:                         bitpos = 31 - ((uint8_t)__builtin_clz(d) & 0x1F);
141:                         (girq23_htable[bitpos])(bitpos);
142:                         d &= ~(1ul << bitpos);
143:                     }    
144:                 }
145:                 
146:                 #else
147:                 
148:                 
149:                 /* 16-bit Basic Timer 0 */
150:                 void __attribute__((weak, interrupt, nomips16))
151:                 girq23_b0(void)
152:                 {
BFD072A0  E17C03BD   RDPGPR SP, SP
BFD072A4  00FC036E   MFC0 K1, EPC
BFD072A6  034C00FC   INS A3, GP, 13, -12
BFD072A8  10FC034C   MFC0 K0, SRSCtl
BFD072AA  4FF110FC   ADDI A3, GP, 20465
BFD072AC      4FF1   ADDIU SP, SP, -32
BFD072AE      CB67   SW K1, 28(SP)
BFD072B0  00FC036C   MFC0 K1, Status
BFD072B4      CB46   SW K0, 24(SP)
BFD072B6  00FC034D   MFC0 K0, Cause
BFD072BA      CB65   SW K1, 20(SP)
BFD072BC  5040035A   SRL K0, K0, 10
BFD072BE  037A5040   ORI V0, ZERO, 890
BFD072C0  7A8C037A   INS K1, K0, 10, 6
BFD072C2  03607A8C   ADDIUPC A1, 787296
BFD072C4  204C0360   INS K1, ZERO, 1, 4
BFD072C6  036C204C   LWC2 V0, 876(T4)
BFD072C8  02FC036C   MTC0 K1, Status
BFD072CC      C862   SW V1, 8(SP)
BFD072CE      C841   SW V0, 4(SP)
BFD072D0      4866   LW V1, 24(SP)
BFD072D2      2DB7   ANDI V1, V1, 0xF
BFD072D4      CBC3   SW S8, 12(SP)
BFD072D6      0FDD   MOVE S8, SP
153:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ23_ID].SOURCE = (1ul << 0);  
BFD072D8  BFFF41A2   LUI V0, 0xBFFF
BFD072DA  5042BFFF   LDC1 F31, 20546(RA)
BFD072DC  C0005042   ORI V0, V0, -16384
BFD072E0      ED81   LI V1, 1
BFD072E2  00F0F862   SW V1, 240(V0)
154:                 }
BFD072E6      0FBE   MOVE SP, S8
BFD072E8      4846   LW V0, 24(SP)
BFD072EA      2D27   ANDI V0, V0, 0xF
BFD072EC      4BC3   LW S8, 12(SP)
BFD072EE      4862   LW V1, 8(SP)
BFD072F0      4841   LW V0, 4(SP)
BFD072F2  477C0000   DI ZERO
BFD072F6  18000000   SLL ZERO, ZERO, 3
BFD072F8  4B471800   SB ZERO, 19271(ZERO)
BFD072FA      4B47   LW K0, 28(SP)
BFD072FC      4B65   LW K1, 20(SP)
BFD072FE  02FC034E   MTC0 K0, EPC
BFD07302      4B46   LW K0, 24(SP)
BFD07304      4C11   ADDIU SP, SP, 32
BFD07306  12FC034C   MTC0 K0, SRSCtl
BFD07308  03BD12FC   ADDI S7, GP, 957
BFD0730A  F17C03BD   WRPGPR SP, SP
BFD0730C  036CF17C   JALX 0xBDF00DB0
BFD0730E  02FC036C   MTC0 K1, Status
BFD07310  000002FC   SLL S7, GP, 0
BFD07312  F37C0000   ERET
BFD07314  0C00F37C   JALX 0xBDF03000
155:                 
156:                 /* 16-bit Basic Timer 1 */
157:                 void __attribute__((weak, interrupt, nomips16))
158:                 girq23_b1(void)
159:                 {
BFD04C70  E17C03BD   RDPGPR SP, SP
BFD04C74  00FC036E   MFC0 K1, EPC
BFD04C76  034C00FC   INS A3, GP, 13, -12
BFD04C78  10FC034C   MFC0 K0, SRSCtl
BFD04C7A  4FC510FC   ADDI A3, GP, 20421
BFD04C7C      4FC5   ADDIU SP, SP, -120
BFD04C7E      CB7D   SW K1, 116(SP)
BFD04C80  00FC036C   MFC0 K1, Status
BFD04C84      CB5C   SW K0, 112(SP)
BFD04C86  00FC034D   MFC0 K0, Cause
BFD04C8A      CB7B   SW K1, 108(SP)
BFD04C8C  5040035A   SRL K0, K0, 10
BFD04C8E  037A5040   ORI V0, ZERO, 890
BFD04C90  7A8C037A   INS K1, K0, 10, 6
BFD04C92  03607A8C   ADDIUPC A1, 787296
BFD04C94  204C0360   INS K1, ZERO, 1, 4
BFD04C96  036C204C   LWC2 V0, 876(T4)
BFD04C98  02FC036C   MTC0 K1, Status
BFD04C9C      C867   SW V1, 28(SP)
BFD04C9E      C846   SW V0, 24(SP)
BFD04CA0      487C   LW V1, 112(SP)
BFD04CA2      2DB7   ANDI V1, V1, 0xF
BFD04CA4  001140A3   BNEZC V1, 0xBFD04CCA
BFD04CA8      CBF7   SW RA, 92(SP)
BFD04CAA      CBD6   SW S8, 88(SP)
BFD04CAC      CB35   SW T9, 84(SP)
BFD04CAE      CB14   SW T8, 80(SP)
BFD04CB0      C9F3   SW T7, 76(SP)
BFD04CB2      C9D2   SW T6, 72(SP)
BFD04CB4      C9B1   SW T5, 68(SP)
BFD04CB6      C990   SW T4, 64(SP)
BFD04CB8      C96F   SW T3, 60(SP)
BFD04CBA      C94E   SW T2, 56(SP)
BFD04CBC      C92D   SW T1, 52(SP)
BFD04CBE      C90C   SW T0, 48(SP)
BFD04CC0      C8EB   SW A3, 44(SP)
BFD04CC2      C8CA   SW A2, 40(SP)
BFD04CC4      C8A9   SW A1, 36(SP)
BFD04CC6      C888   SW A0, 32(SP)
BFD04CC8      C825   SW AT, 20(SP)
BFD04CCA      4642   MFLO V0
BFD04CCC      C859   SW V0, 100(SP)
BFD04CCE      4603   MFHI V1
BFD04CD0      C878   SW V1, 96(SP)
BFD04CD2      0FDD   MOVE S8, SP
160:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 1, TRUE);
BFD04CD4      EE0F   LI A0, 15
BFD04CD6      EE81   LI A1, 1
BFD04CD8      EF01   LI A2, 1
BFD04CDA  3A4077E8   JALS jtvic_dis_clr_source
BFD04CDC  0C003A40   SH S2, 3072(ZERO)
BFD04CDE      0C00   NOP
161:                 }
BFD04CE0      0FBE   MOVE SP, S8
BFD04CE2      4859   LW V0, 100(SP)
BFD04CE4  3D7C0002   MTLO V0
BFD04CE6  48783D7C   LH T3, 18552(GP)
BFD04CE8      4878   LW V1, 96(SP)
BFD04CEA  2D7C0003   MTHI V1
BFD04CEC      2D7C   ANDI V0, A3, 0x40
BFD04CEE      485C   LW V0, 112(SP)
BFD04CF0      2D27   ANDI V0, V0, 0xF
BFD04CF2  001340A2   BNEZC V0, 0xBFD04D1C
BFD04CF6      4BF7   LW RA, 92(SP)
BFD04CF8      4BD6   LW S8, 88(SP)
BFD04CFA      4B35   LW T9, 84(SP)
BFD04CFC      4B14   LW T8, 80(SP)
BFD04CFE      49F3   LW T7, 76(SP)
BFD04D00      49D2   LW T6, 72(SP)
BFD04D02      49B1   LW T5, 68(SP)
BFD04D04      4990   LW T4, 64(SP)
BFD04D06      496F   LW T3, 60(SP)
BFD04D08      494E   LW T2, 56(SP)
BFD04D0A      492D   LW T1, 52(SP)
BFD04D0C      490C   LW T0, 48(SP)
BFD04D0E      48EB   LW A3, 44(SP)
BFD04D10      48CA   LW A2, 40(SP)
BFD04D12      48A9   LW A1, 36(SP)
BFD04D14      4888   LW A0, 32(SP)
BFD04D16      4867   LW V1, 28(SP)
BFD04D18      4846   LW V0, 24(SP)
BFD04D1A      4825   LW AT, 20(SP)
BFD04D1C  477C0000   DI ZERO
BFD04D20  18000000   SLL ZERO, ZERO, 3
BFD04D22  4B5D1800   SB ZERO, 19293(ZERO)
BFD04D24      4B5D   LW K0, 116(SP)
BFD04D26      4B7B   LW K1, 108(SP)
BFD04D28  02FC034E   MTC0 K0, EPC
BFD04D2C      4B5C   LW K0, 112(SP)
BFD04D2E      4C3D   ADDIU SP, SP, 120
BFD04D30  12FC034C   MTC0 K0, SRSCtl
BFD04D32  03BD12FC   ADDI S7, GP, 957
BFD04D34  F17C03BD   WRPGPR SP, SP
BFD04D36  036CF17C   JALX 0xBDF00DB0
BFD04D38  02FC036C   MTC0 K1, Status
BFD04D3A  000002FC   SLL S7, GP, 0
BFD04D3C  F37C0000   ERET
BFD04D3E  03BDF37C   JALX 0xBDF00EF4
162:                 
163:                 /* 16-bit Basic Timer 2 */
164:                 void __attribute__((weak, interrupt, nomips16))
165:                 girq23_b2(void)
166:                 {
BFD04D40  E17C03BD   RDPGPR SP, SP
BFD04D44  00FC036E   MFC0 K1, EPC
BFD04D46  034C00FC   INS A3, GP, 13, -12
BFD04D48  10FC034C   MFC0 K0, SRSCtl
BFD04D4A  4FC510FC   ADDI A3, GP, 20421
BFD04D4C      4FC5   ADDIU SP, SP, -120
BFD04D4E      CB7D   SW K1, 116(SP)
BFD04D50  00FC036C   MFC0 K1, Status
BFD04D54      CB5C   SW K0, 112(SP)
BFD04D56  00FC034D   MFC0 K0, Cause
BFD04D5A      CB7B   SW K1, 108(SP)
BFD04D5C  5040035A   SRL K0, K0, 10
BFD04D5E  037A5040   ORI V0, ZERO, 890
BFD04D60  7A8C037A   INS K1, K0, 10, 6
BFD04D62  03607A8C   ADDIUPC A1, 787296
BFD04D64  204C0360   INS K1, ZERO, 1, 4
BFD04D66  036C204C   LWC2 V0, 876(T4)
BFD04D68  02FC036C   MTC0 K1, Status
BFD04D6C      C867   SW V1, 28(SP)
BFD04D6E      C846   SW V0, 24(SP)
BFD04D70      487C   LW V1, 112(SP)
BFD04D72      2DB7   ANDI V1, V1, 0xF
BFD04D74  001140A3   BNEZC V1, 0xBFD04D9A
BFD04D78      CBF7   SW RA, 92(SP)
BFD04D7A      CBD6   SW S8, 88(SP)
BFD04D7C      CB35   SW T9, 84(SP)
BFD04D7E      CB14   SW T8, 80(SP)
BFD04D80      C9F3   SW T7, 76(SP)
BFD04D82      C9D2   SW T6, 72(SP)
BFD04D84      C9B1   SW T5, 68(SP)
BFD04D86      C990   SW T4, 64(SP)
BFD04D88      C96F   SW T3, 60(SP)
BFD04D8A      C94E   SW T2, 56(SP)
BFD04D8C      C92D   SW T1, 52(SP)
BFD04D8E      C90C   SW T0, 48(SP)
BFD04D90      C8EB   SW A3, 44(SP)
BFD04D92      C8CA   SW A2, 40(SP)
BFD04D94      C8A9   SW A1, 36(SP)
BFD04D96      C888   SW A0, 32(SP)
BFD04D98      C825   SW AT, 20(SP)
BFD04D9A      4642   MFLO V0
BFD04D9C      C859   SW V0, 100(SP)
BFD04D9E      4603   MFHI V1
BFD04DA0      C878   SW V1, 96(SP)
BFD04DA2      0FDD   MOVE S8, SP
167:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 2, TRUE);
BFD04DA4      EE0F   LI A0, 15
BFD04DA6      EE82   LI A1, 2
BFD04DA8      EF01   LI A2, 1
BFD04DAA  3A4077E8   JALS jtvic_dis_clr_source
BFD04DAC  0C003A40   SH S2, 3072(ZERO)
BFD04DAE      0C00   NOP
168:                 }
BFD04DB0      0FBE   MOVE SP, S8
BFD04DB2      4859   LW V0, 100(SP)
BFD04DB4  3D7C0002   MTLO V0
BFD04DB6  48783D7C   LH T3, 18552(GP)
BFD04DB8      4878   LW V1, 96(SP)
BFD04DBA  2D7C0003   MTHI V1
BFD04DBC      2D7C   ANDI V0, A3, 0x40
BFD04DBE      485C   LW V0, 112(SP)
BFD04DC0      2D27   ANDI V0, V0, 0xF
BFD04DC2  001340A2   BNEZC V0, 0xBFD04DEC
BFD04DC6      4BF7   LW RA, 92(SP)
BFD04DC8      4BD6   LW S8, 88(SP)
BFD04DCA      4B35   LW T9, 84(SP)
BFD04DCC      4B14   LW T8, 80(SP)
BFD04DCE      49F3   LW T7, 76(SP)
BFD04DD0      49D2   LW T6, 72(SP)
BFD04DD2      49B1   LW T5, 68(SP)
BFD04DD4      4990   LW T4, 64(SP)
BFD04DD6      496F   LW T3, 60(SP)
BFD04DD8      494E   LW T2, 56(SP)
BFD04DDA      492D   LW T1, 52(SP)
BFD04DDC      490C   LW T0, 48(SP)
BFD04DDE      48EB   LW A3, 44(SP)
BFD04DE0      48CA   LW A2, 40(SP)
BFD04DE2      48A9   LW A1, 36(SP)
BFD04DE4      4888   LW A0, 32(SP)
BFD04DE6      4867   LW V1, 28(SP)
BFD04DE8      4846   LW V0, 24(SP)
BFD04DEA      4825   LW AT, 20(SP)
BFD04DEC  477C0000   DI ZERO
BFD04DF0  18000000   SLL ZERO, ZERO, 3
BFD04DF2  4B5D1800   SB ZERO, 19293(ZERO)
BFD04DF4      4B5D   LW K0, 116(SP)
BFD04DF6      4B7B   LW K1, 108(SP)
BFD04DF8  02FC034E   MTC0 K0, EPC
BFD04DFC      4B5C   LW K0, 112(SP)
BFD04DFE      4C3D   ADDIU SP, SP, 120
BFD04E00  12FC034C   MTC0 K0, SRSCtl
BFD04E02  03BD12FC   ADDI S7, GP, 957
BFD04E04  F17C03BD   WRPGPR SP, SP
BFD04E06  036CF17C   JALX 0xBDF00DB0
BFD04E08  02FC036C   MTC0 K1, Status
BFD04E0A  000002FC   SLL S7, GP, 0
BFD04E0C  F37C0000   ERET
BFD04E0E  03BDF37C   JALX 0xBDF00EF4
169:                 
170:                 /* 16-bit Basic Timer 3 */
171:                 void __attribute__((weak, interrupt, nomips16))
172:                 girq23_b3(void)
173:                 {
BFD04E10  E17C03BD   RDPGPR SP, SP
BFD04E14  00FC036E   MFC0 K1, EPC
BFD04E16  034C00FC   INS A3, GP, 13, -12
BFD04E18  10FC034C   MFC0 K0, SRSCtl
BFD04E1A  4FC510FC   ADDI A3, GP, 20421
BFD04E1C      4FC5   ADDIU SP, SP, -120
BFD04E1E      CB7D   SW K1, 116(SP)
BFD04E20  00FC036C   MFC0 K1, Status
BFD04E24      CB5C   SW K0, 112(SP)
BFD04E26  00FC034D   MFC0 K0, Cause
BFD04E2A      CB7B   SW K1, 108(SP)
BFD04E2C  5040035A   SRL K0, K0, 10
BFD04E2E  037A5040   ORI V0, ZERO, 890
BFD04E30  7A8C037A   INS K1, K0, 10, 6
BFD04E32  03607A8C   ADDIUPC A1, 787296
BFD04E34  204C0360   INS K1, ZERO, 1, 4
BFD04E36  036C204C   LWC2 V0, 876(T4)
BFD04E38  02FC036C   MTC0 K1, Status
BFD04E3C      C867   SW V1, 28(SP)
BFD04E3E      C846   SW V0, 24(SP)
BFD04E40      487C   LW V1, 112(SP)
BFD04E42      2DB7   ANDI V1, V1, 0xF
BFD04E44  001140A3   BNEZC V1, 0xBFD04E6A
BFD04E48      CBF7   SW RA, 92(SP)
BFD04E4A      CBD6   SW S8, 88(SP)
BFD04E4C      CB35   SW T9, 84(SP)
BFD04E4E      CB14   SW T8, 80(SP)
BFD04E50      C9F3   SW T7, 76(SP)
BFD04E52      C9D2   SW T6, 72(SP)
BFD04E54      C9B1   SW T5, 68(SP)
BFD04E56      C990   SW T4, 64(SP)
BFD04E58      C96F   SW T3, 60(SP)
BFD04E5A      C94E   SW T2, 56(SP)
BFD04E5C      C92D   SW T1, 52(SP)
BFD04E5E      C90C   SW T0, 48(SP)
BFD04E60      C8EB   SW A3, 44(SP)
BFD04E62      C8CA   SW A2, 40(SP)
BFD04E64      C8A9   SW A1, 36(SP)
BFD04E66      C888   SW A0, 32(SP)
BFD04E68      C825   SW AT, 20(SP)
BFD04E6A      4642   MFLO V0
BFD04E6C      C859   SW V0, 100(SP)
BFD04E6E      4603   MFHI V1
BFD04E70      C878   SW V1, 96(SP)
BFD04E72      0FDD   MOVE S8, SP
174:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 3, TRUE);
BFD04E74      EE0F   LI A0, 15
BFD04E76      EE83   LI A1, 3
BFD04E78      EF01   LI A2, 1
BFD04E7A  3A4077E8   JALS jtvic_dis_clr_source
BFD04E7C  0C003A40   SH S2, 3072(ZERO)
BFD04E7E      0C00   NOP
175:                 }
BFD04E80      0FBE   MOVE SP, S8
BFD04E82      4859   LW V0, 100(SP)
BFD04E84  3D7C0002   MTLO V0
BFD04E86  48783D7C   LH T3, 18552(GP)
BFD04E88      4878   LW V1, 96(SP)
BFD04E8A  2D7C0003   MTHI V1
BFD04E8C      2D7C   ANDI V0, A3, 0x40
BFD04E8E      485C   LW V0, 112(SP)
BFD04E90      2D27   ANDI V0, V0, 0xF
BFD04E92  001340A2   BNEZC V0, 0xBFD04EBC
BFD04E96      4BF7   LW RA, 92(SP)
BFD04E98      4BD6   LW S8, 88(SP)
BFD04E9A      4B35   LW T9, 84(SP)
BFD04E9C      4B14   LW T8, 80(SP)
BFD04E9E      49F3   LW T7, 76(SP)
BFD04EA0      49D2   LW T6, 72(SP)
BFD04EA2      49B1   LW T5, 68(SP)
BFD04EA4      4990   LW T4, 64(SP)
BFD04EA6      496F   LW T3, 60(SP)
BFD04EA8      494E   LW T2, 56(SP)
BFD04EAA      492D   LW T1, 52(SP)
BFD04EAC      490C   LW T0, 48(SP)
BFD04EAE      48EB   LW A3, 44(SP)
BFD04EB0      48CA   LW A2, 40(SP)
BFD04EB2      48A9   LW A1, 36(SP)
BFD04EB4      4888   LW A0, 32(SP)
BFD04EB6      4867   LW V1, 28(SP)
BFD04EB8      4846   LW V0, 24(SP)
BFD04EBA      4825   LW AT, 20(SP)
BFD04EBC  477C0000   DI ZERO
BFD04EC0  18000000   SLL ZERO, ZERO, 3
BFD04EC2  4B5D1800   SB ZERO, 19293(ZERO)
BFD04EC4      4B5D   LW K0, 116(SP)
BFD04EC6      4B7B   LW K1, 108(SP)
BFD04EC8  02FC034E   MTC0 K0, EPC
BFD04ECC      4B5C   LW K0, 112(SP)
BFD04ECE      4C3D   ADDIU SP, SP, 120
BFD04ED0  12FC034C   MTC0 K0, SRSCtl
BFD04ED2  03BD12FC   ADDI S7, GP, 957
BFD04ED4  F17C03BD   WRPGPR SP, SP
BFD04ED6  036CF17C   JALX 0xBDF00DB0
BFD04ED8  02FC036C   MTC0 K1, Status
BFD04EDA  000002FC   SLL S7, GP, 0
BFD04EDC  F37C0000   ERET
BFD04EDE  03BDF37C   JALX 0xBDF00EF4
176:                 
177:                 /* RTOS Timer  */
178:                 void __attribute__((weak, interrupt, nomips16))
179:                 girq23_b4(void)
180:                 {
BFD07318  E17C03BD   RDPGPR SP, SP
BFD0731C  00FC036E   MFC0 K1, EPC
BFD0731E  034C00FC   INS A3, GP, 13, -12
BFD07320  10FC034C   MFC0 K0, SRSCtl
BFD07322  4FF110FC   ADDI A3, GP, 20465
BFD07324      4FF1   ADDIU SP, SP, -32
BFD07326      CB67   SW K1, 28(SP)
BFD07328  00FC036C   MFC0 K1, Status
BFD0732C      CB46   SW K0, 24(SP)
BFD0732E  00FC034D   MFC0 K0, Cause
BFD07332      CB65   SW K1, 20(SP)
BFD07334  5040035A   SRL K0, K0, 10
BFD07336  037A5040   ORI V0, ZERO, 890
BFD07338  7A8C037A   INS K1, K0, 10, 6
BFD0733A  03607A8C   ADDIUPC A1, 787296
BFD0733C  204C0360   INS K1, ZERO, 1, 4
BFD0733E  036C204C   LWC2 V0, 876(T4)
BFD07340  02FC036C   MTC0 K1, Status
BFD07344      C862   SW V1, 8(SP)
BFD07346      C841   SW V0, 4(SP)
BFD07348      4866   LW V1, 24(SP)
BFD0734A      2DB7   ANDI V1, V1, 0xF
BFD0734C      CBC3   SW S8, 12(SP)
BFD0734E      0FDD   MOVE S8, SP
181:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ23_ID].SOURCE = (1ul << 4);
BFD07350  BFFF41A2   LUI V0, 0xBFFF
BFD07352  5042BFFF   LDC1 F31, 20546(RA)
BFD07354  C0005042   ORI V0, V0, -16384
BFD07358      ED90   LI V1, 16
BFD0735A  00F0F862   SW V1, 240(V0)
182:                     
183:                 }
BFD0735E      0FBE   MOVE SP, S8
BFD07360      4846   LW V0, 24(SP)
BFD07362      2D27   ANDI V0, V0, 0xF
BFD07364      4BC3   LW S8, 12(SP)
BFD07366      4862   LW V1, 8(SP)
BFD07368      4841   LW V0, 4(SP)
BFD0736A  477C0000   DI ZERO
BFD0736E  18000000   SLL ZERO, ZERO, 3
BFD07370  4B471800   SB ZERO, 19271(ZERO)
BFD07372      4B47   LW K0, 28(SP)
BFD07374      4B65   LW K1, 20(SP)
BFD07376  02FC034E   MTC0 K0, EPC
BFD0737A      4B46   LW K0, 24(SP)
BFD0737C      4C11   ADDIU SP, SP, 32
BFD0737E  12FC034C   MTC0 K0, SRSCtl
BFD07380  03BD12FC   ADDI S7, GP, 957
BFD07382  F17C03BD   WRPGPR SP, SP
BFD07384  036CF17C   JALX 0xBDF00DB0
BFD07386  02FC036C   MTC0 K1, Status
BFD07388  000002FC   SLL S7, GP, 0
BFD0738A  F37C0000   ERET
BFD0738C  0C00F37C   JALX 0xBDF03000
184:                 
185:                 /* Hibernation Timer */
186:                 void __attribute__((weak, interrupt, nomips16))
187:                 girq23_b5(void)
188:                 {
BFD04EE0  E17C03BD   RDPGPR SP, SP
BFD04EE4  00FC036E   MFC0 K1, EPC
BFD04EE6  034C00FC   INS A3, GP, 13, -12
BFD04EE8  10FC034C   MFC0 K0, SRSCtl
BFD04EEA  4FC510FC   ADDI A3, GP, 20421
BFD04EEC      4FC5   ADDIU SP, SP, -120
BFD04EEE      CB7D   SW K1, 116(SP)
BFD04EF0  00FC036C   MFC0 K1, Status
BFD04EF4      CB5C   SW K0, 112(SP)
BFD04EF6  00FC034D   MFC0 K0, Cause
BFD04EFA      CB7B   SW K1, 108(SP)
BFD04EFC  5040035A   SRL K0, K0, 10
BFD04EFE  037A5040   ORI V0, ZERO, 890
BFD04F00  7A8C037A   INS K1, K0, 10, 6
BFD04F02  03607A8C   ADDIUPC A1, 787296
BFD04F04  204C0360   INS K1, ZERO, 1, 4
BFD04F06  036C204C   LWC2 V0, 876(T4)
BFD04F08  02FC036C   MTC0 K1, Status
BFD04F0C      C867   SW V1, 28(SP)
BFD04F0E      C846   SW V0, 24(SP)
BFD04F10      487C   LW V1, 112(SP)
BFD04F12      2DB7   ANDI V1, V1, 0xF
BFD04F14  001140A3   BNEZC V1, 0xBFD04F3A
BFD04F18      CBF7   SW RA, 92(SP)
BFD04F1A      CBD6   SW S8, 88(SP)
BFD04F1C      CB35   SW T9, 84(SP)
BFD04F1E      CB14   SW T8, 80(SP)
BFD04F20      C9F3   SW T7, 76(SP)
BFD04F22      C9D2   SW T6, 72(SP)
BFD04F24      C9B1   SW T5, 68(SP)
BFD04F26      C990   SW T4, 64(SP)
BFD04F28      C96F   SW T3, 60(SP)
BFD04F2A      C94E   SW T2, 56(SP)
BFD04F2C      C92D   SW T1, 52(SP)
BFD04F2E      C90C   SW T0, 48(SP)
BFD04F30      C8EB   SW A3, 44(SP)
BFD04F32      C8CA   SW A2, 40(SP)
BFD04F34      C8A9   SW A1, 36(SP)
BFD04F36      C888   SW A0, 32(SP)
BFD04F38      C825   SW AT, 20(SP)
BFD04F3A      4642   MFLO V0
BFD04F3C      C859   SW V0, 100(SP)
BFD04F3E      4603   MFHI V1
BFD04F40      C878   SW V1, 96(SP)
BFD04F42      0FDD   MOVE S8, SP
189:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 5, TRUE);
BFD04F44      EE0F   LI A0, 15
BFD04F46      EE85   LI A1, 5
BFD04F48      EF01   LI A2, 1
BFD04F4A  3A4077E8   JALS jtvic_dis_clr_source
BFD04F4C  0C003A40   SH S2, 3072(ZERO)
BFD04F4E      0C00   NOP
190:                 }
BFD04F50      0FBE   MOVE SP, S8
BFD04F52      4859   LW V0, 100(SP)
BFD04F54  3D7C0002   MTLO V0
BFD04F56  48783D7C   LH T3, 18552(GP)
BFD04F58      4878   LW V1, 96(SP)
BFD04F5A  2D7C0003   MTHI V1
BFD04F5C      2D7C   ANDI V0, A3, 0x40
BFD04F5E      485C   LW V0, 112(SP)
BFD04F60      2D27   ANDI V0, V0, 0xF
BFD04F62  001340A2   BNEZC V0, 0xBFD04F8C
BFD04F66      4BF7   LW RA, 92(SP)
BFD04F68      4BD6   LW S8, 88(SP)
BFD04F6A      4B35   LW T9, 84(SP)
BFD04F6C      4B14   LW T8, 80(SP)
BFD04F6E      49F3   LW T7, 76(SP)
BFD04F70      49D2   LW T6, 72(SP)
BFD04F72      49B1   LW T5, 68(SP)
BFD04F74      4990   LW T4, 64(SP)
BFD04F76      496F   LW T3, 60(SP)
BFD04F78      494E   LW T2, 56(SP)
BFD04F7A      492D   LW T1, 52(SP)
BFD04F7C      490C   LW T0, 48(SP)
BFD04F7E      48EB   LW A3, 44(SP)
BFD04F80      48CA   LW A2, 40(SP)
BFD04F82      48A9   LW A1, 36(SP)
BFD04F84      4888   LW A0, 32(SP)
BFD04F86      4867   LW V1, 28(SP)
BFD04F88      4846   LW V0, 24(SP)
BFD04F8A      4825   LW AT, 20(SP)
BFD04F8C  477C0000   DI ZERO
BFD04F90  18000000   SLL ZERO, ZERO, 3
BFD04F92  4B5D1800   SB ZERO, 19293(ZERO)
BFD04F94      4B5D   LW K0, 116(SP)
BFD04F96      4B7B   LW K1, 108(SP)
BFD04F98  02FC034E   MTC0 K0, EPC
BFD04F9C      4B5C   LW K0, 112(SP)
BFD04F9E      4C3D   ADDIU SP, SP, 120
BFD04FA0  12FC034C   MTC0 K0, SRSCtl
BFD04FA2  03BD12FC   ADDI S7, GP, 957
BFD04FA4  F17C03BD   WRPGPR SP, SP
BFD04FA6  036CF17C   JALX 0xBDF00DB0
BFD04FA8  02FC036C   MTC0 K1, Status
BFD04FAA  000002FC   SLL S7, GP, 0
BFD04FAC  F37C0000   ERET
BFD04FAE  03BDF37C   JALX 0xBDF00EF4
191:                 
192:                 /* Week Alarm */
193:                 void __attribute__((weak, interrupt, nomips16))
194:                 girq23_b6(void)
195:                 {
BFD04FB0  E17C03BD   RDPGPR SP, SP
BFD04FB4  00FC036E   MFC0 K1, EPC
BFD04FB6  034C00FC   INS A3, GP, 13, -12
BFD04FB8  10FC034C   MFC0 K0, SRSCtl
BFD04FBA  4FC510FC   ADDI A3, GP, 20421
BFD04FBC      4FC5   ADDIU SP, SP, -120
BFD04FBE      CB7D   SW K1, 116(SP)
BFD04FC0  00FC036C   MFC0 K1, Status
BFD04FC4      CB5C   SW K0, 112(SP)
BFD04FC6  00FC034D   MFC0 K0, Cause
BFD04FCA      CB7B   SW K1, 108(SP)
BFD04FCC  5040035A   SRL K0, K0, 10
BFD04FCE  037A5040   ORI V0, ZERO, 890
BFD04FD0  7A8C037A   INS K1, K0, 10, 6
BFD04FD2  03607A8C   ADDIUPC A1, 787296
BFD04FD4  204C0360   INS K1, ZERO, 1, 4
BFD04FD6  036C204C   LWC2 V0, 876(T4)
BFD04FD8  02FC036C   MTC0 K1, Status
BFD04FDC      C867   SW V1, 28(SP)
BFD04FDE      C846   SW V0, 24(SP)
BFD04FE0      487C   LW V1, 112(SP)
BFD04FE2      2DB7   ANDI V1, V1, 0xF
BFD04FE4  001140A3   BNEZC V1, 0xBFD0500A
BFD04FE8      CBF7   SW RA, 92(SP)
BFD04FEA      CBD6   SW S8, 88(SP)
BFD04FEC      CB35   SW T9, 84(SP)
BFD04FEE      CB14   SW T8, 80(SP)
BFD04FF0      C9F3   SW T7, 76(SP)
BFD04FF2      C9D2   SW T6, 72(SP)
BFD04FF4      C9B1   SW T5, 68(SP)
BFD04FF6      C990   SW T4, 64(SP)
BFD04FF8      C96F   SW T3, 60(SP)
BFD04FFA      C94E   SW T2, 56(SP)
BFD04FFC      C92D   SW T1, 52(SP)
BFD04FFE      C90C   SW T0, 48(SP)
BFD05000      C8EB   SW A3, 44(SP)
BFD05002      C8CA   SW A2, 40(SP)
BFD05004      C8A9   SW A1, 36(SP)
BFD05006      C888   SW A0, 32(SP)
BFD05008      C825   SW AT, 20(SP)
BFD0500A      4642   MFLO V0
BFD0500C      C859   SW V0, 100(SP)
BFD0500E      4603   MFHI V1
BFD05010      C878   SW V1, 96(SP)
BFD05012      0FDD   MOVE S8, SP
196:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 6, TRUE);
BFD05014      EE0F   LI A0, 15
BFD05016      EE86   LI A1, 6
BFD05018      EF01   LI A2, 1
BFD0501A  3A4077E8   JALS jtvic_dis_clr_source
BFD0501C  0C003A40   SH S2, 3072(ZERO)
BFD0501E      0C00   NOP
197:                 }
BFD05020      0FBE   MOVE SP, S8
BFD05022      4859   LW V0, 100(SP)
BFD05024  3D7C0002   MTLO V0
BFD05026  48783D7C   LH T3, 18552(GP)
BFD05028      4878   LW V1, 96(SP)
BFD0502A  2D7C0003   MTHI V1
BFD0502C      2D7C   ANDI V0, A3, 0x40
BFD0502E      485C   LW V0, 112(SP)
BFD05030      2D27   ANDI V0, V0, 0xF
BFD05032  001340A2   BNEZC V0, 0xBFD0505C
BFD05036      4BF7   LW RA, 92(SP)
BFD05038      4BD6   LW S8, 88(SP)
BFD0503A      4B35   LW T9, 84(SP)
BFD0503C      4B14   LW T8, 80(SP)
BFD0503E      49F3   LW T7, 76(SP)
BFD05040      49D2   LW T6, 72(SP)
BFD05042      49B1   LW T5, 68(SP)
BFD05044      4990   LW T4, 64(SP)
BFD05046      496F   LW T3, 60(SP)
BFD05048      494E   LW T2, 56(SP)
BFD0504A      492D   LW T1, 52(SP)
BFD0504C      490C   LW T0, 48(SP)
BFD0504E      48EB   LW A3, 44(SP)
BFD05050      48CA   LW A2, 40(SP)
BFD05052      48A9   LW A1, 36(SP)
BFD05054      4888   LW A0, 32(SP)
BFD05056      4867   LW V1, 28(SP)
BFD05058      4846   LW V0, 24(SP)
BFD0505A      4825   LW AT, 20(SP)
BFD0505C  477C0000   DI ZERO
BFD05060  18000000   SLL ZERO, ZERO, 3
BFD05062  4B5D1800   SB ZERO, 19293(ZERO)
BFD05064      4B5D   LW K0, 116(SP)
BFD05066      4B7B   LW K1, 108(SP)
BFD05068  02FC034E   MTC0 K0, EPC
BFD0506C      4B5C   LW K0, 112(SP)
BFD0506E      4C3D   ADDIU SP, SP, 120
BFD05070  12FC034C   MTC0 K0, SRSCtl
BFD05072  03BD12FC   ADDI S7, GP, 957
BFD05074  F17C03BD   WRPGPR SP, SP
BFD05076  036CF17C   JALX 0xBDF00DB0
BFD05078  02FC036C   MTC0 K1, Status
BFD0507A  000002FC   SLL S7, GP, 0
BFD0507C  F37C0000   ERET
BFD0507E  03BDF37C   JALX 0xBDF00EF4
198:                 
199:                 /* Sub-Week Alarm */
200:                 void __attribute__((weak, interrupt, nomips16))
201:                 girq23_b7(void)
202:                 {
BFD05080  E17C03BD   RDPGPR SP, SP
BFD05084  00FC036E   MFC0 K1, EPC
BFD05086  034C00FC   INS A3, GP, 13, -12
BFD05088  10FC034C   MFC0 K0, SRSCtl
BFD0508A  4FC510FC   ADDI A3, GP, 20421
BFD0508C      4FC5   ADDIU SP, SP, -120
BFD0508E      CB7D   SW K1, 116(SP)
BFD05090  00FC036C   MFC0 K1, Status
BFD05094      CB5C   SW K0, 112(SP)
BFD05096  00FC034D   MFC0 K0, Cause
BFD0509A      CB7B   SW K1, 108(SP)
BFD0509C  5040035A   SRL K0, K0, 10
BFD0509E  037A5040   ORI V0, ZERO, 890
BFD050A0  7A8C037A   INS K1, K0, 10, 6
BFD050A2  03607A8C   ADDIUPC A1, 787296
BFD050A4  204C0360   INS K1, ZERO, 1, 4
BFD050A6  036C204C   LWC2 V0, 876(T4)
BFD050A8  02FC036C   MTC0 K1, Status
BFD050AC      C867   SW V1, 28(SP)
BFD050AE      C846   SW V0, 24(SP)
BFD050B0      487C   LW V1, 112(SP)
BFD050B2      2DB7   ANDI V1, V1, 0xF
BFD050B4  001140A3   BNEZC V1, 0xBFD050DA
BFD050B8      CBF7   SW RA, 92(SP)
BFD050BA      CBD6   SW S8, 88(SP)
BFD050BC      CB35   SW T9, 84(SP)
BFD050BE      CB14   SW T8, 80(SP)
BFD050C0      C9F3   SW T7, 76(SP)
BFD050C2      C9D2   SW T6, 72(SP)
BFD050C4      C9B1   SW T5, 68(SP)
BFD050C6      C990   SW T4, 64(SP)
BFD050C8      C96F   SW T3, 60(SP)
BFD050CA      C94E   SW T2, 56(SP)
BFD050CC      C92D   SW T1, 52(SP)
BFD050CE      C90C   SW T0, 48(SP)
BFD050D0      C8EB   SW A3, 44(SP)
BFD050D2      C8CA   SW A2, 40(SP)
BFD050D4      C8A9   SW A1, 36(SP)
BFD050D6      C888   SW A0, 32(SP)
BFD050D8      C825   SW AT, 20(SP)
BFD050DA      4642   MFLO V0
BFD050DC      C859   SW V0, 100(SP)
BFD050DE      4603   MFHI V1
BFD050E0      C878   SW V1, 96(SP)
BFD050E2      0FDD   MOVE S8, SP
203:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 7, TRUE);
BFD050E4      EE0F   LI A0, 15
BFD050E6      EE87   LI A1, 7
BFD050E8      EF01   LI A2, 1
BFD050EA  3A4077E8   JALS jtvic_dis_clr_source
BFD050EC  0C003A40   SH S2, 3072(ZERO)
BFD050EE      0C00   NOP
204:                 }
BFD050F0      0FBE   MOVE SP, S8
BFD050F2      4859   LW V0, 100(SP)
BFD050F4  3D7C0002   MTLO V0
BFD050F6  48783D7C   LH T3, 18552(GP)
BFD050F8      4878   LW V1, 96(SP)
BFD050FA  2D7C0003   MTHI V1
BFD050FC      2D7C   ANDI V0, A3, 0x40
BFD050FE      485C   LW V0, 112(SP)
BFD05100      2D27   ANDI V0, V0, 0xF
BFD05102  001340A2   BNEZC V0, 0xBFD0512C
BFD05106      4BF7   LW RA, 92(SP)
BFD05108      4BD6   LW S8, 88(SP)
BFD0510A      4B35   LW T9, 84(SP)
BFD0510C      4B14   LW T8, 80(SP)
BFD0510E      49F3   LW T7, 76(SP)
BFD05110      49D2   LW T6, 72(SP)
BFD05112      49B1   LW T5, 68(SP)
BFD05114      4990   LW T4, 64(SP)
BFD05116      496F   LW T3, 60(SP)
BFD05118      494E   LW T2, 56(SP)
BFD0511A      492D   LW T1, 52(SP)
BFD0511C      490C   LW T0, 48(SP)
BFD0511E      48EB   LW A3, 44(SP)
BFD05120      48CA   LW A2, 40(SP)
BFD05122      48A9   LW A1, 36(SP)
BFD05124      4888   LW A0, 32(SP)
BFD05126      4867   LW V1, 28(SP)
BFD05128      4846   LW V0, 24(SP)
BFD0512A      4825   LW AT, 20(SP)
BFD0512C  477C0000   DI ZERO
BFD05130  18000000   SLL ZERO, ZERO, 3
BFD05132  4B5D1800   SB ZERO, 19293(ZERO)
BFD05134      4B5D   LW K0, 116(SP)
BFD05136      4B7B   LW K1, 108(SP)
BFD05138  02FC034E   MTC0 K0, EPC
BFD0513C      4B5C   LW K0, 112(SP)
BFD0513E      4C3D   ADDIU SP, SP, 120
BFD05140  12FC034C   MTC0 K0, SRSCtl
BFD05142  03BD12FC   ADDI S7, GP, 957
BFD05144  F17C03BD   WRPGPR SP, SP
BFD05146  036CF17C   JALX 0xBDF00DB0
BFD05148  02FC036C   MTC0 K1, Status
BFD0514A  000002FC   SLL S7, GP, 0
BFD0514C  F37C0000   ERET
BFD0514E  03BDF37C   JALX 0xBDF00EF4
205:                 
206:                 /* Week Alarm One Second */
207:                 void __attribute__((weak, interrupt, nomips16))
208:                 girq23_b8(void)
209:                 {
BFD05150  E17C03BD   RDPGPR SP, SP
BFD05154  00FC036E   MFC0 K1, EPC
BFD05156  034C00FC   INS A3, GP, 13, -12
BFD05158  10FC034C   MFC0 K0, SRSCtl
BFD0515A  4FC510FC   ADDI A3, GP, 20421
BFD0515C      4FC5   ADDIU SP, SP, -120
BFD0515E      CB7D   SW K1, 116(SP)
BFD05160  00FC036C   MFC0 K1, Status
BFD05164      CB5C   SW K0, 112(SP)
BFD05166  00FC034D   MFC0 K0, Cause
BFD0516A      CB7B   SW K1, 108(SP)
BFD0516C  5040035A   SRL K0, K0, 10
BFD0516E  037A5040   ORI V0, ZERO, 890
BFD05170  7A8C037A   INS K1, K0, 10, 6
BFD05172  03607A8C   ADDIUPC A1, 787296
BFD05174  204C0360   INS K1, ZERO, 1, 4
BFD05176  036C204C   LWC2 V0, 876(T4)
BFD05178  02FC036C   MTC0 K1, Status
BFD0517C      C867   SW V1, 28(SP)
BFD0517E      C846   SW V0, 24(SP)
BFD05180      487C   LW V1, 112(SP)
BFD05182      2DB7   ANDI V1, V1, 0xF
BFD05184  001140A3   BNEZC V1, 0xBFD051AA
BFD05188      CBF7   SW RA, 92(SP)
BFD0518A      CBD6   SW S8, 88(SP)
BFD0518C      CB35   SW T9, 84(SP)
BFD0518E      CB14   SW T8, 80(SP)
BFD05190      C9F3   SW T7, 76(SP)
BFD05192      C9D2   SW T6, 72(SP)
BFD05194      C9B1   SW T5, 68(SP)
BFD05196      C990   SW T4, 64(SP)
BFD05198      C96F   SW T3, 60(SP)
BFD0519A      C94E   SW T2, 56(SP)
BFD0519C      C92D   SW T1, 52(SP)
BFD0519E      C90C   SW T0, 48(SP)
BFD051A0      C8EB   SW A3, 44(SP)
BFD051A2      C8CA   SW A2, 40(SP)
BFD051A4      C8A9   SW A1, 36(SP)
BFD051A6      C888   SW A0, 32(SP)
BFD051A8      C825   SW AT, 20(SP)
BFD051AA      4642   MFLO V0
BFD051AC      C859   SW V0, 100(SP)
BFD051AE      4603   MFHI V1
BFD051B0      C878   SW V1, 96(SP)
BFD051B2      0FDD   MOVE S8, SP
210:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 8, TRUE);
BFD051B4      EE0F   LI A0, 15
BFD051B6      EE88   LI A1, 8
BFD051B8      EF01   LI A2, 1
BFD051BA  3A4077E8   JALS jtvic_dis_clr_source
BFD051BC  0C003A40   SH S2, 3072(ZERO)
BFD051BE      0C00   NOP
211:                 }
BFD051C0      0FBE   MOVE SP, S8
BFD051C2      4859   LW V0, 100(SP)
BFD051C4  3D7C0002   MTLO V0
BFD051C6  48783D7C   LH T3, 18552(GP)
BFD051C8      4878   LW V1, 96(SP)
BFD051CA  2D7C0003   MTHI V1
BFD051CC      2D7C   ANDI V0, A3, 0x40
BFD051CE      485C   LW V0, 112(SP)
BFD051D0      2D27   ANDI V0, V0, 0xF
BFD051D2  001340A2   BNEZC V0, 0xBFD051FC
BFD051D6      4BF7   LW RA, 92(SP)
BFD051D8      4BD6   LW S8, 88(SP)
BFD051DA      4B35   LW T9, 84(SP)
BFD051DC      4B14   LW T8, 80(SP)
BFD051DE      49F3   LW T7, 76(SP)
BFD051E0      49D2   LW T6, 72(SP)
BFD051E2      49B1   LW T5, 68(SP)
BFD051E4      4990   LW T4, 64(SP)
BFD051E6      496F   LW T3, 60(SP)
BFD051E8      494E   LW T2, 56(SP)
BFD051EA      492D   LW T1, 52(SP)
BFD051EC      490C   LW T0, 48(SP)
BFD051EE      48EB   LW A3, 44(SP)
BFD051F0      48CA   LW A2, 40(SP)
BFD051F2      48A9   LW A1, 36(SP)
BFD051F4      4888   LW A0, 32(SP)
BFD051F6      4867   LW V1, 28(SP)
BFD051F8      4846   LW V0, 24(SP)
BFD051FA      4825   LW AT, 20(SP)
BFD051FC  477C0000   DI ZERO
BFD05200  18000000   SLL ZERO, ZERO, 3
BFD05202  4B5D1800   SB ZERO, 19293(ZERO)
BFD05204      4B5D   LW K0, 116(SP)
BFD05206      4B7B   LW K1, 108(SP)
BFD05208  02FC034E   MTC0 K0, EPC
BFD0520C      4B5C   LW K0, 112(SP)
BFD0520E      4C3D   ADDIU SP, SP, 120
BFD05210  12FC034C   MTC0 K0, SRSCtl
BFD05212  03BD12FC   ADDI S7, GP, 957
BFD05214  F17C03BD   WRPGPR SP, SP
BFD05216  036CF17C   JALX 0xBDF00DB0
BFD05218  02FC036C   MTC0 K1, Status
BFD0521A  000002FC   SLL S7, GP, 0
BFD0521C  F37C0000   ERET
BFD0521E  03BDF37C   JALX 0xBDF00EF4
212:                 
213:                 /* Week Alarm Sub Second */
214:                 void __attribute__((weak, interrupt, nomips16))
215:                 girq23_b9(void)
216:                 {
BFD05220  E17C03BD   RDPGPR SP, SP
BFD05224  00FC036E   MFC0 K1, EPC
BFD05226  034C00FC   INS A3, GP, 13, -12
BFD05228  10FC034C   MFC0 K0, SRSCtl
BFD0522A  4FC510FC   ADDI A3, GP, 20421
BFD0522C      4FC5   ADDIU SP, SP, -120
BFD0522E      CB7D   SW K1, 116(SP)
BFD05230  00FC036C   MFC0 K1, Status
BFD05234      CB5C   SW K0, 112(SP)
BFD05236  00FC034D   MFC0 K0, Cause
BFD0523A      CB7B   SW K1, 108(SP)
BFD0523C  5040035A   SRL K0, K0, 10
BFD0523E  037A5040   ORI V0, ZERO, 890
BFD05240  7A8C037A   INS K1, K0, 10, 6
BFD05242  03607A8C   ADDIUPC A1, 787296
BFD05244  204C0360   INS K1, ZERO, 1, 4
BFD05246  036C204C   LWC2 V0, 876(T4)
BFD05248  02FC036C   MTC0 K1, Status
BFD0524C      C867   SW V1, 28(SP)
BFD0524E      C846   SW V0, 24(SP)
BFD05250      487C   LW V1, 112(SP)
BFD05252      2DB7   ANDI V1, V1, 0xF
BFD05254  001140A3   BNEZC V1, 0xBFD0527A
BFD05258      CBF7   SW RA, 92(SP)
BFD0525A      CBD6   SW S8, 88(SP)
BFD0525C      CB35   SW T9, 84(SP)
BFD0525E      CB14   SW T8, 80(SP)
BFD05260      C9F3   SW T7, 76(SP)
BFD05262      C9D2   SW T6, 72(SP)
BFD05264      C9B1   SW T5, 68(SP)
BFD05266      C990   SW T4, 64(SP)
BFD05268      C96F   SW T3, 60(SP)
BFD0526A      C94E   SW T2, 56(SP)
BFD0526C      C92D   SW T1, 52(SP)
BFD0526E      C90C   SW T0, 48(SP)
BFD05270      C8EB   SW A3, 44(SP)
BFD05272      C8CA   SW A2, 40(SP)
BFD05274      C8A9   SW A1, 36(SP)
BFD05276      C888   SW A0, 32(SP)
BFD05278      C825   SW AT, 20(SP)
BFD0527A      4642   MFLO V0
BFD0527C      C859   SW V0, 100(SP)
BFD0527E      4603   MFHI V1
BFD05280      C878   SW V1, 96(SP)
BFD05282      0FDD   MOVE S8, SP
217:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 9, TRUE);
BFD05284      EE0F   LI A0, 15
BFD05286      EE89   LI A1, 9
BFD05288      EF01   LI A2, 1
BFD0528A  3A4077E8   JALS jtvic_dis_clr_source
BFD0528C  0C003A40   SH S2, 3072(ZERO)
BFD0528E      0C00   NOP
218:                 }
BFD05290      0FBE   MOVE SP, S8
BFD05292      4859   LW V0, 100(SP)
BFD05294  3D7C0002   MTLO V0
BFD05296  48783D7C   LH T3, 18552(GP)
BFD05298      4878   LW V1, 96(SP)
BFD0529A  2D7C0003   MTHI V1
BFD0529C      2D7C   ANDI V0, A3, 0x40
BFD0529E      485C   LW V0, 112(SP)
BFD052A0      2D27   ANDI V0, V0, 0xF
BFD052A2  001340A2   BNEZC V0, 0xBFD052CC
BFD052A6      4BF7   LW RA, 92(SP)
BFD052A8      4BD6   LW S8, 88(SP)
BFD052AA      4B35   LW T9, 84(SP)
BFD052AC      4B14   LW T8, 80(SP)
BFD052AE      49F3   LW T7, 76(SP)
BFD052B0      49D2   LW T6, 72(SP)
BFD052B2      49B1   LW T5, 68(SP)
BFD052B4      4990   LW T4, 64(SP)
BFD052B6      496F   LW T3, 60(SP)
BFD052B8      494E   LW T2, 56(SP)
BFD052BA      492D   LW T1, 52(SP)
BFD052BC      490C   LW T0, 48(SP)
BFD052BE      48EB   LW A3, 44(SP)
BFD052C0      48CA   LW A2, 40(SP)
BFD052C2      48A9   LW A1, 36(SP)
BFD052C4      4888   LW A0, 32(SP)
BFD052C6      4867   LW V1, 28(SP)
BFD052C8      4846   LW V0, 24(SP)
BFD052CA      4825   LW AT, 20(SP)
BFD052CC  477C0000   DI ZERO
BFD052D0  18000000   SLL ZERO, ZERO, 3
BFD052D2  4B5D1800   SB ZERO, 19293(ZERO)
BFD052D4      4B5D   LW K0, 116(SP)
BFD052D6      4B7B   LW K1, 108(SP)
BFD052D8  02FC034E   MTC0 K0, EPC
BFD052DC      4B5C   LW K0, 112(SP)
BFD052DE      4C3D   ADDIU SP, SP, 120
BFD052E0  12FC034C   MTC0 K0, SRSCtl
BFD052E2  03BD12FC   ADDI S7, GP, 957
BFD052E4  F17C03BD   WRPGPR SP, SP
BFD052E6  036CF17C   JALX 0xBDF00DB0
BFD052E8  02FC036C   MTC0 K1, Status
BFD052EA  000002FC   SLL S7, GP, 0
BFD052EC  F37C0000   ERET
BFD052EE  03BDF37C   JALX 0xBDF00EF4
219:                 
220:                 /* Week Alarm System Power Present Pin */
221:                 void __attribute__((weak, interrupt, nomips16))
222:                 girq23_b10(void)
223:                 {
BFD052F0  E17C03BD   RDPGPR SP, SP
BFD052F4  00FC036E   MFC0 K1, EPC
BFD052F6  034C00FC   INS A3, GP, 13, -12
BFD052F8  10FC034C   MFC0 K0, SRSCtl
BFD052FA  4FC510FC   ADDI A3, GP, 20421
BFD052FC      4FC5   ADDIU SP, SP, -120
BFD052FE      CB7D   SW K1, 116(SP)
BFD05300  00FC036C   MFC0 K1, Status
BFD05304      CB5C   SW K0, 112(SP)
BFD05306  00FC034D   MFC0 K0, Cause
BFD0530A      CB7B   SW K1, 108(SP)
BFD0530C  5040035A   SRL K0, K0, 10
BFD0530E  037A5040   ORI V0, ZERO, 890
BFD05310  7A8C037A   INS K1, K0, 10, 6
BFD05312  03607A8C   ADDIUPC A1, 787296
BFD05314  204C0360   INS K1, ZERO, 1, 4
BFD05316  036C204C   LWC2 V0, 876(T4)
BFD05318  02FC036C   MTC0 K1, Status
BFD0531C      C867   SW V1, 28(SP)
BFD0531E      C846   SW V0, 24(SP)
BFD05320      487C   LW V1, 112(SP)
BFD05322      2DB7   ANDI V1, V1, 0xF
BFD05324  001140A3   BNEZC V1, 0xBFD0534A
BFD05328      CBF7   SW RA, 92(SP)
BFD0532A      CBD6   SW S8, 88(SP)
BFD0532C      CB35   SW T9, 84(SP)
BFD0532E      CB14   SW T8, 80(SP)
BFD05330      C9F3   SW T7, 76(SP)
BFD05332      C9D2   SW T6, 72(SP)
BFD05334      C9B1   SW T5, 68(SP)
BFD05336      C990   SW T4, 64(SP)
BFD05338      C96F   SW T3, 60(SP)
BFD0533A      C94E   SW T2, 56(SP)
BFD0533C      C92D   SW T1, 52(SP)
BFD0533E      C90C   SW T0, 48(SP)
BFD05340      C8EB   SW A3, 44(SP)
BFD05342      C8CA   SW A2, 40(SP)
BFD05344      C8A9   SW A1, 36(SP)
BFD05346      C888   SW A0, 32(SP)
BFD05348      C825   SW AT, 20(SP)
BFD0534A      4642   MFLO V0
BFD0534C      C859   SW V0, 100(SP)
BFD0534E      4603   MFHI V1
BFD05350      C878   SW V1, 96(SP)
BFD05352      0FDD   MOVE S8, SP
224:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 10, TRUE);
BFD05354      EE0F   LI A0, 15
BFD05356      EE8A   LI A1, 10
BFD05358      EF01   LI A2, 1
BFD0535A  3A4077E8   JALS jtvic_dis_clr_source
BFD0535C  0C003A40   SH S2, 3072(ZERO)
BFD0535E      0C00   NOP
225:                 }
BFD05360      0FBE   MOVE SP, S8
BFD05362      4859   LW V0, 100(SP)
BFD05364  3D7C0002   MTLO V0
BFD05366  48783D7C   LH T3, 18552(GP)
BFD05368      4878   LW V1, 96(SP)
BFD0536A  2D7C0003   MTHI V1
BFD0536C      2D7C   ANDI V0, A3, 0x40
BFD0536E      485C   LW V0, 112(SP)
BFD05370      2D27   ANDI V0, V0, 0xF
BFD05372  001340A2   BNEZC V0, 0xBFD0539C
BFD05376      4BF7   LW RA, 92(SP)
BFD05378      4BD6   LW S8, 88(SP)
BFD0537A      4B35   LW T9, 84(SP)
BFD0537C      4B14   LW T8, 80(SP)
BFD0537E      49F3   LW T7, 76(SP)
BFD05380      49D2   LW T6, 72(SP)
BFD05382      49B1   LW T5, 68(SP)
BFD05384      4990   LW T4, 64(SP)
BFD05386      496F   LW T3, 60(SP)
BFD05388      494E   LW T2, 56(SP)
BFD0538A      492D   LW T1, 52(SP)
BFD0538C      490C   LW T0, 48(SP)
BFD0538E      48EB   LW A3, 44(SP)
BFD05390      48CA   LW A2, 40(SP)
BFD05392      48A9   LW A1, 36(SP)
BFD05394      4888   LW A0, 32(SP)
BFD05396      4867   LW V1, 28(SP)
BFD05398      4846   LW V0, 24(SP)
BFD0539A      4825   LW AT, 20(SP)
BFD0539C  477C0000   DI ZERO
BFD053A0  18000000   SLL ZERO, ZERO, 3
BFD053A2  4B5D1800   SB ZERO, 19293(ZERO)
BFD053A4      4B5D   LW K0, 116(SP)
BFD053A6      4B7B   LW K1, 108(SP)
BFD053A8  02FC034E   MTC0 K0, EPC
BFD053AC      4B5C   LW K0, 112(SP)
BFD053AE      4C3D   ADDIU SP, SP, 120
BFD053B0  12FC034C   MTC0 K0, SRSCtl
BFD053B2  03BD12FC   ADDI S7, GP, 957
BFD053B4  F17C03BD   WRPGPR SP, SP
BFD053B6  036CF17C   JALX 0xBDF00DB0
BFD053B8  02FC036C   MTC0 K1, Status
BFD053BA  000002FC   SLL S7, GP, 0
BFD053BC  F37C0000   ERET
BFD053BE  03BDF37C   JALX 0xBDF00EF4
226:                 
227:                 /* VCI OVRD Input  */
228:                 void __attribute__((weak, interrupt, nomips16))
229:                 girq23_b11(void)
230:                 {
BFD053C0  E17C03BD   RDPGPR SP, SP
BFD053C4  00FC036E   MFC0 K1, EPC
BFD053C6  034C00FC   INS A3, GP, 13, -12
BFD053C8  10FC034C   MFC0 K0, SRSCtl
BFD053CA  4FC510FC   ADDI A3, GP, 20421
BFD053CC      4FC5   ADDIU SP, SP, -120
BFD053CE      CB7D   SW K1, 116(SP)
BFD053D0  00FC036C   MFC0 K1, Status
BFD053D4      CB5C   SW K0, 112(SP)
BFD053D6  00FC034D   MFC0 K0, Cause
BFD053DA      CB7B   SW K1, 108(SP)
BFD053DC  5040035A   SRL K0, K0, 10
BFD053DE  037A5040   ORI V0, ZERO, 890
BFD053E0  7A8C037A   INS K1, K0, 10, 6
BFD053E2  03607A8C   ADDIUPC A1, 787296
BFD053E4  204C0360   INS K1, ZERO, 1, 4
BFD053E6  036C204C   LWC2 V0, 876(T4)
BFD053E8  02FC036C   MTC0 K1, Status
BFD053EC      C867   SW V1, 28(SP)
BFD053EE      C846   SW V0, 24(SP)
BFD053F0      487C   LW V1, 112(SP)
BFD053F2      2DB7   ANDI V1, V1, 0xF
BFD053F4  001140A3   BNEZC V1, 0xBFD0541A
BFD053F8      CBF7   SW RA, 92(SP)
BFD053FA      CBD6   SW S8, 88(SP)
BFD053FC      CB35   SW T9, 84(SP)
BFD053FE      CB14   SW T8, 80(SP)
BFD05400      C9F3   SW T7, 76(SP)
BFD05402      C9D2   SW T6, 72(SP)
BFD05404      C9B1   SW T5, 68(SP)
BFD05406      C990   SW T4, 64(SP)
BFD05408      C96F   SW T3, 60(SP)
BFD0540A      C94E   SW T2, 56(SP)
BFD0540C      C92D   SW T1, 52(SP)
BFD0540E      C90C   SW T0, 48(SP)
BFD05410      C8EB   SW A3, 44(SP)
BFD05412      C8CA   SW A2, 40(SP)
BFD05414      C8A9   SW A1, 36(SP)
BFD05416      C888   SW A0, 32(SP)
BFD05418      C825   SW AT, 20(SP)
BFD0541A      4642   MFLO V0
BFD0541C      C859   SW V0, 100(SP)
BFD0541E      4603   MFHI V1
BFD05420      C878   SW V1, 96(SP)
BFD05422      0FDD   MOVE S8, SP
231:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 11, TRUE);
BFD05424      EE0F   LI A0, 15
BFD05426      EE8B   LI A1, 11
BFD05428      EF01   LI A2, 1
BFD0542A  3A4077E8   JALS jtvic_dis_clr_source
BFD0542C  0C003A40   SH S2, 3072(ZERO)
BFD0542E      0C00   NOP
232:                 }
BFD05430      0FBE   MOVE SP, S8
BFD05432      4859   LW V0, 100(SP)
BFD05434  3D7C0002   MTLO V0
BFD05436  48783D7C   LH T3, 18552(GP)
BFD05438      4878   LW V1, 96(SP)
BFD0543A  2D7C0003   MTHI V1
BFD0543C      2D7C   ANDI V0, A3, 0x40
BFD0543E      485C   LW V0, 112(SP)
BFD05440      2D27   ANDI V0, V0, 0xF
BFD05442  001340A2   BNEZC V0, 0xBFD0546C
BFD05446      4BF7   LW RA, 92(SP)
BFD05448      4BD6   LW S8, 88(SP)
BFD0544A      4B35   LW T9, 84(SP)
BFD0544C      4B14   LW T8, 80(SP)
BFD0544E      49F3   LW T7, 76(SP)
BFD05450      49D2   LW T6, 72(SP)
BFD05452      49B1   LW T5, 68(SP)
BFD05454      4990   LW T4, 64(SP)
BFD05456      496F   LW T3, 60(SP)
BFD05458      494E   LW T2, 56(SP)
BFD0545A      492D   LW T1, 52(SP)
BFD0545C      490C   LW T0, 48(SP)
BFD0545E      48EB   LW A3, 44(SP)
BFD05460      48CA   LW A2, 40(SP)
BFD05462      48A9   LW A1, 36(SP)
BFD05464      4888   LW A0, 32(SP)
BFD05466      4867   LW V1, 28(SP)
BFD05468      4846   LW V0, 24(SP)
BFD0546A      4825   LW AT, 20(SP)
BFD0546C  477C0000   DI ZERO
BFD05470  18000000   SLL ZERO, ZERO, 3
BFD05472  4B5D1800   SB ZERO, 19293(ZERO)
BFD05474      4B5D   LW K0, 116(SP)
BFD05476      4B7B   LW K1, 108(SP)
BFD05478  02FC034E   MTC0 K0, EPC
BFD0547C      4B5C   LW K0, 112(SP)
BFD0547E      4C3D   ADDIU SP, SP, 120
BFD05480  12FC034C   MTC0 K0, SRSCtl
BFD05482  03BD12FC   ADDI S7, GP, 957
BFD05484  F17C03BD   WRPGPR SP, SP
BFD05486  036CF17C   JALX 0xBDF00DB0
BFD05488  02FC036C   MTC0 K1, Status
BFD0548A  000002FC   SLL S7, GP, 0
BFD0548C  F37C0000   ERET
BFD0548E  03BDF37C   JALX 0xBDF00EF4
233:                 
234:                 /* VCI IN0 */
235:                 void __attribute__((weak, interrupt, nomips16))
236:                 girq23_b12(void)
237:                 {
BFD05490  E17C03BD   RDPGPR SP, SP
BFD05494  00FC036E   MFC0 K1, EPC
BFD05496  034C00FC   INS A3, GP, 13, -12
BFD05498  10FC034C   MFC0 K0, SRSCtl
BFD0549A  4FC510FC   ADDI A3, GP, 20421
BFD0549C      4FC5   ADDIU SP, SP, -120
BFD0549E      CB7D   SW K1, 116(SP)
BFD054A0  00FC036C   MFC0 K1, Status
BFD054A4      CB5C   SW K0, 112(SP)
BFD054A6  00FC034D   MFC0 K0, Cause
BFD054AA      CB7B   SW K1, 108(SP)
BFD054AC  5040035A   SRL K0, K0, 10
BFD054AE  037A5040   ORI V0, ZERO, 890
BFD054B0  7A8C037A   INS K1, K0, 10, 6
BFD054B2  03607A8C   ADDIUPC A1, 787296
BFD054B4  204C0360   INS K1, ZERO, 1, 4
BFD054B6  036C204C   LWC2 V0, 876(T4)
BFD054B8  02FC036C   MTC0 K1, Status
BFD054BC      C867   SW V1, 28(SP)
BFD054BE      C846   SW V0, 24(SP)
BFD054C0      487C   LW V1, 112(SP)
BFD054C2      2DB7   ANDI V1, V1, 0xF
BFD054C4  001140A3   BNEZC V1, 0xBFD054EA
BFD054C8      CBF7   SW RA, 92(SP)
BFD054CA      CBD6   SW S8, 88(SP)
BFD054CC      CB35   SW T9, 84(SP)
BFD054CE      CB14   SW T8, 80(SP)
BFD054D0      C9F3   SW T7, 76(SP)
BFD054D2      C9D2   SW T6, 72(SP)
BFD054D4      C9B1   SW T5, 68(SP)
BFD054D6      C990   SW T4, 64(SP)
BFD054D8      C96F   SW T3, 60(SP)
BFD054DA      C94E   SW T2, 56(SP)
BFD054DC      C92D   SW T1, 52(SP)
BFD054DE      C90C   SW T0, 48(SP)
BFD054E0      C8EB   SW A3, 44(SP)
BFD054E2      C8CA   SW A2, 40(SP)
BFD054E4      C8A9   SW A1, 36(SP)
BFD054E6      C888   SW A0, 32(SP)
BFD054E8      C825   SW AT, 20(SP)
BFD054EA      4642   MFLO V0
BFD054EC      C859   SW V0, 100(SP)
BFD054EE      4603   MFHI V1
BFD054F0      C878   SW V1, 96(SP)
BFD054F2      0FDD   MOVE S8, SP
238:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 12, TRUE);
BFD054F4      EE0F   LI A0, 15
BFD054F6      EE8C   LI A1, 12
BFD054F8      EF01   LI A2, 1
BFD054FA  3A4077E8   JALS jtvic_dis_clr_source
BFD054FC  0C003A40   SH S2, 3072(ZERO)
BFD054FE      0C00   NOP
239:                 }
BFD05500      0FBE   MOVE SP, S8
BFD05502      4859   LW V0, 100(SP)
BFD05504  3D7C0002   MTLO V0
BFD05506  48783D7C   LH T3, 18552(GP)
BFD05508      4878   LW V1, 96(SP)
BFD0550A  2D7C0003   MTHI V1
BFD0550C      2D7C   ANDI V0, A3, 0x40
BFD0550E      485C   LW V0, 112(SP)
BFD05510      2D27   ANDI V0, V0, 0xF
BFD05512  001340A2   BNEZC V0, 0xBFD0553C
BFD05516      4BF7   LW RA, 92(SP)
BFD05518      4BD6   LW S8, 88(SP)
BFD0551A      4B35   LW T9, 84(SP)
BFD0551C      4B14   LW T8, 80(SP)
BFD0551E      49F3   LW T7, 76(SP)
BFD05520      49D2   LW T6, 72(SP)
BFD05522      49B1   LW T5, 68(SP)
BFD05524      4990   LW T4, 64(SP)
BFD05526      496F   LW T3, 60(SP)
BFD05528      494E   LW T2, 56(SP)
BFD0552A      492D   LW T1, 52(SP)
BFD0552C      490C   LW T0, 48(SP)
BFD0552E      48EB   LW A3, 44(SP)
BFD05530      48CA   LW A2, 40(SP)
BFD05532      48A9   LW A1, 36(SP)
BFD05534      4888   LW A0, 32(SP)
BFD05536      4867   LW V1, 28(SP)
BFD05538      4846   LW V0, 24(SP)
BFD0553A      4825   LW AT, 20(SP)
BFD0553C  477C0000   DI ZERO
BFD05540  18000000   SLL ZERO, ZERO, 3
BFD05542  4B5D1800   SB ZERO, 19293(ZERO)
BFD05544      4B5D   LW K0, 116(SP)
BFD05546      4B7B   LW K1, 108(SP)
BFD05548  02FC034E   MTC0 K0, EPC
BFD0554C      4B5C   LW K0, 112(SP)
BFD0554E      4C3D   ADDIU SP, SP, 120
BFD05550  12FC034C   MTC0 K0, SRSCtl
BFD05552  03BD12FC   ADDI S7, GP, 957
BFD05554  F17C03BD   WRPGPR SP, SP
BFD05556  036CF17C   JALX 0xBDF00DB0
BFD05558  02FC036C   MTC0 K1, Status
BFD0555A  000002FC   SLL S7, GP, 0
BFD0555C  F37C0000   ERET
BFD0555E  03BDF37C   JALX 0xBDF00EF4
240:                 
241:                 /* VCI IN1 */
242:                 void __attribute__((weak, interrupt, nomips16))
243:                 girq23_b13(void)
244:                 {
BFD05560  E17C03BD   RDPGPR SP, SP
BFD05564  00FC036E   MFC0 K1, EPC
BFD05566  034C00FC   INS A3, GP, 13, -12
BFD05568  10FC034C   MFC0 K0, SRSCtl
BFD0556A  4FC510FC   ADDI A3, GP, 20421
BFD0556C      4FC5   ADDIU SP, SP, -120
BFD0556E      CB7D   SW K1, 116(SP)
BFD05570  00FC036C   MFC0 K1, Status
BFD05574      CB5C   SW K0, 112(SP)
BFD05576  00FC034D   MFC0 K0, Cause
BFD0557A      CB7B   SW K1, 108(SP)
BFD0557C  5040035A   SRL K0, K0, 10
BFD0557E  037A5040   ORI V0, ZERO, 890
BFD05580  7A8C037A   INS K1, K0, 10, 6
BFD05582  03607A8C   ADDIUPC A1, 787296
BFD05584  204C0360   INS K1, ZERO, 1, 4
BFD05586  036C204C   LWC2 V0, 876(T4)
BFD05588  02FC036C   MTC0 K1, Status
BFD0558C      C867   SW V1, 28(SP)
BFD0558E      C846   SW V0, 24(SP)
BFD05590      487C   LW V1, 112(SP)
BFD05592      2DB7   ANDI V1, V1, 0xF
BFD05594  001140A3   BNEZC V1, 0xBFD055BA
BFD05598      CBF7   SW RA, 92(SP)
BFD0559A      CBD6   SW S8, 88(SP)
BFD0559C      CB35   SW T9, 84(SP)
BFD0559E      CB14   SW T8, 80(SP)
BFD055A0      C9F3   SW T7, 76(SP)
BFD055A2      C9D2   SW T6, 72(SP)
BFD055A4      C9B1   SW T5, 68(SP)
BFD055A6      C990   SW T4, 64(SP)
BFD055A8      C96F   SW T3, 60(SP)
BFD055AA      C94E   SW T2, 56(SP)
BFD055AC      C92D   SW T1, 52(SP)
BFD055AE      C90C   SW T0, 48(SP)
BFD055B0      C8EB   SW A3, 44(SP)
BFD055B2      C8CA   SW A2, 40(SP)
BFD055B4      C8A9   SW A1, 36(SP)
BFD055B6      C888   SW A0, 32(SP)
BFD055B8      C825   SW AT, 20(SP)
BFD055BA      4642   MFLO V0
BFD055BC      C859   SW V0, 100(SP)
BFD055BE      4603   MFHI V1
BFD055C0      C878   SW V1, 96(SP)
BFD055C2      0FDD   MOVE S8, SP
245:                     jtvic_dis_clr_source(MEC14xx_GIRQ23_ID, 13, TRUE);
BFD055C4      EE0F   LI A0, 15
BFD055C6      EE8D   LI A1, 13
BFD055C8      EF01   LI A2, 1
BFD055CA  3A4077E8   JALS jtvic_dis_clr_source
BFD055CC  0C003A40   SH S2, 3072(ZERO)
BFD055CE      0C00   NOP
246:                 }
BFD055D0      0FBE   MOVE SP, S8
BFD055D2      4859   LW V0, 100(SP)
BFD055D4  3D7C0002   MTLO V0
BFD055D6  48783D7C   LH T3, 18552(GP)
BFD055D8      4878   LW V1, 96(SP)
BFD055DA  2D7C0003   MTHI V1
BFD055DC      2D7C   ANDI V0, A3, 0x40
BFD055DE      485C   LW V0, 112(SP)
BFD055E0      2D27   ANDI V0, V0, 0xF
BFD055E2  001340A2   BNEZC V0, 0xBFD0560C
BFD055E6      4BF7   LW RA, 92(SP)
BFD055E8      4BD6   LW S8, 88(SP)
BFD055EA      4B35   LW T9, 84(SP)
BFD055EC      4B14   LW T8, 80(SP)
BFD055EE      49F3   LW T7, 76(SP)
BFD055F0      49D2   LW T6, 72(SP)
BFD055F2      49B1   LW T5, 68(SP)
BFD055F4      4990   LW T4, 64(SP)
BFD055F6      496F   LW T3, 60(SP)
BFD055F8      494E   LW T2, 56(SP)
BFD055FA      492D   LW T1, 52(SP)
BFD055FC      490C   LW T0, 48(SP)
BFD055FE      48EB   LW A3, 44(SP)
BFD05600      48CA   LW A2, 40(SP)
BFD05602      48A9   LW A1, 36(SP)
BFD05604      4888   LW A0, 32(SP)
BFD05606      4867   LW V1, 28(SP)
BFD05608      4846   LW V0, 24(SP)
BFD0560A      4825   LW AT, 20(SP)
BFD0560C  477C0000   DI ZERO
BFD05610  18000000   SLL ZERO, ZERO, 3
BFD05612  4B5D1800   SB ZERO, 19293(ZERO)
BFD05614      4B5D   LW K0, 116(SP)
BFD05616      4B7B   LW K1, 108(SP)
BFD05618  02FC034E   MTC0 K0, EPC
BFD0561C      4B5C   LW K0, 112(SP)
BFD0561E      4C3D   ADDIU SP, SP, 120
BFD05620  12FC034C   MTC0 K0, SRSCtl
BFD05622  03BD12FC   ADDI S7, GP, 957
BFD05624  F17C03BD   WRPGPR SP, SP
BFD05626  036CF17C   JALX 0xBDF00DB0
BFD05628  02FC036C   MTC0 K1, Status
BFD0562A  000002FC   SLL S7, GP, 0
BFD0562C  F37C0000   ERET
BFD0562E  4FF5F37C   JALX 0xBDF13FD4
247:                 
248:                 
249:                 #endif
250:                 
251:                 
252:                 /* end girq23.c */
253:                 /**   @}
254:                  */
255:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq22.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq22.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #if GIRQ22_DISAGG == 0
37:                  
38:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
39:                  girq22_isr(void)
40:                  {
BFD07228  E17C03BD   RDPGPR SP, SP
BFD0722C  00FC036E   MFC0 K1, EPC
BFD0722E  034C00FC   INS A3, GP, 13, -12
BFD07230  10FC034C   MFC0 K0, SRSCtl
BFD07232  4FF110FC   ADDI A3, GP, 20465
BFD07234      4FF1   ADDIU SP, SP, -32
BFD07236      CB67   SW K1, 28(SP)
BFD07238  00FC036C   MFC0 K1, Status
BFD0723C      CB46   SW K0, 24(SP)
BFD0723E  00FC034D   MFC0 K0, Cause
BFD07242      CB65   SW K1, 20(SP)
BFD07244  5040035A   SRL K0, K0, 10
BFD07246  037A5040   ORI V0, ZERO, 890
BFD07248  7A8C037A   INS K1, K0, 10, 6
BFD0724A  03607A8C   ADDIUPC A1, 787296
BFD0724C  204C0360   INS K1, ZERO, 1, 4
BFD0724E  036C204C   LWC2 V0, 876(T4)
BFD07250  02FC036C   MTC0 K1, Status
BFD07254      C862   SW V1, 8(SP)
BFD07256      C841   SW V0, 4(SP)
BFD07258      4866   LW V1, 24(SP)
BFD0725A      2DB7   ANDI V1, V1, 0xF
BFD0725C      CBC3   SW S8, 12(SP)
BFD0725E      0FDD   MOVE S8, SP
41:                      JTVIC_GROUP_EN_CLR->w = (1ul<<14);
BFD07260  BFFF41A2   LUI V0, 0xBFFF
BFD07262  5042BFFF   LDC1 F31, 20546(RA)
BFD07264  C50C5042   ORI V0, V0, -15092
BFD07268  40003060   ADDIU V1, ZERO, 16384
BFD0726A  E9A04000   BLTZ ZERO, 0xBFD045AE
BFD0726C      E9A0   SW V1, 0(V0)
42:                  }
BFD0726E      0FBE   MOVE SP, S8
BFD07270      4846   LW V0, 24(SP)
BFD07272      2D27   ANDI V0, V0, 0xF
BFD07274      4BC3   LW S8, 12(SP)
BFD07276      4862   LW V1, 8(SP)
BFD07278      4841   LW V0, 4(SP)
BFD0727A  477C0000   DI ZERO
BFD0727E  18000000   SLL ZERO, ZERO, 3
BFD07280  4B471800   SB ZERO, 19271(ZERO)
BFD07282      4B47   LW K0, 28(SP)
BFD07284      4B65   LW K1, 20(SP)
BFD07286  02FC034E   MTC0 K0, EPC
BFD0728A      4B46   LW K0, 24(SP)
BFD0728C      4C11   ADDIU SP, SP, 32
BFD0728E  12FC034C   MTC0 K0, SRSCtl
BFD07290  03BD12FC   ADDI S7, GP, 957
BFD07292  F17C03BD   WRPGPR SP, SP
BFD07294  036CF17C   JALX 0xBDF00DB0
BFD07296  02FC036C   MTC0 K1, Status
BFD07298  000002FC   SLL S7, GP, 0
BFD0729A  F37C0000   ERET
BFD0729C  0C00F37C   JALX 0xBDF03000
43:                  
44:                  #else
45:                  
46:                  void __attribute__((weak, interrupt, nomips16))
47:                  girq22_b0(void)
48:                  {
49:                      jtvic_dis_clr_source(MEC14xx_GIRQ22_ID, 0);
50:                  }
51:                  
52:                  void __attribute__((weak, interrupt, nomips16))
53:                  girq22_b1(void)
54:                  {
55:                      jtvic_dis_clr_source(MEC14xx_GIRQ22_ID, 1);
56:                  }
57:                  
58:                  void __attribute__((weak, interrupt, nomips16))
59:                  girq22_b2(void)
60:                  {
61:                      jtvic_dis_clr_source(MEC14xx_GIRQ22_ID, 2);
62:                  }
63:                  
64:                  void __attribute__((weak, interrupt, nomips16))
65:                  girq22_b3(void)
66:                  {
67:                      jtvic_dis_clr_source(MEC14xx_GIRQ22_ID, 3);
68:                  }
69:                  
70:                  void __attribute__((weak, interrupt, nomips16))
71:                  girq22_b4(void)
72:                  {
73:                      jtvic_dis_clr_source(MEC14xx_GIRQ22_ID, 4);
74:                  }
75:                  
76:                  void __attribute__((weak, interrupt, nomips16))
77:                  girq22_b5(void)
78:                  {
79:                      jtvic_dis_clr_source(MEC14xx_GIRQ22_ID, 5);
80:                  }
81:                  
82:                  void __attribute__((weak, interrupt, nomips16))
83:                  girq22_b6(void)
84:                  {
85:                      jtvic_dis_clr_source(MEC14xx_GIRQ22_ID, 6);
86:                  }
87:                  
88:                  void __attribute__((weak, interrupt, nomips16))
89:                  girq22_b7(void)
90:                  {
91:                      jtvic_dis_clr_source(MEC14xx_GIRQ22_ID, 7);
92:                  }
93:                  
94:                  void __attribute__((weak, interrupt, nomips16))
95:                  girq22_b8(void)
96:                  {
97:                      jtvic_dis_clr_source(MEC14xx_GIRQ22_ID, 8);
98:                  }
99:                  
100:                 void __attribute__((weak, interrupt, nomips16))
101:                 girq22_b9(void)
102:                 {
103:                     jtvic_dis_clr_source(MEC14xx_GIRQ22_ID, 9);
104:                 }
105:                 
106:                 
107:                 #endif
108:                 
109:                 /* end girq22.c */
110:                 /**   @}
111:                  */
112:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq21.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq21.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #if GIRQ21_DISAGG == 0
37:                  
38:                  /*
39:                   * GIRQ21 is a wake peripheral logic only interrupt.
40:                   * It's purpose is to allow the peripheral logic such as SMBus or LPC to 
41:                   * wake an service HW event without waking the EC.
42:                   * This handler is superfluous.
43:                   */
44:                  
45:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
46:                  girq21_isr(void)
47:                  {
BFD071B0  E17C03BD   RDPGPR SP, SP
BFD071B4  00FC036E   MFC0 K1, EPC
BFD071B6  034C00FC   INS A3, GP, 13, -12
BFD071B8  10FC034C   MFC0 K0, SRSCtl
BFD071BA  4FF110FC   ADDI A3, GP, 20465
BFD071BC      4FF1   ADDIU SP, SP, -32
BFD071BE      CB67   SW K1, 28(SP)
BFD071C0  00FC036C   MFC0 K1, Status
BFD071C4      CB46   SW K0, 24(SP)
BFD071C6  00FC034D   MFC0 K0, Cause
BFD071CA      CB65   SW K1, 20(SP)
BFD071CC  5040035A   SRL K0, K0, 10
BFD071CE  037A5040   ORI V0, ZERO, 890
BFD071D0  7A8C037A   INS K1, K0, 10, 6
BFD071D2  03607A8C   ADDIUPC A1, 787296
BFD071D4  204C0360   INS K1, ZERO, 1, 4
BFD071D6  036C204C   LWC2 V0, 876(T4)
BFD071D8  02FC036C   MTC0 K1, Status
BFD071DC      C862   SW V1, 8(SP)
BFD071DE      C841   SW V0, 4(SP)
BFD071E0      4866   LW V1, 24(SP)
BFD071E2      2DB7   ANDI V1, V1, 0xF
BFD071E4      CBC3   SW S8, 12(SP)
BFD071E6      0FDD   MOVE S8, SP
48:                      JTVIC_GROUP_EN_CLR->w = (1ul<<13);
BFD071E8  BFFF41A2   LUI V0, 0xBFFF
BFD071EA  5042BFFF   LDC1 F31, 20546(RA)
BFD071EC  C50C5042   ORI V0, V0, -15092
BFD071F0  20003060   ADDIU V1, ZERO, 8192
BFD071F4      E9A0   SW V1, 0(V0)
49:                  }
BFD071F6      0FBE   MOVE SP, S8
BFD071F8      4846   LW V0, 24(SP)
BFD071FA      2D27   ANDI V0, V0, 0xF
BFD071FC      4BC3   LW S8, 12(SP)
BFD071FE      4862   LW V1, 8(SP)
BFD07200      4841   LW V0, 4(SP)
BFD07202  477C0000   DI ZERO
BFD07206  18000000   SLL ZERO, ZERO, 3
BFD07208  4B471800   SB ZERO, 19271(ZERO)
BFD0720A      4B47   LW K0, 28(SP)
BFD0720C      4B65   LW K1, 20(SP)
BFD0720E  02FC034E   MTC0 K0, EPC
BFD07212      4B46   LW K0, 24(SP)
BFD07214      4C11   ADDIU SP, SP, 32
BFD07216  12FC034C   MTC0 K0, SRSCtl
BFD07218  03BD12FC   ADDI S7, GP, 957
BFD0721A  F17C03BD   WRPGPR SP, SP
BFD0721C  036CF17C   JALX 0xBDF00DB0
BFD0721E  02FC036C   MTC0 K1, Status
BFD07220  000002FC   SLL S7, GP, 0
BFD07222  F37C0000   ERET
BFD07224  0C00F37C   JALX 0xBDF03000
50:                  
51:                  #else
52:                  
53:                  void __attribute__((weak, interrupt, nomips16))
54:                  girq21_b0(void)
55:                  {
56:                      JTVIC_GROUP_EN_CLR->w = (1ul<<13);
57:                  }
58:                  
59:                  #endif
60:                  
61:                  /* end girq21.c */
62:                  /**   @}
63:                   */
64:                  
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq20.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq20.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #if GIRQ20_DISAGG == 0
37:                  
38:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
39:                  girq20_isr(void)
40:                  {
BFD07138  E17C03BD   RDPGPR SP, SP
BFD0713C  00FC036E   MFC0 K1, EPC
BFD0713E  034C00FC   INS A3, GP, 13, -12
BFD07140  10FC034C   MFC0 K0, SRSCtl
BFD07142  4FF110FC   ADDI A3, GP, 20465
BFD07144      4FF1   ADDIU SP, SP, -32
BFD07146      CB67   SW K1, 28(SP)
BFD07148  00FC036C   MFC0 K1, Status
BFD0714C      CB46   SW K0, 24(SP)
BFD0714E  00FC034D   MFC0 K0, Cause
BFD07152      CB65   SW K1, 20(SP)
BFD07154  5040035A   SRL K0, K0, 10
BFD07156  037A5040   ORI V0, ZERO, 890
BFD07158  7A8C037A   INS K1, K0, 10, 6
BFD0715A  03607A8C   ADDIUPC A1, 787296
BFD0715C  204C0360   INS K1, ZERO, 1, 4
BFD0715E  036C204C   LWC2 V0, 876(T4)
BFD07160  02FC036C   MTC0 K1, Status
BFD07164      C862   SW V1, 8(SP)
BFD07166      C841   SW V0, 4(SP)
BFD07168      4866   LW V1, 24(SP)
BFD0716A      2DB7   ANDI V1, V1, 0xF
BFD0716C      CBC3   SW S8, 12(SP)
BFD0716E      0FDD   MOVE S8, SP
41:                      JTVIC_GROUP_EN_CLR->w = (1ul<<12);
BFD07170  BFFF41A2   LUI V0, 0xBFFF
BFD07172  5042BFFF   LDC1 F31, 20546(RA)
BFD07174  C50C5042   ORI V0, V0, -15092
BFD07178  10003060   ADDIU V1, ZERO, 4096
BFD0717A  E9A01000   ADDI ZERO, ZERO, -5728
BFD0717C      E9A0   SW V1, 0(V0)
42:                  }
BFD0717E      0FBE   MOVE SP, S8
BFD07180      4846   LW V0, 24(SP)
BFD07182      2D27   ANDI V0, V0, 0xF
BFD07184      4BC3   LW S8, 12(SP)
BFD07186      4862   LW V1, 8(SP)
BFD07188      4841   LW V0, 4(SP)
BFD0718A  477C0000   DI ZERO
BFD0718E  18000000   SLL ZERO, ZERO, 3
BFD07190  4B471800   SB ZERO, 19271(ZERO)
BFD07192      4B47   LW K0, 28(SP)
BFD07194      4B65   LW K1, 20(SP)
BFD07196  02FC034E   MTC0 K0, EPC
BFD0719A      4B46   LW K0, 24(SP)
BFD0719C      4C11   ADDIU SP, SP, 32
BFD0719E  12FC034C   MTC0 K0, SRSCtl
BFD071A0  03BD12FC   ADDI S7, GP, 957
BFD071A2  F17C03BD   WRPGPR SP, SP
BFD071A4  036CF17C   JALX 0xBDF00DB0
BFD071A6  02FC036C   MTC0 K1, Status
BFD071A8  000002FC   SLL S7, GP, 0
BFD071AA  F37C0000   ERET
BFD071AC  0C00F37C   JALX 0xBDF03000
43:                  
44:                  #else
45:                  
46:                  void __attribute__((weak, interrupt, nomips16))
47:                  girq20_b0(void)
48:                  {
49:                      jtvic_dis_clr_source(MEC14xx_GIRQ20_ID, 0);
50:                  }
51:                  
52:                  void __attribute__((weak, interrupt, nomips16))
53:                  girq20_b1(void)
54:                  {
55:                      jtvic_dis_clr_source(MEC14xx_GIRQ20_ID, 1);
56:                  }
57:                  
58:                  void __attribute__((weak, interrupt, nomips16))
59:                  girq20_b2(void)
60:                  {
61:                      jtvic_dis_clr_source(MEC14xx_GIRQ20_ID, 2);
62:                  }
63:                  
64:                  void __attribute__((weak, interrupt, nomips16))
65:                  girq20_b3(void)
66:                  {
67:                      jtvic_dis_clr_source(MEC14xx_GIRQ20_ID, 3);
68:                  }
69:                  
70:                  void __attribute__((weak, interrupt, nomips16))
71:                  girq20_b4(void)
72:                  {
73:                      jtvic_dis_clr_source(MEC14xx_GIRQ20_ID, 4);
74:                  }
75:                  
76:                  void __attribute__((weak, interrupt, nomips16))
77:                  girq20_b5(void)
78:                  {
79:                      jtvic_dis_clr_source(MEC14xx_GIRQ20_ID, 5);
80:                  }
81:                  
82:                  
83:                  #endif
84:                  
85:                  /* end girq20.c */
86:                  /**   @}
87:                   */
88:                  
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq19.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq19.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #if GIRQ19_DISAGG == 0
37:                  
38:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
39:                  girq19_isr(void)
40:                  {
BFD070C0  E17C03BD   RDPGPR SP, SP
BFD070C4  00FC036E   MFC0 K1, EPC
BFD070C6  034C00FC   INS A3, GP, 13, -12
BFD070C8  10FC034C   MFC0 K0, SRSCtl
BFD070CA  4FF110FC   ADDI A3, GP, 20465
BFD070CC      4FF1   ADDIU SP, SP, -32
BFD070CE      CB67   SW K1, 28(SP)
BFD070D0  00FC036C   MFC0 K1, Status
BFD070D4      CB46   SW K0, 24(SP)
BFD070D6  00FC034D   MFC0 K0, Cause
BFD070DA      CB65   SW K1, 20(SP)
BFD070DC  5040035A   SRL K0, K0, 10
BFD070DE  037A5040   ORI V0, ZERO, 890
BFD070E0  7A8C037A   INS K1, K0, 10, 6
BFD070E2  03607A8C   ADDIUPC A1, 787296
BFD070E4  204C0360   INS K1, ZERO, 1, 4
BFD070E6  036C204C   LWC2 V0, 876(T4)
BFD070E8  02FC036C   MTC0 K1, Status
BFD070EC      C862   SW V1, 8(SP)
BFD070EE      C841   SW V0, 4(SP)
BFD070F0      4866   LW V1, 24(SP)
BFD070F2      2DB7   ANDI V1, V1, 0xF
BFD070F4      CBC3   SW S8, 12(SP)
BFD070F6      0FDD   MOVE S8, SP
41:                      JTVIC_GROUP_EN_CLR->w = (1ul<<11);
BFD070F8  BFFF41A2   LUI V0, 0xBFFF
BFD070FA  5042BFFF   LDC1 F31, 20546(RA)
BFD070FC  C50C5042   ORI V0, V0, -15092
BFD07100  08003060   ADDIU V1, ZERO, 2048
BFD07102      0800   LBU S0, 0(S0)
BFD07104      E9A0   SW V1, 0(V0)
42:                  }
BFD07106      0FBE   MOVE SP, S8
BFD07108      4846   LW V0, 24(SP)
BFD0710A      2D27   ANDI V0, V0, 0xF
BFD0710C      4BC3   LW S8, 12(SP)
BFD0710E      4862   LW V1, 8(SP)
BFD07110      4841   LW V0, 4(SP)
BFD07112  477C0000   DI ZERO
BFD07116  18000000   SLL ZERO, ZERO, 3
BFD07118  4B471800   SB ZERO, 19271(ZERO)
BFD0711A      4B47   LW K0, 28(SP)
BFD0711C      4B65   LW K1, 20(SP)
BFD0711E  02FC034E   MTC0 K0, EPC
BFD07122      4B46   LW K0, 24(SP)
BFD07124      4C11   ADDIU SP, SP, 32
BFD07126  12FC034C   MTC0 K0, SRSCtl
BFD07128  03BD12FC   ADDI S7, GP, 957
BFD0712A  F17C03BD   WRPGPR SP, SP
BFD0712C  036CF17C   JALX 0xBDF00DB0
BFD0712E  02FC036C   MTC0 K1, Status
BFD07130  000002FC   SLL S7, GP, 0
BFD07132  F37C0000   ERET
BFD07134  0C00F37C   JALX 0xBDF03000
43:                  
44:                  #else
45:                  
46:                  void __attribute__((weak, interrupt, nomips16))
47:                  girq19_b0(void)
48:                  {
49:                      jtvic_dis_clr_source(MEC14xx_GIRQ19_ID, 0);
50:                  }
51:                  
52:                  void __attribute__((weak, interrupt, nomips16))
53:                  girq19_b1(void)
54:                  {
55:                      jtvic_dis_clr_source(MEC14xx_GIRQ19_ID, 1);
56:                  }
57:                  
58:                  void __attribute__((weak, interrupt, nomips16))
59:                  girq19_b2(void)
60:                  {
61:                      jtvic_dis_clr_source(MEC14xx_GIRQ19_ID, 2);
62:                  }
63:                  
64:                  void __attribute__((weak, interrupt, nomips16))
65:                  girq19_b3(void)
66:                  {
67:                      jtvic_dis_clr_source(MEC14xx_GIRQ19_ID, 3);
68:                  }
69:                  
70:                  void __attribute__((weak, interrupt, nomips16))
71:                  girq19_b4(void)
72:                  {
73:                      jtvic_dis_clr_source(MEC14xx_GIRQ19_ID, 4);
74:                  }
75:                  
76:                  void __attribute__((weak, interrupt, nomips16))
77:                  girq19_b5(void)
78:                  {
79:                      jtvic_dis_clr_source(MEC14xx_GIRQ19_ID, 5);
80:                  }
81:                  
82:                  void __attribute__((weak, interrupt, nomips16))
83:                  girq19_b6(void)
84:                  {
85:                      jtvic_dis_clr_source(MEC14xx_GIRQ19_ID, 6);
86:                  }
87:                  
88:                  void __attribute__((weak, interrupt, nomips16))
89:                  girq19_b7(void)
90:                  {
91:                      jtvic_dis_clr_source(MEC14xx_GIRQ19_ID, 7);
92:                  }
93:                  
94:                  void __attribute__((weak, interrupt, nomips16))
95:                  girq19_b8(void)
96:                  {
97:                      jtvic_dis_clr_source(MEC14xx_GIRQ19_ID, 8);
98:                  }
99:                  
100:                 
101:                 #endif
102:                 
103:                 /* end girq19.c */
104:                 /**   @}
105:                  */
106:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq18.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq18.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #if GIRQ18_DISAGG == 0
37:                  
38:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
39:                  girq18_isr(void)
40:                  {
BFD07048  E17C03BD   RDPGPR SP, SP
BFD0704C  00FC036E   MFC0 K1, EPC
BFD0704E  034C00FC   INS A3, GP, 13, -12
BFD07050  10FC034C   MFC0 K0, SRSCtl
BFD07052  4FF110FC   ADDI A3, GP, 20465
BFD07054      4FF1   ADDIU SP, SP, -32
BFD07056      CB67   SW K1, 28(SP)
BFD07058  00FC036C   MFC0 K1, Status
BFD0705C      CB46   SW K0, 24(SP)
BFD0705E  00FC034D   MFC0 K0, Cause
BFD07062      CB65   SW K1, 20(SP)
BFD07064  5040035A   SRL K0, K0, 10
BFD07066  037A5040   ORI V0, ZERO, 890
BFD07068  7A8C037A   INS K1, K0, 10, 6
BFD0706A  03607A8C   ADDIUPC A1, 787296
BFD0706C  204C0360   INS K1, ZERO, 1, 4
BFD0706E  036C204C   LWC2 V0, 876(T4)
BFD07070  02FC036C   MTC0 K1, Status
BFD07074      C862   SW V1, 8(SP)
BFD07076      C841   SW V0, 4(SP)
BFD07078      4866   LW V1, 24(SP)
BFD0707A      2DB7   ANDI V1, V1, 0xF
BFD0707C      CBC3   SW S8, 12(SP)
BFD0707E      0FDD   MOVE S8, SP
41:                      JTVIC_GROUP_EN_CLR->w = (1ul<<10);
BFD07080  BFFF41A2   LUI V0, 0xBFFF
BFD07082  5042BFFF   LDC1 F31, 20546(RA)
BFD07084  C50C5042   ORI V0, V0, -15092
BFD07088  04003060   ADDIU V1, ZERO, 1024
BFD0708A      0400   ADDU S0, S0, S0
BFD0708C      E9A0   SW V1, 0(V0)
42:                  }
BFD0708E      0FBE   MOVE SP, S8
BFD07090      4846   LW V0, 24(SP)
BFD07092      2D27   ANDI V0, V0, 0xF
BFD07094      4BC3   LW S8, 12(SP)
BFD07096      4862   LW V1, 8(SP)
BFD07098      4841   LW V0, 4(SP)
BFD0709A  477C0000   DI ZERO
BFD0709E  18000000   SLL ZERO, ZERO, 3
BFD070A0  4B471800   SB ZERO, 19271(ZERO)
BFD070A2      4B47   LW K0, 28(SP)
BFD070A4      4B65   LW K1, 20(SP)
BFD070A6  02FC034E   MTC0 K0, EPC
BFD070AA      4B46   LW K0, 24(SP)
BFD070AC      4C11   ADDIU SP, SP, 32
BFD070AE  12FC034C   MTC0 K0, SRSCtl
BFD070B0  03BD12FC   ADDI S7, GP, 957
BFD070B2  F17C03BD   WRPGPR SP, SP
BFD070B4  036CF17C   JALX 0xBDF00DB0
BFD070B6  02FC036C   MTC0 K1, Status
BFD070B8  000002FC   SLL S7, GP, 0
BFD070BA  F37C0000   ERET
BFD070BC  0C00F37C   JALX 0xBDF03000
43:                  
44:                  #else
45:                  
46:                  void __attribute__((weak, interrupt, nomips16))
47:                  girq18_b0(void)
48:                  {
49:                      jtvic_dis_clr_source(MEC14xx_GIRQ18_ID, 0);
50:                  }
51:                  
52:                  #endif
53:                  
54:                  /* end girq18.c */
55:                  /**   @}
56:                   */
57:                  
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq17.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq17.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #if GIRQ17_DISAGG == 0
37:                  
38:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
39:                  girq17_isr(void)
40:                  {
BFD06FD0  E17C03BD   RDPGPR SP, SP
BFD06FD4  00FC036E   MFC0 K1, EPC
BFD06FD6  034C00FC   INS A3, GP, 13, -12
BFD06FD8  10FC034C   MFC0 K0, SRSCtl
BFD06FDA  4FF110FC   ADDI A3, GP, 20465
BFD06FDC      4FF1   ADDIU SP, SP, -32
BFD06FDE      CB67   SW K1, 28(SP)
BFD06FE0  00FC036C   MFC0 K1, Status
BFD06FE4      CB46   SW K0, 24(SP)
BFD06FE6  00FC034D   MFC0 K0, Cause
BFD06FEA      CB65   SW K1, 20(SP)
BFD06FEC  5040035A   SRL K0, K0, 10
BFD06FEE  037A5040   ORI V0, ZERO, 890
BFD06FF0  7A8C037A   INS K1, K0, 10, 6
BFD06FF2  03607A8C   ADDIUPC A1, 787296
BFD06FF4  204C0360   INS K1, ZERO, 1, 4
BFD06FF6  036C204C   LWC2 V0, 876(T4)
BFD06FF8  02FC036C   MTC0 K1, Status
BFD06FFC      C862   SW V1, 8(SP)
BFD06FFE      C841   SW V0, 4(SP)
BFD07000      4866   LW V1, 24(SP)
BFD07002      2DB7   ANDI V1, V1, 0xF
BFD07004      CBC3   SW S8, 12(SP)
BFD07006      0FDD   MOVE S8, SP
41:                      JTVIC_GROUP_EN_CLR->w = (1ul<<9);
BFD07008  BFFF41A2   LUI V0, 0xBFFF
BFD0700A  5042BFFF   LDC1 F31, 20546(RA)
BFD0700C  C50C5042   ORI V0, V0, -15092
BFD07010  02003060   ADDIU V1, ZERO, 512
BFD07014      E9A0   SW V1, 0(V0)
42:                  }
BFD07016      0FBE   MOVE SP, S8
BFD07018      4846   LW V0, 24(SP)
BFD0701A      2D27   ANDI V0, V0, 0xF
BFD0701C      4BC3   LW S8, 12(SP)
BFD0701E      4862   LW V1, 8(SP)
BFD07020      4841   LW V0, 4(SP)
BFD07022  477C0000   DI ZERO
BFD07026  18000000   SLL ZERO, ZERO, 3
BFD07028  4B471800   SB ZERO, 19271(ZERO)
BFD0702A      4B47   LW K0, 28(SP)
BFD0702C      4B65   LW K1, 20(SP)
BFD0702E  02FC034E   MTC0 K0, EPC
BFD07032      4B46   LW K0, 24(SP)
BFD07034      4C11   ADDIU SP, SP, 32
BFD07036  12FC034C   MTC0 K0, SRSCtl
BFD07038  03BD12FC   ADDI S7, GP, 957
BFD0703A  F17C03BD   WRPGPR SP, SP
BFD0703C  036CF17C   JALX 0xBDF00DB0
BFD0703E  02FC036C   MTC0 K1, Status
BFD07040  000002FC   SLL S7, GP, 0
BFD07042  F37C0000   ERET
BFD07044  0C00F37C   JALX 0xBDF03000
43:                  
44:                  #else
45:                  
46:                  void __attribute__((weak, interrupt, nomips16))
47:                  girq17_b0(void)
48:                  {
49:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 0);
50:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 0);
51:                  }
52:                  
53:                  void __attribute__((weak, interrupt, nomips16))
54:                  girq17_b1(void)
55:                  {
56:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 1);
57:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 1);
58:                  }
59:                  
60:                  void __attribute__((weak, interrupt, nomips16))
61:                  girq17_b2(void)
62:                  {
63:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 2);
64:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 2);
65:                  }
66:                  
67:                  void __attribute__((weak, interrupt, nomips16))
68:                  girq17_b3(void)
69:                  {
70:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 3);
71:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 3);
72:                  }
73:                  
74:                  void __attribute__((weak, interrupt, nomips16))
75:                  girq17_b4(void)
76:                  {
77:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 4);
78:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 4);
79:                  }
80:                  
81:                  void __attribute__((weak, interrupt, nomips16))
82:                  girq17_b5(void)
83:                  {
84:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 5);
85:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 5);
86:                  }
87:                  
88:                  void __attribute__((weak, interrupt, nomips16))
89:                  girq17_b6(void)
90:                  {
91:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 6);
92:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 6);
93:                  }
94:                  
95:                  void __attribute__((weak, interrupt, nomips16))
96:                  girq17_b7(void)
97:                  {
98:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 7);
99:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 7);
100:                 }
101:                 
102:                 void __attribute__((weak, interrupt, nomips16))
103:                 girq17_b8(void)
104:                 {
105:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 8);
106:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 8);
107:                 }
108:                 
109:                 void __attribute__((weak, interrupt, nomips16))
110:                 girq17_b9(void)
111:                 {
112:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 9);
113:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 9);
114:                 }
115:                 
116:                 void __attribute__((weak, interrupt, nomips16))
117:                 girq17_b10(void)
118:                 {
119:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].EN_CLR = (1ul << 10);
120:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ17_ID].SOURCE = (1ul << 10);
121:                 }
122:                 
123:                 #endif
124:                 
125:                 /* end girq17.c */
126:                 /**   @}
127:                  */
128:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq16.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq16.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  
29:                  #include "appcfg.h"
30:                  #include "platform.h"
31:                  #include "MEC14xx/mec14xx.h"
32:                  #include "MEC14xx/mec14xx_girqs.h"
33:                  #include "MEC14xx/mec14xx_gpio.h"
34:                  #include "MEC14xx/mec14xx_trace_func.h"
35:                  
36:                  
37:                  #if GIRQ16_DISAGG == 0
38:                  
39:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
40:                  girq16_isr(void)
41:                  {
BFD06F58  E17C03BD   RDPGPR SP, SP
BFD06F5C  00FC036E   MFC0 K1, EPC
BFD06F5E  034C00FC   INS A3, GP, 13, -12
BFD06F60  10FC034C   MFC0 K0, SRSCtl
BFD06F62  4FF110FC   ADDI A3, GP, 20465
BFD06F64      4FF1   ADDIU SP, SP, -32
BFD06F66      CB67   SW K1, 28(SP)
BFD06F68  00FC036C   MFC0 K1, Status
BFD06F6C      CB46   SW K0, 24(SP)
BFD06F6E  00FC034D   MFC0 K0, Cause
BFD06F72      CB65   SW K1, 20(SP)
BFD06F74  5040035A   SRL K0, K0, 10
BFD06F76  037A5040   ORI V0, ZERO, 890
BFD06F78  7A8C037A   INS K1, K0, 10, 6
BFD06F7A  03607A8C   ADDIUPC A1, 787296
BFD06F7C  204C0360   INS K1, ZERO, 1, 4
BFD06F7E  036C204C   LWC2 V0, 876(T4)
BFD06F80  02FC036C   MTC0 K1, Status
BFD06F84      C862   SW V1, 8(SP)
BFD06F86      C841   SW V0, 4(SP)
BFD06F88      4866   LW V1, 24(SP)
BFD06F8A      2DB7   ANDI V1, V1, 0xF
BFD06F8C      CBC3   SW S8, 12(SP)
BFD06F8E      0FDD   MOVE S8, SP
42:                      JTVIC_GROUP_EN_CLR->w = (1ul<<8);
BFD06F90  BFFF41A2   LUI V0, 0xBFFF
BFD06F92  5042BFFF   LDC1 F31, 20546(RA)
BFD06F94  C50C5042   ORI V0, V0, -15092
BFD06F98  01003060   ADDIU V1, ZERO, 256
BFD06F9C      E9A0   SW V1, 0(V0)
43:                  }
BFD06F9E      0FBE   MOVE SP, S8
BFD06FA0      4846   LW V0, 24(SP)
BFD06FA2      2D27   ANDI V0, V0, 0xF
BFD06FA4      4BC3   LW S8, 12(SP)
BFD06FA6      4862   LW V1, 8(SP)
BFD06FA8      4841   LW V0, 4(SP)
BFD06FAA  477C0000   DI ZERO
BFD06FAE  18000000   SLL ZERO, ZERO, 3
BFD06FB0  4B471800   SB ZERO, 19271(ZERO)
BFD06FB2      4B47   LW K0, 28(SP)
BFD06FB4      4B65   LW K1, 20(SP)
BFD06FB6  02FC034E   MTC0 K0, EPC
BFD06FBA      4B46   LW K0, 24(SP)
BFD06FBC      4C11   ADDIU SP, SP, 32
BFD06FBE  12FC034C   MTC0 K0, SRSCtl
BFD06FC0  03BD12FC   ADDI S7, GP, 957
BFD06FC2  F17C03BD   WRPGPR SP, SP
BFD06FC4  036CF17C   JALX 0xBDF00DB0
BFD06FC6  02FC036C   MTC0 K1, Status
BFD06FC8  000002FC   SLL S7, GP, 0
BFD06FCA  F37C0000   ERET
BFD06FCC  0C00F37C   JALX 0xBDF03000
44:                  
45:                  #else
46:                  
47:                  void __attribute__((weak, interrupt, nomips16))
48:                  girq16_b0(void)
49:                  {
50:                      jtvic_dis_clr_source(MEC14xx_GIRQ16_ID, 0);
51:                  }
52:                  
53:                  void __attribute__((weak, interrupt, nomips16))
54:                  girq16_b1(void)
55:                  {
56:                      jtvic_dis_clr_source(MEC14xx_GIRQ16_ID, 1);
57:                  }
58:                  
59:                  void __attribute__((weak, interrupt, nomips16))
60:                  girq16_b2(void)
61:                  {
62:                      jtvic_dis_clr_source(MEC14xx_GIRQ16_ID, 2);
63:                  }
64:                  
65:                  void __attribute__((weak, interrupt, nomips16))
66:                  girq16_b3(void)
67:                  {
68:                      jtvic_dis_clr_source(MEC14xx_GIRQ16_ID, 3);
69:                  }
70:                  
71:                  void __attribute__((weak, interrupt, nomips16))
72:                  girq16_b4(void)
73:                  {
74:                      jtvic_dis_clr_source(MEC14xx_GIRQ16_ID, 4);
75:                  }
76:                  
77:                  void __attribute__((weak, interrupt, nomips16))
78:                  girq16_b5(void)
79:                  {
80:                      jtvic_dis_clr_source(MEC14xx_GIRQ16_ID, 5);
81:                  }
82:                  
83:                  void __attribute__((weak, interrupt, nomips16))
84:                  girq16_b6(void)
85:                  {
86:                      jtvic_dis_clr_source(MEC14xx_GIRQ16_ID, 6);
87:                  }
88:                  
89:                  void __attribute__((weak, interrupt, nomips16))
90:                  girq16_b7(void)
91:                  {
92:                      jtvic_dis_clr_source(MEC14xx_GIRQ16_ID, 7);
93:                  }
94:                  
95:                  void __attribute__((weak, interrupt, nomips16))
96:                  girq16_b8(void)
97:                  {
98:                      jtvic_dis_clr_source(MEC14xx_GIRQ16_ID, 8);
99:                  }
100:                 
101:                 void __attribute__((weak, interrupt, nomips16))
102:                 girq16_b9(void)
103:                 {
104:                     jtvic_dis_clr_source(MEC14xx_GIRQ16_ID, 9);
105:                 }
106:                 
107:                 #endif
108:                 
109:                 /* end girq16.c */
110:                 /**   @}
111:                  */
112:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq15.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq15.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #if GIRQ15_DISAGG == 0
37:                  
38:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
39:                  girq15_isr(void)
40:                  {
BFD06EE0  E17C03BD   RDPGPR SP, SP
BFD06EE4  00FC036E   MFC0 K1, EPC
BFD06EE6  034C00FC   INS A3, GP, 13, -12
BFD06EE8  10FC034C   MFC0 K0, SRSCtl
BFD06EEA  4FF110FC   ADDI A3, GP, 20465
BFD06EEC      4FF1   ADDIU SP, SP, -32
BFD06EEE      CB67   SW K1, 28(SP)
BFD06EF0  00FC036C   MFC0 K1, Status
BFD06EF4      CB46   SW K0, 24(SP)
BFD06EF6  00FC034D   MFC0 K0, Cause
BFD06EFA      CB65   SW K1, 20(SP)
BFD06EFC  5040035A   SRL K0, K0, 10
BFD06EFE  037A5040   ORI V0, ZERO, 890
BFD06F00  7A8C037A   INS K1, K0, 10, 6
BFD06F02  03607A8C   ADDIUPC A1, 787296
BFD06F04  204C0360   INS K1, ZERO, 1, 4
BFD06F06  036C204C   LWC2 V0, 876(T4)
BFD06F08  02FC036C   MTC0 K1, Status
BFD06F0C      C862   SW V1, 8(SP)
BFD06F0E      C841   SW V0, 4(SP)
BFD06F10      4866   LW V1, 24(SP)
BFD06F12      2DB7   ANDI V1, V1, 0xF
BFD06F14      CBC3   SW S8, 12(SP)
BFD06F16      0FDD   MOVE S8, SP
41:                      JTVIC_GROUP_EN_CLR->w = (1ul<<7);
BFD06F18  BFFF41A2   LUI V0, 0xBFFF
BFD06F1A  5042BFFF   LDC1 F31, 20546(RA)
BFD06F1C  C50C5042   ORI V0, V0, -15092
BFD06F20  00803060   ADDIU V1, ZERO, 128
BFD06F24      E9A0   SW V1, 0(V0)
42:                  }
BFD06F26      0FBE   MOVE SP, S8
BFD06F28      4846   LW V0, 24(SP)
BFD06F2A      2D27   ANDI V0, V0, 0xF
BFD06F2C      4BC3   LW S8, 12(SP)
BFD06F2E      4862   LW V1, 8(SP)
BFD06F30      4841   LW V0, 4(SP)
BFD06F32  477C0000   DI ZERO
BFD06F36  18000000   SLL ZERO, ZERO, 3
BFD06F38  4B471800   SB ZERO, 19271(ZERO)
BFD06F3A      4B47   LW K0, 28(SP)
BFD06F3C      4B65   LW K1, 20(SP)
BFD06F3E  02FC034E   MTC0 K0, EPC
BFD06F42      4B46   LW K0, 24(SP)
BFD06F44      4C11   ADDIU SP, SP, 32
BFD06F46  12FC034C   MTC0 K0, SRSCtl
BFD06F48  03BD12FC   ADDI S7, GP, 957
BFD06F4A  F17C03BD   WRPGPR SP, SP
BFD06F4C  036CF17C   JALX 0xBDF00DB0
BFD06F4E  02FC036C   MTC0 K1, Status
BFD06F50  000002FC   SLL S7, GP, 0
BFD06F52  F37C0000   ERET
BFD06F54  0C00F37C   JALX 0xBDF03000
43:                  
44:                  #else
45:                  
46:                  void __attribute__((weak, interrupt, nomips16))
47:                  girq15_b0(void)
48:                  {
49:                      jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 0);
50:                  }
51:                  
52:                  void __attribute__((weak, interrupt, nomips16))
53:                  girq15_b1(void)
54:                  {
55:                      jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 1);
56:                  }
57:                  
58:                  void __attribute__((weak, interrupt, nomips16))
59:                  girq15_b2(void)
60:                  {
61:                      jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 2);
62:                  }
63:                  
64:                  void __attribute__((weak, interrupt, nomips16))
65:                  girq15_b3(void)
66:                  {
67:                      jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 3);
68:                  }
69:                  
70:                  void __attribute__((weak, interrupt, nomips16))
71:                  girq15_b4(void)
72:                  {
73:                      jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 4);
74:                  }
75:                  
76:                  void __attribute__((weak, interrupt, nomips16))
77:                  girq15_b5(void)
78:                  {
79:                      jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 5);
80:                  }
81:                  
82:                  void __attribute__((weak, interrupt, nomips16))
83:                  girq15_b6(void)
84:                  {
85:                      jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 6);
86:                  }
87:                  
88:                  void __attribute__((weak, interrupt, nomips16))
89:                  girq15_b7(void)
90:                  {
91:                      jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 7);
92:                  }
93:                  
94:                  void __attribute__((weak, interrupt, nomips16))
95:                  girq15_b8(void)
96:                  {
97:                      jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 8);
98:                  }
99:                  
100:                 void __attribute__((weak, interrupt, nomips16))
101:                 girq15_b9(void)
102:                 {
103:                     jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 9);
104:                 }
105:                 
106:                 void __attribute__((weak, interrupt, nomips16))
107:                 girq15_b10(void)
108:                 {
109:                     jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 10);
110:                 }
111:                 
112:                 void __attribute__((weak, interrupt, nomips16))
113:                 girq15_b11(void)
114:                 {
115:                     jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 11);
116:                 }
117:                 
118:                 void __attribute__((weak, interrupt, nomips16))
119:                 girq15_b12(void)
120:                 {
121:                     jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 12);
122:                 }
123:                 
124:                 void __attribute__((weak, interrupt, nomips16))
125:                 girq15_b13(void)
126:                 {
127:                     jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 13);
128:                 }
129:                 
130:                 void __attribute__((weak, interrupt, nomips16))
131:                 girq15_b14(void)
132:                 {
133:                     jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 14);
134:                 }
135:                 
136:                 void __attribute__((weak, interrupt, nomips16))
137:                 girq15_b15(void)
138:                 {
139:                     jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 15);
140:                 }
141:                 
142:                 void __attribute__((weak, interrupt, nomips16))
143:                 girq15_b16(void)
144:                 {
145:                     jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 16);
146:                 }
147:                 
148:                 void __attribute__((weak, interrupt, nomips16))
149:                 girq15_b17(void)
150:                 {
151:                     jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 17);
152:                 }
153:                 
154:                 void __attribute__((weak, interrupt, nomips16))
155:                 girq15_b18(void)
156:                 {
157:                     jtvic_dis_clr_source(MEC14xx_GIRQ15_ID, 18);
158:                 }
159:                 
160:                 
161:                 #endif
162:                 
163:                 /* end girq15.c */
164:                 /**   @}
165:                  */
166:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq14.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq14.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #if GIRQ14_DISAGG == 0
37:                  
38:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
39:                  girq14_isr(void)
40:                  {
BFD078A0  E17C03BD   RDPGPR SP, SP
BFD078A4  00FC036E   MFC0 K1, EPC
BFD078A6  034C00FC   INS A3, GP, 13, -12
BFD078A8  10FC034C   MFC0 K0, SRSCtl
BFD078AA  4FF110FC   ADDI A3, GP, 20465
BFD078AC      4FF1   ADDIU SP, SP, -32
BFD078AE      CB67   SW K1, 28(SP)
BFD078B0  00FC036C   MFC0 K1, Status
BFD078B4      CB46   SW K0, 24(SP)
BFD078B6  00FC034D   MFC0 K0, Cause
BFD078BA      CB65   SW K1, 20(SP)
BFD078BC  5040035A   SRL K0, K0, 10
BFD078BE  037A5040   ORI V0, ZERO, 890
BFD078C0  7A8C037A   INS K1, K0, 10, 6
BFD078C2  03607A8C   ADDIUPC A1, 787296
BFD078C4  204C0360   INS K1, ZERO, 1, 4
BFD078C6  036C204C   LWC2 V0, 876(T4)
BFD078C8  02FC036C   MTC0 K1, Status
BFD078CC      C862   SW V1, 8(SP)
BFD078CE      C841   SW V0, 4(SP)
BFD078D0      4866   LW V1, 24(SP)
BFD078D2      2DB7   ANDI V1, V1, 0xF
BFD078D4      CBC3   SW S8, 12(SP)
BFD078D6      0FDD   MOVE S8, SP
41:                      JTVIC_GROUP_EN_CLR->w = (1ul<<6);
BFD078D8  BFFF41A2   LUI V0, 0xBFFF
BFD078DA  5042BFFF   LDC1 F31, 20546(RA)
BFD078DC  C50C5042   ORI V0, V0, -15092
BFD078E0      EDC0   LI V1, 64
BFD078E2      E9A0   SW V1, 0(V0)
42:                  }
BFD078E4      0FBE   MOVE SP, S8
BFD078E6      4846   LW V0, 24(SP)
BFD078E8      2D27   ANDI V0, V0, 0xF
BFD078EA      4BC3   LW S8, 12(SP)
BFD078EC      4862   LW V1, 8(SP)
BFD078EE      4841   LW V0, 4(SP)
BFD078F0  477C0000   DI ZERO
BFD078F4  18000000   SLL ZERO, ZERO, 3
BFD078F6  4B471800   SB ZERO, 19271(ZERO)
BFD078F8      4B47   LW K0, 28(SP)
BFD078FA      4B65   LW K1, 20(SP)
BFD078FC  02FC034E   MTC0 K0, EPC
BFD07900      4B46   LW K0, 24(SP)
BFD07902      4C11   ADDIU SP, SP, 32
BFD07904  12FC034C   MTC0 K0, SRSCtl
BFD07906  03BD12FC   ADDI S7, GP, 957
BFD07908  F17C03BD   WRPGPR SP, SP
BFD0790A  036CF17C   JALX 0xBDF00DB0
BFD0790C  02FC036C   MTC0 K1, Status
BFD0790E  000002FC   SLL S7, GP, 0
BFD07910  F37C0000   ERET
BFD07912  4FF1F37C   JALX 0xBDF13FC4
43:                  
44:                  #else
45:                  
46:                  void __attribute__((weak, interrupt, nomips16))
47:                  girq14_b0(void)
48:                  {
49:                      jtvic_dis_clr_source(MEC14xx_GIRQ14_ID, 0);
50:                  }
51:                  
52:                  void __attribute__((weak, interrupt, nomips16))
53:                  girq14_b1(void)
54:                  {
55:                      jtvic_dis_clr_source(MEC14xx_GIRQ14_ID, 1);
56:                  }
57:                  
58:                  void __attribute__((weak, interrupt, nomips16))
59:                  girq14_b2(void)
60:                  {
61:                      jtvic_dis_clr_source(MEC14xx_GIRQ14_ID, 2);
62:                  }
63:                  
64:                  void __attribute__((weak, interrupt, nomips16))
65:                  girq14_b3(void)
66:                  {
67:                      jtvic_dis_clr_source(MEC14xx_GIRQ14_ID, 3);
68:                  }
69:                  
70:                  void __attribute__((weak, interrupt, nomips16))
71:                  girq14_b4(void)
72:                  {
73:                      jtvic_dis_clr_source(MEC14xx_GIRQ14_ID, 4);
74:                  }
75:                  
76:                  void __attribute__((weak, interrupt, nomips16))
77:                  girq14_b5(void)
78:                  {
79:                      jtvic_dis_clr_source(MEC14xx_GIRQ14_ID, 5);
80:                  }
81:                  
82:                  
83:                  #endif
84:                  
85:                  /* end girq14.c */
86:                  /**   @}
87:                   */
88:                  
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq13.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq13.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  #if GIRQ13_DISAGG == 0
37:                  
38:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
39:                  girq13_isr(void)
40:                  {
BFD0782C  E17C03BD   RDPGPR SP, SP
BFD07830  00FC036E   MFC0 K1, EPC
BFD07832  034C00FC   INS A3, GP, 13, -12
BFD07834  10FC034C   MFC0 K0, SRSCtl
BFD07836  4FF110FC   ADDI A3, GP, 20465
BFD07838      4FF1   ADDIU SP, SP, -32
BFD0783A      CB67   SW K1, 28(SP)
BFD0783C  00FC036C   MFC0 K1, Status
BFD07840      CB46   SW K0, 24(SP)
BFD07842  00FC034D   MFC0 K0, Cause
BFD07846      CB65   SW K1, 20(SP)
BFD07848  5040035A   SRL K0, K0, 10
BFD0784A  037A5040   ORI V0, ZERO, 890
BFD0784C  7A8C037A   INS K1, K0, 10, 6
BFD0784E  03607A8C   ADDIUPC A1, 787296
BFD07850  204C0360   INS K1, ZERO, 1, 4
BFD07852  036C204C   LWC2 V0, 876(T4)
BFD07854  02FC036C   MTC0 K1, Status
BFD07858      C862   SW V1, 8(SP)
BFD0785A      C841   SW V0, 4(SP)
BFD0785C      4866   LW V1, 24(SP)
BFD0785E      2DB7   ANDI V1, V1, 0xF
BFD07860      CBC3   SW S8, 12(SP)
BFD07862      0FDD   MOVE S8, SP
41:                      JTVIC_GROUP_EN_CLR->w = (1ul<<5);
BFD07864  BFFF41A2   LUI V0, 0xBFFF
BFD07866  5042BFFF   LDC1 F31, 20546(RA)
BFD07868  C50C5042   ORI V0, V0, -15092
BFD0786C      EDA0   LI V1, 32
BFD0786E      E9A0   SW V1, 0(V0)
42:                  }
BFD07870      0FBE   MOVE SP, S8
BFD07872      4846   LW V0, 24(SP)
BFD07874      2D27   ANDI V0, V0, 0xF
BFD07876      4BC3   LW S8, 12(SP)
BFD07878      4862   LW V1, 8(SP)
BFD0787A      4841   LW V0, 4(SP)
BFD0787C  477C0000   DI ZERO
BFD07880  18000000   SLL ZERO, ZERO, 3
BFD07882  4B471800   SB ZERO, 19271(ZERO)
BFD07884      4B47   LW K0, 28(SP)
BFD07886      4B65   LW K1, 20(SP)
BFD07888  02FC034E   MTC0 K0, EPC
BFD0788C      4B46   LW K0, 24(SP)
BFD0788E      4C11   ADDIU SP, SP, 32
BFD07890  12FC034C   MTC0 K0, SRSCtl
BFD07892  03BD12FC   ADDI S7, GP, 957
BFD07894  F17C03BD   WRPGPR SP, SP
BFD07896  036CF17C   JALX 0xBDF00DB0
BFD07898  02FC036C   MTC0 K1, Status
BFD0789A  000002FC   SLL S7, GP, 0
BFD0789C  F37C0000   ERET
BFD0789E  03BDF37C   JALX 0xBDF00EF4
43:                  
44:                  #else
45:                  
46:                  void __attribute__((weak, interrupt, nomips16))
47:                  girq13_b0(void)
48:                  {
49:                      jtvic_dis_clr_source(MEC14xx_GIRQ13_ID, 0);
50:                  }
51:                  
52:                  void __attribute__((weak, interrupt, nomips16))
53:                  girq13_b1(void)
54:                  {
55:                      jtvic_dis_clr_source(MEC14xx_GIRQ13_ID, 1);
56:                  }
57:                  
58:                  void __attribute__((weak, interrupt, nomips16))
59:                  girq13_b2(void)
60:                  {
61:                      jtvic_dis_clr_source(MEC14xx_GIRQ13_ID, 2);
62:                  }
63:                  
64:                  void __attribute__((weak, interrupt, nomips16))
65:                  girq13_b3(void)
66:                  {
67:                      jtvic_dis_clr_source(MEC14xx_GIRQ13_ID, 3);
68:                  }
69:                  
70:                  void __attribute__((weak, interrupt, nomips16))
71:                  girq13_b4(void)
72:                  {
73:                      jtvic_dis_clr_source(MEC14xx_GIRQ13_ID, 4);
74:                  }
75:                  
76:                  void __attribute__((weak, interrupt, nomips16))
77:                  girq13_b5(void)
78:                  {
79:                      jtvic_dis_clr_source(MEC14xx_GIRQ13_ID, 5);
80:                  }
81:                  
82:                  void __attribute__((weak, interrupt, nomips16))
83:                  girq13_b6(void)
84:                  {
85:                      jtvic_dis_clr_source(MEC14xx_GIRQ13_ID, 6);
86:                  }
87:                  
88:                  #endif
89:                  
90:                  /* end girq13.c */
91:                  /**   @}
92:                   */
93:                  
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq12.c  ----
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq12.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  
29:                  #include "appcfg.h"
30:                  #include "platform.h"
31:                  #include "MEC14xx/mec14xx.h"
32:                  #include "MEC14xx/mec14xx_girqs.h"
33:                  #include "MEC14xx/mec14xx_gpio.h"
34:                  #include "MEC14xx/mec14xx_trace_func.h"
35:                  
36:                  
37:                  #if GIRQ12_DISAGG == 0
38:                  
39:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
40:                  girq12_isr(void)
41:                  {
BFD077B8  E17C03BD   RDPGPR SP, SP
BFD077BC  00FC036E   MFC0 K1, EPC
BFD077BE  034C00FC   INS A3, GP, 13, -12
BFD077C0  10FC034C   MFC0 K0, SRSCtl
BFD077C2  4FF110FC   ADDI A3, GP, 20465
BFD077C4      4FF1   ADDIU SP, SP, -32
BFD077C6      CB67   SW K1, 28(SP)
BFD077C8  00FC036C   MFC0 K1, Status
BFD077CC      CB46   SW K0, 24(SP)
BFD077CE  00FC034D   MFC0 K0, Cause
BFD077D2      CB65   SW K1, 20(SP)
BFD077D4  5040035A   SRL K0, K0, 10
BFD077D6  037A5040   ORI V0, ZERO, 890
BFD077D8  7A8C037A   INS K1, K0, 10, 6
BFD077DA  03607A8C   ADDIUPC A1, 787296
BFD077DC  204C0360   INS K1, ZERO, 1, 4
BFD077DE  036C204C   LWC2 V0, 876(T4)
BFD077E0  02FC036C   MTC0 K1, Status
BFD077E4      C862   SW V1, 8(SP)
BFD077E6      C841   SW V0, 4(SP)
BFD077E8      4866   LW V1, 24(SP)
BFD077EA      2DB7   ANDI V1, V1, 0xF
BFD077EC      CBC3   SW S8, 12(SP)
BFD077EE      0FDD   MOVE S8, SP
42:                      JTVIC_GROUP_EN_CLR->w = (1ul<<4);
BFD077F0  BFFF41A2   LUI V0, 0xBFFF
BFD077F2  5042BFFF   LDC1 F31, 20546(RA)
BFD077F4  C50C5042   ORI V0, V0, -15092
BFD077F8      ED90   LI V1, 16
BFD077FA      E9A0   SW V1, 0(V0)
43:                  }
BFD077FC      0FBE   MOVE SP, S8
BFD077FE      4846   LW V0, 24(SP)
BFD07800      2D27   ANDI V0, V0, 0xF
BFD07802      4BC3   LW S8, 12(SP)
BFD07804      4862   LW V1, 8(SP)
BFD07806      4841   LW V0, 4(SP)
BFD07808  477C0000   DI ZERO
BFD0780C  18000000   SLL ZERO, ZERO, 3
BFD0780E  4B471800   SB ZERO, 19271(ZERO)
BFD07810      4B47   LW K0, 28(SP)
BFD07812      4B65   LW K1, 20(SP)
BFD07814  02FC034E   MTC0 K0, EPC
BFD07818      4B46   LW K0, 24(SP)
BFD0781A      4C11   ADDIU SP, SP, 32
BFD0781C  12FC034C   MTC0 K0, SRSCtl
BFD0781E  03BD12FC   ADDI S7, GP, 957
BFD07820  F17C03BD   WRPGPR SP, SP
BFD07822  036CF17C   JALX 0xBDF00DB0
BFD07824  02FC036C   MTC0 K1, Status
BFD07826  000002FC   SLL S7, GP, 0
BFD07828  F37C0000   ERET
BFD0782A  03BDF37C   JALX 0xBDF00EF4
44:                  
45:                  #else
46:                  
47:                  void __attribute__((weak, interrupt, nomips16))
48:                  girq12_b0(void)
49:                  {
50:                      jtvic_dis_clr_source(MEC14xx_GIRQ12_ID, 0);
51:                  }
52:                  
53:                  void __attribute__((weak, interrupt, nomips16))
54:                  girq12_b1(void)
55:                  {
56:                      jtvic_dis_clr_source(MEC14xx_GIRQ12_ID, 1);
57:                  }
58:                  
59:                  void __attribute__((weak, interrupt, nomips16))
60:                  girq12_b2(void)
61:                  {
62:                      jtvic_dis_clr_source(MEC14xx_GIRQ12_ID, 2);
63:                  }
64:                  
65:                  #endif
66:                  
67:                  /* end girq12.c */
68:                  /**   @}
69:                   */
70:                  
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq11.c  ----
1:                   /*****************************************************************************
2:                   * Copyright 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq11.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  
29:                  #include "appcfg.h"
30:                  #include "platform.h"
31:                  #include "MEC14xx/mec14xx.h"
32:                  #include "MEC14xx/mec14xx_girqs.h"
33:                  #include "MEC14xx/mec14xx_gpio.h"
34:                  #include "MEC14xx/mec14xx_trace_func.h"
35:                  
36:                  
37:                  #if GIRQ11_DISAGG == 0
38:                  
39:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
40:                  girq11_isr(void)
41:                  {
BFD07744  E17C03BD   RDPGPR SP, SP
BFD07748  00FC036E   MFC0 K1, EPC
BFD0774A  034C00FC   INS A3, GP, 13, -12
BFD0774C  10FC034C   MFC0 K0, SRSCtl
BFD0774E  4FF110FC   ADDI A3, GP, 20465
BFD07750      4FF1   ADDIU SP, SP, -32
BFD07752      CB67   SW K1, 28(SP)
BFD07754  00FC036C   MFC0 K1, Status
BFD07758      CB46   SW K0, 24(SP)
BFD0775A  00FC034D   MFC0 K0, Cause
BFD0775E      CB65   SW K1, 20(SP)
BFD07760  5040035A   SRL K0, K0, 10
BFD07762  037A5040   ORI V0, ZERO, 890
BFD07764  7A8C037A   INS K1, K0, 10, 6
BFD07766  03607A8C   ADDIUPC A1, 787296
BFD07768  204C0360   INS K1, ZERO, 1, 4
BFD0776A  036C204C   LWC2 V0, 876(T4)
BFD0776C  02FC036C   MTC0 K1, Status
BFD07770      C862   SW V1, 8(SP)
BFD07772      C841   SW V0, 4(SP)
BFD07774      4866   LW V1, 24(SP)
BFD07776      2DB7   ANDI V1, V1, 0xF
BFD07778      CBC3   SW S8, 12(SP)
BFD0777A      0FDD   MOVE S8, SP
42:                      JTVIC_GROUP_EN_CLR->w = (1ul<<3);
BFD0777C  BFFF41A2   LUI V0, 0xBFFF
BFD0777E  5042BFFF   LDC1 F31, 20546(RA)
BFD07780  C50C5042   ORI V0, V0, -15092
BFD07784      ED88   LI V1, 8
BFD07786      E9A0   SW V1, 0(V0)
43:                  }
BFD07788      0FBE   MOVE SP, S8
BFD0778A      4846   LW V0, 24(SP)
BFD0778C      2D27   ANDI V0, V0, 0xF
BFD0778E      4BC3   LW S8, 12(SP)
BFD07790      4862   LW V1, 8(SP)
BFD07792      4841   LW V0, 4(SP)
BFD07794  477C0000   DI ZERO
BFD07798  18000000   SLL ZERO, ZERO, 3
BFD0779A  4B471800   SB ZERO, 19271(ZERO)
BFD0779C      4B47   LW K0, 28(SP)
BFD0779E      4B65   LW K1, 20(SP)
BFD077A0  02FC034E   MTC0 K0, EPC
BFD077A4      4B46   LW K0, 24(SP)
BFD077A6      4C11   ADDIU SP, SP, 32
BFD077A8  12FC034C   MTC0 K0, SRSCtl
BFD077AA  03BD12FC   ADDI S7, GP, 957
BFD077AC  F17C03BD   WRPGPR SP, SP
BFD077AE  036CF17C   JALX 0xBDF00DB0
BFD077B0  02FC036C   MTC0 K1, Status
BFD077B2  000002FC   SLL S7, GP, 0
BFD077B4  F37C0000   ERET
BFD077B6  03BDF37C   JALX 0xBDF00EF4
44:                  
45:                  #else
46:                  
47:                  void __attribute__((weak, interrupt, nomips16))
48:                  girq11_b0(void)
49:                  {
50:                      return;
51:                  }
52:                  
53:                  void __attribute__((weak, interrupt, nomips16))
54:                  girq11_b1(void)
55:                  {
56:                      jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 1, JTVIC_CLR_SRC);
57:                  }
58:                  
59:                  void __attribute__((weak, interrupt, nomips16))
60:                  girq11_b2(void)
61:                  {
62:                      jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 2, JTVIC_CLR_SRC);
63:                  }
64:                  
65:                  void __attribute__((weak, interrupt, nomips16))
66:                  girq11_b3(void)
67:                  {
68:                      jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 3, JTVIC_CLR_SRC);
69:                  }
70:                  
71:                  void __attribute__((weak, interrupt, nomips16))
72:                  girq11_b4(void)
73:                  {
74:                      jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 4, JTVIC_CLR_SRC);
75:                  }
76:                  
77:                  void __attribute__((weak, interrupt, nomips16))
78:                  girq11_b5(void)
79:                  {
80:                      jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 5, JTVIC_CLR_SRC);
81:                  }
82:                  
83:                  void __attribute__((weak, interrupt, nomips16))
84:                  girq11_b6(void)
85:                  {
86:                      jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 6, JTVIC_CLR_SRC);
87:                  }
88:                  
89:                  void __attribute__((weak, interrupt, nomips16))
90:                  girq11_b7(void)
91:                  {
92:                      jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 7, JTVIC_CLR_SRC);
93:                  }
94:                  
95:                  void __attribute__((weak, interrupt, nomips16))
96:                  girq11_b8(void)
97:                  {
98:                      jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 8, JTVIC_CLR_SRC);
99:                  }
100:                 
101:                 void __attribute__((weak, interrupt, nomips16))
102:                 girq11_b9(void)
103:                 {
104:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 9, JTVIC_CLR_SRC);
105:                 }
106:                 
107:                 void __attribute__((weak, interrupt, nomips16))
108:                 girq11_b10(void)
109:                 {
110:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 10, JTVIC_CLR_SRC);
111:                 }
112:                 
113:                 void __attribute__((weak, interrupt, nomips16))
114:                 girq11_b11(void)
115:                 {
116:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 11, JTVIC_CLR_SRC);
117:                 }
118:                 
119:                 void __attribute__((weak, interrupt, nomips16))
120:                 girq11_b12(void)
121:                 {
122:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 12, JTVIC_CLR_SRC);
123:                 }
124:                 
125:                 void __attribute__((weak, interrupt, nomips16))
126:                 girq11_b13(void)
127:                 {
128:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 13, JTVIC_CLR_SRC);
129:                 }
130:                 
131:                 void __attribute__((weak, interrupt, nomips16))
132:                 girq11_b14(void)
133:                 {
134:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 14, JTVIC_CLR_SRC);
135:                 }
136:                 
137:                 void __attribute__((weak, interrupt, nomips16))
138:                 girq11_b15(void)
139:                 {
140:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 15, JTVIC_CLR_SRC);
141:                 }
142:                 
143:                 void __attribute__((weak, interrupt, nomips16))
144:                 girq11_b16(void)
145:                 {
146:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 16, JTVIC_CLR_SRC);
147:                 }
148:                 
149:                 void __attribute__((weak, interrupt, nomips16))
150:                 girq11_b17(void)
151:                 {
152:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 17, JTVIC_CLR_SRC);
153:                 }
154:                 
155:                 void __attribute__((weak, interrupt, nomips16))
156:                 girq11_b18(void)
157:                 {
158:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 18, JTVIC_CLR_SRC);
159:                 }
160:                 
161:                 void __attribute__((weak, interrupt, nomips16))
162:                 girq11_b19(void)
163:                 {
164:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 19, JTVIC_CLR_SRC);
165:                 }
166:                 
167:                 void __attribute__((weak, interrupt, nomips16))
168:                 girq11_b20(void)
169:                 {
170:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 20, JTVIC_CLR_SRC);
171:                 }
172:                 
173:                 void __attribute__((weak, interrupt, nomips16))
174:                 girq11_b21(void)
175:                 {
176:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 21, JTVIC_CLR_SRC);
177:                 }
178:                 
179:                 void __attribute__((weak, interrupt, nomips16))
180:                 girq11_b22(void)
181:                 {
182:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 22, JTVIC_CLR_SRC);
183:                 }
184:                 
185:                 void __attribute__((weak, interrupt, nomips16))
186:                 girq11_b23(void)
187:                 {
188:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 23, JTVIC_CLR_SRC);
189:                 }
190:                 
191:                 void __attribute__((weak, interrupt, nomips16))
192:                 girq11_b24(void)
193:                 {
194:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 24, JTVIC_CLR_SRC);
195:                 }
196:                 
197:                 void __attribute__((weak, interrupt, nomips16))
198:                 girq11_b25(void)
199:                 {
200:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 25, JTVIC_CLR_SRC);
201:                 }
202:                 
203:                 void __attribute__((weak, interrupt, nomips16))
204:                 girq11_b26(void)
205:                 {
206:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 26, JTVIC_CLR_SRC);
207:                 }
208:                 
209:                 void __attribute__((weak, interrupt, nomips16))
210:                 girq11_b27(void)
211:                 {
212:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 27, JTVIC_CLR_SRC);
213:                 }
214:                 
215:                 void __attribute__((weak, interrupt, nomips16))
216:                 girq11_b28(void)
217:                 {
218:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 28, JTVIC_CLR_SRC);
219:                 }
220:                 
221:                 void __attribute__((weak, interrupt, nomips16))
222:                 girq11_b29(void)
223:                 {
224:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 29, JTVIC_CLR_SRC);
225:                 }
226:                 
227:                 void __attribute__((weak, interrupt, nomips16))
228:                 girq11_b30(void)
229:                 {
230:                     jtvic_dis_clr_source(MEC14xx_GIRQ11_ID, 30, JTVIC_CLR_SRC);
231:                 }
232:                 
233:                 #endif
234:                 
235:                 /* end girq11.c */
236:                 /**   @}
237:                  */
238:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq10.c  ----
1:                   /*****************************************************************************
2:                   * Copyright 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq10.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  
29:                  #include "appcfg.h"
30:                  #include "platform.h"
31:                  #include "MEC14xx/mec14xx.h"
32:                  #include "MEC14xx/mec14xx_girqs.h"
33:                  #include "MEC14xx/mec14xx_gpio.h"
34:                  #include "MEC14xx/mec14xx_trace_func.h"
35:                  
36:                  
37:                  #if GIRQ10_DISAGG == 0
38:                  
39:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
40:                  girq10_isr(void)
41:                  {
BFD076D0  E17C03BD   RDPGPR SP, SP
BFD076D4  00FC036E   MFC0 K1, EPC
BFD076D6  034C00FC   INS A3, GP, 13, -12
BFD076D8  10FC034C   MFC0 K0, SRSCtl
BFD076DA  4FF110FC   ADDI A3, GP, 20465
BFD076DC      4FF1   ADDIU SP, SP, -32
BFD076DE      CB67   SW K1, 28(SP)
BFD076E0  00FC036C   MFC0 K1, Status
BFD076E4      CB46   SW K0, 24(SP)
BFD076E6  00FC034D   MFC0 K0, Cause
BFD076EA      CB65   SW K1, 20(SP)
BFD076EC  5040035A   SRL K0, K0, 10
BFD076EE  037A5040   ORI V0, ZERO, 890
BFD076F0  7A8C037A   INS K1, K0, 10, 6
BFD076F2  03607A8C   ADDIUPC A1, 787296
BFD076F4  204C0360   INS K1, ZERO, 1, 4
BFD076F6  036C204C   LWC2 V0, 876(T4)
BFD076F8  02FC036C   MTC0 K1, Status
BFD076FC      C862   SW V1, 8(SP)
BFD076FE      C841   SW V0, 4(SP)
BFD07700      4866   LW V1, 24(SP)
BFD07702      2DB7   ANDI V1, V1, 0xF
BFD07704      CBC3   SW S8, 12(SP)
BFD07706      0FDD   MOVE S8, SP
42:                      JTVIC_GROUP_EN_CLR->w = (1ul<<2);
BFD07708  BFFF41A2   LUI V0, 0xBFFF
BFD0770A  5042BFFF   LDC1 F31, 20546(RA)
BFD0770C  C50C5042   ORI V0, V0, -15092
BFD07710      ED84   LI V1, 4
BFD07712      E9A0   SW V1, 0(V0)
43:                  }
BFD07714      0FBE   MOVE SP, S8
BFD07716      4846   LW V0, 24(SP)
BFD07718      2D27   ANDI V0, V0, 0xF
BFD0771A      4BC3   LW S8, 12(SP)
BFD0771C      4862   LW V1, 8(SP)
BFD0771E      4841   LW V0, 4(SP)
BFD07720  477C0000   DI ZERO
BFD07724  18000000   SLL ZERO, ZERO, 3
BFD07726  4B471800   SB ZERO, 19271(ZERO)
BFD07728      4B47   LW K0, 28(SP)
BFD0772A      4B65   LW K1, 20(SP)
BFD0772C  02FC034E   MTC0 K0, EPC
BFD07730      4B46   LW K0, 24(SP)
BFD07732      4C11   ADDIU SP, SP, 32
BFD07734  12FC034C   MTC0 K0, SRSCtl
BFD07736  03BD12FC   ADDI S7, GP, 957
BFD07738  F17C03BD   WRPGPR SP, SP
BFD0773A  036CF17C   JALX 0xBDF00DB0
BFD0773C  02FC036C   MTC0 K1, Status
BFD0773E  000002FC   SLL S7, GP, 0
BFD07740  F37C0000   ERET
BFD07742  03BDF37C   JALX 0xBDF00EF4
44:                  
45:                  #else
46:                  
47:                  void __attribute__((weak, interrupt, nomips16))
48:                  girq10_b0(void)
49:                  {
50:                      jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 0, JTVIC_CLR_SRC);
51:                  }
52:                  
53:                  void __attribute__((weak, interrupt, nomips16))
54:                  girq10_b1(void)
55:                  {
56:                      jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 1, JTVIC_CLR_SRC);
57:                  }
58:                  
59:                  void __attribute__((weak, interrupt, nomips16))
60:                  girq10_b2(void)
61:                  {
62:                      jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 2, JTVIC_CLR_SRC);
63:                  }
64:                  
65:                  void __attribute__((weak, interrupt, nomips16))
66:                  girq10_b3(void)
67:                  {
68:                      jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 3, JTVIC_CLR_SRC);
69:                  }
70:                  
71:                  void __attribute__((weak, interrupt, nomips16))
72:                  girq10_b4(void)
73:                  {
74:                      jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 4, JTVIC_CLR_SRC);
75:                  }
76:                  
77:                  void __attribute__((weak, interrupt, nomips16))
78:                  girq10_b5(void)
79:                  {
80:                      jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 5, JTVIC_CLR_SRC);
81:                  }
82:                  
83:                  void __attribute__((weak, interrupt, nomips16))
84:                  girq10_b6(void)
85:                  {
86:                      jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 6, JTVIC_CLR_SRC);
87:                  }
88:                  
89:                  void __attribute__((weak, interrupt, nomips16))
90:                  girq10_b7(void)
91:                  {
92:                      jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 7, JTVIC_CLR_SRC);
93:                  }
94:                  
95:                  void __attribute__((weak, interrupt, nomips16))
96:                  girq10_b8(void)
97:                  {
98:                      jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 8, JTVIC_CLR_SRC);
99:                  }
100:                 
101:                 void __attribute__((weak, interrupt, nomips16))
102:                 girq10_b9(void)
103:                 {
104:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 9, JTVIC_CLR_SRC);
105:                 }
106:                 
107:                 void __attribute__((weak, interrupt, nomips16))
108:                 girq10_b10(void)
109:                 {
110:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 10, JTVIC_CLR_SRC);
111:                 }
112:                 
113:                 void __attribute__((weak, interrupt, nomips16))
114:                 girq10_b11(void)
115:                 {
116:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 11, JTVIC_CLR_SRC);
117:                 }
118:                 
119:                 
120:                 void __attribute__((weak, interrupt, nomips16))
121:                 girq10_b12(void)
122:                 {
123:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 12, JTVIC_CLR_SRC);
124:                 }
125:                 
126:                 void __attribute__((weak, interrupt, nomips16))
127:                 girq10_b13(void)
128:                 {
129:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 13, JTVIC_CLR_SRC);
130:                 }
131:                 
132:                 void __attribute__((weak, interrupt, nomips16))
133:                 girq10_b14(void)
134:                 {
135:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 14, JTVIC_CLR_SRC);
136:                 }
137:                 
138:                 void __attribute__((weak, interrupt, nomips16))
139:                 girq10_b15(void)
140:                 {
141:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 15, JTVIC_CLR_SRC);
142:                 }
143:                 
144:                 void __attribute__((weak, interrupt, nomips16))
145:                 girq10_b16(void)
146:                 {
147:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 16, JTVIC_CLR_SRC);
148:                 }
149:                 
150:                 void __attribute__((weak, interrupt, nomips16))
151:                 girq10_b17(void)
152:                 {
153:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 17, JTVIC_CLR_SRC);
154:                 }
155:                 
156:                 void __attribute__((weak, interrupt, nomips16))
157:                 girq10_b18(void)
158:                 {
159:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 18, JTVIC_CLR_SRC);
160:                 }
161:                 
162:                 void __attribute__((weak, interrupt, nomips16))
163:                 girq10_b19(void)
164:                 {
165:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 19, JTVIC_CLR_SRC);
166:                 }
167:                 
168:                 void __attribute__((weak, interrupt, nomips16))
169:                 girq10_b20(void)
170:                 {
171:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 20, JTVIC_CLR_SRC);
172:                 }
173:                 
174:                 void __attribute__((weak, interrupt, nomips16))
175:                 girq10_b21(void)
176:                 {
177:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 21, JTVIC_CLR_SRC);
178:                 }
179:                 
180:                 void __attribute__((weak, interrupt, nomips16))
181:                 girq10_b22(void)
182:                 {
183:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 22, JTVIC_CLR_SRC);
184:                 }
185:                 
186:                 void __attribute__((weak, interrupt, nomips16))
187:                 girq10_b23(void)
188:                 {
189:                     jtvic_dis_clr_source(MEC14xx_GIRQ10_ID, 23, JTVIC_CLR_SRC);
190:                 }
191:                 
192:                 #endif
193:                 
194:                 /* end girq10.c */
195:                 /**   @}
196:                  */
197:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq09.c  ----
1:                   /*****************************************************************************
2:                   * Copyright 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq09.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  
29:                  
30:                  #include "appcfg.h"
31:                  #include "platform.h"
32:                  #include "MEC14xx/mec14xx.h"
33:                  #include "MEC14xx/mec14xx_girqs.h"
34:                  #include "MEC14xx/mec14xx_gpio.h"
35:                  #include "MEC14xx/mec14xx_trace_func.h"
36:                  
37:                  
38:                  #if GIRQ09_DISAGG == 0
39:                  
40:                  /*
41:                   * Aggregated mode handler, must handle all enabled 
42:                   * GIRQ08 sources. 
43:                  */
44:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
45:                  girq09_isr( void )
46:                  {
BFD0765C  E17C03BD   RDPGPR SP, SP
BFD07660  00FC036E   MFC0 K1, EPC
BFD07662  034C00FC   INS A3, GP, 13, -12
BFD07664  10FC034C   MFC0 K0, SRSCtl
BFD07666  4FF110FC   ADDI A3, GP, 20465
BFD07668      4FF1   ADDIU SP, SP, -32
BFD0766A      CB67   SW K1, 28(SP)
BFD0766C  00FC036C   MFC0 K1, Status
BFD07670      CB46   SW K0, 24(SP)
BFD07672  00FC034D   MFC0 K0, Cause
BFD07676      CB65   SW K1, 20(SP)
BFD07678  5040035A   SRL K0, K0, 10
BFD0767A  037A5040   ORI V0, ZERO, 890
BFD0767C  7A8C037A   INS K1, K0, 10, 6
BFD0767E  03607A8C   ADDIUPC A1, 787296
BFD07680  204C0360   INS K1, ZERO, 1, 4
BFD07682  036C204C   LWC2 V0, 876(T4)
BFD07684  02FC036C   MTC0 K1, Status
BFD07688      C862   SW V1, 8(SP)
BFD0768A      C841   SW V0, 4(SP)
BFD0768C      4866   LW V1, 24(SP)
BFD0768E      2DB7   ANDI V1, V1, 0xF
BFD07690      CBC3   SW S8, 12(SP)
BFD07692      0FDD   MOVE S8, SP
47:                      JTVIC_GROUP_EN_CLR->w = (1ul<<1);
BFD07694  BFFF41A2   LUI V0, 0xBFFF
BFD07696  5042BFFF   LDC1 F31, 20546(RA)
BFD07698  C50C5042   ORI V0, V0, -15092
BFD0769C      ED82   LI V1, 2
BFD0769E      E9A0   SW V1, 0(V0)
48:                  }
BFD076A0      0FBE   MOVE SP, S8
BFD076A2      4846   LW V0, 24(SP)
BFD076A4      2D27   ANDI V0, V0, 0xF
BFD076A6      4BC3   LW S8, 12(SP)
BFD076A8      4862   LW V1, 8(SP)
BFD076AA      4841   LW V0, 4(SP)
BFD076AC  477C0000   DI ZERO
BFD076B0  18000000   SLL ZERO, ZERO, 3
BFD076B2  4B471800   SB ZERO, 19271(ZERO)
BFD076B4      4B47   LW K0, 28(SP)
BFD076B6      4B65   LW K1, 20(SP)
BFD076B8  02FC034E   MTC0 K0, EPC
BFD076BC      4B46   LW K0, 24(SP)
BFD076BE      4C11   ADDIU SP, SP, 32
BFD076C0  12FC034C   MTC0 K0, SRSCtl
BFD076C2  03BD12FC   ADDI S7, GP, 957
BFD076C4  F17C03BD   WRPGPR SP, SP
BFD076C6  036CF17C   JALX 0xBDF00DB0
BFD076C8  02FC036C   MTC0 K1, Status
BFD076CA  000002FC   SLL S7, GP, 0
BFD076CC  F37C0000   ERET
BFD076CE  03BDF37C   JALX 0xBDF00EF4
49:                  
50:                  #else
51:                  
52:                  void __attribute__((weak, interrupt, nomips16))
53:                  girq09_b0(void)
54:                  {
55:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 0);
56:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 0);
57:                  }
58:                  
59:                  void __attribute__((weak, interrupt, nomips16))
60:                  girq09_b1(void)
61:                  {
62:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 1);
63:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 1);
64:                  }
65:                  
66:                  void __attribute__((weak, interrupt, nomips16))
67:                  girq09_b2(void)
68:                  {
69:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 2);
70:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 2);
71:                  }
72:                  
73:                  void __attribute__((weak, interrupt, nomips16))
74:                  girq09_b3(void)
75:                  {
76:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 3);
77:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 3);
78:                  }
79:                  
80:                  void __attribute__((weak, interrupt, nomips16))
81:                  girq09_b4(void)
82:                  {
83:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 4);
84:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 4);
85:                  }
86:                  
87:                  void __attribute__((weak, interrupt, nomips16))
88:                  girq09_b5(void)
89:                  {
90:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 5);
91:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 5);
92:                  }
93:                  
94:                  void __attribute__((weak, interrupt, nomips16))
95:                  girq09_b6(void)
96:                  {
97:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 6);
98:                      JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 6);
99:                  }
100:                 
101:                 void __attribute__((weak, interrupt, nomips16))
102:                 girq09_b7(void)
103:                 {
104:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 7);
105:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 7);
106:                 }
107:                 
108:                 void __attribute__((weak, interrupt, nomips16))
109:                 girq09_b8(void)
110:                 {
111:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 8);
112:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 8);
113:                 }
114:                 
115:                 void __attribute__((weak, interrupt, nomips16))
116:                 girq09_b9(void)
117:                 {
118:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 9);
119:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 9);
120:                 }
121:                 
122:                 void __attribute__((weak, interrupt, nomips16))
123:                 girq09_b10(void)
124:                 {
125:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 10);
126:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 10);
127:                 }
128:                 
129:                 void __attribute__((weak, interrupt, nomips16))
130:                 girq09_b11(void)
131:                 {
132:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 11);
133:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 11);
134:                 }
135:                 
136:                 void __attribute__((weak, interrupt, nomips16))
137:                 girq09_b12(void)
138:                 {
139:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 12);
140:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 12);
141:                 }
142:                 
143:                 void __attribute__((weak, interrupt, nomips16))
144:                 girq09_b13(void)
145:                 {
146:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 13);
147:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 13);
148:                 }
149:                 
150:                 void __attribute__((weak, interrupt, nomips16))
151:                 girq09_b14(void)
152:                 {
153:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 14);
154:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 14);
155:                 }
156:                 
157:                 void __attribute__((weak, interrupt, nomips16))
158:                 girq09_b15(void)
159:                 {
160:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 15);
161:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 15);
162:                 }
163:                 
164:                 void __attribute__((weak, interrupt, nomips16))
165:                 girq09_b16(void)
166:                 {
167:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 16);
168:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 16);
169:                 }
170:                 
171:                 void __attribute__((weak, interrupt, nomips16))
172:                 girq09_b17(void)
173:                 {
174:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 17);
175:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 17);
176:                 }
177:                 
178:                 void __attribute__((weak, interrupt, nomips16))
179:                 girq09_b18(void)
180:                 {
181:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 18);
182:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 18);
183:                 }
184:                 
185:                 void __attribute__((weak, interrupt, nomips16))
186:                 girq09_b19(void)
187:                 {
188:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 19);
189:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 19);
190:                 }
191:                 
192:                 void __attribute__((weak, interrupt, nomips16))
193:                 girq09_b20(void)
194:                 {
195:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 20);
196:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 20);
197:                 }
198:                 
199:                 void __attribute__((weak, interrupt, nomips16))
200:                 girq09_b21(void)
201:                 {
202:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 21);
203:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 21);
204:                 }
205:                 
206:                 void __attribute__((weak, interrupt, nomips16))
207:                 girq09_b22(void)
208:                 {
209:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 22);
210:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 22);
211:                 }
212:                 
213:                 void __attribute__((weak, interrupt, nomips16))
214:                 girq09_b23(void)
215:                 {
216:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 23);
217:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 23);
218:                 }
219:                 
220:                 void __attribute__((weak, interrupt, nomips16))
221:                 girq09_b24(void)
222:                 {
223:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 24);
224:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 24);
225:                 }
226:                 
227:                 void __attribute__((weak, interrupt, nomips16))
228:                 girq09_b25(void)
229:                 {
230:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 25);
231:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 25);
232:                 }
233:                 
234:                 void __attribute__((weak, interrupt, nomips16))
235:                 girq09_b26(void)
236:                 {
237:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 26);
238:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 26);
239:                 }
240:                 
241:                 void __attribute__((weak, interrupt, nomips16))
242:                 girq09_b27(void)
243:                 {
244:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 27);
245:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 27);
246:                 }
247:                 
248:                 void __attribute__((weak, interrupt, nomips16))
249:                 girq09_b28(void)
250:                 {
251:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 28);
252:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 28);
253:                 }
254:                 
255:                 void __attribute__((weak, interrupt, nomips16))
256:                 girq09_b29(void)
257:                 {
258:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 29);
259:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 29);
260:                 }
261:                 
262:                 void __attribute__((weak, interrupt, nomips16))
263:                 girq09_b30(void)
264:                 {
265:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].EN_CLR = (1ul << 30);
266:                     JTVIC_GIRQ->REGS[MEC14xx_GIRQ09_ID].SOURCE = (1ul << 30);
267:                 }
268:                 
269:                 
270:                 #endif
271:                 
272:                 /* end girq09.c */
273:                 /**   @}
274:                  */
275:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/interrupts/girq08.c  ----
1:                   /*****************************************************************************
2:                   * Copyright 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file girq08.c
22:                   *Interrupt service routines for MIPS using vanilla GCC and MCHP XC32
23:                   */
24:                  /** @defgroup MEC14xx ISR
25:                   *  @{
26:                   */
27:                  
28:                  #include "appcfg.h"
29:                  #include "platform.h"
30:                  #include "MEC14xx/mec14xx.h"
31:                  #include "MEC14xx/mec14xx_girqs.h"
32:                  #include "MEC14xx/mec14xx_gpio.h"
33:                  #include "MEC14xx/mec14xx_trace_func.h"
34:                  
35:                  
36:                  
37:                  #if GIRQ08_DISAGG == 0
38:                  
39:                  /*
40:                   * Aggregated mode handler, must handle all enabled 
41:                   * GIRQ08 sources. 
42:                  */
43:                  void __attribute__((weak, interrupt, nomips16, section(".girqs")))
44:                  girq08_isr( void )
45:                  {
BFD075E8  E17C03BD   RDPGPR SP, SP
BFD075EC  00FC036E   MFC0 K1, EPC
BFD075EE  034C00FC   INS A3, GP, 13, -12
BFD075F0  10FC034C   MFC0 K0, SRSCtl
BFD075F2  4FF110FC   ADDI A3, GP, 20465
BFD075F4      4FF1   ADDIU SP, SP, -32
BFD075F6      CB67   SW K1, 28(SP)
BFD075F8  00FC036C   MFC0 K1, Status
BFD075FC      CB46   SW K0, 24(SP)
BFD075FE  00FC034D   MFC0 K0, Cause
BFD07602      CB65   SW K1, 20(SP)
BFD07604  5040035A   SRL K0, K0, 10
BFD07606  037A5040   ORI V0, ZERO, 890
BFD07608  7A8C037A   INS K1, K0, 10, 6
BFD0760A  03607A8C   ADDIUPC A1, 787296
BFD0760C  204C0360   INS K1, ZERO, 1, 4
BFD0760E  036C204C   LWC2 V0, 876(T4)
BFD07610  02FC036C   MTC0 K1, Status
BFD07614      C862   SW V1, 8(SP)
BFD07616      C841   SW V0, 4(SP)
BFD07618      4866   LW V1, 24(SP)
BFD0761A      2DB7   ANDI V1, V1, 0xF
BFD0761C      CBC3   SW S8, 12(SP)
BFD0761E      0FDD   MOVE S8, SP
46:                      JTVIC_GROUP_EN_CLR->w = (1ul<<0);
BFD07620  BFFF41A2   LUI V0, 0xBFFF
BFD07622  5042BFFF   LDC1 F31, 20546(RA)
BFD07624  C50C5042   ORI V0, V0, -15092
BFD07628      ED81   LI V1, 1
BFD0762A      E9A0   SW V1, 0(V0)
47:                  }
BFD0762C      0FBE   MOVE SP, S8
BFD0762E      4846   LW V0, 24(SP)
BFD07630      2D27   ANDI V0, V0, 0xF
BFD07632      4BC3   LW S8, 12(SP)
BFD07634      4862   LW V1, 8(SP)
BFD07636      4841   LW V0, 4(SP)
BFD07638  477C0000   DI ZERO
BFD0763C  18000000   SLL ZERO, ZERO, 3
BFD0763E  4B471800   SB ZERO, 19271(ZERO)
BFD07640      4B47   LW K0, 28(SP)
BFD07642      4B65   LW K1, 20(SP)
BFD07644  02FC034E   MTC0 K0, EPC
BFD07648      4B46   LW K0, 24(SP)
BFD0764A      4C11   ADDIU SP, SP, 32
BFD0764C  12FC034C   MTC0 K0, SRSCtl
BFD0764E  03BD12FC   ADDI S7, GP, 957
BFD07650  F17C03BD   WRPGPR SP, SP
BFD07652  036CF17C   JALX 0xBDF00DB0
BFD07654  02FC036C   MTC0 K1, Status
BFD07656  000002FC   SLL S7, GP, 0
BFD07658  F37C0000   ERET
BFD0765A  03BDF37C   JALX 0xBDF00EF4
48:                  
49:                  #else
50:                  
51:                  /*
52:                   * Disaggregated GIRQ08 subhandlers, one for each 
53:                   * source.  Called by assembly language wrapper. 
54:                  */
55:                  
56:                  
57:                  void __attribute__((weak, interrupt, nomips16))
58:                  girq08_b0(void)
59:                  {
60:                      jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 0);
61:                  }
62:                  
63:                  
64:                  void __attribute__((weak, interrupt, nomips16))
65:                  girq08_b1(void)
66:                  {
67:                      jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 1);
68:                  }
69:                  
70:                  
71:                  void __attribute__((weak, interrupt, nomips16))
72:                  girq08_b2(void)
73:                  {
74:                      jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 2);
75:                  }
76:                  
77:                  
78:                  void __attribute__((weak, interrupt, nomips16))
79:                  girq08_b3(void)
80:                  {
81:                      jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 3);
82:                  }
83:                  
84:                  
85:                  void __attribute__((weak, interrupt, nomips16))
86:                  girq08_b4(void)
87:                  {
88:                      jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 4);
89:                  }
90:                  
91:                  
92:                  void __attribute__((weak, interrupt, nomips16))
93:                  girq08_b5(void)
94:                  {
95:                      jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 5);
96:                  }
97:                  
98:                  
99:                  void __attribute__((weak, interrupt, nomips16))
100:                 girq08_b6(void)
101:                 {
102:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 6);
103:                 }
104:                 
105:                 
106:                 void __attribute__((weak, interrupt, nomips16))
107:                 girq08_b7(void)
108:                 {
109:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 7);
110:                 }
111:                 
112:                 
113:                 void __attribute__((weak, interrupt, nomips16))
114:                 girq08_b8(void)
115:                 {
116:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 8);
117:                 }
118:                 
119:                 
120:                 void __attribute__((weak, interrupt, nomips16))
121:                 girq08_b9(void)
122:                 {
123:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 9);
124:                 }
125:                 
126:                 
127:                 void __attribute__((weak, interrupt, nomips16))
128:                 girq08_b10(void)
129:                 {
130:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 10);
131:                 }
132:                 
133:                 
134:                 void __attribute__((weak, interrupt, nomips16))
135:                 girq08_b11(void)
136:                 {
137:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 11);
138:                 }
139:                 
140:                 
141:                 void __attribute__((weak, interrupt, nomips16))
142:                 girq08_b12(void)
143:                 {
144:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 12);
145:                 }
146:                 
147:                 
148:                 void __attribute__((weak, interrupt, nomips16))
149:                 girq08_b13(void)
150:                 {
151:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 13);
152:                 }
153:                 
154:                 
155:                 void __attribute__((weak, interrupt, nomips16))
156:                 girq08_b14(void)
157:                 {
158:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 14);
159:                 }
160:                 
161:                 
162:                 void __attribute__((weak, interrupt, nomips16))
163:                 girq08_b15(void)
164:                 {
165:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 15);
166:                 }
167:                 
168:                 
169:                 void __attribute__((weak, interrupt, nomips16))
170:                 girq08_b16(void)
171:                 {
172:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 16);
173:                 }
174:                 
175:                 
176:                 void __attribute__((weak, interrupt, nomips16))
177:                 girq08_b17(void)
178:                 {
179:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 17);
180:                 }
181:                 
182:                 
183:                 void __attribute__((weak, interrupt, nomips16))
184:                 girq08_b18(void)
185:                 {
186:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 18);
187:                 }
188:                 
189:                 
190:                 void __attribute__((weak, interrupt, nomips16))
191:                 girq08_b19(void)
192:                 {
193:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 19);
194:                 }
195:                 
196:                 
197:                 void __attribute__((weak, interrupt, nomips16))
198:                 girq08_b20(void)
199:                 {
200:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 20);
201:                 }
202:                 
203:                 
204:                 void __attribute__((weak, interrupt, nomips16))
205:                 girq08_b21(void)
206:                 {
207:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 21);
208:                 }
209:                 
210:                 
211:                 void __attribute__((weak, interrupt, nomips16))
212:                 girq08_b22(void)
213:                 {
214:                     jtvic_dis_clr_source(MEC14xx_GIRQ08_ID, 22);
215:                 }
216:                 
217:                 
218:                 #endif
219:                 
220:                 
221:                 /* end girq08.c */
222:                 /**   @}
223:                  */
224:                 
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/mec14xx/exceptions/mplab/general_exception.c
1:                   /*****************************************************************************
2:                   * (c) 2014 Microchip Technology Inc. and its subsidiaries.
3:                   * You may use this software and any derivatives exclusively with
4:                   * Microchip products.
5:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".
6:                   * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
7:                   * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
8:                   * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP
9:                   * PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
10:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
11:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
12:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
13:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.
14:                  * TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
15:                  * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF
16:                  * FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
17:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE
18:                  * OF THESE TERMS.
19:                  *****************************************************************************/
20:                  
21:                  /** @file general_exception.c
22:                   *MEC14xx General Exception Handler
23:                   */
24:                  /** @defgroup MEC14xx Exceptions
25:                   *  @{
26:                   */
27:                  
28:                  
29:                  #include "appcfg.h"
30:                  #include "platform.h"
31:                  #include "MEC14xx/mec14xx.h"
32:                  #include "MEC14xx/mec14xx_trace_inline.h"
33:                  
34:                  typedef struct gen_except_capture
35:                  {
36:                      uint32_t stack_ptr;
37:                      uint32_t cp0_status;
38:                      uint32_t cp0_cause;
39:                      uint32_t cp0_epc;
40:                      uint32_t cp0_error_epc;
41:                      uint32_t cp0_nexc;
42:                      uint32_t cp0_nepc;
43:                      uint32_t cp0_badvaddr;
44:                      uint32_t ahb_err;
45:                  } GEN_EXCEPT_CAPTURE;
46:                  
47:                  GEN_EXCEPT_CAPTURE gexc_cap;
48:                  
49:                  void 
50:                  __attribute__((nomips16, noreturn)) _general_exception_handler (void)
51:                  {
BFD00460      4FF9   ADDIU SP, SP, -16
BFD00462      CBE3   SW RA, 12(SP)
BFD00464      CBC2   SW S8, 8(SP)
BFD00466      0FDD   MOVE S8, SP
52:                      /* 
53:                       *  MEC14xx Application General Exception handler
54:                       */
55:                      uint32_t e;
56:                  
57:                      /* Get current Stack Pointer. Note: this is not SP at
58:                       * exception. XC32 wraps _general_exception_handler in
59:                       * assembly code which saves state resulting is a
60:                       * modified SP. Wrapper allocates 88 bytes for context
61:                       * save. Original SP = SPcurrent + 88.
62:                       */
63:                      __asm__ __volatile (
BFD00468      0FFD   MOVE RA, SP
BFD0046A      0C00   NOP
BFD0046C  0000FBFE   SW RA, 0(S8)
64:                        "move %0,$sp \n\t"
65:                        "nop        \n\t" 
66:                        :"=r" (e) 
67:                        ::);
68:                      gexc_cap.stack_ptr = e;
BFD00470  BFD241A2   LUI V0, 0xBFD2
BFD00472  FC7EBFD2   LDC1 F30, -898(S2)
BFD00474  0000FC7E   LW V1, 0(S8)
BFD00478  8134F862   SW V1, -32460(V0)
69:                      
70:                      gexc_cap.cp0_status = _CP0_GET_STATUS();
BFD0047C  00FC006C   MFC0 V1, Status
BFD00480  BFD241A2   LUI V0, 0xBFD2
BFD00482  3042BFD2   LDC1 F30, 12354(S2)
BFD00484  81343042   ADDIU V0, V0, -32460
BFD00488      E9A1   SW V1, 4(V0)
71:                      gexc_cap.cp0_cause = _CP0_GET_CAUSE();
BFD0048A  00FC006D   MFC0 V1, Cause
BFD0048E  BFD241A2   LUI V0, 0xBFD2
BFD00490  3042BFD2   LDC1 F30, 12354(S2)
BFD00492  81343042   ADDIU V0, V0, -32460
BFD00496      E9A2   SW V1, 8(V0)
72:                      gexc_cap.cp0_epc = _CP0_GET_EPC();
BFD00498  00FC006E   MFC0 V1, EPC
BFD0049C  BFD241A2   LUI V0, 0xBFD2
BFD0049E  3042BFD2   LDC1 F30, 12354(S2)
BFD004A0  81343042   ADDIU V0, V0, -32460
BFD004A4      E9A3   SW V1, 12(V0)
73:                      gexc_cap.cp0_error_epc = _CP0_GET_ERROREPC();
BFD004A6  00FC007E   MFC0 V1, ErrorEPC
BFD004AA  BFD241A2   LUI V0, 0xBFD2
BFD004AC  3042BFD2   LDC1 F30, 12354(S2)
BFD004AE  81343042   ADDIU V0, V0, -32460
BFD004B2      E9A4   SW V1, 16(V0)
74:                      gexc_cap.cp0_nexc = _CP0_GET_NESTEDEXC();
BFD004B4  10FC006D   MFC0 V1, $13, 2
BFD004B6  41A210FC   ADDI A3, GP, 16802
BFD004B8  BFD241A2   LUI V0, 0xBFD2
BFD004BA  3042BFD2   LDC1 F30, 12354(S2)
BFD004BC  81343042   ADDIU V0, V0, -32460
BFD004C0      E9A5   SW V1, 20(V0)
75:                      gexc_cap.cp0_nepc = _CP0_GET_NESTEDEPC();
BFD004C2  08FC006E   MFC0 V1, $14, 1
BFD004C4      08FC   LBU S1, 12(A3)
BFD004C6  BFD241A2   LUI V0, 0xBFD2
BFD004C8  3042BFD2   LDC1 F30, 12354(S2)
BFD004CA  81343042   ADDIU V0, V0, -32460
BFD004CE      E9A6   SW V1, 24(V0)
76:                      gexc_cap.cp0_badvaddr = _CP0_GET_BADVADDR();
BFD004D0  00FC0068   MFC0 V1, BadVAddr
BFD004D4  BFD241A2   LUI V0, 0xBFD2
BFD004D6  3042BFD2   LDC1 F30, 12354(S2)
BFD004D8  81343042   ADDIU V0, V0, -32460
BFD004DC      E9A7   SW V1, 28(V0)
77:                  
78:                      trace0(0, AP3GENEXCEPT, 0, "Application General Exception Handler (BEV=0)");
79:                      TRACE11(601, AP3GENEXCEPT, 0, "Current SP   = 0x%08x",gexc_cap.stack_ptr);
BFD004DE  A00041A2   LUI V0, 0xA000
BFD004E2  8C005042   ORI V0, V0, -29696
BFD004E4      8C00   BEQZ S0, 0xBFD004E6
BFD004E6  FFFD3060   ADDIU V1, ZERO, -3
BFD004E8  89A0FFFD   LW RA, -30304(SP)
BFD004EA      89A0   SB V1, 0(V0)
BFD004EC  A00041A2   LUI V0, 0xA000
BFD004F0  8C005042   ORI V0, V0, -29696
BFD004F2      8C00   BEQZ S0, 0xBFD004F4
BFD004F4      EDD9   LI V1, 89
BFD004F6      89A0   SB V1, 0(V0)
BFD004F8  A00041A2   LUI V0, 0xA000
BFD004FC  8C005042   ORI V0, V0, -29696
BFD004FE      8C00   BEQZ S0, 0xBFD00500
BFD00500      ED82   LI V1, 2
BFD00502      89A0   SB V1, 0(V0)
BFD00504  A00041A2   LUI V0, 0xA000
BFD00508  8C005042   ORI V0, V0, -29696
BFD0050A      8C00   BEQZ S0, 0xBFD0050C
BFD0050C  BFD241A3   LUI V1, 0xBFD2
BFD0050E  FC63BFD2   LDC1 F30, -925(S2)
BFD00510  8134FC63   LW V1, -32460(V1)
BFD00514      2DBD   ANDI V1, V1, 0xFF
BFD00516      89A0   SB V1, 0(V0)
BFD00518  A00041A2   LUI V0, 0xA000
BFD0051C  8C005042   ORI V0, V0, -29696
BFD0051E      8C00   BEQZ S0, 0xBFD00520
BFD00520  BFD241A3   LUI V1, 0xBFD2
BFD00522  FC63BFD2   LDC1 F30, -925(S2)
BFD00524  8134FC63   LW V1, -32460(V1)
BFD00528      25B1   SRL V1, V1, 8
BFD0052A      2DBD   ANDI V1, V1, 0xFF
BFD0052C      89A0   SB V1, 0(V0)
BFD0052E  A00041A2   LUI V0, 0xA000
BFD00532  8C005042   ORI V0, V0, -29696
BFD00534      8C00   BEQZ S0, 0xBFD00536
BFD00536  BFD241A3   LUI V1, 0xBFD2
BFD00538  FC63BFD2   LDC1 F30, -925(S2)
BFD0053A  8134FC63   LW V1, -32460(V1)
BFD0053E  80400063   SRL V1, V1, 16
BFD00542      2DBD   ANDI V1, V1, 0xFF
BFD00544      89A0   SB V1, 0(V0)
BFD00546  A00041A2   LUI V0, 0xA000
BFD0054A  8C005042   ORI V0, V0, -29696
BFD0054C      8C00   BEQZ S0, 0xBFD0054E
BFD0054E  BFD241A3   LUI V1, 0xBFD2
BFD00550  FC63BFD2   LDC1 F30, -925(S2)
BFD00552  8134FC63   LW V1, -32460(V1)
BFD00556  C0400063   SRL V1, V1, 24
BFD0055A      2DBD   ANDI V1, V1, 0xFF
BFD0055C      89A0   SB V1, 0(V0)
80:                      TRACE11(602, AP3GENEXCEPT, 0, "CP0 STATUS   = 0x%08x",gexc_cap.cp0_status);
BFD0055E  A00041A2   LUI V0, 0xA000
BFD00562  8C005042   ORI V0, V0, -29696
BFD00564      8C00   BEQZ S0, 0xBFD00566
BFD00566  FFFD3060   ADDIU V1, ZERO, -3
BFD00568  89A0FFFD   LW RA, -30304(SP)
BFD0056A      89A0   SB V1, 0(V0)
BFD0056C  A00041A2   LUI V0, 0xA000
BFD00570  8C005042   ORI V0, V0, -29696
BFD00572      8C00   BEQZ S0, 0xBFD00574
BFD00574      EDDA   LI V1, 90
BFD00576      89A0   SB V1, 0(V0)
BFD00578  A00041A2   LUI V0, 0xA000
BFD0057C  8C005042   ORI V0, V0, -29696
BFD0057E      8C00   BEQZ S0, 0xBFD00580
BFD00580      ED82   LI V1, 2
BFD00582      89A0   SB V1, 0(V0)
BFD00584  A00041A2   LUI V0, 0xA000
BFD00588  8C005042   ORI V0, V0, -29696
BFD0058A      8C00   BEQZ S0, 0xBFD0058C
BFD0058C  BFD241A3   LUI V1, 0xBFD2
BFD0058E  3063BFD2   LDC1 F30, 12387(S2)
BFD00590  81343063   ADDIU V1, V1, -32460
BFD00594      69B1   LW V1, 4(V1)
BFD00596      2DBD   ANDI V1, V1, 0xFF
BFD00598      89A0   SB V1, 0(V0)
BFD0059A  A00041A2   LUI V0, 0xA000
BFD0059E  8C005042   ORI V0, V0, -29696
BFD005A0      8C00   BEQZ S0, 0xBFD005A2
BFD005A2  BFD241A3   LUI V1, 0xBFD2
BFD005A4  3063BFD2   LDC1 F30, 12387(S2)
BFD005A6  81343063   ADDIU V1, V1, -32460
BFD005AA      69B1   LW V1, 4(V1)
BFD005AC      25B1   SRL V1, V1, 8
BFD005AE      2DBD   ANDI V1, V1, 0xFF
BFD005B0      89A0   SB V1, 0(V0)
BFD005B2  A00041A2   LUI V0, 0xA000
BFD005B6  8C005042   ORI V0, V0, -29696
BFD005B8      8C00   BEQZ S0, 0xBFD005BA
BFD005BA  BFD241A3   LUI V1, 0xBFD2
BFD005BC  3063BFD2   LDC1 F30, 12387(S2)
BFD005BE  81343063   ADDIU V1, V1, -32460
BFD005C2      69B1   LW V1, 4(V1)
BFD005C4  80400063   SRL V1, V1, 16
BFD005C8      2DBD   ANDI V1, V1, 0xFF
BFD005CA      89A0   SB V1, 0(V0)
BFD005CC  A00041A2   LUI V0, 0xA000
BFD005D0  8C005042   ORI V0, V0, -29696
BFD005D2      8C00   BEQZ S0, 0xBFD005D4
BFD005D4  BFD241A3   LUI V1, 0xBFD2
BFD005D6  3063BFD2   LDC1 F30, 12387(S2)
BFD005D8  81343063   ADDIU V1, V1, -32460
BFD005DC      69B1   LW V1, 4(V1)
BFD005DE  C0400063   SRL V1, V1, 24
BFD005E2      2DBD   ANDI V1, V1, 0xFF
BFD005E4      89A0   SB V1, 0(V0)
81:                      TRACE11(603, AP3GENEXCEPT, 0, "CP0 CAUSE    = 0x%08x",gexc_cap.cp0_cause);
BFD005E6  A00041A2   LUI V0, 0xA000
BFD005EA  8C005042   ORI V0, V0, -29696
BFD005EC      8C00   BEQZ S0, 0xBFD005EE
BFD005EE  FFFD3060   ADDIU V1, ZERO, -3
BFD005F0  89A0FFFD   LW RA, -30304(SP)
BFD005F2      89A0   SB V1, 0(V0)
BFD005F4  A00041A2   LUI V0, 0xA000
BFD005F8  8C005042   ORI V0, V0, -29696
BFD005FA      8C00   BEQZ S0, 0xBFD005FC
BFD005FC      EDDB   LI V1, 91
BFD005FE      89A0   SB V1, 0(V0)
BFD00600  A00041A2   LUI V0, 0xA000
BFD00604  8C005042   ORI V0, V0, -29696
BFD00606      8C00   BEQZ S0, 0xBFD00608
BFD00608      ED82   LI V1, 2
BFD0060A      89A0   SB V1, 0(V0)
BFD0060C  A00041A2   LUI V0, 0xA000
BFD00610  8C005042   ORI V0, V0, -29696
BFD00612      8C00   BEQZ S0, 0xBFD00614
BFD00614  BFD241A3   LUI V1, 0xBFD2
BFD00616  3063BFD2   LDC1 F30, 12387(S2)
BFD00618  81343063   ADDIU V1, V1, -32460
BFD0061C      69B2   LW V1, 8(V1)
BFD0061E      2DBD   ANDI V1, V1, 0xFF
BFD00620      89A0   SB V1, 0(V0)
BFD00622  A00041A2   LUI V0, 0xA000
BFD00626  8C005042   ORI V0, V0, -29696
BFD00628      8C00   BEQZ S0, 0xBFD0062A
BFD0062A  BFD241A3   LUI V1, 0xBFD2
BFD0062C  3063BFD2   LDC1 F30, 12387(S2)
BFD0062E  81343063   ADDIU V1, V1, -32460
BFD00632      69B2   LW V1, 8(V1)
BFD00634      25B1   SRL V1, V1, 8
BFD00636      2DBD   ANDI V1, V1, 0xFF
BFD00638      89A0   SB V1, 0(V0)
BFD0063A  A00041A2   LUI V0, 0xA000
BFD0063E  8C005042   ORI V0, V0, -29696
BFD00640      8C00   BEQZ S0, 0xBFD00642
BFD00642  BFD241A3   LUI V1, 0xBFD2
BFD00644  3063BFD2   LDC1 F30, 12387(S2)
BFD00646  81343063   ADDIU V1, V1, -32460
BFD0064A      69B2   LW V1, 8(V1)
BFD0064C  80400063   SRL V1, V1, 16
BFD00650      2DBD   ANDI V1, V1, 0xFF
BFD00652      89A0   SB V1, 0(V0)
BFD00654  A00041A2   LUI V0, 0xA000
BFD00658  8C005042   ORI V0, V0, -29696
BFD0065A      8C00   BEQZ S0, 0xBFD0065C
BFD0065C  BFD241A3   LUI V1, 0xBFD2
BFD0065E  3063BFD2   LDC1 F30, 12387(S2)
BFD00660  81343063   ADDIU V1, V1, -32460
BFD00664      69B2   LW V1, 8(V1)
BFD00666  C0400063   SRL V1, V1, 24
BFD0066A      2DBD   ANDI V1, V1, 0xFF
BFD0066C      89A0   SB V1, 0(V0)
82:                      TRACE11(604, AP3GENEXCEPT, 0, "CP0 EPC      = 0x%08x",gexc_cap.cp0_epc);
BFD0066E  A00041A2   LUI V0, 0xA000
BFD00672  8C005042   ORI V0, V0, -29696
BFD00674      8C00   BEQZ S0, 0xBFD00676
BFD00676  FFFD3060   ADDIU V1, ZERO, -3
BFD00678  89A0FFFD   LW RA, -30304(SP)
BFD0067A      89A0   SB V1, 0(V0)
BFD0067C  A00041A2   LUI V0, 0xA000
BFD00680  8C005042   ORI V0, V0, -29696
BFD00682      8C00   BEQZ S0, 0xBFD00684
BFD00684      EDDC   LI V1, 92
BFD00686      89A0   SB V1, 0(V0)
BFD00688  A00041A2   LUI V0, 0xA000
BFD0068C  8C005042   ORI V0, V0, -29696
BFD0068E      8C00   BEQZ S0, 0xBFD00690
BFD00690      ED82   LI V1, 2
BFD00692      89A0   SB V1, 0(V0)
BFD00694  A00041A2   LUI V0, 0xA000
BFD00698  8C005042   ORI V0, V0, -29696
BFD0069A      8C00   BEQZ S0, 0xBFD0069C
BFD0069C  BFD241A3   LUI V1, 0xBFD2
BFD0069E  3063BFD2   LDC1 F30, 12387(S2)
BFD006A0  81343063   ADDIU V1, V1, -32460
BFD006A4      69B3   LW V1, 12(V1)
BFD006A6      2DBD   ANDI V1, V1, 0xFF
BFD006A8      89A0   SB V1, 0(V0)
BFD006AA  A00041A2   LUI V0, 0xA000
BFD006AE  8C005042   ORI V0, V0, -29696
BFD006B0      8C00   BEQZ S0, 0xBFD006B2
BFD006B2  BFD241A3   LUI V1, 0xBFD2
BFD006B4  3063BFD2   LDC1 F30, 12387(S2)
BFD006B6  81343063   ADDIU V1, V1, -32460
BFD006BA      69B3   LW V1, 12(V1)
BFD006BC      25B1   SRL V1, V1, 8
BFD006BE      2DBD   ANDI V1, V1, 0xFF
BFD006C0      89A0   SB V1, 0(V0)
BFD006C2  A00041A2   LUI V0, 0xA000
BFD006C6  8C005042   ORI V0, V0, -29696
BFD006C8      8C00   BEQZ S0, 0xBFD006CA
BFD006CA  BFD241A3   LUI V1, 0xBFD2
BFD006CC  3063BFD2   LDC1 F30, 12387(S2)
BFD006CE  81343063   ADDIU V1, V1, -32460
BFD006D2      69B3   LW V1, 12(V1)
BFD006D4  80400063   SRL V1, V1, 16
BFD006D8      2DBD   ANDI V1, V1, 0xFF
BFD006DA      89A0   SB V1, 0(V0)
BFD006DC  A00041A2   LUI V0, 0xA000
BFD006E0  8C005042   ORI V0, V0, -29696
BFD006E2      8C00   BEQZ S0, 0xBFD006E4
BFD006E4  BFD241A3   LUI V1, 0xBFD2
BFD006E6  3063BFD2   LDC1 F30, 12387(S2)
BFD006E8  81343063   ADDIU V1, V1, -32460
BFD006EC      69B3   LW V1, 12(V1)
BFD006EE  C0400063   SRL V1, V1, 24
BFD006F2      2DBD   ANDI V1, V1, 0xFF
BFD006F4      89A0   SB V1, 0(V0)
83:                      TRACE11(605, AP3GENEXCEPT, 0, "CP0 ERROREPC = 0x%08x",gexc_cap.cp0_error_epc);
BFD006F6  A00041A2   LUI V0, 0xA000
BFD006FA  8C005042   ORI V0, V0, -29696
BFD006FC      8C00   BEQZ S0, 0xBFD006FE
BFD006FE  FFFD3060   ADDIU V1, ZERO, -3
BFD00700  89A0FFFD   LW RA, -30304(SP)
BFD00702      89A0   SB V1, 0(V0)
BFD00704  A00041A2   LUI V0, 0xA000
BFD00708  8C005042   ORI V0, V0, -29696
BFD0070A      8C00   BEQZ S0, 0xBFD0070C
BFD0070C      EDDD   LI V1, 93
BFD0070E      89A0   SB V1, 0(V0)
BFD00710  A00041A2   LUI V0, 0xA000
BFD00714  8C005042   ORI V0, V0, -29696
BFD00716      8C00   BEQZ S0, 0xBFD00718
BFD00718      ED82   LI V1, 2
BFD0071A      89A0   SB V1, 0(V0)
BFD0071C  A00041A2   LUI V0, 0xA000
BFD00720  8C005042   ORI V0, V0, -29696
BFD00722      8C00   BEQZ S0, 0xBFD00724
BFD00724  BFD241A3   LUI V1, 0xBFD2
BFD00726  3063BFD2   LDC1 F30, 12387(S2)
BFD00728  81343063   ADDIU V1, V1, -32460
BFD0072C      69B4   LW V1, 16(V1)
BFD0072E      2DBD   ANDI V1, V1, 0xFF
BFD00730      89A0   SB V1, 0(V0)
BFD00732  A00041A2   LUI V0, 0xA000
BFD00736  8C005042   ORI V0, V0, -29696
BFD00738      8C00   BEQZ S0, 0xBFD0073A
BFD0073A  BFD241A3   LUI V1, 0xBFD2
BFD0073C  3063BFD2   LDC1 F30, 12387(S2)
BFD0073E  81343063   ADDIU V1, V1, -32460
BFD00742      69B4   LW V1, 16(V1)
BFD00744      25B1   SRL V1, V1, 8
BFD00746      2DBD   ANDI V1, V1, 0xFF
BFD00748      89A0   SB V1, 0(V0)
BFD0074A  A00041A2   LUI V0, 0xA000
BFD0074E  8C005042   ORI V0, V0, -29696
BFD00750      8C00   BEQZ S0, 0xBFD00752
BFD00752  BFD241A3   LUI V1, 0xBFD2
BFD00754  3063BFD2   LDC1 F30, 12387(S2)
BFD00756  81343063   ADDIU V1, V1, -32460
BFD0075A      69B4   LW V1, 16(V1)
BFD0075C  80400063   SRL V1, V1, 16
BFD00760      2DBD   ANDI V1, V1, 0xFF
BFD00762      89A0   SB V1, 0(V0)
BFD00764  A00041A2   LUI V0, 0xA000
BFD00768  8C005042   ORI V0, V0, -29696
BFD0076A      8C00   BEQZ S0, 0xBFD0076C
BFD0076C  BFD241A3   LUI V1, 0xBFD2
BFD0076E  3063BFD2   LDC1 F30, 12387(S2)
BFD00770  81343063   ADDIU V1, V1, -32460
BFD00774      69B4   LW V1, 16(V1)
BFD00776  C0400063   SRL V1, V1, 24
BFD0077A      2DBD   ANDI V1, V1, 0xFF
BFD0077C      89A0   SB V1, 0(V0)
84:                      TRACE11(606, AP3GENEXCEPT, 0, "CP0 NEXC     = 0x%08x",gexc_cap.cp0_nexc);
BFD0077E  A00041A2   LUI V0, 0xA000
BFD00782  8C005042   ORI V0, V0, -29696
BFD00784      8C00   BEQZ S0, 0xBFD00786
BFD00786  FFFD3060   ADDIU V1, ZERO, -3
BFD00788  89A0FFFD   LW RA, -30304(SP)
BFD0078A      89A0   SB V1, 0(V0)
BFD0078C  A00041A2   LUI V0, 0xA000
BFD00790  8C005042   ORI V0, V0, -29696
BFD00792      8C00   BEQZ S0, 0xBFD00794
BFD00794      EDDE   LI V1, 94
BFD00796      89A0   SB V1, 0(V0)
BFD00798  A00041A2   LUI V0, 0xA000
BFD0079C  8C005042   ORI V0, V0, -29696
BFD0079E      8C00   BEQZ S0, 0xBFD007A0
BFD007A0      ED82   LI V1, 2
BFD007A2      89A0   SB V1, 0(V0)
BFD007A4  A00041A2   LUI V0, 0xA000
BFD007A8  8C005042   ORI V0, V0, -29696
BFD007AA      8C00   BEQZ S0, 0xBFD007AC
BFD007AC  BFD241A3   LUI V1, 0xBFD2
BFD007AE  3063BFD2   LDC1 F30, 12387(S2)
BFD007B0  81343063   ADDIU V1, V1, -32460
BFD007B4      69B5   LW V1, 20(V1)
BFD007B6      2DBD   ANDI V1, V1, 0xFF
BFD007B8      89A0   SB V1, 0(V0)
BFD007BA  A00041A2   LUI V0, 0xA000
BFD007BE  8C005042   ORI V0, V0, -29696
BFD007C0      8C00   BEQZ S0, 0xBFD007C2
BFD007C2  BFD241A3   LUI V1, 0xBFD2
BFD007C4  3063BFD2   LDC1 F30, 12387(S2)
BFD007C6  81343063   ADDIU V1, V1, -32460
BFD007CA      69B5   LW V1, 20(V1)
BFD007CC      25B1   SRL V1, V1, 8
BFD007CE      2DBD   ANDI V1, V1, 0xFF
BFD007D0      89A0   SB V1, 0(V0)
BFD007D2  A00041A2   LUI V0, 0xA000
BFD007D6  8C005042   ORI V0, V0, -29696
BFD007D8      8C00   BEQZ S0, 0xBFD007DA
BFD007DA  BFD241A3   LUI V1, 0xBFD2
BFD007DC  3063BFD2   LDC1 F30, 12387(S2)
BFD007DE  81343063   ADDIU V1, V1, -32460
BFD007E2      69B5   LW V1, 20(V1)
BFD007E4  80400063   SRL V1, V1, 16
BFD007E8      2DBD   ANDI V1, V1, 0xFF
BFD007EA      89A0   SB V1, 0(V0)
BFD007EC  A00041A2   LUI V0, 0xA000
BFD007F0  8C005042   ORI V0, V0, -29696
BFD007F2      8C00   BEQZ S0, 0xBFD007F4
BFD007F4  BFD241A3   LUI V1, 0xBFD2
BFD007F6  3063BFD2   LDC1 F30, 12387(S2)
BFD007F8  81343063   ADDIU V1, V1, -32460
BFD007FC      69B5   LW V1, 20(V1)
BFD007FE  C0400063   SRL V1, V1, 24
BFD00802      2DBD   ANDI V1, V1, 0xFF
BFD00804      89A0   SB V1, 0(V0)
85:                      TRACE11(607, AP3GENEXCEPT, 0, "CP0 NEPC     = 0x%08x",gexc_cap.cp0_nepc);
BFD00806  A00041A2   LUI V0, 0xA000
BFD0080A  8C005042   ORI V0, V0, -29696
BFD0080C      8C00   BEQZ S0, 0xBFD0080E
BFD0080E  FFFD3060   ADDIU V1, ZERO, -3
BFD00810  89A0FFFD   LW RA, -30304(SP)
BFD00812      89A0   SB V1, 0(V0)
BFD00814  A00041A2   LUI V0, 0xA000
BFD00818  8C005042   ORI V0, V0, -29696
BFD0081A      8C00   BEQZ S0, 0xBFD0081C
BFD0081C      EDDF   LI V1, 95
BFD0081E      89A0   SB V1, 0(V0)
BFD00820  A00041A2   LUI V0, 0xA000
BFD00824  8C005042   ORI V0, V0, -29696
BFD00826      8C00   BEQZ S0, 0xBFD00828
BFD00828      ED82   LI V1, 2
BFD0082A      89A0   SB V1, 0(V0)
BFD0082C  A00041A2   LUI V0, 0xA000
BFD00830  8C005042   ORI V0, V0, -29696
BFD00832      8C00   BEQZ S0, 0xBFD00834
BFD00834  BFD241A3   LUI V1, 0xBFD2
BFD00836  3063BFD2   LDC1 F30, 12387(S2)
BFD00838  81343063   ADDIU V1, V1, -32460
BFD0083C      69B6   LW V1, 24(V1)
BFD0083E      2DBD   ANDI V1, V1, 0xFF
BFD00840      89A0   SB V1, 0(V0)
BFD00842  A00041A2   LUI V0, 0xA000
BFD00846  8C005042   ORI V0, V0, -29696
BFD00848      8C00   BEQZ S0, 0xBFD0084A
BFD0084A  BFD241A3   LUI V1, 0xBFD2
BFD0084C  3063BFD2   LDC1 F30, 12387(S2)
BFD0084E  81343063   ADDIU V1, V1, -32460
BFD00852      69B6   LW V1, 24(V1)
BFD00854      25B1   SRL V1, V1, 8
BFD00856      2DBD   ANDI V1, V1, 0xFF
BFD00858      89A0   SB V1, 0(V0)
BFD0085A  A00041A2   LUI V0, 0xA000
BFD0085E  8C005042   ORI V0, V0, -29696
BFD00860      8C00   BEQZ S0, 0xBFD00862
BFD00862  BFD241A3   LUI V1, 0xBFD2
BFD00864  3063BFD2   LDC1 F30, 12387(S2)
BFD00866  81343063   ADDIU V1, V1, -32460
BFD0086A      69B6   LW V1, 24(V1)
BFD0086C  80400063   SRL V1, V1, 16
BFD00870      2DBD   ANDI V1, V1, 0xFF
BFD00872      89A0   SB V1, 0(V0)
BFD00874  A00041A2   LUI V0, 0xA000
BFD00878  8C005042   ORI V0, V0, -29696
BFD0087A      8C00   BEQZ S0, 0xBFD0087C
BFD0087C  BFD241A3   LUI V1, 0xBFD2
BFD0087E  3063BFD2   LDC1 F30, 12387(S2)
BFD00880  81343063   ADDIU V1, V1, -32460
BFD00884      69B6   LW V1, 24(V1)
BFD00886  C0400063   SRL V1, V1, 24
BFD0088A      2DBD   ANDI V1, V1, 0xFF
BFD0088C      89A0   SB V1, 0(V0)
86:                      TRACE11(608, AP3GENEXCEPT, 0, "CP0 BADVADDR = 0x%08x",gexc_cap.cp0_badvaddr);
BFD0088E  A00041A2   LUI V0, 0xA000
BFD00892  8C005042   ORI V0, V0, -29696
BFD00894      8C00   BEQZ S0, 0xBFD00896
BFD00896  FFFD3060   ADDIU V1, ZERO, -3
BFD00898  89A0FFFD   LW RA, -30304(SP)
BFD0089A      89A0   SB V1, 0(V0)
BFD0089C  A00041A2   LUI V0, 0xA000
BFD008A0  8C005042   ORI V0, V0, -29696
BFD008A2      8C00   BEQZ S0, 0xBFD008A4
BFD008A4      EDE0   LI V1, 96
BFD008A6      89A0   SB V1, 0(V0)
BFD008A8  A00041A2   LUI V0, 0xA000
BFD008AC  8C005042   ORI V0, V0, -29696
BFD008AE      8C00   BEQZ S0, 0xBFD008B0
BFD008B0      ED82   LI V1, 2
BFD008B2      89A0   SB V1, 0(V0)
BFD008B4  A00041A2   LUI V0, 0xA000
BFD008B8  8C005042   ORI V0, V0, -29696
BFD008BA      8C00   BEQZ S0, 0xBFD008BC
BFD008BC  BFD241A3   LUI V1, 0xBFD2
BFD008BE  3063BFD2   LDC1 F30, 12387(S2)
BFD008C0  81343063   ADDIU V1, V1, -32460
BFD008C4      69B7   LW V1, 28(V1)
BFD008C6      2DBD   ANDI V1, V1, 0xFF
BFD008C8      89A0   SB V1, 0(V0)
BFD008CA  A00041A2   LUI V0, 0xA000
BFD008CE  8C005042   ORI V0, V0, -29696
BFD008D0      8C00   BEQZ S0, 0xBFD008D2
BFD008D2  BFD241A3   LUI V1, 0xBFD2
BFD008D4  3063BFD2   LDC1 F30, 12387(S2)
BFD008D6  81343063   ADDIU V1, V1, -32460
BFD008DA      69B7   LW V1, 28(V1)
BFD008DC      25B1   SRL V1, V1, 8
BFD008DE      2DBD   ANDI V1, V1, 0xFF
BFD008E0      89A0   SB V1, 0(V0)
BFD008E2  A00041A2   LUI V0, 0xA000
BFD008E6  8C005042   ORI V0, V0, -29696
BFD008E8      8C00   BEQZ S0, 0xBFD008EA
BFD008EA  BFD241A3   LUI V1, 0xBFD2
BFD008EC  3063BFD2   LDC1 F30, 12387(S2)
BFD008EE  81343063   ADDIU V1, V1, -32460
BFD008F2      69B7   LW V1, 28(V1)
BFD008F4  80400063   SRL V1, V1, 16
BFD008F8      2DBD   ANDI V1, V1, 0xFF
BFD008FA      89A0   SB V1, 0(V0)
BFD008FC  A00041A2   LUI V0, 0xA000
BFD00900  8C005042   ORI V0, V0, -29696
BFD00902      8C00   BEQZ S0, 0xBFD00904
BFD00904  BFD241A3   LUI V1, 0xBFD2
BFD00906  3063BFD2   LDC1 F30, 12387(S2)
BFD00908  81343063   ADDIU V1, V1, -32460
BFD0090C      69B7   LW V1, 28(V1)
BFD0090E  C0400063   SRL V1, V1, 24
BFD00912      2DBD   ANDI V1, V1, 0xFF
BFD00914      89A0   SB V1, 0(V0)
87:                  
88:                      for (;;) {
89:                          __asm__ __volatile ("%(ssnop%)" : :);
BFD00916  08000000   SSNOP
BFD00918      0800   LBU S0, 0(S0)
90:                      } 
BFD0091A      CFFD   B 0xBFD00916
BFD0091C      0C00   NOP
91:                  }
92:                  
93:                  
94:                  /* end general_exception.c */
95:                  /**   @}
96:                   */
97:                  
---  c:/e/dev/freertos/workingcopy/freertos/demo/pic32mec14xx_mplab/src/main.c  -------------------------
1:                   #warning configTIMERS_DISAGGREGATED_ISRS and configCPU_DISAGGREGATED_ISRS need documenting.
2:                   
3:                   /*
4:                       FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
5:                       All rights reserved
6:                   
7:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
8:                   
9:                       This file is part of the FreeRTOS distribution.
10:                  
11:                      FreeRTOS is free software; you can redistribute it and/or modify it under
12:                      the terms of the GNU General Public License (version 2) as published by the
13:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
14:                  
15:                      ***************************************************************************
16:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
17:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
18:                      >>!   obliged to provide the source code for proprietary components     !<<
19:                      >>!   outside of the FreeRTOS kernel.                                   !<<
20:                      ***************************************************************************
21:                  
22:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
23:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
24:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
25:                      link: http://www.freertos.org/a00114.html
26:                  
27:                      ***************************************************************************
28:                       *                                                                       *
29:                       *    FreeRTOS provides completely free yet professionally developed,    *
30:                       *    robust, strictly quality controlled, supported, and cross          *
31:                       *    platform software that is more than just the market leader, it     *
32:                       *    is the industry's de facto standard.                               *
33:                       *                                                                       *
34:                       *    Help yourself get started quickly while simultaneously helping     *
35:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
36:                       *    tutorial book, reference manual, or both:                          *
37:                       *    http://www.FreeRTOS.org/Documentation                              *
38:                       *                                                                       *
39:                      ***************************************************************************
40:                  
41:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
42:                      the FAQ page "My application does not run, what could be wrong?".  Have you
43:                      defined configASSERT()?
44:                  
45:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
46:                      embedded software for free we request you assist our global community by
47:                      participating in the support forum.
48:                  
49:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
50:                      be as productive as possible as early as possible.  Now you can receive
51:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
52:                      Ltd, and the world's leading authority on the world's leading RTOS.
53:                  
54:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
55:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
56:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
57:                  
58:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
59:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
60:                  
61:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
62:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
63:                      licenses offer ticketed support, indemnification and commercial middleware.
64:                  
65:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
66:                      engineered and independently SIL3 certified version for use in safety and
67:                      mission critical applications that require provable dependability.
68:                  
69:                      1 tab == 4 spaces!
70:                  */
71:                  
72:                  /******************************************************************************
73:                   * This project only provides a simple blinky demonstration.
74:                   *
75:                   * main() creates one queue, two tasks, and one software timer.  It then starts
76:                   * the scheduler.
77:                   *
78:                   * The Blinky Software Timer:
79:                   * This demonstrates an auto-reload software timer.  The timer callback function
80:                   * does nothing but toggle an LED.
81:                   *
82:                   * The Queue Send Task:
83:                   * The queue send task is implemented by prvQueueSendTask().  It sends the value
84:                   * 100 to the queue every 200 milliseconds.
85:                   *
86:                   * The Queue Receive Task:
87:                   * The queue receive task is implemented by prvQueueReceiveTask().
88:                   * prvQueueReceiveTask() repeatedly blocks on attempts to read from the queue,
89:                   * toggling an LED each time data is received.  The queue send task sends data
90:                   * to the queue every 200 milliseconds, so the LED will toggle every 200
91:                   * milliseconds.
92:                   */
93:                  
94:                  /* Kernel includes. */
95:                  #include "FreeRTOS.h"
96:                  #include "task.h"
97:                  #include "queue.h"
98:                  #include "timers.h"
99:                  
100:                 /* Target includes. */
101:                 #include "appcfg.h"
102:                 #include "MEC14xx/mec14xx.h"
103:                 #include "MEC14xx/mec14xx_jtvic.h"
104:                 #include "MEC14xx/mec14xx_bbled.h"
105:                 #include "MEC14xx/mec14xx_girqs.h"
106:                 
107:                 /* Priorities at which the tasks are created. */
108:                 #define mainQUEUE_SEND_TASK_PRIORITY	( tskIDLE_PRIORITY + 1 )
109:                 #define mainQUEUE_RECEIVE_TASK_PRIORITY	( tskIDLE_PRIORITY + 2 )
110:                 
111:                 /* The rate at which data is sent to the queue.  The 200ms value is converted
112:                 to ticks using the pdMS_TO_TICKS() macro. */
113:                 #define mainQUEUE_SEND_FREQUENCY_MS		( pdMS_TO_TICKS( 200UL ) )
114:                 
115:                 /* The number of items the queue can hold.  This is 1 as the receive task
116:                 will remove items as they are added, meaning the send task should always find
117:                 the queue empty. */
118:                 #define mainQUEUE_LENGTH				( 1 )
119:                 
120:                 /* Values passed to the two tasks just to check the task parameter
121:                 functionality. */
122:                 #define mainQUEUE_SEND_PARAMETER		( 0x1111UL )
123:                 #define mainQUEUE_RECEIVE_PARAMETER		( 0x22UL )
124:                 
125:                 /* The period of the software timer.  The period is specified in ms and
126:                 converted to ticks using the pdMS_TO_TICKS() macro. */
127:                 #define mainBLINKY_TIMER_PERIOD			( pdMS_TO_TICKS( 50UL ) )
128:                 
129:                 /* The LED used by the communicating tasks and the timer respectively. */
130:                 #define mainTASKS_LED					( LED0_ID )
131:                 #define mainTIMER_LED					( LED1_ID )
132:                 
133:                 /* Misc. */
134:                 #define mainDONT_BLOCK					( 0 )
135:                 
136:                 
137:                 /*-----------------------------------------------------------*/
138:                 
139:                 /*
140:                  * The tasks as described in the comments at the top of this file.
141:                  */
142:                 static void prvQueueReceiveTask( void *pvParameters );
143:                 static void prvQueueSendTask( void *pvParameters );
144:                 
145:                 /*
146:                  * The callback function for the software timer, as described at the top of this
147:                  * file.
148:                  */
149:                 static void prvBlinkyTimerCallback( TimerHandle_t xTimer );
150:                 
151:                 /*
152:                  * Performs any hardware setup necessary.
153:                  */
154:                  static void prvSetupHardware( void );
155:                 
156:                 /*
157:                  * Add some thread safety to the LED toggle function.
158:                  */
159:                 static void prvToggleLED( uint8_t ucLED );
160:                 
161:                 /*-----------------------------------------------------------*/
162:                 
163:                 /* The queue used by both tasks. */
164:                 static QueueHandle_t xQueue = NULL;
165:                 
166:                 /*-----------------------------------------------------------*/
167:                 
168:                 int main( void )
169:                 {
BFD096C0      4FF1   ADDIU SP, SP, -32
BFD096C2      CBE7   SW RA, 28(SP)
BFD096C4      CBC6   SW S8, 24(SP)
BFD096C6      0FDD   MOVE S8, SP
170:                 TimerHandle_t xTimer;
171:                 
172:                 	/* Perform any hardware initialisation necessary. */
173:                 	//prvSetupHardware();
174:                 
175:                    	__asm volatile( "di" );
BFD096C8  477C0000   DI ZERO
176:                 
177:                 
178:                     {
179:                         volatile uint32_t ulx = 0;
BFD096CC  0010F81E   SW ZERO, 16(S8)
180:                         
181:                         for( ;; )
182:                         {
183:                             for( ulx = 0; ulx < 0x1fff; ulx++ )
BFD096D0      CC0A   B 0xBFD096E6
BFD096D2  0010F81E   SW ZERO, 16(S8)
BFD096D4  0C000010   SLL ZERO, S0, 1
BFD096DC  0010FC5E   LW V0, 16(S8)
BFD096E0      6D20   ADDIU V0, V0, 1
BFD096E2  0010F85E   SW V0, 16(S8)
BFD096E6  0010FC5E   LW V0, 16(S8)
BFD096EA  1FFFB042   SLTIU V0, V0, 8191
BFD096EC  40A21FFF   LB RA, 16546(RA)
BFD096EE  FFF240A2   BNEZC V0, 0xBFD096D6
BFD096F0  77E8FFF2   LW RA, 30696(S2)
184:                             {
185:                                 __asm volatile( "NOP" );
BFD096D6      0C00   NOP
186:                                 __asm volatile( "NOP" );
BFD096D8      0C00   NOP
187:                                 __asm volatile( "NOP" );    
BFD096DA      0C00   NOP
188:                             }
189:                             
190:                             led_out_toggle( 0 );
BFD096F2  42D477E8   JALS led_out_toggle
BFD096F6      0C80   MOVE A0, ZERO
191:                         }
BFD096F8      CFEB   B 0xBFD096D0
BFD096FA      0C00   NOP
192:                     }
193:                     
194:                     
195:                     
196:                 	/* Create the queue. */
197:                 	xQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( unsigned long ) );
198:                 	configASSERT( xQueue );
199:                 
200:                 	if( xQueue != NULL )
201:                 	{
202:                 		/* Create the two tasks as described in the comments at the top of this
203:                 		file. */
204:                 		xTaskCreate(	prvQueueReceiveTask,					/* The function that implements the task. */
205:                 						"Rx", 									/* The text name assigned to the task - for debug only as it is not used by the kernel. */
206:                 						configMINIMAL_STACK_SIZE, 				/* The size of the stack to allocate to the task. */
207:                 						( void * ) mainQUEUE_RECEIVE_PARAMETER,	/* The parameter passed to the task - just to check the functionality. */
208:                 						mainQUEUE_RECEIVE_TASK_PRIORITY,		/* The priority assigned to the task. */
209:                 						NULL );									/* The task handle is not required, so NULL is passed. */
210:                 
211:                 		xTaskCreate( prvQueueSendTask, "TX", configMINIMAL_STACK_SIZE, ( void * ) mainQUEUE_SEND_PARAMETER, mainQUEUE_SEND_TASK_PRIORITY, NULL );
212:                 
213:                 
214:                 		/* Create the blinky software timer as described at the top of this file. */
215:                 		xTimer = xTimerCreate(	"Blinky",					/* A text name, purely to help debugging. */
216:                 								( mainBLINKY_TIMER_PERIOD ),/* The timer period. */
217:                 								pdTRUE,						/* This is an auto-reload timer, so xAutoReload is set to pdTRUE. */
218:                 								( void * ) 0,				/* The ID is not used, so can be set to anything. */
219:                 								prvBlinkyTimerCallback );	/* The callback function that inspects the status of all the other tasks. */
220:                 		configASSERT( xTimer );
221:                 
222:                 		if( xTimer != NULL )
223:                 		{
224:                 			xTimerStart( xTimer, mainDONT_BLOCK );
225:                 		}
226:                 
227:                 		/* Start the tasks and timer running. */
228:                 		vTaskStartScheduler();
229:                 	}
230:                 
231:                 	/* If all is well, the scheduler will now be running, and the following
232:                 	line will never be reached.  If the following line does execute, then
233:                 	there was insufficient FreeRTOS heap memory available for the idle and/or
234:                 	timer tasks	to be created.  See the memory management section on the
235:                 	FreeRTOS web site for more details. http://www.freertos.org/a00111.html */
236:                 	for( ;; );
237:                 }
238:                 /*-----------------------------------------------------------*/
239:                 
240:                 static void prvQueueSendTask( void *pvParameters )
241:                 {
BFD07E34      4FF1   ADDIU SP, SP, -32
BFD07E36      CBE7   SW RA, 28(SP)
BFD07E38      CBC6   SW S8, 24(SP)
BFD07E3A      0FDD   MOVE S8, SP
BFD07E3C  0020F89E   SW A0, 32(S8)
242:                 TickType_t xNextWakeTime;
243:                 const unsigned long ulValueToSend = 100UL;
BFD07E40      ED64   LI V0, 100
BFD07E42  0014F85E   SW V0, 20(S8)
244:                 
245:                 	/* Remove compiler warnigns in the case that configASSERT() is not dfined. */
246:                 	( void ) pvParameters;
247:                 
248:                 	/* Check the task parameter is as expected. */
249:                 	configASSERT( ( ( unsigned long ) pvParameters ) == mainQUEUE_SEND_PARAMETER );
BFD07E46  0020FC7E   LW V1, 32(S8)
BFD07E48  30400020   SRL AT, ZERO, 6
BFD07E4A  11113040   ADDIU V0, ZERO, 4369
BFD07E4C  94431111   ADDI T0, S1, -27581
BFD07E4E  000A9443   BEQ V1, V0, 0xBFD07E66
BFD07E50  0C00000A   SLL ZERO, T2, 1
BFD07E52      0C00   NOP
BFD07E54  BFD141A2   LUI V0, 0xBFD1
BFD07E56  3082BFD1   LDC1 F30, 12418(S1)
BFD07E58  9EF43082   ADDIU A0, V0, -24844
BFD07E5A  30A09EF4   LWC1 F23, 12448(S4)
BFD07E5C  00F930A0   ADDIU A1, ZERO, 249
BFD07E60  4B7E77E8   JALS vAssertCalled
BFD07E62      4B7E   LW K1, 120(SP)
BFD07E64      0C00   NOP
250:                 
251:                 	/* Initialise xNextWakeTime - this only needs to be done once. */
252:                 	xNextWakeTime = xTaskGetTickCount();
BFD07E66  4CCA77E8   JALS xTaskGetTickCount
BFD07E68      4CCA   ADDIU A2, A2, 5
BFD07E6A      0C00   NOP
BFD07E6C  0010F85E   SW V0, 16(S8)
253:                 
254:                 	for( ;; )
255:                 	{
256:                 		/* Place this task in the blocked state until it is time to run again.
257:                 		The block time is specified in ticks, the constant used converts ticks
258:                 		to ms.  While in the Blocked state this task will not consume any CPU
259:                 		time. */
260:                 		vTaskDelayUntil( &xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS );
BFD07E70  0010305E   ADDIU V0, S8, 16
BFD07E74      0C82   MOVE A0, V0
BFD07E76  00C830A0   ADDIU A1, ZERO, 200
BFD07E7A  000477E8   JALS vTaskDelayUntil
BFD07E7C  0C000004   SLL ZERO, A0, 1
BFD07E7E      0C00   NOP
261:                 
262:                 		/* Send to the queue - causing the queue receive task to unblock and
263:                 		toggle the LED.  0 is used as the block time so the sending operation
264:                 		will not block - it shouldn't need to block as the queue should always
265:                 		be empty at this point in the code. */
266:                 		xQueueSend( xQueue, &ulValueToSend, 0U );
BFD07E80  8070FC7C   LW V1, -32656(GP)
BFD07E84  0014305E   ADDIU V0, S8, 20
BFD07E88      0C83   MOVE A0, V1
BFD07E8A      0CA2   MOVE A1, V0
BFD07E8C      0CC0   MOVE A2, ZERO
BFD07E8E      0CE0   MOVE A3, ZERO
BFD07E90  06A277E8   JALS xQueueGenericSend
BFD07E92      06A2   ADDU A1, S1, V0
BFD07E94      0C00   NOP
267:                 	}
BFD07E96      CFEC   B 0xBFD07E70
BFD07E98      0C00   NOP
268:                 }
269:                 /*-----------------------------------------------------------*/
270:                 
271:                 static void prvQueueReceiveTask( void *pvParameters )
272:                 {
BFD08090      4FF1   ADDIU SP, SP, -32
BFD08092      CBE7   SW RA, 28(SP)
BFD08094      CBC6   SW S8, 24(SP)
BFD08096      0FDD   MOVE S8, SP
BFD08098  0020F89E   SW A0, 32(S8)
273:                 unsigned long ulReceivedValue;
274:                 
275:                 	/* Remove compiler warnings in the case where configASSERT() is not defined. */
276:                 	( void ) pvParameters;
277:                 
278:                 	/* Check the task parameter is as expected. */
279:                 	configASSERT( ( ( unsigned long ) pvParameters ) == mainQUEUE_RECEIVE_PARAMETER );
BFD0809C  0020FC7E   LW V1, 32(S8)
BFD080A0      ED22   LI V0, 34
BFD080A2  000D9443   BEQ V1, V0, 0xBFD080C0
BFD080A4  0C00000D   SLL ZERO, T5, 1
BFD080A6      0C00   NOP
BFD080A8  BFD141A2   LUI V0, 0xBFD1
BFD080AA  3082BFD1   LDC1 F30, 12418(S1)
BFD080AC  9EF43082   ADDIU A0, V0, -24844
BFD080AE  30A09EF4   LWC1 F23, 12448(S4)
BFD080B0  011730A0   ADDIU A1, ZERO, 279
BFD080B4  4B7E77E8   JALS vAssertCalled
BFD080B6      4B7E   LW K1, 120(SP)
BFD080B8      0C00   NOP
BFD080BA      CC02   B 0xBFD080C0
BFD080BC      0C00   NOP
280:                 
281:                 	for( ;; )
282:                 	{
283:                 		/* Wait until something arrives in the queue - this task will block
284:                 		indefinitely provided INCLUDE_vTaskSuspend is set to 1 in
285:                 		FreeRTOSConfig.h. */
286:                 		xQueueReceive( xQueue, &ulReceivedValue, portMAX_DELAY );
BFD080C0  8070FC5C   LW V0, -32656(GP)
BFD080C4      0C82   MOVE A0, V0
BFD080C6  0010305E   ADDIU V0, S8, 16
BFD080CA      0CA2   MOVE A1, V0
BFD080CC      EF7F   LI A2, -1
BFD080CE      0CE0   MOVE A3, ZERO
BFD080D0  081E77E8   JALS xQueueGenericReceive
BFD080D2      081E   LBU S0, 14(S1)
BFD080D4      0C00   NOP
287:                 
288:                 		/*  To get here something must have been received from the queue, but
289:                 		is it the expected value?  If it is, toggle the LED. */
290:                 		if( ulReceivedValue == 100UL )
BFD080D6  0010FC7E   LW V1, 16(S8)
BFD080DA      ED64   LI V0, 100
BFD080DC  FFEFB443   BNE V1, V0, 0xBFD080BE
BFD080DE  0C00FFEF   LW RA, 3072(T7)
BFD080E0      0C00   NOP
291:                 		{
292:                 			prvToggleLED( mainTASKS_LED );
BFD080E2      0C80   MOVE A0, ZERO
BFD080E4  4C3C77E8   JALS prvToggleLED
BFD080E6      4C3C   ADDIU AT, AT, -2
BFD080E8      0C00   NOP
293:                 			ulReceivedValue = 0U;
BFD080EA  0010F81E   SW ZERO, 16(S8)
294:                 		}
295:                 	}
BFD080BE      0C00   NOP
BFD080EE      CFE8   B 0xBFD080C0
BFD080F0      0C00   NOP
296:                 }
297:                 /*-----------------------------------------------------------*/
298:                 
299:                 static void prvBlinkyTimerCallback( TimerHandle_t xTimer )
300:                 {
BFD09DAC      4FF5   ADDIU SP, SP, -24
BFD09DAE      CBE5   SW RA, 20(SP)
BFD09DB0      CBC4   SW S8, 16(SP)
BFD09DB2      0FDD   MOVE S8, SP
BFD09DB4  0018F89E   SW A0, 24(S8)
301:                 	/* Avoid compiler warnings. */
302:                 	( void ) xTimer;
303:                 
304:                 	/* This function is called when the blinky software time expires.  All the
305:                 	function does is toggle the LED.  LED mainTIMER_LED should therefore toggle
306:                 	with the period set by mainBLINKY_TIMER_PERIOD. */
307:                 	prvToggleLED( mainTIMER_LED );
BFD09DB8      EE01   LI A0, 1
BFD09DBA  4C3C77E8   JALS prvToggleLED
BFD09DBC      4C3C   ADDIU AT, AT, -2
BFD09DBE      0C00   NOP
308:                 }
BFD09DC0      0FBE   MOVE SP, S8
BFD09DC2      4BE5   LW RA, 20(SP)
BFD09DC4      4BC4   LW S8, 16(SP)
BFD09DC6      4C0D   ADDIU SP, SP, 24
BFD09DC8      459F   JR16 RA
BFD09DCA      0C00   NOP
309:                 /*-----------------------------------------------------------*/
310:                 
311:                 static void prvToggleLED( uint8_t ucLED )
312:                 {
BFD09878      4FF5   ADDIU SP, SP, -24
BFD0987A      CBE5   SW RA, 20(SP)
BFD0987C      CBC4   SW S8, 16(SP)
BFD0987E      0FDD   MOVE S8, SP
BFD09880      0C44   MOVE V0, A0
BFD09882  0018185E   SB V0, 24(S8)
313:                 	taskENTER_CRITICAL();
BFD09886  33B877E8   JALS vTaskEnterCritical
BFD09888  0C0033B8   ADDIU SP, T8, 3072
BFD0988A      0C00   NOP
314:                 	{
315:                 		led_out_toggle( ucLED );
BFD0988C  0018145E   LBU V0, 24(S8)
BFD09890      0C82   MOVE A0, V0
BFD09892  42D477E8   JALS led_out_toggle
BFD09896      0C00   NOP
316:                 	}
317:                 	taskEXIT_CRITICAL();
BFD09898  40AA77E8   JALS vTaskExitCritical
BFD0989A  0C0040AA   BNEZC T2, 0xBFD0B09E
BFD0989C      0C00   NOP
318:                 }
BFD0989E      0FBE   MOVE SP, S8
BFD098A0      4BE5   LW RA, 20(SP)
BFD098A2      4BC4   LW S8, 16(SP)
BFD098A4      4C0D   ADDIU SP, SP, 24
BFD098A6      459F   JR16 RA
BFD098A8      0C00   NOP
319:                 /*-----------------------------------------------------------*/
320:                 
321:                 static void prvSetupHardware( void )
322:                 {
BFD05890      4FF1   ADDIU SP, SP, -32
BFD05892      CBE7   SW RA, 28(SP)
BFD05894      CBC6   SW S8, 24(SP)
BFD05896      0FDD   MOVE S8, SP
323:                 volatile uint32_t ulTemp;
324:                 
325:                 	/* Interrupts are automatically re-enabled when the scheduler is started. */
326:                 	__asm volatile( "di" );
BFD05898  477C0000   DI ZERO
327:                 
328:                 	/* Enable M14K Vector Pre-fetch: CP0.IntCtl b[22]=1
329:                 	   IRET (interrupt chaining): b[21]=1
330:                 	   Enable Auto-Prolog: b[14]=1 */
331:                 	ulTemp = _CP0_GET_INTCTL();
BFD0589C  08FC004C   MFC0 V0, IntCtl
BFD0589E      08FC   LBU S1, 12(A3)
BFD058A0  0010F85E   SW V0, 16(S8)
332:                 	ulTemp |= ( 1ul << 22 ) + ( 1ul << 21 ) + ( 1ul << 14 );
BFD058A4  0010FC7E   LW V1, 16(S8)
BFD058A8  006041A2   LUI V0, 0x60
BFD058AC  40005042   ORI V0, V0, 16384
BFD058AE  44D34000   BLTZ ZERO, 0xBFD0E258
BFD058B0      44D3   OR16 V0, V1
BFD058B2  0010F85E   SW V0, 16(S8)
333:                 	_CP0_SET_INTCTL( ulTemp );
BFD058B6  0010FC5E   LW V0, 16(S8)
BFD058B8  004C0010   INS ZERO, S0, 1, 0
BFD058BA  0AFC004C   MTC0 V0, IntCtl
BFD058BC      0AFC   LBU A1, 12(A3)
BFD058BE  18000000   SLL ZERO, ZERO, 3
BFD058C0  41A21800   SB ZERO, 16802(ZERO)
334:                 
335:                 	/* Configure 32KHz for Switched Clock Source always ON
336:                 	   b[ 0 ] = XOSEL                     = 1
337:                 	   b[ 1 ] = EXT_32K_OSC_EN            = 1
338:                 	   b[ 2 ] = INT_32K_OSC_EN            = 1
339:                 	   b[ 3 ] = INT_32K_VTR_PWR_WELL_EMUL = 0
340:                 	   b[ 4 ] = 32K_SWITCHER_CTRL         = 0 */
341:                 	VBAT_REGS->CLOCK_ENABLE = 0x07;
BFD058C2  A00041A2   LUI V0, 0xA000
BFD058C6  A4005042   ORI V0, V0, -23552
BFD058CA      ED87   LI V1, 7
BFD058CC      E9A2   SW V1, 8(V0)
342:                 
343:                 	ulTemp = 256;
BFD058CE  01003040   ADDIU V0, ZERO, 256
344:                 	while (ulTemp--)
BFD058D2      CC06   B 0xBFD058E0
BFD058D4  0010F85E   SW V0, 16(S8)
BFD058D6  0C000010   SLL ZERO, S0, 1
BFD058E0  0010FC5E   LW V0, 16(S8)
BFD058E2  00400010   SRL ZERO, S0, 0
BFD058E4  1B900040   SLTU V1, ZERO, V0
BFD058E6  2DBD1B90   SB GP, 11709(S0)
BFD058E8      2DBD   ANDI V1, V1, 0xFF
BFD058EA      6D2E   ADDIU V0, V0, -1
BFD058EC  0010F85E   SW V0, 16(S8)
BFD058F0  FFF240A3   BNEZC V1, 0xBFD058D8
BFD058F2  41A2FFF2   LW RA, 16802(S2)
345:                 	{
346:                 		__asm volatile( "NOP" );
BFD058D8      0C00   NOP
347:                 		__asm volatile( "NOP" );
BFD058DA      0C00   NOP
348:                 		__asm volatile( "NOP" );
BFD058DC      0C00   NOP
349:                 		__asm volatile( "NOP" );
BFD058DE      0C00   NOP
350:                 	}
351:                 
352:                 	/* Disaggregate GIRQ23 & GIRQ24 for FreeRTOS.  Second parameter is a bit-map
353:                 	for each GIRQ where
354:                 	  0 = Aggregated, 1 = Dis-aggregate
355:                 	  Bit position = GIRQ_Number - 8
356:                 	  Example: GIRQ23 ( 23 - 8 ) = 15
357:                 	  Dis-aggregate GIRQ23 & GIRQ24
358:                 	  The symbols JTVIC_DISAGR_BITMAP is generated in header file mec14xx_girqm.h
359:                 
360:                 	  Each disaggregated interrupt handler is spaced 8-bytes apart starting at
361:                 	  base address for that GIRQ. */
362:                 	jtvic_init( dflt_ih_table, ( JTVIC_DISAGR_BITMAP ), ( JTVIC_FLAG_DISAGR_SPACING_8 ) );
BFD058F4  BFD041A2   LUI V0, 0xBFD0
BFD058F6  3082BFD0   LDC1 F30, 12418(S0)
BFD058F8  26F03082   ADDIU A0, V0, 9968
BFD058FA      26F0   SLL A1, A3, 8
BFD058FC  000141A2   LUI V0, 0x1
BFD05900  800050A2   ORI A1, V0, -32768
BFD05904  1B2277E8   JALS jtvic_init
BFD05906  0CC01B22   SB T9, 3264(V0)
BFD05908      0CC0   MOVE A2, ZERO
363:                 
364:                 	/* Initialise the LEDs. */
365:                 	for( ulTemp = 0; ulTemp < LED_ID_MAX; ulTemp++ )
BFD0590A      CC1A   B 0xBFD05940
BFD0590C  0010F81E   SW ZERO, 16(S8)
BFD05936  0010FC5E   LW V0, 16(S8)
BFD0593A      6D20   ADDIU V0, V0, 1
BFD0593C  0010F85E   SW V0, 16(S8)
BFD05940  0010FC5E   LW V0, 16(S8)
BFD05944  0003B042   SLTIU V0, V0, 3
BFD05948  FFE240A2   BNEZC V0, 0xBFD05910
BFD0594A  0FBEFFE2   LW RA, 4030(V0)
366:                 	{
367:                 		led_sleep_en( ulTemp, ADISABLE );
BFD05910  0010FC5E   LW V0, 16(S8)
BFD05914      2D2D   ANDI V0, V0, 0xFF
BFD05916      0C82   MOVE A0, V0
BFD05918  2E8677E8   JALS led_sleep_en
BFD0591A      2E86   ANDI A1, S0, 0x8
BFD0591C      0CA0   MOVE A1, ZERO
368:                 		led_init( ulTemp );
BFD0591E  0010FC5E   LW V0, 16(S8)
BFD05922      2D2D   ANDI V0, V0, 0xFF
BFD05924  3E7E77E8   JALS led_init
BFD05926  0C823E7E   LH S3, 3202(S8)
BFD05928      0C82   MOVE A0, V0
369:                 		led_out_low( ulTemp );
BFD0592A  0010FC5E   LW V0, 16(S8)
BFD0592E      2D2D   ANDI V0, V0, 0xFF
BFD05930  4A3077E8   JALS led_out_low
BFD05932      4A30   LW S1, 64(SP)
BFD05934      0C82   MOVE A0, V0
370:                 	}
371:                 }
BFD0594C      0FBE   MOVE SP, S8
BFD0594E      4BE7   LW RA, 28(SP)
BFD05950      4BC6   LW S8, 24(SP)
BFD05952      459F   JR16 RA
BFD05954      4C11   ADDIU SP, SP, 32
372:                 /*-----------------------------------------------------------*/
373:                 
374:                 void vApplicationMallocFailedHook( void )
375:                 {
BFD08900      4FF1   ADDIU SP, SP, -32
BFD08902      CBE7   SW RA, 28(SP)
BFD08904      CBC6   SW S8, 24(SP)
BFD08906      0FDD   MOVE S8, SP
376:                 	/* vApplicationMallocFailedHook() will only be called if
377:                 	configUSE_MALLOC_FAILED_HOOK is set to 1 in FreeRTOSConfig.h.  It is a hook
378:                 	function that will get called if a call to pvPortMalloc() fails.
379:                 	pvPortMalloc() is called internally by the kernel whenever a task, queue,
380:                 	timer or semaphore is created.  It is also called by various parts of the
381:                 	demo application.  If heap_1.c or heap_2.c are used, then the size of the
382:                 	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
383:                 	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
384:                 	to query the size of free heap space that remains (although it does not
385:                 	provide information on how the remaining heap might be fragmented). */
386:                 	taskDISABLE_INTERRUPTS();
BFD08908  4EB677E8   JALS ulPortGetCP0Status
BFD0890A      4EB6   ADDIU S5, S5, -5
BFD0890C      0C00   NOP
BFD0890E  0010F85E   SW V0, 16(S8)
BFD08912  0010FC7E   LW V1, 16(S8)
BFD08916  000141A2   LUI V0, 0x1
BFD0891A  FC005042   ORI V0, V0, -1024
BFD0891C  4493FC00   LW ZERO, 17555(ZERO)
BFD0891E      4493   AND16 V0, V1
BFD08920  50400042   SRL V0, V0, 10
BFD08922  B0425040   ORI V0, ZERO, -20414
BFD08924  0003B042   SLTIU V0, V0, 3
BFD08928  001140E2   BEQZC V0, 0xBFD0894E
BFD0892C  0010FC7E   LW V1, 16(S8)
BFD08930  FFFE41A2   LUI V0, 0xFFFE
BFD08932  5042FFFE   LW RA, 20546(S8)
BFD08934  03FF5042   ORI V0, V0, 1023
BFD08938      4493   AND16 V0, V1
BFD0893A  0010F85E   SW V0, 16(S8)
BFD0893E  0010FC5E   LW V0, 16(S8)
BFD08942  0C005042   ORI V0, V0, 3072
BFD08944      0C00   NOP
BFD08946      0C82   MOVE A0, V0
BFD08948  4EC677E8   JALS vPortSetCP0Status
BFD0894A      4EC6   ADDIU S6, S6, 3
BFD0894C      0C00   NOP
387:                 	for( ;; );
BFD0894E      CFFF   B 0xBFD0894E
BFD08950      0C00   NOP
388:                 }
389:                 /*-----------------------------------------------------------*/
390:                 
391:                 void vApplicationIdleHook( void )
392:                 {
BFD09F04      4FB0   ADDIU SP, SP, -8
BFD09F06      CBC1   SW S8, 4(SP)
BFD09F08      0FDD   MOVE S8, SP
393:                 	/* vApplicationIdleHook() will only be called if configUSE_IDLE_HOOK is set
394:                 	to 1 in FreeRTOSConfig.h.  It will be called on each iteration of the idle
395:                 	task.  It is essential that code added to this hook function never attempts
396:                 	to block in any way (for example, call xQueueReceive() with a block time
397:                 	specified, or call vTaskDelay()).  If the application makes use of the
398:                 	vTaskDelete() API function (as this demo application does) then it is also
399:                 	important that vApplicationIdleHook() is permitted to return to its calling
400:                 	function, because it is the responsibility of the idle task to clean up
401:                 	memory allocated by the kernel to any task that has since been deleted. */
402:                 }
BFD09F0A      0FBE   MOVE SP, S8
BFD09F0C      4BC1   LW S8, 4(SP)
BFD09F0E      4C05   ADDIU SP, SP, 8
BFD09F10      459F   JR16 RA
BFD09F12      0C00   NOP
403:                 /*-----------------------------------------------------------*/
404:                 
405:                 void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
406:                 {
BFD08444      4FF1   ADDIU SP, SP, -32
BFD08446      CBE7   SW RA, 28(SP)
BFD08448      CBC6   SW S8, 24(SP)
BFD0844A      0FDD   MOVE S8, SP
BFD0844C  0020F89E   SW A0, 32(S8)
BFD08450  0024F8BE   SW A1, 36(S8)
407:                 	( void ) pcTaskName;
408:                 	( void ) pxTask;
409:                 
410:                 	/* Run time task stack overflow checking is performed if
411:                 	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook	function is
412:                 	called if a task stack overflow is detected.  Note the system/interrupt
413:                 	stack is not checked. */
414:                 	taskDISABLE_INTERRUPTS();
BFD08454  4EB677E8   JALS ulPortGetCP0Status
BFD08456      4EB6   ADDIU S5, S5, -5
BFD08458      0C00   NOP
BFD0845A  0010F85E   SW V0, 16(S8)
BFD0845E  0010FC7E   LW V1, 16(S8)
BFD08462  000141A2   LUI V0, 0x1
BFD08466  FC005042   ORI V0, V0, -1024
BFD08468  4493FC00   LW ZERO, 17555(ZERO)
BFD0846A      4493   AND16 V0, V1
BFD0846C  50400042   SRL V0, V0, 10
BFD0846E  B0425040   ORI V0, ZERO, -20414
BFD08470  0003B042   SLTIU V0, V0, 3
BFD08474  001140E2   BEQZC V0, 0xBFD0849A
BFD08478  0010FC7E   LW V1, 16(S8)
BFD0847C  FFFE41A2   LUI V0, 0xFFFE
BFD0847E  5042FFFE   LW RA, 20546(S8)
BFD08480  03FF5042   ORI V0, V0, 1023
BFD08484      4493   AND16 V0, V1
BFD08486  0010F85E   SW V0, 16(S8)
BFD0848A  0010FC5E   LW V0, 16(S8)
BFD0848E  0C005042   ORI V0, V0, 3072
BFD08490      0C00   NOP
BFD08492      0C82   MOVE A0, V0
BFD08494  4EC677E8   JALS vPortSetCP0Status
BFD08496      4EC6   ADDIU S6, S6, 3
BFD08498      0C00   NOP
415:                 	for( ;; );
BFD0849A      CFFF   B 0xBFD0849A
BFD0849C      0C00   NOP
416:                 }
417:                 /*-----------------------------------------------------------*/
418:                 
419:                 void vApplicationTickHook( void )
420:                 {
BFD09F14      4FB0   ADDIU SP, SP, -8
BFD09F16      CBC1   SW S8, 4(SP)
BFD09F18      0FDD   MOVE S8, SP
421:                 	/* This function will be called by each tick interrupt if
422:                 	configUSE_TICK_HOOK is set to 1 in FreeRTOSConfig.h.  User code can be
423:                 	added here, but the tick hook is called from an interrupt context, so
424:                 	code must not attempt to block, and only the interrupt safe FreeRTOS API
425:                 	functions can be used (those that end in FromISR()). */
426:                 }
BFD09F1A      0FBE   MOVE SP, S8
BFD09F1C      4BC1   LW S8, 4(SP)
BFD09F1E      4C05   ADDIU SP, SP, 8
BFD09F20      459F   JR16 RA
BFD09F22      0C00   NOP
427:                 /*-----------------------------------------------------------*/
428:                 
429:                 void vAssertCalled( const char * pcFile, unsigned long ulLine )
430:                 {
BFD096FC      4FF9   ADDIU SP, SP, -16
BFD096FE      CBC3   SW S8, 12(SP)
BFD09700      0FDD   MOVE S8, SP
BFD09702  0010F89E   SW A0, 16(S8)
BFD09706  0014F8BE   SW A1, 20(S8)
431:                 volatile char *pcFileName;
432:                 volatile unsigned long ulLineNumber;
433:                 
434:                 	/* Prevent things that are useful to view in the debugger from being
435:                 	optimised away. */
436:                 	pcFileName = ( char * ) pcFile;
BFD0970A  0010FC5E   LW V0, 16(S8)
BFD0970E  0000F85E   SW V0, 0(S8)
437:                 	( void ) pcFileName;
438:                 	ulLineNumber = ulLine;
BFD09712  0014FC5E   LW V0, 20(S8)
BFD09716  0004F85E   SW V0, 4(S8)
439:                 
440:                 	/* Set ulLineNumber to 0 in the debugger to break out of this loop and
441:                 	return to the line that triggered the assert. */
442:                 	while( ulLineNumber != 0 )
BFD0971A      CC06   B 0xBFD09728
BFD0971C      0C00   NOP
BFD09728  0004FC5E   LW V0, 4(S8)
BFD0972C  FFF740A2   BNEZC V0, 0xBFD0971E
BFD0972E  0FBEFFF7   LW RA, 4030(S7)
443:                 	{
444:                 		__asm volatile( "NOP" );
BFD0971E      0C00   NOP
445:                 		__asm volatile( "NOP" );
BFD09720      0C00   NOP
446:                 		__asm volatile( "NOP" );
BFD09722      0C00   NOP
447:                 		__asm volatile( "NOP" );
BFD09724      0C00   NOP
448:                 		__asm volatile( "NOP" );
BFD09726      0C00   NOP
449:                 	}
450:                 }
BFD09730      0FBE   MOVE SP, S8
BFD09732      4BC3   LW S8, 12(SP)
BFD09734      459F   JR16 RA
BFD09736      4C09   ADDIU SP, SP, 16
451:                 
---  C:/E/Dev/FreeRTOS/WorkingCopy/FreeRTOS/Source/portable/MPLAB/PIC32MEC14xx/port_asm.S  --------------
                                                  1:     /*
                                                  2:         FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
                                                  3:         All rights reserved
                                                  4:     
                                                  5:         VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
                                                  6:     
                                                  7:         This file is part of the FreeRTOS distribution.
                                                  8:     
                                                  9:         FreeRTOS is free software; you can redistribute it and/or modify it under
                                                  10:        the terms of the GNU General Public License (version 2) as published by the
                                                  11:        Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
                                                  12:    
                                                  13:        ***************************************************************************
                                                  14:        >>!   NOTE: The modification to the GPL is included to allow you to     !<<
                                                  15:        >>!   distribute a combined work that includes FreeRTOS without being   !<<
                                                  16:        >>!   obliged to provide the source code for proprietary components     !<<
                                                  17:        >>!   outside of the FreeRTOS kernel.                                   !<<
                                                  18:        ***************************************************************************
                                                  19:    
                                                  20:        FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
                                                  21:        WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
                                                  22:        FOR A PARTICULAR PURPOSE.  Full license text is available on the following
                                                  23:        link: http://www.freertos.org/a00114.html
                                                  24:    
                                                  25:        ***************************************************************************
                                                  26:         *                                                                       *
                                                  27:         *    FreeRTOS provides completely free yet professionally developed,    *
                                                  28:         *    robust, strictly quality controlled, supported, and cross          *
                                                  29:         *    platform software that is more than just the market leader, it     *
                                                  30:         *    is the industry's de facto standard.                               *
                                                  31:         *                                                                       *
                                                  32:         *    Help yourself get started quickly while simultaneously helping     *
                                                  33:         *    to support the FreeRTOS project by purchasing a FreeRTOS           *
                                                  34:         *    tutorial book, reference manual, or both:                          *
                                                  35:         *    http://www.FreeRTOS.org/Documentation                              *
                                                  36:         *                                                                       *
                                                  37:        ***************************************************************************
                                                  38:    
                                                  39:        http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
                                                  40:        the FAQ page "My application does not run, what could be wrong?".  Have you
                                                  41:        defined configASSERT()?
                                                  42:    
                                                  43:        http://www.FreeRTOS.org/support - In return for receiving this top quality
                                                  44:        embedded software for free we request you assist our global community by
                                                  45:        participating in the support forum.
                                                  46:    
                                                  47:        http://www.FreeRTOS.org/training - Investing in training allows your team to
                                                  48:        be as productive as possible as early as possible.  Now you can receive
                                                  49:        FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
                                                  50:        Ltd, and the world's leading authority on the world's leading RTOS.
                                                  51:    
                                                  52:        http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
                                                  53:        including FreeRTOS+Trace - an indispensable productivity tool, a DOS
                                                  54:        compatible FAT file system, and our tiny thread aware UDP/IP stack.
                                                  55:    
                                                  56:        http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
                                                  57:        Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
                                                  58:    
                                                  59:        http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
                                                  60:        Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
                                                  61:        licenses offer ticketed support, indemnification and commercial middleware.
                                                  62:    
                                                  63:        http://www.SafeRTOS.com - High Integrity Systems also provide a safety
                                                  64:        engineered and independently SIL3 certified version for use in safety and
                                                  65:        mission critical applications that require provable dependability.
                                                  66:    
                                                  67:        1 tab == 4 spaces!
                                                  68:    */
                                                  69:    
                                                  70:    #include <xc.h>
                                                  71:    #include <sys/asm.h>
                                                  72:    #include "FreeRTOSConfig.h"
                                                  73:    #include "ISR_Support.h"
                                                  74:    
                                                  75:    
                                                  76:    	.extern pxCurrentTCB
                                                  77:    	.extern vTaskSwitchContext
                                                  78:    	.extern vPortIncrementTick
                                                  79:    	.extern xISRStackTop
                                                  80:    
                                                  81:    	PORT_CPP_JTVIC_BASE = 0xBFFFC000
                                                  82:    	PORT_CCP_JTVIC_GIRQ24_SRC = 0xBFFFC100
                                                  83:    
                                                  84:    	.global vPortStartFirstTask .text
                                                  85:    	.global vPortYieldISR .text
                                                  86:    	.global vPortTickInterruptHandler .text
                                                  87:    
                                                  88:    
                                                  89:    /******************************************************************/
                                                  90:    
                                                  91:    
                                                  92:    /***************************************************************
                                                  93:    *  The following is needed to locate the
                                                  94:    *  vPortTickInterruptHandler function into the correct vector
                                                  95:    *  MEC14xx - This ISR will only be used if HW timers' interrupts
                                                  96:    *  in GIRQ23 are disaggregated.
                                                  97:    *
                                                  98:    ***************************************************************/
                                                  99:    
                                                  100:   	.set  noreorder
                                                  101:   	.set  noat
                                                  102:   	.set  micromips
                                                  103:   
                                                  104:   	.section .text, code
                                                  105:   	.ent    vPortTickInterruptHandler
                                                  106:   
                                                  107:   #if configTIMERS_DISAGGREGATED_ISRS == 0
                                                  108:   
                                                  109:   	.globl girq23_isr
                                                  110:   
                                                  111:   girq23_isr:
                                                  112:   vPortTickInterruptHandler:
                                                  113:   
                                                  114:   	portSAVE_CONTEXT2 vpti
                                                  115:   
                                                  116:   	jal		girq23_handler
                                                  117:   	nop
                                                  118:   
                                                  119:   	portRESTORE_CONTEXT
                                                  120:   
                                                  121:   .end vPortTickInterruptHandler
                                                  122:   
                                                  123:   #else
                                                  124:   
                                                  125:   	.globl girq23_b4
                                                  126:   
                                                  127:   girq23_b4:
                                                  128:   vPortTickInterruptHandler:
                                                  129:   
                                                  130:   	/*    portSAVE_CONTEXT   */
BFD00920  00FC034D   MFC0 K0, Cause               131:   	portSAVE_CONTEXT2 vpti
                                                  132:   
BFD009F0  34DCF7E8   JAL 0xBFD069B8               133:   	jal		vPortIncrementTick
BFD009F4  00000000   NOP                          134:   	nop
                                                  135:   
BFD009F8  BFD241B6   LUI S6, 0xBFD2               136:   	portRESTORE_CONTEXT
                                                  137:   
                                                  138:   .end vPortTickInterruptHandler
                                                  139:   
                                                  140:   #endif /* #if configTIMERS_DISAGGREGATED_ISRS == 0 */
                                                  141:   
                                                  142:   /******************************************************************/
                                                  143:   
                                                  144:   	.set	micromips
                                                  145:   	.set	noreorder
                                                  146:   	.set	noat
                                                  147:   
                                                  148:   	.section .text, code
                                                  149:   	.ent	vPortStartFirstTask
                                                  150:   
                                                  151:   vPortStartFirstTask:
                                                  152:   
                                                  153:   	/* Simply restore the context of the highest priority task that has
                                                  154:   	been created so far. */
BFD00AB4  BFD241B6   LUI S6, 0xBFD2               155:   	portRESTORE_CONTEXT
                                                  156:   
                                                  157:   .end vPortStartFirstTask
                                                  158:   
                                                  159:   
                                                  160:   
                                                  161:   /*******************************************************************/
                                                  162:   
                                                  163:   /***************************************************************
                                                  164:   *  The following is needed to locate the vPortYieldISR function
                                                  165:   *  into the correct vector
                                                  166:   ***************************************************************/
                                                  167:   
                                                  168:   	.set micromips
                                                  169:   	.set noreorder
                                                  170:   	.set noat
                                                  171:   
                                                  172:   	.section .text, code
                                                  173:   
                                                  174:   	.global vPortYieldISR
                                                  175:   
                                                  176:   
                                                  177:   #if configCPU_DISAGGREGATED_ISRS == 0
                                                  178:   	.global girq24_isr
                                                  179:   	.ent girq24_isr
                                                  180:   girq24_isr:
                                                  181:   	la		k0, PORT_CPP_JTVIC_BASE
                                                  182:   	lw		k0, 0x10C(k0)
                                                  183:   	andi	k1, k0, 0x2
                                                  184:   	bgtz	k1, vPortYieldISR
                                                  185:   	nop
                                                  186:   
                                                  187:   	portSAVE_CONTEXT
                                                  188:   
                                                  189:   	jal		girq24_b_0_2
                                                  190:   
                                                  191:   	portRESTORE_CONTEXT
                                                  192:   
                                                  193:   	.end girq24_isr
                                                  194:   
                                                  195:   #else
                                                  196:   	.global girq24_b1
                                                  197:   girq24_b1:
                                                  198:   #endif
                                                  199:   		.ent  vPortYieldISR
                                                  200:   vPortYieldISR:
                                                  201:   
                                                  202:   	/* Make room for the context. First save the current status so it can be
                                                  203:   	manipulated, and the cause and EPC registers so thier original values
                                                  204:   	are captured. */
BFD00B70      4FBF   ADDIU SP, SP, -132           205:   	addiu   sp, sp, -portCONTEXT_SIZE
BFD00B72  00FC036C   MFC0 K1, Status              206:   	mfc0	k1, _CP0_STATUS
                                                  207:   
                                                  208:   	/* Also save s6 and s5 so they can be used.  Any nesting interrupts should
                                                  209:   	maintain the values of these registers across the ISR. */
BFD00B76      CACB   SW S6, 44(SP)                210:   	sw		s6, 44(sp)
BFD00B78      CAAA   SW S5, 40(SP)                211:   	sw		s5, 40(sp)
BFD00B7A  0080FB7D   SW K1, 128(SP)               212:   	sw		k1, portSTATUS_STACK_LOCATION(sp)
                                                  213:   
                                                  214:   	/* Prepare to re-enabled interrupts above the kernel priority. */
BFD00B7E  828C0360   INS K1, ZERO, 10, 7          215:   	ins		k1, zero, 10, 7		 /* Clear IPL bits 0:6. */
BFD00B82  948C0360   INS K1, ZERO, 18, 1          216:   	ins		k1, zero, 18, 1		 /* Clear IPL bit 7  */
BFD00B86  0C00537B   ORI K1, K1, 3072             217:   	ori		k1, k1, ( configMAX_SYSCALL_INTERRUPT_PRIORITY << 10 )
BFD00B8A  204C0360   INS K1, ZERO, 1, 4           218:   	ins		k1, zero, 1, 4		  /* Clear EXL, ERL and UM. */
                                                  219:   
                                                  220:   	/* s5 is used as the frame pointer. */
BFD00B8E  A91003A0   ADD S5, ZERO, SP             221:   	add		s5, zero, sp
                                                  222:   
                                                  223:   	/* Swap to the system stack.  This is not conditional on the nesting
                                                  224:   	count as this interrupt is always the lowest priority and therefore
                                                  225:   	the nesting is always 0. */
BFD00B92  BFD141BD   LUI SP, 0xBFD1               226:   	la		sp, xISRStackTop
BFD00B9A      4BA0   LW SP, 0(SP)                 227:   	lw		sp, (sp)
                                                  228:   
                                                  229:   	/* Set the nesting count. */
BFD00B9C  BFD241BA   LUI K0, 0xBFD2               230:   	la		k0, uxInterruptNesting
BFD00BA4  000132C0   ADDIU S6, ZERO, 1            231:   	addiu   s6, zero, 1
BFD00BA8  0000FADA   SW S6, 0(K0)                 232:   	sw		s6, 0(k0)
                                                  233:   
                                                  234:   	/* s6 holds the EPC value, this is saved with the rest of the context
                                                  235:   	after interrupts are enabled. */
BFD00BAC  00FC02CE   MFC0 S6, EPC                 236:   	mfc0	s6, _CP0_EPC
                                                  237:   
                                                  238:   	/* Re-enable interrupts above configMAX_SYSCALL_INTERRUPT_PRIORITY. */
BFD00BB0  02FC036C   MTC0 K1, Status              239:   	mtc0	k1, _CP0_STATUS
                                                  240:   
                                                  241:   	/* Save the context into the space just created.  s6 is saved again
                                                  242:   	here as it now contains the EPC value. */
BFD00BB4  0078FBF5   SW RA, 120(S5)               243:   	sw		ra, 120(s5)
BFD00BB8  0074FBD5   SW S8, 116(S5)               244:   	sw		s8, 116(s5)
BFD00BBC  0070FB35   SW T9, 112(S5)               245:   	sw		t9, 112(s5)
BFD00BC0  006CFB15   SW T8, 108(S5)               246:   	sw		t8, 108(s5)
BFD00BC4  0068F9F5   SW T7, 104(S5)               247:   	sw		t7, 104(s5)
BFD00BC8  0064F9D5   SW T6, 100(S5)               248:   	sw		t6, 100(s5)
BFD00BCC  0060F9B5   SW T5, 96(S5)                249:   	sw		t5, 96(s5)
BFD00BD0  005CF995   SW T4, 92(S5)                250:   	sw		t4, 92(s5)
BFD00BD4  0058F975   SW T3, 88(S5)                251:   	sw		t3, 88(s5)
BFD00BD8  0054F955   SW T2, 84(S5)                252:   	sw		t2, 84(s5)
BFD00BDC  0050F935   SW T1, 80(S5)                253:   	sw		t1, 80(s5)
BFD00BE0  004CF915   SW T0, 76(S5)                254:   	sw		t0, 76(s5)
BFD00BE4  0048F8F5   SW A3, 72(S5)                255:   	sw		a3, 72(s5)
BFD00BE8  0044F8D5   SW A2, 68(S5)                256:   	sw		a2, 68(s5)
BFD00BEC  0040F8B5   SW A1, 64(S5)                257:   	sw		a1, 64(s5)
BFD00BF0  003CF895   SW A0, 60(S5)                258:   	sw		a0, 60(s5)
BFD00BF4  0038F875   SW V1, 56(S5)                259:   	sw		v1, 56(s5)
BFD00BF8  0034F855   SW V0, 52(S5)                260:   	sw		v0, 52(s5)
BFD00BFC  0030FAF5   SW S7, 48(S5)                261:   	sw		s7, 48(s5)
BFD00C00  007CFAD5   SW S6, 124(S5)               262:   	sw		s6, portEPC_STACK_LOCATION(s5)
                                                  263:   	/* s5 and s6 has already been saved. */
BFD00C04  0024FA95   SW S4, 36(S5)                264:   	sw		s4, 36(s5)
BFD00C08  0020FA75   SW S3, 32(S5)                265:   	sw		s3, 32(s5)
BFD00C0C  001CFA55   SW S2, 28(S5)                266:   	sw		s2, 28(s5)
BFD00C10  0018FA35   SW S1, 24(S5)                267:   	sw		s1, 24(s5)
BFD00C14  0014FA15   SW S0, 20(S5)                268:   	sw		s0, 20(s5)
BFD00C18  0010F835   SW AT, 16(S5)                269:   	sw		$1, 16(s5)
                                                  270:   
                                                  271:   	/* s7 is used as a scratch register as this should always be saved acro ss
                                                  272:   	nesting interrupts. */
BFD00C1C      4617   MFHI S7                      273:   	mfhi	s7
BFD00C1E  000CFAF5   SW S7, 12(S5)                274:   	sw		s7, 12(s5)
BFD00C22      4657   MFLO S7                      275:   	mflo	s7
BFD00C24  0008FAF5   SW S7, 8(S5)                 276:   	sw		s7, 8(s5)
                                                  277:   
                                                  278:   	/* Save the stack pointer to the task. */
BFD00C28  BFD241B7   LUI S7, 0xBFD2               279:   	la		s7, pxCurrentTCB
BFD00C30  0000FEF7   LW S7, 0(S7)                 280:   	lw		s7, (s7)
BFD00C34  0000FAB7   SW S5, 0(S7)                 281:   	sw		s5, (s7)
                                                  282:   
                                                  283:   	/* Set the interrupt mask to the max priority that can use the API.
                                                  284:   	The yield handler will only be called at configKERNEL_INTERRUPT_PRIORITY
                                                  285:   	which is below configMAX_SYSCALL_INTERRUPT_PRIORITY - so this can only
                                                  286:   	ever raise the IPL value and never lower it. */
BFD00C38  477C0000   DI ZERO                      287:   	di
BFD00C3C  18000000   SLL ZERO, ZERO, 3            288:   	ehb
BFD00C40  00FC02EC   MFC0 S7, Status              289:   	mfc0	s7, _CP0_STATUS
BFD00C44  828C02E0   INS S7, ZERO, 10, 7          290:   	ins		s7, zero, 10, 7
BFD00C48  948C02E0   INS S7, ZERO, 18, 1          291:   	ins		s7, zero, 18, 1
BFD00C4C  0C0152D7   ORI S6, S7, 3073             292:   	ori		s6, s7, ( configMAX_SYSCALL_INTERRUPT_PRIORITY << 10 ) | 1
                                                  293:   
                                                  294:   	/* This mtc0 re-enables interrupts, but only above
                                                  295:   	configMAX_SYSCALL_INTERRUPT_PRIORITY. */
BFD00C50  02FC02CC   MTC0 S6, Status              296:   	mtc0	s6, _CP0_STATUS
BFD00C54  18000000   SLL ZERO, ZERO, 3            297:   	ehb
                                                  298:   
                                                  299:   	/* Clear the software interrupt in the core. */
BFD00C58  00FC02CD   MFC0 S6, Cause               300:   	mfc0	s6, _CP0_CAUSE
BFD00C5C  420C02C0   INS S6, ZERO, 8, 1           301:   	ins		s6, zero, 8, 1
BFD00C60  02FC02CD   MTC0 S6, Cause               302:   	mtc0	s6, _CP0_CAUSE
BFD00C64  18000000   SLL ZERO, ZERO, 3            303:   	ehb
                                                  304:   
                                                  305:   	/* Clear the interrupt in the interrupt controller.
                                                  306:   	MEC14xx GIRQ24 Source bit[1] = 1 to clear */
BFD00C68  BFFF41B6   LUI S6, 0xBFFF               307:   	la		s6, PORT_CCP_JTVIC_GIRQ24_SRC
BFD00C70  00023280   ADDIU S4, ZERO, 2            308:   	addiu   s4, zero, 2
BFD00C74  0000FA96   SW S4, 0(S6)                 309:   	sw		s4, (s6)
BFD00C78  16DEF7E8   JAL 0xBFD02DBC               310:   	jal		vTaskSwitchContext
BFD00C7C  00000000   NOP                          311:   	nop
                                                  312:   
                                                  313:   	/* Clear the interrupt mask again. The saved status value is still in s7 */
BFD00C80  02FC02EC   MTC0 S7, Status              314:   	mtc0	s7, _CP0_STATUS
BFD00C84  18000000   SLL ZERO, ZERO, 3            315:   	ehb
                                                  316:   
                                                  317:   	/* Restore the stack pointer from the TCB. */
BFD00C88  BFD241B0   LUI S0, 0xBFD2               318:   	la		s0, pxCurrentTCB
BFD00C90      6800   LW S0, 0(S0)                 319:   	lw		s0, (s0)
BFD00C92  0000FEB0   LW S5, 0(S0)                 320:   	lw		s5, (s0)
                                                  321:   
                                                  322:   	/* Restore the rest of the context. */
BFD00C96  0008FE15   LW S0, 8(S5)                 323:   	lw		s0, 8(s5)
BFD00C9A  3D7C0010   MTLO S0                      324:   	mtlo	s0
BFD00C9E  000CFE15   LW S0, 12(S5)                325:   	lw		s0, 12(s5)
BFD00CA2  2D7C0010   MTHI S0                      326:   	mthi	s0
                                                  327:   
BFD00CA6  0010FC35   LW AT, 16(S5)                328:   	lw		$1, 16(s5)
BFD00CAA  0014FE15   LW S0, 20(S5)                329:   	lw		s0, 20(s5)
BFD00CAE  0018FE35   LW S1, 24(S5)                330:   	lw		s1, 24(s5)
BFD00CB2  001CFE55   LW S2, 28(S5)                331:   	lw		s2, 28(s5)
BFD00CB6  0020FE75   LW S3, 32(S5)                332:   	lw		s3, 32(s5)
BFD00CBA  0024FE95   LW S4, 36(S5)                333:   	lw		s4, 36(s5)
                                                  334:   
                                                  335:   	/* s5 is loaded later. */
BFD00CBE  002CFED5   LW S6, 44(S5)                336:   	lw		s6, 44(s5)
BFD00CC2  0030FEF5   LW S7, 48(S5)                337:   	lw		s7, 48(s5)
BFD00CC6  0034FC55   LW V0, 52(S5)                338:   	lw		v0, 52(s5)
BFD00CCA  0038FC75   LW V1, 56(S5)                339:   	lw		v1, 56(s5)
BFD00CCE  003CFC95   LW A0, 60(S5)                340:   	lw		a0, 60(s5)
BFD00CD2  0040FCB5   LW A1, 64(S5)                341:   	lw		a1, 64(s5)
BFD00CD6  0044FCD5   LW A2, 68(S5)                342:   	lw		a2, 68(s5)
BFD00CDA  0048FCF5   LW A3, 72(S5)                343:   	lw		a3, 72(s5)
BFD00CDE  004CFD15   LW T0, 76(S5)                344:   	lw		t0, 76(s5)
BFD00CE2  0050FD35   LW T1, 80(S5)                345:   	lw		t1, 80(s5)
BFD00CE6  0054FD55   LW T2, 84(S5)                346:   	lw		t2, 84(s5)
BFD00CEA  0058FD75   LW T3, 88(S5)                347:   	lw		t3, 88(s5)
BFD00CEE  005CFD95   LW T4, 92(S5)                348:   	lw		t4, 92(s5)
BFD00CF2  0060FDB5   LW T5, 96(S5)                349:   	lw		t5, 96(s5)
BFD00CF6  0064FDD5   LW T6, 100(S5)               350:   	lw		t6, 100(s5)
BFD00CFA  0068FDF5   LW T7, 104(S5)               351:   	lw		t7, 104(s5)
BFD00CFE  006CFF15   LW T8, 108(S5)               352:   	lw		t8, 108(s5)
BFD00D02  0070FF35   LW T9, 112(S5)               353:   	lw		t9, 112(s5)
BFD00D06  0074FFD5   LW S8, 116(S5)               354:   	lw		s8, 116(s5)
BFD00D0A  0078FFF5   LW RA, 120(S5)               355:   	lw		ra, 120(s5)
                                                  356:   
                                                  357:   	/* Protect access to the k registers, and others. */
BFD00D0E  477C0000   DI ZERO                      358:   	di
BFD00D12  18000000   SLL ZERO, ZERO, 3            359:   	ehb
                                                  360:   
                                                  361:   	/* Set nesting back to zero.  As the lowest priority interrupt this
                                                  362:   	interrupt cannot have nested. */
BFD00D16  BFD241BA   LUI K0, 0xBFD2               363:   	la		k0, uxInterruptNesting
BFD00D1E  0000F81A   SW ZERO, 0(K0)               364:   	sw		zero, 0(k0)
                                                  365:   
                                                  366:   	/* Switch back to use the real stack pointer. */
BFD00D22  E91002A0   ADD SP, ZERO, S5             367:   	add		sp, zero, s5
                                                  368:   
                                                  369:   	/* Restore the real s5 value. */
BFD00D26      4AAA   LW S5, 40(SP)                370:   	lw		s5, 40(sp)
                                                  371:   
                                                  372:   	/* Pop the status and epc values. */
BFD00D28  0080FF7D   LW K1, 128(SP)               373:   	lw		k1, portSTATUS_STACK_LOCATION(sp)
BFD00D2C      4B5F   LW K0, 124(SP)               374:   	lw		k0, portEPC_STACK_LOCATION(sp)
                                                  375:   
                                                  376:   	/* Remove stack frame. */
BFD00D2E      4C43   ADDIU SP, SP, 132            377:   	addiu   sp, sp, portCONTEXT_SIZE
                                                  378:   
BFD00D30  02FC036C   MTC0 K1, Status              379:   	mtc0	k1, _CP0_STATUS
BFD00D34  02FC034E   MTC0 K0, EPC                 380:   	mtc0	k0, _CP0_EPC
BFD00D38  18000000   SLL ZERO, ZERO, 3            381:   	ehb
BFD00D3C  F37C0000   ERET                         382:   	eret
BFD00D40      0C00   NOP                          383:   	nop
                                                  384:   
                                                  385:   .end	vPortYieldISR
                                                  386:   
                                                  387:   
                                                  388:   
                                                  389:   
---  C:/E/Dev/FreeRTOS/WorkingCopy/FreeRTOS/Demo/PIC32MEC14xx_MPLAB/src/MEC14xx/startup/MPLAB/crtn.S  ---
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crtn.s
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * This software is developed by Microchip Technology Inc. and its
                                                  17:     * subsidiaries ("Microchip").
                                                  18:     *
                                                  19:     * Redistribution and use in source and binary forms, with or without
                                                  20:     * modification, are permitted provided that the following conditions are met:
                                                  21:     *
                                                  22:     * 1.      Redistributions of source code must retain the above copyright
                                                  23:     * notice, this list of conditions and the following disclaimer.
                                                  24:     *
                                                  25:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer in the
                                                  27:     * documentation and/or other materials provided with the distribution.
                                                  28:     *
                                                  29:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  30:     * derived from this software without specific prior written permission.
                                                  31:     *
                                                  32:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  33:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  34:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  35:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  36:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  37:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  38:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  39:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  40:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  41:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  42:     *
                                                  43:     ********************************************************************/
                                                  44:    
                                                  45:    #ifdef __LIBBUILD__
                                                  46:    	# Replace the standard debugging information with a simple filename. This 
                                                  47:    	# prevents the library build directory from showing up in MPLAB IDE. It 
                                                  48:    	# also effectively disables source-line debugging.
                                                  49:    	.file 1 "libpic32/startup/crtn.s"
                                                  50:    	.loc 1 0
                                                  51:    #endif
                                                  52:    
                                                  53:    	.section .init, code
BFD00440  8FBF0014   LW RA, 20(SP)                54:    	lw	$31,20($sp)
                                                  55:    	addu	$sp,$sp,32
BFD00444  03E00008   JR RA                        56:    	j	$31
                                                  57:    
                                                  58:    	.section .fini, code
BFD00454  8FBF0014   LW RA, 20(SP)                59:    	lw	$31,20($sp)
                                                  60:    	addu	$sp,$sp,32
BFD00458  03E00008   JR RA                        61:    	j	$31
                                                  62:    
---  C:/E/Dev/FreeRTOS/WorkingCopy/FreeRTOS/Demo/PIC32MEC14xx_MPLAB/src/MEC14xx/startup/MPLAB/crti.S  ---
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crti.s
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * This software is developed by Microchip Technology Inc. and its
                                                  17:     * subsidiaries ("Microchip").
                                                  18:     *
                                                  19:     * Redistribution and use in source and binary forms, with or without
                                                  20:     * modification, are permitted provided that the following conditions are met:
                                                  21:     *
                                                  22:     * 1.      Redistributions of source code must retain the above copyright
                                                  23:     * notice, this list of conditions and the following disclaimer.
                                                  24:     *
                                                  25:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer in the
                                                  27:     * documentation and/or other materials provided with the distribution.
                                                  28:     *
                                                  29:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  30:     * derived from this software without specific prior written permission.
                                                  31:     *
                                                  32:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  33:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  34:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  35:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  36:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  37:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  38:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  39:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  40:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  41:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  42:     *
                                                  43:     ********************************************************************/
                                                  44:     
                                                  45:    #ifdef __LIBBUILD__
                                                  46:    	# Replace the standard debugging information with a simple filename. This 
                                                  47:    	# prevents the library build directory from showing up in MPLAB IDE. It 
                                                  48:    	# also effectively disables source-line debugging.
                                                  49:    	.file 1 "libpic32/startup/crti.s"
                                                  50:    	.loc 1 0
                                                  51:    #endif
                                                  52:    
                                                  53:    /* 4 slots for argument spill area.  1 for cpreturn, 1 for stack.
                                                  54:       Return spill offset of 40 and 20.  Aligned to 16 bytes for n32.  */
                                                  55:    
                                                  56:    	.section .init, code
                                                  57:    	.globl	_init
                                                  58:    	.type	_init,@function
                                                  59:    _init:
BFD00438  27BDFFE0   ADDIU SP, SP, -32            60:    	addu	$sp,$sp,-32
BFD0043C  AFBF0014   SW RA, 20(SP)                61:    	sw	$31,20($sp)
                                                  62:    	
                                                  63:    	.section .fini, code
                                                  64:    	.globl	_fini
                                                  65:    	.type	_fini,@function
                                                  66:    _fini:
BFD0044C  27BDFFE0   ADDIU SP, SP, -32            67:    	addu	$sp,$sp,-32
BFD00450  AFBF0014   SW RA, 20(SP)                68:    	sw	$31,20($sp)
---  C:/E/Dev/FreeRTOS/WorkingCopy/FreeRTOS/Demo/PIC32MEC14xx_MPLAB/src/MEC14xx/startup/MPLAB/crt0.S  ---
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crt0.S
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * This software is developed by Microchip Technology Inc. and its
                                                  17:     * subsidiaries ("Microchip").
                                                  18:     *
                                                  19:     * Redistribution and use in source and binary forms, with or without
                                                  20:     * modification, are permitted provided that the following conditions are met:
                                                  21:     *
                                                  22:     * 1.      Redistributions of source code must retain the above copyright
                                                  23:     * notice, this list of conditions and the following disclaimer.
                                                  24:     *
                                                  25:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer in the
                                                  27:     * documentation and/or other materials provided with the distribution.
                                                  28:     *
                                                  29:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  30:     * derived from this software without specific prior written permission.
                                                  31:     *
                                                  32:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  33:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  34:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  35:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  36:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  37:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  38:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  39:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  40:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  41:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  42:     *
                                                  43:     ********************************************************************/
                                                  44:    
                                                  45:    #include <xc.h>
                                                  46:    #include <cp0defs.h>
                                                  47:    
                                                  48:    /* MEC14xx */
                                                  49:    #define PIC32_SRS_SET_COUNT 1
                                                  50:    #define INIT_SSX
                                                  51:    #undef INIT_MMU_MZ_FIXED
                                                  52:    #undef INIT_L1_CACHE
                                                  53:    
                                                  54:    /* MEC14xx fill stack with sentinel value */
                                                  55:    #define EN_STACK_FILL */
                                                  56:    
                                                  57:    #if (__XC32_VERSION > 1000) && !defined(CPP_INIT)
                                                  58:    #define CPP_INIT
                                                  59:    #endif
                                                  60:    
                                                  61:    #if !defined(PIC32_SRS_SET_COUNT)
                                                  62:    # warning PIC32_SRS_SET_COUNT not defined on build line
                                                  63:    # define PIC32_SRS_SET_COUNT 2
                                                  64:    #endif
                                                  65:    
                                                  66:    #if !defined(STACK_FILL_VALUE)
                                                  67:    # define STACK_FILL_VALUE 0xDEADBEEFul
                                                  68:    #endif
                                                  69:    
                                                  70:    /* This file contains 32-bit assembly code */
                                                  71:           .set nomips16
                                                  72:    
                                                  73:            ##################################################################
                                                  74:            # Entry point of the entire application
                                                  75:            ##################################################################
                                                  76:            .section .reset,code,keep
                                                  77:            .align 2
                                                  78:            .set noreorder
                                                  79:            .ent _reset
                                                  80:    
                                                  81:    ############################
                                                  82:    # Begin ISA switching code #
                                                  83:    ############################
                                                  84:    
                                                  85:    #if defined(__PIC32_HAS_MICROMIPS) || defined(__mips_micromips)
                                                  86:    #if defined (__mips_micromips)
                                                  87:            .set micromips
                                                  88:    #endif
                                                  89:    _reset:
                                                  90:            .word 0x10000003     /* MIPS32:    branch to 0xBFC00010 from here     */
                                                  91:                                 /* MicroMIPS: ADDI32 $0, $0, 0x0007 (nop)        */
                                                  92:                                 /* DO NOT change the relative branch             */
                                                  93:    
                                                  94:            .word 0x00000000     /* NOP */
                                                  95:    __reset_micromips_isa:
                                                  96:            .set    micromips
                                                  97:            jal     _startup
                                                  98:            nop
                                                  99:    
                                                  100:           .align 2
                                                  101:           /* Device not in proper ISA mode */
                                                  102:           .set nomicromips
                                                  103:   __reset_switch_isa:
                                                  104:           jal _startup
                                                  105:           nop
                                                  106:   
                                                  107:   #else
                                                  108:   
                                                  109:   _reset:
BFD00000  0FF400A2   JAL 0xBFD00288               110:           jal _startup
BFD00004  00000000   NOP                          111:           nop
                                                  112:   
                                                  113:   #endif  /* __PIC32_HAS_MICROMIPS */
                                                  114:   
                                                  115:           .align 2
                                                  116:           .end _reset
                                                  117:           .globl _reset
                                                  118:           .size _reset, .-_reset
                                                  119:   
                                                  120:           .section .reset.startup,code,keep
                                                  121:           .align 2
                                                  122:           .set noreorder
                                                  123:   
                                                  124:   #if defined (__mips_micromips)
                                                  125:           .set micromips
                                                  126:   #else
                                                  127:           .set nomicromips
                                                  128:   #endif
                                                  129:   
                                                  130:   ############################
                                                  131:   # End ISA switching code   #
                                                  132:   ############################
                                                  133:   
                                                  134:   
                                                  135:           ##################################################################
                                                  136:           # Startup code
                                                  137:           ##################################################################
                                                  138:           .align 2
                                                  139:           .set noreorder
                                                  140:           .ent _startup
                                                  141:   _startup:
                                                  142:   
                                                  143:           ##################################################################
                                                  144:           # New - Set BEV=1 for the cases where M14K instruction pointer 
                                                  145:           # is changed to force ROM to run again. CP0.BEV must be 1 to 
                                                  146:           # safely write CP0.EBASE
                                                  147:           ##################################################################
BFD00288  401A6000   MFC0 K0, Status              148:           mfc0    k0, _CP0_STATUS
BFD0028C  3C1B0040   LUI K1, 64                   149:           lui     k1, 0x0040
BFD00290  035BD025   OR K0, K0, K1                150:           or      k0, k0, k1        # CP0.STATUS.BEV(bit[22]) = 1
BFD00294  409A6000   MTC0 K0, Status              151:           mtc0    k0, _CP0_STATUS
BFD00298  000000C0   EHB                          152:           ehb
                                                  153:   
                                                  154:           ##################################################################
                                                  155:           # Initialize Stack Pointer
                                                  156:           #   _stack is initialized by the linker script to point to the
                                                  157:           #    starting location of the stack in DRM
                                                  158:           ##################################################################
BFD0029C  3C1DBFD2   LUI SP, -16430               159:           la      sp,_stack
                                                  160:   
                                                  161:           ##################################################################
                                                  162:           # Initialize Global Pointer
                                                  163:           #   _gp is initialized by the linker script to point to "middle"
                                                  164:           #   of the small variables region
                                                  165:           ##################################################################
BFD002A4  3C1CBFD2   LUI GP, -16430               166:           la      gp,_gp
                                                  167:   
                                                  168:   #if (PIC32_SRS_SET_COUNT == 2)
                                                  169:           ##################################################################
                                                  170:           # Initialize Global Pointer in Shadow Set
                                                  171:           #   The SRSCtl's PSS field must be set to the shadow set in which
                                                  172:           #   to initialize the global pointer.  Since we have only a
                                                  173:           #   single shadow set (besides the normal), we will initialize
                                                  174:           #   SRSCtl<PSS> to SRSCtl<HSS>.  We then write the global pointer
                                                  175:           #   to the previous shadow set to ensure that on interrupt, the
                                                  176:           #   global pointer has been initialized.
                                                  177:           ##################################################################
                                                  178:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  179:           add     t3,t1,zero              # Save off current SRSCtl
                                                  180:           ext     t2,t1,26,4              # to obtain HSS field
                                                  181:           ins     t1,t2,6,4               # Put HSS field
                                                  182:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  183:           ehb                             # Clear hazard before using new SRSCTL
                                                  184:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  185:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  186:           ehb
                                                  187:   
                                                  188:   #elif (PIC32_SRS_SET_COUNT > 2)
                                                  189:           ##################################################################
                                                  190:           # Initialize Global Pointer in Shadow Set(s)
                                                  191:           #   The SRSCtl PSS field must be set to the shadow set in which
                                                  192:           #   to initialize the global pointer.  We will initialize
                                                  193:           #   SRSCtl<PSS> to the number of reg sets and work down to set zero.
                                                  194:           #   We write the global pointer to the previous shadow set to
                                                  195:           #   ensure that on interrupt, the global pointer has been
                                                  196:           #   initialized.
                                                  197:           ##################################################################
                                                  198:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  199:           add     t3,t1,zero              # Save off current SRSCtl
                                                  200:   
                                                  201:           li      t2,(PIC32_SRS_SET_COUNT-1)
                                                  202:   
                                                  203:   1:      ins     t1,t2,6,4               # Put next shadow set field
                                                  204:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  205:           ehb                             # Clear hazard before using new SRSCTL
                                                  206:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  207:   
                                                  208:           addiu   t2,t2,-1                # Next lower shadow set
                                                  209:                                           # Loop for all sets
                                                  210:           bne     t2,$0,1b                # Down to zero (normal GPR set)
                                                  211:           nop
                                                  212:   
                                                  213:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  214:           ehb
                                                  215:   
                                                  216:   #endif /* (PIC32_SRS_SET_COUNT > 2) */
                                                  217:   
                                                  218:           ##################################################################
                                                  219:           # Call the "on reset" procedure
                                                  220:           ##################################################################
BFD002AC  3C08BFD1   LUI T0, -16431               221:           la      t0,_on_reset
BFD002B4  0100F809   JALR T0                      222:           jalr    t0
BFD002B8  00000000   NOP                          223:           nop
                                                  224:   
                                                  225:   #if defined(INIT_MMU_MZ_FIXED)
                                                  226:           ##################################################################
                                                  227:           # Initialize TLB for fixed mapping to EBI and SQI
                                                  228:           ##################################################################
                                                  229:           .extern __pic32_tlb_init_ebi_sqi
                                                  230:           la      t0,__pic32_tlb_init_ebi_sqi
                                                  231:           jalr    t0
                                                  232:           nop
                                                  233:   #endif
                                                  234:   
                                                  235:   #if defined(INIT_L1_CACHE)
                                                  236:           ##################################################################
                                                  237:           # Initialize L1 cache register
                                                  238:           ##################################################################
                                                  239:           .extern __pic32_init_cache
                                                  240:           la      t0,__pic32_init_cache
                                                  241:           jalr    t0
                                                  242:           nop
                                                  243:   #endif
                                                  244:   
                                                  245:   #if defined(EN_STACK_FILL)
                                                  246:           ##################################################################
                                                  247:           # Fill stack
                                                  248:           # TODO - handle different stack lengths:
                                                  249:           # mulitple of 4, 8, 16, or 32
                                                  250:           ##################################################################
BFD002BC  3C08BFD2   LUI T0, -16430               251:           la      t0,_stack_start
BFD002C4  3C09BFD2   LUI T1, -16430               252:           la      t1,_stack
BFD002CC  10000005   BEQ ZERO, ZERO, 0xBFD002E4   253:           b       _stack_check
                                                  254:   
                                                  255:   _stack_init:
BFD002D0  AD000000   SW ZERO, 0(T0)               256:           sw      zero,0x0(t0)
BFD002D4  AD000004   SW ZERO, 4(T0)               257:           sw      zero,0x4(t0)
BFD002D8  AD000008   SW ZERO, 8(T0)               258:           sw      zero,0x8(t0)
BFD002DC  AD00000C   SW ZERO, 12(T0)              259:           sw      zero,0xc(t0)
BFD002E0  25080010   ADDIU T0, T0, 16             260:           addu    t0,16
                                                  261:   
                                                  262:   _stack_check:
BFD002E4  0109082B   SLTU AT, T0, T1              263:           bltu    t0,t1,_stack_init
BFD002EC  00000000   NOP                          264:           nop
                                                  265:   #endif
                                                  266:   
                                                  267:           ##################################################################
                                                  268:           # Clear uninitialized data sections
                                                  269:           ##################################################################
BFD002F0  3C08BFD2   LUI T0, -16430               270:           la      t0,_bss_begin
BFD002F8  3C09BFD2   LUI T1, -16430               271:           la      t1,_bss_end
BFD00300  10000006   BEQ ZERO, ZERO, 0xBFD0031C   272:           b       _bss_check
BFD00304  00000000   NOP                          273:           nop
                                                  274:   
                                                  275:   _bss_init:
BFD00308  AD000000   SW ZERO, 0(T0)               276:           sw      zero,0x0(t0)
BFD0030C  AD000004   SW ZERO, 4(T0)               277:           sw      zero,0x4(t0)
BFD00310  AD000008   SW ZERO, 8(T0)               278:           sw      zero,0x8(t0)
BFD00314  AD00000C   SW ZERO, 12(T0)              279:           sw      zero,0xc(t0)
BFD00318  25080010   ADDIU T0, T0, 16             280:           addu    t0,16
                                                  281:   _bss_check:
BFD0031C  0109082B   SLTU AT, T0, T1              282:           bltu    t0,t1,_bss_init
BFD00324  00000000   NOP                          283:           nop
                                                  284:   
                                                  285:           ##################################################################
                                                  286:           # Initialize data using the linker-generated .dinit table
                                                  287:           ##################################################################
                                                  288:           .equiv FMT_CLEAR,0
                                                  289:           .equiv FMT_COPY,1
                                                  290:   _dinit_init:
BFD00328  3C08BFD0   LUI T0, -16432               291:           la      t0,_dinit_addr
                                                  292:   
                                                  293:   #define SRC t0
                                                  294:   #define DST t1
                                                  295:   #define LEN t2
                                                  296:   #define FMT t3
                                                  297:   
BFD00330  8D090000   LW T1, 0(T0)                 298:   0:      lw      DST,0(SRC)
BFD00334  11200018   BEQ T1, ZERO, 0xBFD00398     299:           beqz    DST,9f
BFD00338  25080004   ADDIU T0, T0, 4              300:           addu    SRC,4
BFD0033C  8D0A0000   LW T2, 0(T0)                 301:           lw      LEN,0(SRC)
BFD00340  25080004   ADDIU T0, T0, 4              302:           addu    SRC,4
BFD00344  8D0B0000   LW T3, 0(T0)                 303:           lw      FMT,0(SRC)
BFD00348  11600009   BEQ T3, ZERO, 0xBFD00370     304:           beq     FMT,$0,_dinit_clear
BFD0034C  25080004   ADDIU T0, T0, 4              305:           addu    SRC,4
                                                  306:   
                                                  307:   _dinit_copy:
BFD00350  910C0000   LBU T4, 0(T0)                308:           lbu     t4,0(SRC)
BFD00354  254AFFFF   ADDIU T2, T2, -1             309:           subu    LEN,1
BFD00358  25080001   ADDIU T0, T0, 1              310:           addu    SRC,1
BFD0035C  A12C0000   SB T4, 0(T1)                 311:           sb      t4,0(DST)
BFD00360  1540FFFB   BNE T2, ZERO, 0xBFD00350     312:           bne     LEN,$0,_dinit_copy
BFD00364  25290001   ADDIU T1, T1, 1              313:           addu    DST,1
                                                  314:   
BFD00368  10000005   BEQ ZERO, ZERO, 0xBFD00380   315:           b       _dinit_end
BFD0036C  00000000   NOP                          316:           nop
                                                  317:   
                                                  318:   _dinit_clear:
BFD00370  A1200000   SB ZERO, 0(T1)               319:           sb      $0,(DST)
BFD00374  254AFFFF   ADDIU T2, T2, -1             320:           subu    LEN,1
BFD00378  1540FFFD   BNE T2, ZERO, 0xBFD00370     321:           bne     LEN,$0,_dinit_clear
BFD0037C  25290001   ADDIU T1, T1, 1              322:           addu    DST,1
                                                  323:   
                                                  324:   _dinit_end:
BFD00380  25080003   ADDIU T0, T0, 3              325:           addu    SRC,3
BFD00384  240AFFFC   ADDIU T2, ZERO, -4           326:           addiu   LEN,$0,0xFFFFFFFC
BFD00388  01484024   AND T0, T2, T0               327:           and     SRC,LEN,SRC
BFD0038C  8D090000   LW T1, 0(T0)                 328:           lw      DST,0(SRC)
BFD00390  1520FFE7   BNE T1, ZERO, 0xBFD00330     329:           bne     DST,$0,0b
BFD00394  00000000   NOP                          330:           nop
                                                  331:   9:
                                                  332:   
                                                  333:           ##################################################################
                                                  334:           # If there are no RAM functions, skip the next section --
                                                  335:           # initializing bus matrix registers.
                                                  336:           ##################################################################
BFD00398  3C090000   LUI T1, 0                    337:           la      t1,_ramfunc_begin
BFD003A0  11200001   BEQ T1, ZERO, 0xBFD003A8     338:           beqz    t1,_ramfunc_done
BFD003A4  00000000   NOP                          339:           nop
                                                  340:   
                                                  341:   #if defined(INIT_SSX)
                                                  342:     /* No initialization required */
                                                  343:   #else /* Use BMX */
                                                  344:           ##################################################################
                                                  345:           # Initialize bus matrix registers if RAM functions exist in the
                                                  346:           # application
                                                  347:           ##################################################################
                                                  348:           la      t1,_bmxdkpba_address
                                                  349:           la      t2,BMXDKPBA
                                                  350:           sw      t1,0(t2)
                                                  351:           la      t1,_bmxdudba_address
                                                  352:           la      t2,BMXDUDBA
                                                  353:           sw      t1,0(t2)
                                                  354:           la      t1,_bmxdupba_address
                                                  355:           la      t2,BMXDUPBA
                                                  356:           sw      t1,0(t2)
                                                  357:   #endif /* INIT_SSX */
                                                  358:   
                                                  359:   _ramfunc_done:
                                                  360:   
                                                  361:           ##################################################################
                                                  362:           # Initialize CP0 registers
                                                  363:           ##################################################################
                                                  364:           # Initialize Count register
                                                  365:           ##################################################################
BFD003A8  40804800   MTC0 ZERO, Count             366:           mtc0    zero,_CP0_COUNT
                                                  367:   
                                                  368:           ##################################################################
                                                  369:           # Initialize Compare register
                                                  370:           ##################################################################
BFD003AC  240AFFFF   ADDIU T2, ZERO, -1           371:           li      t2,-1
BFD003B0  408A5800   MTC0 T2, Compare             372:           mtc0    t2,_CP0_COMPARE
                                                  373:   
                                                  374:           ##################################################################
                                                  375:           # Initialize EBase register
                                                  376:           ##################################################################
BFD003B4  3C09BFD0   LUI T1, -16432               377:           la      t1,_ebase_address
BFD003BC  40897801   MTC0 T1, EBase               378:           mtc0    t1,_CP0_EBASE
                                                  379:   
                                                  380:           ##################################################################
                                                  381:           # Initialize IntCtl register
                                                  382:           ##################################################################
BFD003C0  3C090000   LUI T1, 0                    383:           la      t1,_vector_spacing
BFD003C8  240A0000   ADDIU T2, ZERO, 0            384:           li      t2,0                    # Clear t2 and
BFD003CC  7D2A4944   INS T2, T1, 5, 5             385:           ins     t2,t1,5,5               # shift value to VS field
BFD003D0  408A6001   MTC0 T2, IntCtl              386:           mtc0    t2,_CP0_INTCTL
                                                  387:   
                                                  388:           ##################################################################
                                                  389:           # Initialize CAUSE registers
                                                  390:           # - Enable counting of Count register <DC = 0>
                                                  391:           # - Use special exception vector <IV = 1>
                                                  392:           # - Clear pending software interrupts <IP1:IP0 = 0>
                                                  393:           ##################################################################
BFD003D4  3C090080   LUI T1, 128                  394:           li      t1,0x00800000
BFD003D8  40896800   MTC0 T1, Cause               395:           mtc0    t1,_CP0_CAUSE
                                                  396:   
                                                  397:           ##################################################################
                                                  398:           # Initialize STATUS register
                                                  399:           # - Access to Coprocessor 0 not allowed in user mode <CU0 = 0>
                                                  400:           # - User mode uses configured endianness <RE = 0>
                                                  401:           # - Preserve Bootstrap Exception vectors <BEV>
                                                  402:           # - Preserve soft reset <SR> and non-maskable interrupt <NMI>
                                                  403:           # - CorExtend enabled based on whether CorExtend User Defined
                                                  404:           #   Instructions have been implemented <CEE = Config<UDI>>
                                                  405:           # - Disable any pending interrups <IM7..IM2 = 0, IM1..IM0 = 0>
                                                  406:           # - Disable hardware interrupts <IPL7:IPL2 = 0>
                                                  407:           # - Base mode is Kernel mode <UM = 0>
                                                  408:           # - Error level is normal <ERL = 0>
                                                  409:           # - Exception level is normal <EXL = 0>
                                                  410:           # - Interrupts are disabled <IE = 0>
                                                  411:           # - DSPr2 ASE is enabled for devices that support it <MX = 1>
                                                  412:           ##################################################################
BFD003DC  40088000   MFC0 T0, Config              413:           mfc0    t0,_CP0_CONFIG
BFD003E0  7D090580   EXT T1, T0, 22, 1            414:           ext     t1,t0,22,1              # Extract UDI from Config register
BFD003E4  00094C40   SLL T1, T1, 17               415:           sll     t1,t1,17                # Move UDI to Status.CEE location
BFD003E8  40086000   MFC0 T0, Status              416:           mfc0    t0,_CP0_STATUS
BFD003EC  3C010058   LUI AT, 88                   417:           and     t0,t0,0x00580000        # Preserve SR, NMI, and BEV
                                                  418:   #if defined(INIT_DSPR2)
                                                  419:           li      t2, 0x01000000          # Set the Status.MX bit to enable DSP
                                                  420:           or      t0,t2,t0
                                                  421:   #endif
BFD003F4  01284025   OR T0, T1, T0                422:           or      t0,t1,t0                # Include Status.CEE (from UDI)
BFD003F8  40886000   MTC0 T0, Status              423:           mtc0    t0,_CP0_STATUS
                                                  424:   
                                                  425:           ##################################################################
                                                  426:           # Call the "on bootstrap" procedure
                                                  427:           ##################################################################
BFD003FC  3C08BFD1   LUI T0, -16431               428:           la      t0,_on_bootstrap
BFD00404  0100F809   JALR T0                      429:           jalr    t0
BFD00408  00000000   NOP                          430:           nop
                                                  431:   
                                                  432:           ##################################################################
                                                  433:           # Initialize Status<BEV> for normal exception vectors
                                                  434:           ##################################################################
BFD0040C  40086000   MFC0 T0, Status              435:           mfc0    t0,_CP0_STATUS
BFD00410  3C01FFBF   LUI AT, -65                  436:           and     t0,t0,0xffbfffff        # Clear BEV
BFD0041C  40886000   MTC0 T0, Status              437:           mtc0    t0,_CP0_STATUS
                                                  438:   
                                                  439:           ##################################################################
                                                  440:           # Call main. We do this via a thunk in the text section so that
                                                  441:           # a normal jump and link can be used, enabling the startup code
                                                  442:           # to work properly whether main is written in MIPS16 or MIPS32
                                                  443:           # code. I.e., the linker will correctly adjust the JAL to JALX if
                                                  444:           # necessary
                                                  445:           ##################################################################
BFD00420  30840000   ANDI A0, A0, 0               446:           and     a0,a0,0
BFD00424  30A50000   ANDI A1, A1, 0               447:           and     a1,a1,0
BFD00428  3C08BFD0   LUI T0, -16432               448:           la      t0,_main_entry
BFD00430  01000008   JR T0                        449:           jr      t0
BFD00434  00000000   NOP                          450:           nop
                                                  451:   
                                                  452:           .end _startup
                                                  453:   
                                                  454:   
                                                  455:           ##################################################################
                                                  456:           # General Exception Vector Handler
                                                  457:           # Jumps to _general_exception_context
                                                  458:           ##################################################################
                                                  459:           .section .gen_handler,code
                                                  460:           .set noreorder
                                                  461:           .ent _gen_exception
                                                  462:   _gen_exception:
BFD00180  3C1ABFD0   LUI K0, -16432               463:   0:      la      k0,_general_exception_context
BFD00188  03400008   JR K0                        464:           jr      k0
BFD0018C  00000000   NOP                          465:           nop
                                                  466:   
                                                  467:           .end _gen_exception
                                                  468:   
                                                  469:   #if defined(INIT_MMU_MZ_FIXED)
                                                  470:           ##################################################################
                                                  471:           # Simple TLB-Refill Exception Vector
                                                  472:           # Jumps to _simple_tlb_refill_exception_context
                                                  473:           ##################################################################
                                                  474:           .section .simple_tlb_refill_vector,code,keep
                                                  475:           .set noreorder
                                                  476:           .ent simple_tlb_refill_vector
                                                  477:   simple_tlb_refill_vector:
                                                  478:           la      k0,_simple_tlb_refill_exception_context
                                                  479:           jr      k0
                                                  480:           nop
                                                  481:   
                                                  482:           .end simple_tlb_refill_vector
                                                  483:   #endif
                                                  484:   
                                                  485:   #if defined(INIT_L1_CACHE)
                                                  486:           ##################################################################
                                                  487:           # Cache-Error Exception Vector Handler
                                                  488:           # Jumps to _cache_err_exception_context
                                                  489:           ##################################################################
                                                  490:           .section .cache_err_vector,code,keep
                                                  491:           .set noreorder
                                                  492:           .ent _cache_err_vector
                                                  493:   _cache_err_vector:
                                                  494:           la      k0,_cache_err_exception_context
                                                  495:           jr      k0
                                                  496:           nop
                                                  497:   
                                                  498:           .end _cache_err_vector
                                                  499:   #endif
                                                  500:   
                                                  501:           .section .text.main_entry,code,keep
                                                  502:           .ent _main_entry
                                                  503:   _main_entry:
                                                  504:   
                                                  505:   #if defined(CPP_INIT)
                                                  506:           .weak _init
                                                  507:           # call .init section to run constructors etc
BFD06804  3C04BFD0   LUI A0, -16432               508:           lui	a0,%hi(_init)
BFD06808  27BDFFE8   ADDIU SP, SP, -24            509:           addiu	sp,sp,-24
BFD0680C  24840438   ADDIU A0, A0, 1080           510:           addiu	a0,a0,%lo(_init)
BFD06810  10800003   BEQ A0, ZERO, 0xBFD06820     511:           beq	a0,$0,2f
BFD06814  AFBF0014   SW RA, 20(SP)                512:           sw	$31,20(sp)	 #,
BFD06818  0080F809   JALR A0                      513:           jalr	a0
BFD0681C  00000000   NOP                          514:           nop
                                                  515:   2:
                                                  516:   #endif
BFD06820  30840000   ANDI A0, A0, 0               517:           and     a0,a0,0
BFD06824  30A50000   ANDI A1, A1, 0               518:           and     a1,a1,0
                                                  519:   
                                                  520:           ##################################################################
                                                  521:   
                                                  522:           # Call main
                                                  523:           ##################################################################
BFD06828  77F425B0   JALX 0xBFD096C0              524:           jal main
BFD0682C  00000000   NOP                          525:           nop
                                                  526:   
                                                  527:   #if defined(CALL_EXIT)
                                                  528:           ##################################################################
                                                  529:           # Call exit()
                                                  530:           ##################################################################
                                                  531:           jal exit
                                                  532:           nop
                                                  533:   #endif
                                                  534:   
                                                  535:           ##################################################################
                                                  536:           # Just in case, go into infinite loop
                                                  537:           # Call a software breakpoint only with -mdebugger compiler option
                                                  538:           ##################################################################
                                                  539:           .weak __exception_handler_break
                                                  540:   __crt0_exit:
                                                  541:   1:
BFD06830  3C020000   LUI V0, 0                    542:           la      v0,__exception_handler_break
BFD06838  10400003   BEQ V0, ZERO, 0xBFD06848     543:           beq     v0,0,0f
BFD0683C  00000000   NOP                          544:           nop
BFD06840  0040F809   JALR V0                      545:           jalr    v0
BFD06844  00000000   NOP                          546:           nop
                                                  547:   
BFD06848  1000FFF9   BEQ ZERO, ZERO, 0xBFD06830   548:   0:      b       1b
BFD0684C  00000000   NOP                          549:           nop
                                                  550:   
                                                  551:           .globl __crt0_exit
                                                  552:           .end _main_entry
                                                  553:   
                                                  554:       ###############################################################
                                                  555:       # launch_fw
                                                  556:       ###############################################################
                                                  557:       .globl  rom_launch_fw
                                                  558:       .set    nomips16
                                                  559:       .set    micromips
                                                  560:       .ent   rom_launch_fw
                                                  561:       .type  rom_launch_fw, @function
                                                  562:   
                                                  563:   rom_launch_fw:
                                                  564:   
                                                  565:       .set    noreorder
                                                  566:       .set    nomacro
                                                  567:   
                                                  568:   lfw1:
BFD06850  477C0000   DI ZERO                      569:       di
                                                  570:   lfw2:
BFD06854  18000000   SLL ZERO, ZERO, 3            571:       ehb
                                                  572:   lfw3:
BFD06858      0C00   NOP                          573:       nop
                                                  574:       
                                                  575:       # turn off core timer
                                                  576:   lfw4:
BFD0685A  00FC010D   MFC0 T0, Cause               577:       mfc0    t0, _CP0_CAUSE
                                                  578:   lfw5:
BFD0685E  F7FF41A9   LUI T1, 0xF7FF               579:       lui     t1, 0xf7ff
                                                  580:   lfw6:
BFD06862  FFFF5129   ORI T1, T1, -1               581:       ori     t1, t1, 0xffff
                                                  582:   lfw7:
BFD06866  42500128   AND T0, T0, T1               583:       and     t0, t0, t1
                                                  584:   lfw8:
BFD0686A  02FC010D   MTC0 T0, Cause               585:       mtc0    t0, _CP0_CAUSE
                                                  586:   lfw9:
BFD0686E  18000000   SLL ZERO, ZERO, 3            587:       ehb
                                                  588:   lfw10:
BFD06872      0C00   NOP                          589:       nop
                                                  590:   lfw11:
BFD06874  00FC010C   MFC0 T0, Status              591:       mfc0    t0, _CP0_STATUS
                                                  592:   lfw12:
BFD06878  004041A9   LUI T1, 0x40                 593:       lui     t1, 0x0040
                                                  594:   lfw13:
BFD0687C  42900128   OR T0, T0, T1                595:       or      t0, t0, t1        # BEV(bit[22]) = 1
                                                  596:   lfw14:
BFD06880  02FC010C   MTC0 T0, Status              597:       mtc0    t0, _CP0_STATUS
                                                  598:   lfw15:
BFD06884  18000000   SLL ZERO, ZERO, 3            599:       ehb
                                                  600:   lfw16:
BFD06888      0C00   NOP                          601:       nop
                                                  602:   lfw17:    
BFD0688A  1F3C0004   JALR.HB ZERO, A0             603:       JR.HB   a0
                                                  604:   lfw18:
BFD0688E  00000000   NOP                          605:       nop
                                                  606:   0:
BFD06892  3449D7E8   J 0xBFD06892                 607:       j       0b                  # should not get here
                                                  608:   lfw19:
BFD06896      0C00   NOP                          609:       nop
                                                  610:   
                                                  611:       .set    macro
                                                  612:       .set    reorder
                                                  613:   
                                                  614:       .end    rom_launch_fw
                                                  615:       .size   rom_launch_fw, .-rom_launch_fw
                                                  616:       
---  C:/E/Dev/FreeRTOS/WorkingCopy/FreeRTOS/Demo/PIC32MEC14xx_MPLAB/src/MEC14xx/interrupts/girq24d.S  ---
                                                  1:     /*
                                                  2:         Copyright (C) 2014 Microchip Inc.
                                                  3:         All rights reserved
                                                  4:     
                                                  5:         1 tab == 4 spaces!
                                                  6:     */
                                                  7:     
                                                  8:     #ifdef __XC32
                                                  9:     #include <xc.h>
                                                  10:    #include <sys/asm.h>
                                                  11:    #else
                                                  12:    #include "Regs.S"
                                                  13:    #endif
                                                  14:    
                                                  15:    #include "MEC14xx/mec14xx_girqm.h"
                                                  16:    
                                                  17:    /******************************************************************/
                                                  18:    
                                                  19:    /***************************************************************
                                                  20:     *  MEC14xx GIRQ24 Disaggregated Vector Jump table
                                                  21:     *
                                                  22:     ***************************************************************/
                                                  23:    
                                                  24:        .extern girq24_b0
                                                  25:        .extern girq24_b1
                                                  26:        .extern girq24_b2
                                                  27:    
                                                  28:    #if GIRQ24_DISAGG != 0
                                                  29:    
                                                  30:    /* 
                                                  31:     * FreeRTOS Handler for MIPS M14K Software Interrupt 0 
                                                  32:     * implemented in the porting layer.
                                                  33:     */
                                                  34:        .extern vPortYieldISR
                                                  35:    
                                                  36:    /*
                                                  37:     * Disaggregated girq24_isr
                                                  38:     * Program address of this version of girq24_isr into JTVIC GIRQ24
                                                  39:     * Aggregator Control register with bit[0] = 1.
                                                  40:     */
                                                  41:    
                                                  42:    /*
                                                  43:     * NOTE: All the additional labels surrounding every instruction are
                                                  44:     * there to force GCC OBJDUMP to disassemble microMIPS correctly.
                                                  45:     */
                                                  46:    
                                                  47:        .insn
                                                  48:    #ifdef __XC32
                                                  49:        .section .girqs.girq24_isr, code
                                                  50:    #else
                                                  51:        .section .girqs.girq24_isr,"x"
                                                  52:    #endif
                                                  53:        .set  nomips16
                                                  54:        .set  micromips
                                                  55:        .set  noreorder
                                                  56:        .set  noat
                                                  57:        .ent girq24_isr
                                                  58:        .global girq24_isr
                                                  59:        .align 2
                                                  60:    
                                                  61:    girq24_isr:
BFD00270  32D4D7E8   J 0xBFD065A8                 62:        J       girq24_b0
                                                  63:    g24b0b:
BFD00274      0C00   NOP                          64:        NOP
                                                  65:    
                                                  66:        .align 2
                                                  67:    g24b1a:
BFD00278  05B8D7E8   J 0xBFD00B70                 68:        J       vPortYieldISR   /* girq24_b1 */
                                                  69:    g24b1b:
BFD0027C      0C00   NOP                          70:        NOP
                                                  71:    
                                                  72:        .align 2
                                                  73:    g24b2a:
BFD00280  23A0D7E8   J 0xBFD04740                 74:        J       girq24_b2
                                                  75:    g24b2b:
BFD00284      0C00   NOP                          76:        NOP
                                                  77:    g24end:
                                                  78:        .end girq24_isr
                                                  79:    
                                                  80:    #endif
                                                  81:    
                                                  82:    /******************************************************************/
                                                  83:    
                                                  84:    
---  C:/E/Dev/FreeRTOS/WorkingCopy/FreeRTOS/Demo/PIC32MEC14xx_MPLAB/src/MEC14xx/interrupts/girq23d.S  ---
                                                  1:     /*
                                                  2:         Copyright (C) 2014 Microchip Inc.
                                                  3:         All rights reserved
                                                  4:     
                                                  5:         1 tab == 4 spaces!
                                                  6:     */
                                                  7:     
                                                  8:     #ifdef __XC32
                                                  9:     #include <xc.h>
                                                  10:    #include <sys/asm.h>
                                                  11:    #else
                                                  12:    #include "Regs.S"
                                                  13:    #endif
                                                  14:    
                                                  15:    #include "MEC14xx/mec14xx_girqm.h"
                                                  16:    
                                                  17:    
                                                  18:    /***************************************************************
                                                  19:     *  MEC14xx GIRQ23 Disaggregated Vector Jump table
                                                  20:     *
                                                  21:     ***************************************************************/
                                                  22:    
                                                  23:        .extern girq23_b0
                                                  24:        .extern girq23_b1
                                                  25:        .extern girq23_b2
                                                  26:        .extern girq23_b3
                                                  27:        .extern girq23_b4
                                                  28:        .extern girq23_b5
                                                  29:        .extern girq23_b6
                                                  30:        .extern girq23_b7
                                                  31:        .extern girq23_b8
                                                  32:        .extern girq23_b9
                                                  33:        .extern girq23_b10
                                                  34:        .extern girq23_b11
                                                  35:        .extern girq23_b12
                                                  36:        .extern girq23_b13
                                                  37:    
                                                  38:    #if GIRQ23_DISAGG != 0
                                                  39:    
                                                  40:    /*
                                                  41:     * FreeRTOS Handler for MEC14xx RTOS Timer
                                                  42:     * implemented in the porting layer.
                                                  43:     */
                                                  44:        .extern vPortTickInterruptHandler
                                                  45:    
                                                  46:    /*
                                                  47:     * Disaggregated girq23_isr
                                                  48:     * Program address of this version of girq23_isr into JTVIC GIRQ23
                                                  49:     * Aggregator Control register with bit[0] = 1.
                                                  50:     */
                                                  51:    
                                                  52:    /*
                                                  53:     * NOTE: All the additional labels surrounding every instruction are
                                                  54:     * there to force GCC OBJDUMP to disassemble microMIPS correctly.
                                                  55:     */
                                                  56:    
                                                  57:        .insn
                                                  58:    #ifdef __XC32
                                                  59:        .section .girqs.girq23_isr, code
                                                  60:    #else
                                                  61:        .section .girqs.girq23_isr,"x"
                                                  62:    #endif
                                                  63:        .set  nomips16
                                                  64:        .set  micromips
                                                  65:        .set  noreorder
                                                  66:        .set  noat
                                                  67:        .ent girq23_isr
                                                  68:        .global girq23_isr
                                                  69:        .align 2
                                                  70:    
                                                  71:    girq23_isr:
                                                  72:    
BFD00200  3950D7E8   J 0xBFD072A0                 73:        J       girq23_b0
                                                  74:    g23b0b:
BFD00204      0C00   NOP                          75:        NOP
                                                  76:    
                                                  77:        .align 2
                                                  78:    g23b1a:
BFD00208  2638D7E8   J 0xBFD04C70                 79:        J       girq23_b1
                                                  80:    g23b1b:
BFD0020C      0C00   NOP                          81:        NOP
                                                  82:    
                                                  83:        .align 2
                                                  84:    g23b2a:
BFD00210  26A0D7E8   J 0xBFD04D40                 85:        J       girq23_b2
                                                  86:    g23b2b:
BFD00214      0C00   NOP                          87:        NOP
                                                  88:    
                                                  89:        .align 2
                                                  90:    g23b3a:
BFD00218  2708D7E8   J 0xBFD04E10                 91:        J       girq23_b3
                                                  92:    g23b3b:
BFD0021C      0C00   NOP                          93:        NOP
                                                  94:    
                                                  95:        .align 2
                                                  96:    g23b4a:
BFD00220  0490D7E8   J 0xBFD00920                 97:        J       girq23_b4 
                                                  98:    g23b4b:
BFD00224      0C00   NOP                          99:        NOP
                                                  100:   
                                                  101:       .align 2
                                                  102:   g23b5a:
BFD00228  2770D7E8   J 0xBFD04EE0                 103:       J       girq23_b5
                                                  104:   g23b5b:
BFD0022C      0C00   NOP                          105:       NOP
                                                  106:   
                                                  107:       .align 2
                                                  108:   g23b6a:
BFD00230  27D8D7E8   J 0xBFD04FB0                 109:       J       girq23_b6
                                                  110:   g23b6b:
BFD00234      0C00   NOP                          111:       NOP
                                                  112:   
                                                  113:       .align 2
                                                  114:   g23b7a:
BFD00238  2840D7E8   J 0xBFD05080                 115:       J       girq23_b7
                                                  116:   g23b7b:
BFD0023C      0C00   NOP                          117:       NOP
                                                  118:   
                                                  119:       .align 2
                                                  120:   g23b8a:
BFD00240  28A8D7E8   J 0xBFD05150                 121:       J       girq23_b8
                                                  122:   g23b8b:
BFD00244      0C00   NOP                          123:       NOP
                                                  124:   
                                                  125:       .align 2
                                                  126:   g23b9a:
BFD00248  2910D7E8   J 0xBFD05220                 127:       J       girq23_b9
                                                  128:   g23b9b:
BFD0024C      0C00   NOP                          129:       NOP
                                                  130:   
                                                  131:       .align 2
                                                  132:   g23b10a:
BFD00250  2978D7E8   J 0xBFD052F0                 133:       J       girq23_b10
                                                  134:   g23b10b:
BFD00254      0C00   NOP                          135:       NOP
                                                  136:   
                                                  137:       .align 2
                                                  138:   g23b11a:
BFD00258  29E0D7E8   J 0xBFD053C0                 139:       J       girq23_b11
                                                  140:   g23b11b:
BFD0025C      0C00   NOP                          141:       NOP
                                                  142:   
                                                  143:       .align 2
                                                  144:   g23b12a:
BFD00260  2A48D7E8   J 0xBFD05490                 145:       J       girq23_b12
                                                  146:   g23b12b:
BFD00264      0C00   NOP                          147:       NOP
                                                  148:   
                                                  149:       .align 2
                                                  150:   g23b13a:
BFD00268  2AB0D7E8   J 0xBFD05560                 151:       J       girq23_b13
                                                  152:   g23b13b:
BFD0026C      0C00   NOP                          153:       NOP
                                                  154:   g23end:
                                                  155:       .end girq23_isr
                                                  156:   
                                                  157:   #endif
                                                  158:   
                                                  159:   /******************************************************************/
                                                  160:   
                                                  161:   
                                                  162:   
                                                  163:   
---  C:/E/Dev/FreeRTOS/WorkingCopy/FreeRTOS/Demo/PIC32MEC14xx_MPLAB/src/MEC14xx/exceptions/MPLAB/general_exception_ctx.S
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  General Exception
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        general-exception.S
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32 v1.00
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * This software is developed by Microchip Technology Inc. and its
                                                  17:     * subsidiaries ("Microchip").
                                                  18:     *
                                                  19:     * Redistribution and use in source and binary forms, with or without
                                                  20:     * modification, are permitted provided that the following conditions are met:
                                                  21:     *
                                                  22:     * 1.      Redistributions of source code must retain the above copyright
                                                  23:     * notice, this list of conditions and the following disclaimer.
                                                  24:     *
                                                  25:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer in the
                                                  27:     * documentation and/or other materials provided with the distribution.
                                                  28:     *
                                                  29:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  30:     * derived from this software without specific prior written permission.
                                                  31:     *
                                                  32:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  33:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  34:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  35:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  36:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  37:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  38:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  39:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  40:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  41:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  42:     *
                                                  43:     ********************************************************************/
                                                  44:     
                                                  45:    #include <xc.h>
                                                  46:    #ifdef __LIBBUILD__
                                                  47:       .file 1 "general-exception.S"
                                                  48:       .loc 1 0
                                                  49:    #endif
                                                  50:      ###################
                                                  51:      # Default general exception handler
                                                  52:      ###################
                                                  53:    
                                                  54:      .extern _general_exception_handler
                                                  55:    
                                                  56:      .section .text.general_exception, code
                                                  57:      .set noreorder
                                                  58:      .set noat
                                                  59:      .set nomips16
                                                  60:      .globl _general_exception_context
                                                  61:      .ent _general_exception_context
                                                  62:    
                                                  63:    _general_exception_context:
                                                  64:    
                                                  65:      # Save off the non-callee saved registers that may get mucked with
BFD049E4  27BDFFA8   ADDIU SP, SP, -88            66:       addiu sp, sp, -88
BFD049E8  AFA10004   SW AT, 4(SP)                 67:       sw $1,  4(sp)
BFD049EC  AFA20008   SW V0, 8(SP)                 68:       sw v0,  8(sp)
BFD049F0  AFA3000C   SW V1, 12(SP)                69:       sw v1, 12(sp)
BFD049F4  AFA40010   SW A0, 16(SP)                70:       sw a0, 16(sp)
BFD049F8  AFA50014   SW A1, 20(SP)                71:       sw a1, 20(sp)
BFD049FC  AFA60018   SW A2, 24(SP)                72:       sw a2, 24(sp)
BFD04A00  AFA7001C   SW A3, 28(SP)                73:       sw a3, 28(sp)
BFD04A04  AFA80020   SW T0, 32(SP)                74:       sw t0, 32(sp)
BFD04A08  AFA90024   SW T1, 36(SP)                75:       sw t1, 36(sp)
BFD04A0C  AFAA0028   SW T2, 40(SP)                76:       sw t2, 40(sp)
BFD04A10  AFAB002C   SW T3, 44(SP)                77:       sw t3, 44(sp)
BFD04A14  AFAC0030   SW T4, 48(SP)                78:       sw t4, 48(sp)
BFD04A18  AFAD0034   SW T5, 52(SP)                79:       sw t5, 52(sp)
BFD04A1C  AFAE0038   SW T6, 56(SP)                80:       sw t6, 56(sp)
BFD04A20  AFAF003C   SW T7, 60(SP)                81:       sw t7, 60(sp)
BFD04A24  AFB80040   SW T8, 64(SP)                82:       sw t8, 64(sp)
BFD04A28  AFB90044   SW T9, 68(SP)                83:       sw t9, 68(sp)
BFD04A2C  AFBF0048   SW RA, 72(SP)                84:       sw ra, 72(sp)
BFD04A30  00004012   MFLO T0, 0                   85:       mflo t0
BFD04A34  AFA8004C   SW T0, 76(SP)                86:       sw t0, 76(sp)
BFD04A38  00004010   MFHI T0, 0                   87:       mfhi t0
BFD04A3C  AFA80050   SW T0, 80(SP)                88:       sw t0, 80(sp)
                                                  89:    
BFD04A40  3C1ABFD0   LUI K0, -16432               90:       la      k0,_general_exception_handler
BFD04A48  00000000   NOP                          91:       nop
                                                  92:       
                                                  93:       # Pass Cause and Status to the handler function
BFD04A4C  40046800   MFC0 A0, Cause               94:       mfc0 a0, _CP0_CAUSE
BFD04A50  40056000   MFC0 A1, Status              95:       mfc0 a1, _CP0_STATUS
BFD04A54  0340F809   JALR K0                      96:       jalr    k0
BFD04A58  00000000   NOP                          97:       nop
                                                  98:    
BFD04A5C  8FA80050   LW T0, 80(SP)                99:       lw t0, 80(sp)
BFD04A60  01000011   MTHI T0, 0                   100:      mthi t0
BFD04A64  8FA8004C   LW T0, 76(SP)                101:      lw t0, 76(sp)
BFD04A68  01000013   MTLO T0, 0                   102:      mtlo t0
                                                  103:   
BFD04A6C  8FA10004   LW AT, 4(SP)                 104:      lw $1,  4(sp)
BFD04A70  8FA20008   LW V0, 8(SP)                 105:      lw v0,  8(sp)
BFD04A74  8FA3000C   LW V1, 12(SP)                106:      lw v1, 12(sp)
BFD04A78  8FA40010   LW A0, 16(SP)                107:      lw a0, 16(sp)
BFD04A7C  8FA50014   LW A1, 20(SP)                108:      lw a1, 20(sp)
BFD04A80  8FA60018   LW A2, 24(SP)                109:      lw a2, 24(sp)
BFD04A84  8FA7001C   LW A3, 28(SP)                110:      lw a3, 28(sp)
BFD04A88  8FA80020   LW T0, 32(SP)                111:      lw t0, 32(sp)
BFD04A8C  8FA90024   LW T1, 36(SP)                112:      lw t1, 36(sp)
BFD04A90  8FAA0028   LW T2, 40(SP)                113:      lw t2, 40(sp)
BFD04A94  8FAB002C   LW T3, 44(SP)                114:      lw t3, 44(sp)
BFD04A98  8FAC0030   LW T4, 48(SP)                115:      lw t4, 48(sp)
BFD04A9C  8FAD0034   LW T5, 52(SP)                116:      lw t5, 52(sp)
BFD04AA0  8FAE0038   LW T6, 56(SP)                117:      lw t6, 56(sp)
BFD04AA4  8FAF003C   LW T7, 60(SP)                118:      lw t7, 60(sp)
BFD04AA8  8FB80040   LW T8, 64(SP)                119:      lw t8, 64(sp)
BFD04AAC  8FB90044   LW T9, 68(SP)                120:      lw t9, 68(sp)
BFD04AB0  8FBF0048   LW RA, 72(SP)                121:      lw ra, 72(sp)
BFD04AB4  27BD0058   ADDIU SP, SP, 88             122:      addiu sp, sp, 88
                                                  123:   
BFD04AB8  000000C0   EHB                          124:      ehb
BFD04ABC  42000018   ERET                         125:      eret
                                                  126:   
                                                  127:     .end _general_exception_context
                                                  128:   
