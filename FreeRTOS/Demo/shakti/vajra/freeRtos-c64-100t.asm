
freeRtos-c64-100t.elf:     file format elf64-littleriscv


Disassembly of section .text.init:

0000000080000000 <_start>:
.section ".text.init"
.globl _start

_start:

li  x1, 0
    80000000:	4081                	li	ra,0
li  x2, 0
    80000002:	4101                	li	sp,0
li  x3, 0
    80000004:	4181                	li	gp,0
li  x4, 0
    80000006:	4201                	li	tp,0
li  x5, 0
    80000008:	4281                	li	t0,0
li  x6, 0
    8000000a:	4301                	li	t1,0
li  x7, 0
    8000000c:	4381                	li	t2,0
li  x8, 0
    8000000e:	4401                	li	s0,0
li  x9, 0
    80000010:	4481                	li	s1,0
li  x10,0
    80000012:	4501                	li	a0,0
li  x11,0
    80000014:	4581                	li	a1,0
li  x12,0
    80000016:	4601                	li	a2,0
li  x13,0
    80000018:	4681                	li	a3,0
li  x14,0
    8000001a:	4701                	li	a4,0
li  x15,0
    8000001c:	4781                	li	a5,0
li  x16,0
    8000001e:	4801                	li	a6,0
li  x17,0
    80000020:	4881                	li	a7,0
li  x18,0
    80000022:	4901                	li	s2,0
li  x19,0
    80000024:	4981                	li	s3,0
li  x20,0
    80000026:	4a01                	li	s4,0
li  x21,0
    80000028:	4a81                	li	s5,0
li  x22,0
    8000002a:	4b01                	li	s6,0
li  x23,0
    8000002c:	4b81                	li	s7,0
li  x24,0
    8000002e:	4c01                	li	s8,0
li  x25,0
    80000030:	4c81                	li	s9,0
li  x26,0
    80000032:	4d01                	li	s10,0
li  x27,0
    80000034:	4d81                	li	s11,0
li  x28,0
    80000036:	4e01                	li	t3,0
li  x29,0
    80000038:	4e81                	li	t4,0
li  x30,0
    8000003a:	4f01                	li	t5,0
li  x31,0
    8000003c:	4f81                	li	t6,0
   memset gp to zero
 */
# initialize global pointer
.option push
.option norelax
la gp, __global_pointer$
    8000003e:	0000b197          	auipc	gp,0xb
    80000042:	2ca18193          	addi	gp,gp,714 # 8000b308 <__global_pointer$>

0000000080000046 <init_bss>:
.option pop

init_bss:
    /* init bss section */
    la	a0, __bss_start
    80000046:	0000b517          	auipc	a0,0xb
    8000004a:	bba50513          	addi	a0,a0,-1094 # 8000ac00 <xISRStack>
    la	a1, __bss_end-4 /* section end is actually the start of the next section */
    8000004e:	00107597          	auipc	a1,0x107
    80000052:	1fe58593          	addi	a1,a1,510 # 8010724c <bmp280_calib_dig_P2>
    li	a2, 0x0
    80000056:	4601                	li	a2,0
  1:
    sw		a2, 0(a0)
    80000058:	c110                	sw	a2,0(a0)
    bgeu	a0, a1, init_sbss
    8000005a:	00b57463          	bgeu	a0,a1,80000062 <init_sbss>
    addi	a0, a0, 4
    8000005e:	0511                	addi	a0,a0,4
    j	        1b
    80000060:	bfe5                	j	80000058 <init_bss+0x12>

0000000080000062 <init_sbss>:

init_sbss:
    /* init bss section */
    la	a0, __sbss_start
    80000062:	0000b517          	auipc	a0,0xb
    80000066:	b5e50513          	addi	a0,a0,-1186 # 8000abc0 <ullNextTime>
    la	a1, __sbss_end-4 /* section end is actually the start of the next section */
    8000006a:	0000b597          	auipc	a1,0xb
    8000006e:	b8e58593          	addi	a1,a1,-1138 # 8000abf8 <gtemp>
    li	a2, 0x0
    80000072:	4601                	li	a2,0
   1:
    sw		a2, 0(a0)
    80000074:	c110                	sw	a2,0(a0)
    bgeu	a0, a1, 1f
    80000076:	00b57463          	bgeu	a0,a1,8000007e <init_sbss+0x1c>
    addi	a0, a0, 4
    8000007a:	0511                	addi	a0,a0,4
    j	        1b
    8000007c:	bfe5                	j	80000074 <init_sbss+0x12>

1:
# initialize stack pointer
.option push
.option norelax
la sp, __stack_pointer$
    8000007e:	0011b117          	auipc	sp,0x11b
    80000082:	1d210113          	addi	sp,sp,466 # 8011b250 <__stack>
fmv.s.x f30,x0
fmv.s.x f31,x0

#endif

la  tp, _end + 63
    80000086:	0011b217          	auipc	tp,0x11b
    8000008a:	20920213          	addi	tp,tp,521 # 8011b28f <__stack+0x3f>
and tp, tp, -64
    8000008e:	fc027213          	andi	tp,tp,-64

j init
    80000092:	7340706f          	j	800077c6 <init>

Disassembly of section .text:

0000000080000100 <vPortSetupTimerInterrupt>:
/*-----------------------------------------------------------*/

#if( configMTIME_BASE_ADDRESS != 0 ) && ( configMTIMECMP_BASE_ADDRESS != 0 )

	void vPortSetupTimerInterrupt( void )
	{
    80000100:	1101                	addi	sp,sp,-32
	uint32_t ulCurrentTimeHigh, ulCurrentTimeLow;
	volatile uint32_t * const pulTimeHigh = ( volatile uint32_t * const ) ( ( configMTIME_BASE_ADDRESS ) + 4UL ); /* 8-byte typer so high 32-bit word is 4 bytes up. */
    80000102:	0200c7b7          	lui	a5,0x200c
    80000106:	17f1                	addi	a5,a5,-4
    80000108:	ec3e                	sd	a5,24(sp)
	volatile uint32_t * const pulTimeLow = ( volatile uint32_t * const ) ( configMTIME_BASE_ADDRESS );
    8000010a:	0200c7b7          	lui	a5,0x200c
    8000010e:	17e1                	addi	a5,a5,-8
    80000110:	e83e                	sd	a5,16(sp)
	volatile uint32_t ulHartId;

		__asm volatile( "csrr %0, mhartid" : "=r"( ulHartId ) );
    80000112:	f14027f3          	csrr	a5,mhartid
    80000116:	c23e                	sw	a5,4(sp)
		pullMachineTimerCompareRegister  = ( volatile uint64_t * ) ( ullMachineTimerCompareRegisterBase + ( ulHartId * sizeof( uint64_t ) ) );
    80000118:	020047b7          	lui	a5,0x2004
    8000011c:	02079713          	slli	a4,a5,0x20
    80000120:	9301                	srli	a4,a4,0x20
    80000122:	4792                	lw	a5,4(sp)
    80000124:	2781                	sext.w	a5,a5
    80000126:	1782                	slli	a5,a5,0x20
    80000128:	9381                	srli	a5,a5,0x20
    8000012a:	078e                	slli	a5,a5,0x3
    8000012c:	97ba                	add	a5,a5,a4
    8000012e:	873e                	mv	a4,a5
    80000130:	0000b797          	auipc	a5,0xb
    80000134:	a9878793          	addi	a5,a5,-1384 # 8000abc8 <pullMachineTimerCompareRegister>
    80000138:	e398                	sd	a4,0(a5)

		do
		{
			ulCurrentTimeHigh = *pulTimeHigh;
    8000013a:	67e2                	ld	a5,24(sp)
    8000013c:	439c                	lw	a5,0(a5)
    8000013e:	c63e                	sw	a5,12(sp)
			ulCurrentTimeLow = *pulTimeLow;
    80000140:	67c2                	ld	a5,16(sp)
    80000142:	439c                	lw	a5,0(a5)
    80000144:	c43e                	sw	a5,8(sp)
		} while( ulCurrentTimeHigh != *pulTimeHigh );
    80000146:	67e2                	ld	a5,24(sp)
    80000148:	439c                	lw	a5,0(a5)
    8000014a:	0007871b          	sext.w	a4,a5
    8000014e:	47b2                	lw	a5,12(sp)
    80000150:	2781                	sext.w	a5,a5
    80000152:	fee794e3          	bne	a5,a4,8000013a <vPortSetupTimerInterrupt+0x3a>

		ullNextTime = ( uint64_t ) ulCurrentTimeHigh;
    80000156:	00c16703          	lwu	a4,12(sp)
    8000015a:	0000b797          	auipc	a5,0xb
    8000015e:	a6678793          	addi	a5,a5,-1434 # 8000abc0 <ullNextTime>
    80000162:	e398                	sd	a4,0(a5)
		ullNextTime <<= 32ULL; /* High 4-byte word is 32-bits up. */
    80000164:	0000b797          	auipc	a5,0xb
    80000168:	a5c78793          	addi	a5,a5,-1444 # 8000abc0 <ullNextTime>
    8000016c:	639c                	ld	a5,0(a5)
    8000016e:	02079713          	slli	a4,a5,0x20
    80000172:	0000b797          	auipc	a5,0xb
    80000176:	a4e78793          	addi	a5,a5,-1458 # 8000abc0 <ullNextTime>
    8000017a:	e398                	sd	a4,0(a5)
		ullNextTime |= ( uint64_t ) ulCurrentTimeLow;
    8000017c:	00816703          	lwu	a4,8(sp)
    80000180:	0000b797          	auipc	a5,0xb
    80000184:	a4078793          	addi	a5,a5,-1472 # 8000abc0 <ullNextTime>
    80000188:	639c                	ld	a5,0(a5)
    8000018a:	8f5d                	or	a4,a4,a5
    8000018c:	0000b797          	auipc	a5,0xb
    80000190:	a3478793          	addi	a5,a5,-1484 # 8000abc0 <ullNextTime>
    80000194:	e398                	sd	a4,0(a5)
		ullNextTime += ( uint64_t ) uxTimerIncrementsForOneTick;
    80000196:	0000b797          	auipc	a5,0xb
    8000019a:	a2a78793          	addi	a5,a5,-1494 # 8000abc0 <ullNextTime>
    8000019e:	6398                	ld	a4,0(a5)
    800001a0:	67e1                	lui	a5,0x18
    800001a2:	6a078793          	addi	a5,a5,1696 # 186a0 <_STACK_SIZE+0x46a0>
    800001a6:	973e                	add	a4,a4,a5
    800001a8:	0000b797          	auipc	a5,0xb
    800001ac:	a1878793          	addi	a5,a5,-1512 # 8000abc0 <ullNextTime>
    800001b0:	e398                	sd	a4,0(a5)
		*pullMachineTimerCompareRegister = ullNextTime;
    800001b2:	0000b797          	auipc	a5,0xb
    800001b6:	a1678793          	addi	a5,a5,-1514 # 8000abc8 <pullMachineTimerCompareRegister>
    800001ba:	639c                	ld	a5,0(a5)
    800001bc:	0000b717          	auipc	a4,0xb
    800001c0:	a0470713          	addi	a4,a4,-1532 # 8000abc0 <ullNextTime>
    800001c4:	6318                	ld	a4,0(a4)
    800001c6:	e398                	sd	a4,0(a5)

		/* Prepare the time to use after the next tick interrupt. */
		ullNextTime += ( uint64_t ) uxTimerIncrementsForOneTick;
    800001c8:	0000b797          	auipc	a5,0xb
    800001cc:	9f878793          	addi	a5,a5,-1544 # 8000abc0 <ullNextTime>
    800001d0:	6398                	ld	a4,0(a5)
    800001d2:	67e1                	lui	a5,0x18
    800001d4:	6a078793          	addi	a5,a5,1696 # 186a0 <_STACK_SIZE+0x46a0>
    800001d8:	973e                	add	a4,a4,a5
    800001da:	0000b797          	auipc	a5,0xb
    800001de:	9e678793          	addi	a5,a5,-1562 # 8000abc0 <ullNextTime>
    800001e2:	e398                	sd	a4,0(a5)
	}
    800001e4:	0001                	nop
    800001e6:	6105                	addi	sp,sp,32
    800001e8:	8082                	ret

00000000800001ea <xPortStartScheduler>:

#endif /* ( configMTIME_BASE_ADDRESS != 0 ) && ( configMTIME_BASE_ADDRESS != 0 ) */
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    800001ea:	1101                	addi	sp,sp,-32
    800001ec:	ec06                	sd	ra,24(sp)
extern void xPortStartFirstTask( void );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t mtvec = 0;
    800001ee:	c602                	sw	zero,12(sp)

		/* Check the least significant two bits of mtvec are 00 - indicating
		single vector mode. */
		__asm volatile( "csrr %0, mtvec" : "=r"( mtvec ) );
    800001f0:	305027f3          	csrr	a5,mtvec
    800001f4:	c63e                	sw	a5,12(sp)
		configASSERT( ( mtvec & 0x03UL ) == 0 );
    800001f6:	47b2                	lw	a5,12(sp)
    800001f8:	2781                	sext.w	a5,a5
    800001fa:	1782                	slli	a5,a5,0x20
    800001fc:	9381                	srli	a5,a5,0x20
    800001fe:	8b8d                	andi	a5,a5,3
    80000200:	c781                	beqz	a5,80000208 <xPortStartScheduler+0x1e>
    80000202:	30047073          	csrci	mstatus,8
    80000206:	a001                	j	80000206 <xPortStartScheduler+0x1c>

		/* Check alignment of the interrupt stack - which is the same as the
		stack that was being used by main() prior to the scheduler being
		started. */
		configASSERT( ( xISRStackTop & portBYTE_ALIGNMENT_MASK ) == 0 );
    80000208:	0000b797          	auipc	a5,0xb
    8000020c:	90878793          	addi	a5,a5,-1784 # 8000ab10 <xISRStackTop>
    80000210:	639c                	ld	a5,0(a5)
    80000212:	8bbd                	andi	a5,a5,15
    80000214:	c781                	beqz	a5,8000021c <xPortStartScheduler+0x32>
    80000216:	30047073          	csrci	mstatus,8
    8000021a:	a001                	j	8000021a <xPortStartScheduler+0x30>

		#ifdef configISR_STACK_SIZE_WORDS
		{
			memset( ( void * ) xISRStack, portISR_STACK_FILL_BYTE, sizeof( xISRStack ) );
    8000021c:	6789                	lui	a5,0x2
    8000021e:	f4078613          	addi	a2,a5,-192 # 1f40 <_tbss_end+0x1f40>
    80000222:	0ee00593          	li	a1,238
    80000226:	0000b517          	auipc	a0,0xb
    8000022a:	9da50513          	addi	a0,a0,-1574 # 8000ac00 <xISRStack>
    8000022e:	308080ef          	jal	ra,80008536 <memset>
	#endif /* configASSERT_DEFINED */

	/* If there is a CLINT then it is ok to use the default implementation
	in this file, otherwise vPortSetupTimerInterrupt() must be implemented to
	configure whichever clock is to be used to generate the tick interrupt. */
	vPortSetupTimerInterrupt();
    80000232:	ecfff0ef          	jal	ra,80000100 <vPortSetupTimerInterrupt>
	#if( ( configMTIME_BASE_ADDRESS != 0 ) && ( configMTIMECMP_BASE_ADDRESS != 0 ) )
	{
		/* Enable mtime and external interrupts.  1<<7 for timer interrupt, 1<<11
		for external interrupt.  _RB_ What happens here when mtime is not present as
		with pulpino? */
		__asm volatile( "csrs mie, %0" :: "r"(0x880) );
    80000236:	6785                	lui	a5,0x1
    80000238:	8807879b          	addiw	a5,a5,-1920
    8000023c:	3047a073          	csrs	mie,a5
		/* Enable external interrupts. */
		__asm volatile( "csrs mie, %0" :: "r"(0x800) );
	}
	#endif /* ( configMTIME_BASE_ADDRESS != 0 ) && ( configMTIMECMP_BASE_ADDRESS != 0 ) */

	xPortStartFirstTask();
    80000240:	2c0000ef          	jal	ra,80000500 <xPortStartFirstTask>

	/* Should not get here as after calling xPortStartFirstTask() only tasks
	should be executing. */
	return pdFAIL;
    80000244:	4781                	li	a5,0
}
    80000246:	853e                	mv	a0,a5
    80000248:	60e2                	ld	ra,24(sp)
    8000024a:	6105                	addi	sp,sp,32
    8000024c:	8082                	ret

000000008000024e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
	/* Not implemented. */
	for( ;; );
    8000024e:	a001                	j	8000024e <vPortEndScheduler>
	...

0000000080000300 <freertos_risc_v_trap_handler>:
/*-----------------------------------------------------------*/

.align 8
.func
freertos_risc_v_trap_handler:
	addi sp, sp, -portCONTEXT_SIZE
    80000300:	7151                	addi	sp,sp,-240
	store_x x1, 1 * portWORD_SIZE( sp )
    80000302:	e406                	sd	ra,8(sp)
	store_x x5, 2 * portWORD_SIZE( sp )
    80000304:	e816                	sd	t0,16(sp)
	store_x x6, 3 * portWORD_SIZE( sp )
    80000306:	ec1a                	sd	t1,24(sp)
	store_x x7, 4 * portWORD_SIZE( sp )
    80000308:	f01e                	sd	t2,32(sp)
	store_x x8, 5 * portWORD_SIZE( sp )
    8000030a:	f422                	sd	s0,40(sp)
	store_x x9, 6 * portWORD_SIZE( sp )
    8000030c:	f826                	sd	s1,48(sp)
	store_x x10, 7 * portWORD_SIZE( sp )
    8000030e:	fc2a                	sd	a0,56(sp)
	store_x x11, 8 * portWORD_SIZE( sp )
    80000310:	e0ae                	sd	a1,64(sp)
	store_x x12, 9 * portWORD_SIZE( sp )
    80000312:	e4b2                	sd	a2,72(sp)
	store_x x13, 10 * portWORD_SIZE( sp )
    80000314:	e8b6                	sd	a3,80(sp)
	store_x x14, 11 * portWORD_SIZE( sp )
    80000316:	ecba                	sd	a4,88(sp)
	store_x x15, 12 * portWORD_SIZE( sp )
    80000318:	f0be                	sd	a5,96(sp)
	store_x x16, 13 * portWORD_SIZE( sp )
    8000031a:	f4c2                	sd	a6,104(sp)
	store_x x17, 14 * portWORD_SIZE( sp )
    8000031c:	f8c6                	sd	a7,112(sp)
	store_x x18, 15 * portWORD_SIZE( sp )
    8000031e:	fcca                	sd	s2,120(sp)
	store_x x19, 16 * portWORD_SIZE( sp )
    80000320:	e14e                	sd	s3,128(sp)
	store_x x20, 17 * portWORD_SIZE( sp )
    80000322:	e552                	sd	s4,136(sp)
	store_x x21, 18 * portWORD_SIZE( sp )
    80000324:	e956                	sd	s5,144(sp)
	store_x x22, 19 * portWORD_SIZE( sp )
    80000326:	ed5a                	sd	s6,152(sp)
	store_x x23, 20 * portWORD_SIZE( sp )
    80000328:	f15e                	sd	s7,160(sp)
	store_x x24, 21 * portWORD_SIZE( sp )
    8000032a:	f562                	sd	s8,168(sp)
	store_x x25, 22 * portWORD_SIZE( sp )
    8000032c:	f966                	sd	s9,176(sp)
	store_x x26, 23 * portWORD_SIZE( sp )
    8000032e:	fd6a                	sd	s10,184(sp)
	store_x x27, 24 * portWORD_SIZE( sp )
    80000330:	e1ee                	sd	s11,192(sp)
	store_x x28, 25 * portWORD_SIZE( sp )
    80000332:	e5f2                	sd	t3,200(sp)
	store_x x29, 26 * portWORD_SIZE( sp )
    80000334:	e9f6                	sd	t4,208(sp)
	store_x x30, 27 * portWORD_SIZE( sp )
    80000336:	edfa                	sd	t5,216(sp)
	store_x x31, 28 * portWORD_SIZE( sp )
    80000338:	f1fe                	sd	t6,224(sp)

	csrr t0, mstatus					/* Required for MPIE bit. */
    8000033a:	300022f3          	csrr	t0,mstatus
	store_x t0, 29 * portWORD_SIZE( sp )
    8000033e:	f596                	sd	t0,232(sp)

	portasmSAVE_ADDITIONAL_REGISTERS	/* Defined in freertos_risc_v_chip_specific_extensions.h to save any registers unique to the RISC-V implementation. */

	load_x  t0, pxCurrentTCB			/* Load pxCurrentTCB. */
    80000340:	0000b297          	auipc	t0,0xb
    80000344:	8902b283          	ld	t0,-1904(t0) # 8000abd0 <pxCurrentTCB>
	store_x  sp, 0( t0 )				/* Write sp to first TCB member. */
    80000348:	0022b023          	sd	sp,0(t0)

	csrr a0, mcause
    8000034c:	34202573          	csrr	a0,mcause
	csrr a1, mepc
    80000350:	341025f3          	csrr	a1,mepc

0000000080000354 <test_if_asynchronous>:

test_if_asynchronous:
	srli a2, a0, __riscv_xlen - 1		/* MSB of mcause is 1 if handing an asynchronous interrupt - shift to LSB to clear other bits. */
    80000354:	03f55613          	srli	a2,a0,0x3f
	beq a2, x0, handle_synchronous		/* Branch past interrupt handing if not asynchronous. */
    80000358:	ce29                	beqz	a2,800003b2 <handle_synchronous>
	store_x a1, 0( sp )					/* Asynch so save unmodified exception return address. */
    8000035a:	e02e                	sd	a1,0(sp)

000000008000035c <handle_asynchronous>:

#if( portasmHAS_MTIME != 0 )

	test_if_mtimer:						/* If there is a CLINT then the mtimer is used to generate the tick interrupt. */

		addi t0, x0, 1
    8000035c:	00100293          	li	t0,1

		slli t0, t0, __riscv_xlen - 1   /* LSB is already set, shift into MSB.  Shift 31 on 32-bit or 63 on 64-bit cores. */
    80000360:	12fe                	slli	t0,t0,0x3f
		addi t1, t0, 7					/* 0x8000[]0007 == machine timer interrupt. */
    80000362:	00728313          	addi	t1,t0,7
		bne a0, t1, test_if_external_interrupt
    80000366:	02651c63          	bne	a0,t1,8000039e <test_if_external_interrupt>

		load_x t0, pullMachineTimerCompareRegister  /* Load address of compare register into t0. */
    8000036a:	0000b297          	auipc	t0,0xb
    8000036e:	85e2b283          	ld	t0,-1954(t0) # 8000abc8 <pullMachineTimerCompareRegister>
		load_x t1, pullNextTime  		/* Load the address of ullNextTime into t1. */
    80000372:	8201b303          	ld	t1,-2016(gp) # 8000ab28 <pullNextTime>
		#endif /* __riscv_xlen == 32 */

		#if( __riscv_xlen == 64 )

			/* Update the 64-bit mtimer compare match value. */
			ld t2, 0(t1)			 	/* Load ullNextTime into t2. */
    80000376:	00033383          	ld	t2,0(t1)
			sd t2, 0(t0)				/* Store ullNextTime into compare register. */
    8000037a:	0072b023          	sd	t2,0(t0)
			ld t0, uxTimerIncrementsForOneTick  /* Load the value of ullTimerIncrementForOneTick into t0 (could this be optimized by storing in an array next to pullNextTime?). */
    8000037e:	8101b283          	ld	t0,-2032(gp) # 8000ab18 <uxTimerIncrementsForOneTick>
			add t4, t0, t2				/* Add ullNextTime to the timer increments for one tick. */
    80000382:	00728eb3          	add	t4,t0,t2
			sd t4, 0(t1)				/* Store ullNextTime. */
    80000386:	01d33023          	sd	t4,0(t1)

		#endif /* __riscv_xlen == 64 */

		load_x sp, xISRStackTop			/* Switch to ISR stack before function call. */
    8000038a:	0000a117          	auipc	sp,0xa
    8000038e:	78613103          	ld	sp,1926(sp) # 8000ab10 <xISRStackTop>
		jal xTaskIncrementTick
    80000392:	2f0020ef          	jal	ra,80002682 <xTaskIncrementTick>
		beqz a0, processed_source		/* Don't switch context if incrementing tick didn't unblock a task. */
    80000396:	c521                	beqz	a0,800003de <processed_source>
		jal vTaskSwitchContext
    80000398:	4aa020ef          	jal	ra,80002842 <vTaskSwitchContext>
		j processed_source
    8000039c:	a089                	j	800003de <processed_source>

000000008000039e <test_if_external_interrupt>:

	test_if_external_interrupt:			/* If there is a CLINT and the mtimer interrupt is not pending then check to see if an external interrupt is pending. */
		addi t1, t1, 4					/* 0x80000007 + 4 = 0x8000000b == Machine external interrupt. */
    8000039e:	0311                	addi	t1,t1,4
		bne a0, t1, as_yet_unhandled	/* Something as yet unhandled. */
    800003a0:	02651c63          	bne	a0,t1,800003d8 <as_yet_unhandled>

#endif /* portasmHAS_MTIME */

	load_x sp, xISRStackTop				/* Switch to ISR stack before function call. */
    800003a4:	0000a117          	auipc	sp,0xa
    800003a8:	76c13103          	ld	sp,1900(sp) # 8000ab10 <xISRStackTop>
	jal portasmHANDLE_INTERRUPT			/* Jump to the interrupt handler if there is no CLINT or if there is a CLINT and it has been determined that an external interrupt is pending. */
    800003ac:	499050ef          	jal	ra,80006044 <mach_plic_handler>
	j processed_source
    800003b0:	a03d                	j	800003de <processed_source>

00000000800003b2 <handle_synchronous>:

handle_synchronous:
	addi a1, a1, 4						/* Synchronous so updated exception return address to the instruction after the instruction that generated the exeption. */
    800003b2:	0591                	addi	a1,a1,4
	store_x a1, 0( sp )					/* Save updated exception return address. */
    800003b4:	e02e                	sd	a1,0(sp)

00000000800003b6 <test_if_environment_call>:

test_if_environment_call:
	li t0, 11 							/* 11 == environment call. */
    800003b6:	42ad                	li	t0,11
	bne a0, t0, is_exception			/* Not an M environment call, so some other exception. */
    800003b8:	00551963          	bne	a0,t0,800003ca <is_exception>
	load_x sp, xISRStackTop				/* Switch to ISR stack before function call. */
    800003bc:	0000a117          	auipc	sp,0xa
    800003c0:	75413103          	ld	sp,1876(sp) # 8000ab10 <xISRStackTop>
	jal vTaskSwitchContext
    800003c4:	47e020ef          	jal	ra,80002842 <vTaskSwitchContext>
	j processed_source
    800003c8:	a819                	j	800003de <processed_source>

00000000800003ca <is_exception>:

is_exception:
	csrr t0, mcause						/* For viewing in the debugger only. */
    800003ca:	342022f3          	csrr	t0,mcause
	csrr t1, mepc						/* For viewing in the debugger only */
    800003ce:	34102373          	csrr	t1,mepc
	csrr t2, mstatus
    800003d2:	300023f3          	csrr	t2,mstatus
	j is_exception						/* No other exceptions handled yet. */
    800003d6:	bfd5                	j	800003ca <is_exception>

00000000800003d8 <as_yet_unhandled>:

as_yet_unhandled:
	csrr t0, mcause						/* For viewing in the debugger only. */
    800003d8:	342022f3          	csrr	t0,mcause
	j as_yet_unhandled
    800003dc:	bff5                	j	800003d8 <as_yet_unhandled>

00000000800003de <processed_source>:

processed_source:
	load_x  t1, pxCurrentTCB			/* Load pxCurrentTCB. */
    800003de:	0000a317          	auipc	t1,0xa
    800003e2:	7f233303          	ld	t1,2034(t1) # 8000abd0 <pxCurrentTCB>
	load_x  sp, 0( t1 )				 	/* Read sp from first TCB member. */
    800003e6:	00033103          	ld	sp,0(t1)

	/* Load mret with the address of the next instruction in the task to run next. */
	load_x t0, 0( sp )
    800003ea:	6282                	ld	t0,0(sp)
	csrw mepc, t0
    800003ec:	34129073          	csrw	mepc,t0

	portasmRESTORE_ADDITIONAL_REGISTERS	/* Defined in freertos_risc_v_chip_specific_extensions.h to restore any registers unique to the RISC-V implementation. */

	/* Load mstatus with the interrupt enable bits used by the task. */
	load_x  t0, 29 * portWORD_SIZE( sp )
    800003f0:	72ae                	ld	t0,232(sp)
	csrw mstatus, t0						/* Required for MPIE bit. */
    800003f2:	30029073          	csrw	mstatus,t0

	load_x  x1, 1 * portWORD_SIZE( sp )
    800003f6:	60a2                	ld	ra,8(sp)
	load_x  x5, 2 * portWORD_SIZE( sp )		/* t0 */
    800003f8:	62c2                	ld	t0,16(sp)
	load_x  x6, 3 * portWORD_SIZE( sp )		/* t1 */
    800003fa:	6362                	ld	t1,24(sp)
	load_x  x7, 4 * portWORD_SIZE( sp )		/* t2 */
    800003fc:	7382                	ld	t2,32(sp)
	load_x  x8, 5 * portWORD_SIZE( sp )		/* s0/fp */
    800003fe:	7422                	ld	s0,40(sp)
	load_x  x9, 6 * portWORD_SIZE( sp )		/* s1 */
    80000400:	74c2                	ld	s1,48(sp)
	load_x  x10, 7 * portWORD_SIZE( sp )	/* a0 */
    80000402:	7562                	ld	a0,56(sp)
	load_x  x11, 8 * portWORD_SIZE( sp )	/* a1 */
    80000404:	6586                	ld	a1,64(sp)
	load_x  x12, 9 * portWORD_SIZE( sp )	/* a2 */
    80000406:	6626                	ld	a2,72(sp)
	load_x  x13, 10 * portWORD_SIZE( sp )	/* a3 */
    80000408:	66c6                	ld	a3,80(sp)
	load_x  x14, 11 * portWORD_SIZE( sp )	/* a4 */
    8000040a:	6766                	ld	a4,88(sp)
	load_x  x15, 12 * portWORD_SIZE( sp )	/* a5 */
    8000040c:	7786                	ld	a5,96(sp)
	load_x  x16, 13 * portWORD_SIZE( sp )	/* a6 */
    8000040e:	7826                	ld	a6,104(sp)
	load_x  x17, 14 * portWORD_SIZE( sp )	/* a7 */
    80000410:	78c6                	ld	a7,112(sp)
	load_x  x18, 15 * portWORD_SIZE( sp )	/* s2 */
    80000412:	7966                	ld	s2,120(sp)
	load_x  x19, 16 * portWORD_SIZE( sp )	/* s3 */
    80000414:	698a                	ld	s3,128(sp)
	load_x  x20, 17 * portWORD_SIZE( sp )	/* s4 */
    80000416:	6a2a                	ld	s4,136(sp)
	load_x  x21, 18 * portWORD_SIZE( sp )	/* s5 */
    80000418:	6aca                	ld	s5,144(sp)
	load_x  x22, 19 * portWORD_SIZE( sp )	/* s6 */
    8000041a:	6b6a                	ld	s6,152(sp)
	load_x  x23, 20 * portWORD_SIZE( sp )	/* s7 */
    8000041c:	7b8a                	ld	s7,160(sp)
	load_x  x24, 21 * portWORD_SIZE( sp )	/* s8 */
    8000041e:	7c2a                	ld	s8,168(sp)
	load_x  x25, 22 * portWORD_SIZE( sp )	/* s9 */
    80000420:	7cca                	ld	s9,176(sp)
	load_x  x26, 23 * portWORD_SIZE( sp )	/* s10 */
    80000422:	7d6a                	ld	s10,184(sp)
	load_x  x27, 24 * portWORD_SIZE( sp )	/* s11 */
    80000424:	6d8e                	ld	s11,192(sp)
	load_x  x28, 25 * portWORD_SIZE( sp )	/* t3 */
    80000426:	6e2e                	ld	t3,200(sp)
	load_x  x29, 26 * portWORD_SIZE( sp )	/* t4 */
    80000428:	6ece                	ld	t4,208(sp)
	load_x  x30, 27 * portWORD_SIZE( sp )	/* t5 */
    8000042a:	6f6e                	ld	t5,216(sp)
	load_x  x31, 28 * portWORD_SIZE( sp )	/* t6 */
    8000042c:	7f8e                	ld	t6,224(sp)
	addi sp, sp, portCONTEXT_SIZE
    8000042e:	616d                	addi	sp,sp,240

	mret
    80000430:	30200073          	mret
    80000434:	00000013          	nop
    80000438:	00000013          	nop
    8000043c:	00000013          	nop
    80000440:	00000013          	nop
    80000444:	00000013          	nop
    80000448:	00000013          	nop
    8000044c:	00000013          	nop
    80000450:	00000013          	nop
    80000454:	00000013          	nop
    80000458:	00000013          	nop
    8000045c:	00000013          	nop
    80000460:	00000013          	nop
    80000464:	00000013          	nop
    80000468:	00000013          	nop
    8000046c:	00000013          	nop
    80000470:	00000013          	nop
    80000474:	00000013          	nop
    80000478:	00000013          	nop
    8000047c:	00000013          	nop
    80000480:	00000013          	nop
    80000484:	00000013          	nop
    80000488:	00000013          	nop
    8000048c:	00000013          	nop
    80000490:	00000013          	nop
    80000494:	00000013          	nop
    80000498:	00000013          	nop
    8000049c:	00000013          	nop
    800004a0:	00000013          	nop
    800004a4:	00000013          	nop
    800004a8:	00000013          	nop
    800004ac:	00000013          	nop
    800004b0:	00000013          	nop
    800004b4:	00000013          	nop
    800004b8:	00000013          	nop
    800004bc:	00000013          	nop
    800004c0:	00000013          	nop
    800004c4:	00000013          	nop
    800004c8:	00000013          	nop
    800004cc:	00000013          	nop
    800004d0:	00000013          	nop
    800004d4:	00000013          	nop
    800004d8:	00000013          	nop
    800004dc:	00000013          	nop
    800004e0:	00000013          	nop
    800004e4:	00000013          	nop
    800004e8:	00000013          	nop
    800004ec:	00000013          	nop
    800004f0:	00000013          	nop
    800004f4:	00000013          	nop
    800004f8:	00000013          	nop
    800004fc:	00000013          	nop

0000000080000500 <xPortStartFirstTask>:

#if( portasmHAS_SIFIVE_CLINT != 0 )
	/* If there is a clint then interrupts can branch directly to the FreeRTOS
	trap handler.  Otherwise the interrupt controller will need to be configured
	outside of this file. */
	la t0, freertos_risc_v_trap_handler
    80000500:	00000297          	auipc	t0,0x0
    80000504:	e0028293          	addi	t0,t0,-512 # 80000300 <freertos_risc_v_trap_handler>
	csrw mtvec, t0
    80000508:	30529073          	csrw	mtvec,t0
#endif /* portasmHAS_CLILNT */

	load_x  sp, pxCurrentTCB			/* Load pxCurrentTCB. */
    8000050c:	0000a117          	auipc	sp,0xa
    80000510:	6c413103          	ld	sp,1732(sp) # 8000abd0 <pxCurrentTCB>
	load_x  sp, 0( sp )				 	/* Read sp from first TCB member. */
    80000514:	6102                	ld	sp,0(sp)

	load_x  x1, 0( sp ) /* Note for starting the scheduler the exception return address is used as the function return address. */
    80000516:	6082                	ld	ra,0(sp)

	portasmRESTORE_ADDITIONAL_REGISTERS	/* Defined in freertos_risc_v_chip_specific_extensions.h to restore any registers unique to the RISC-V implementation. */

	load_x  x6, 3 * portWORD_SIZE( sp )		/* t1 */
    80000518:	6362                	ld	t1,24(sp)
	load_x  x7, 4 * portWORD_SIZE( sp )		/* t2 */
    8000051a:	7382                	ld	t2,32(sp)
	load_x  x8, 5 * portWORD_SIZE( sp )		/* s0/fp */
    8000051c:	7422                	ld	s0,40(sp)
	load_x  x9, 6 * portWORD_SIZE( sp )		/* s1 */
    8000051e:	74c2                	ld	s1,48(sp)
	load_x  x10, 7 * portWORD_SIZE( sp )	/* a0 */
    80000520:	7562                	ld	a0,56(sp)
	load_x  x11, 8 * portWORD_SIZE( sp )	/* a1 */
    80000522:	6586                	ld	a1,64(sp)
	load_x  x12, 9 * portWORD_SIZE( sp )	/* a2 */
    80000524:	6626                	ld	a2,72(sp)
	load_x  x13, 10 * portWORD_SIZE( sp )	/* a3 */
    80000526:	66c6                	ld	a3,80(sp)
	load_x  x14, 11 * portWORD_SIZE( sp )	/* a4 */
    80000528:	6766                	ld	a4,88(sp)
	load_x  x15, 12 * portWORD_SIZE( sp )	/* a5 */
    8000052a:	7786                	ld	a5,96(sp)
	load_x  x16, 13 * portWORD_SIZE( sp )	/* a6 */
    8000052c:	7826                	ld	a6,104(sp)
	load_x  x17, 14 * portWORD_SIZE( sp )	/* a7 */
    8000052e:	78c6                	ld	a7,112(sp)
	load_x  x18, 15 * portWORD_SIZE( sp )	/* s2 */
    80000530:	7966                	ld	s2,120(sp)
	load_x  x19, 16 * portWORD_SIZE( sp )	/* s3 */
    80000532:	698a                	ld	s3,128(sp)
	load_x  x20, 17 * portWORD_SIZE( sp )	/* s4 */
    80000534:	6a2a                	ld	s4,136(sp)
	load_x  x21, 18 * portWORD_SIZE( sp )	/* s5 */
    80000536:	6aca                	ld	s5,144(sp)
	load_x  x22, 19 * portWORD_SIZE( sp )	/* s6 */
    80000538:	6b6a                	ld	s6,152(sp)
	load_x  x23, 20 * portWORD_SIZE( sp )	/* s7 */
    8000053a:	7b8a                	ld	s7,160(sp)
	load_x  x24, 21 * portWORD_SIZE( sp )	/* s8 */
    8000053c:	7c2a                	ld	s8,168(sp)
	load_x  x25, 22 * portWORD_SIZE( sp )	/* s9 */
    8000053e:	7cca                	ld	s9,176(sp)
	load_x  x26, 23 * portWORD_SIZE( sp )	/* s10 */
    80000540:	7d6a                	ld	s10,184(sp)
	load_x  x27, 24 * portWORD_SIZE( sp )	/* s11 */
    80000542:	6d8e                	ld	s11,192(sp)
	load_x  x28, 25 * portWORD_SIZE( sp )	/* t3 */
    80000544:	6e2e                	ld	t3,200(sp)
	load_x  x29, 26 * portWORD_SIZE( sp )	/* t4 */
    80000546:	6ece                	ld	t4,208(sp)
	load_x  x30, 27 * portWORD_SIZE( sp )	/* t5 */
    80000548:	6f6e                	ld	t5,216(sp)
	load_x  x31, 28 * portWORD_SIZE( sp )	/* t6 */
    8000054a:	7f8e                	ld	t6,224(sp)

	load_x  x5, 29 * portWORD_SIZE( sp )	/* Initial mstatus into x5 (t0) */
    8000054c:	72ae                	ld	t0,232(sp)
	addi x5, x5, 0x08						/* Set MIE bit so the first task starts with interrupts enabled - required as returns with ret not eret. */
    8000054e:	02a1                	addi	t0,t0,8
	csrrw  x0, mstatus, x5					/* Interrupts enabled from here! */
    80000550:	30029073          	csrw	mstatus,t0
	load_x  x5, 2 * portWORD_SIZE( sp )		/* Initial x5 (t0) value. */
    80000554:	62c2                	ld	t0,16(sp)

	addi	sp, sp, portCONTEXT_SIZE
    80000556:	616d                	addi	sp,sp,240
	ret
    80000558:	8082                	ret
    8000055a:	00000013          	nop
    8000055e:	00000013          	nop
    80000562:	00000013          	nop
    80000566:	00000013          	nop
    8000056a:	00000013          	nop
    8000056e:	00000013          	nop
    80000572:	00000013          	nop
    80000576:	00000013          	nop
    8000057a:	00000013          	nop
    8000057e:	00000013          	nop
    80000582:	00000013          	nop
    80000586:	00000013          	nop
    8000058a:	00000013          	nop
    8000058e:	00000013          	nop
    80000592:	00000013          	nop
    80000596:	00000013          	nop
    8000059a:	00000013          	nop
    8000059e:	00000013          	nop
    800005a2:	00000013          	nop
    800005a6:	00000013          	nop
    800005aa:	00000013          	nop
    800005ae:	00000013          	nop
    800005b2:	00000013          	nop
    800005b6:	00000013          	nop
    800005ba:	00000013          	nop
    800005be:	00000013          	nop
    800005c2:	00000013          	nop
    800005c6:	00000013          	nop
    800005ca:	00000013          	nop
    800005ce:	00000013          	nop
    800005d2:	00000013          	nop
    800005d6:	00000013          	nop
    800005da:	00000013          	nop
    800005de:	00000013          	nop
    800005e2:	00000013          	nop
    800005e6:	00000013          	nop
    800005ea:	00000013          	nop
    800005ee:	00000013          	nop
    800005f2:	00000013          	nop
    800005f6:	00000013          	nop
    800005fa:	00000013          	nop
    800005fe:	0001                	nop

0000000080000600 <pxPortInitialiseStack>:
 */
.align 8
.func
pxPortInitialiseStack:

	csrr t0, mstatus					/* Obtain current mstatus value. */
    80000600:	300022f3          	csrr	t0,mstatus
	andi t0, t0, ~0x8					/* Ensure interrupts are disabled when the stack is restored within an ISR.  Required when a task is created after the schedulre has been started, otherwise interrupts would be disabled anyway. */
    80000604:	ff72f293          	andi	t0,t0,-9
	addi t1, x0, 0x188					/* Generate the value 0x1880, which are the MPIE and MPP bits to set in mstatus. */
    80000608:	18800313          	li	t1,392
	slli t1, t1, 4
    8000060c:	0312                	slli	t1,t1,0x4
	or t0, t0, t1						/* Set MPIE and MPP bits in mstatus value. */
    8000060e:	0062e2b3          	or	t0,t0,t1

	addi a0, a0, -portWORD_SIZE
    80000612:	1561                	addi	a0,a0,-8
	store_x t0, 0(a0)					/* mstatus onto the stack. */
    80000614:	00553023          	sd	t0,0(a0)
	addi a0, a0, -(22 * portWORD_SIZE)	/* Space for registers x11-x31. */
    80000618:	f5050513          	addi	a0,a0,-176
	store_x a2, 0(a0)					/* Task parameters (pvParameters parameter) goes into register X10/a0 on the stack. */
    8000061c:	e110                	sd	a2,0(a0)
	addi a0, a0, -(6 * portWORD_SIZE)	/* Space for registers x5-x9. */
    8000061e:	fd050513          	addi	a0,a0,-48
	store_x x0, 0(a0)					/* Return address onto the stack, could be portTASK_RETURN_ADDRESS */
    80000622:	00053023          	sd	zero,0(a0)
	addi t0, x0, portasmADDITIONAL_CONTEXT_SIZE /* The number of chip specific additional registers. */
    80000626:	00000293          	li	t0,0

000000008000062a <chip_specific_stack_frame>:
chip_specific_stack_frame:				/* First add any chip specific registers to the stack frame being created. */
	beq t0, x0, 1f						/* No more chip specific registers to save. */
    8000062a:	00028763          	beqz	t0,80000638 <chip_specific_stack_frame+0xe>
	addi a0, a0, -portWORD_SIZE			/* Make space for chip specific register. */
    8000062e:	1561                	addi	a0,a0,-8
	store_x x0, 0(a0)					/* Give the chip specific register an initial value of zero. */
    80000630:	00053023          	sd	zero,0(a0)
	addi t0, t0, -1						/* Decrement the count of chip specific registers remaining. */
    80000634:	12fd                	addi	t0,t0,-1
	j chip_specific_stack_frame			/* Until no more chip specific registers. */
    80000636:	bfd5                	j	8000062a <chip_specific_stack_frame>
1:
	addi a0, a0, -portWORD_SIZE
    80000638:	1561                	addi	a0,a0,-8
	store_x a1, 0(a0)					/* mret value (pxCode parameter) onto the stack. */
    8000063a:	e10c                	sd	a1,0(a0)
	ret
    8000063c:	8082                	ret
	...

0000000080000670 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    80000670:	1141                	addi	sp,sp,-16
    80000672:	e42a                	sd	a0,8(sp)
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    80000674:	67a2                	ld	a5,8(sp)
    80000676:	01078713          	addi	a4,a5,16 # 1010 <_tbss_end+0x1010>
    8000067a:	67a2                	ld	a5,8(sp)
    8000067c:	e798                	sd	a4,8(a5)

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    8000067e:	67a2                	ld	a5,8(sp)
    80000680:	577d                	li	a4,-1
    80000682:	eb98                	sd	a4,16(a5)

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    80000684:	67a2                	ld	a5,8(sp)
    80000686:	01078713          	addi	a4,a5,16
    8000068a:	67a2                	ld	a5,8(sp)
    8000068c:	ef98                	sd	a4,24(a5)
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    8000068e:	67a2                	ld	a5,8(sp)
    80000690:	01078713          	addi	a4,a5,16
    80000694:	67a2                	ld	a5,8(sp)
    80000696:	f398                	sd	a4,32(a5)

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    80000698:	67a2                	ld	a5,8(sp)
    8000069a:	0007b023          	sd	zero,0(a5)

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    8000069e:	0001                	nop
    800006a0:	0141                	addi	sp,sp,16
    800006a2:	8082                	ret

00000000800006a4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    800006a4:	1141                	addi	sp,sp,-16
    800006a6:	e42a                	sd	a0,8(sp)
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    800006a8:	67a2                	ld	a5,8(sp)
    800006aa:	0207b023          	sd	zero,32(a5)

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    800006ae:	0001                	nop
    800006b0:	0141                	addi	sp,sp,16
    800006b2:	8082                	ret

00000000800006b4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    800006b4:	1101                	addi	sp,sp,-32
    800006b6:	e42a                	sd	a0,8(sp)
    800006b8:	e02e                	sd	a1,0(sp)
    ListItem_t * const pxIndex = pxList->pxIndex;
    800006ba:	67a2                	ld	a5,8(sp)
    800006bc:	679c                	ld	a5,8(a5)
    800006be:	ec3e                	sd	a5,24(sp)
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    800006c0:	6782                	ld	a5,0(sp)
    800006c2:	6762                	ld	a4,24(sp)
    800006c4:	e798                	sd	a4,8(a5)
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    800006c6:	67e2                	ld	a5,24(sp)
    800006c8:	6b98                	ld	a4,16(a5)
    800006ca:	6782                	ld	a5,0(sp)
    800006cc:	eb98                	sd	a4,16(a5)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    800006ce:	67e2                	ld	a5,24(sp)
    800006d0:	6b9c                	ld	a5,16(a5)
    800006d2:	6702                	ld	a4,0(sp)
    800006d4:	e798                	sd	a4,8(a5)
    pxIndex->pxPrevious = pxNewListItem;
    800006d6:	67e2                	ld	a5,24(sp)
    800006d8:	6702                	ld	a4,0(sp)
    800006da:	eb98                	sd	a4,16(a5)

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    800006dc:	6782                	ld	a5,0(sp)
    800006de:	6722                	ld	a4,8(sp)
    800006e0:	f398                	sd	a4,32(a5)

    ( pxList->uxNumberOfItems )++;
    800006e2:	67a2                	ld	a5,8(sp)
    800006e4:	639c                	ld	a5,0(a5)
    800006e6:	00178713          	addi	a4,a5,1
    800006ea:	67a2                	ld	a5,8(sp)
    800006ec:	e398                	sd	a4,0(a5)
}
    800006ee:	0001                	nop
    800006f0:	6105                	addi	sp,sp,32
    800006f2:	8082                	ret

00000000800006f4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    800006f4:	1101                	addi	sp,sp,-32
    800006f6:	e42a                	sd	a0,8(sp)
    800006f8:	e02e                	sd	a1,0(sp)
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    800006fa:	6782                	ld	a5,0(sp)
    800006fc:	639c                	ld	a5,0(a5)
    800006fe:	e83e                	sd	a5,16(sp)
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    80000700:	6742                	ld	a4,16(sp)
    80000702:	57fd                	li	a5,-1
    80000704:	00f71663          	bne	a4,a5,80000710 <vListInsert+0x1c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    80000708:	67a2                	ld	a5,8(sp)
    8000070a:	739c                	ld	a5,32(a5)
    8000070c:	ec3e                	sd	a5,24(sp)
    8000070e:	a831                	j	8000072a <vListInsert+0x36>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    80000710:	67a2                	ld	a5,8(sp)
    80000712:	07c1                	addi	a5,a5,16
    80000714:	ec3e                	sd	a5,24(sp)
    80000716:	a021                	j	8000071e <vListInsert+0x2a>
    80000718:	67e2                	ld	a5,24(sp)
    8000071a:	679c                	ld	a5,8(a5)
    8000071c:	ec3e                	sd	a5,24(sp)
    8000071e:	67e2                	ld	a5,24(sp)
    80000720:	679c                	ld	a5,8(a5)
    80000722:	639c                	ld	a5,0(a5)
    80000724:	6742                	ld	a4,16(sp)
    80000726:	fef779e3          	bgeu	a4,a5,80000718 <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    8000072a:	67e2                	ld	a5,24(sp)
    8000072c:	6798                	ld	a4,8(a5)
    8000072e:	6782                	ld	a5,0(sp)
    80000730:	e798                	sd	a4,8(a5)
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    80000732:	6782                	ld	a5,0(sp)
    80000734:	679c                	ld	a5,8(a5)
    80000736:	6702                	ld	a4,0(sp)
    80000738:	eb98                	sd	a4,16(a5)
    pxNewListItem->pxPrevious = pxIterator;
    8000073a:	6782                	ld	a5,0(sp)
    8000073c:	6762                	ld	a4,24(sp)
    8000073e:	eb98                	sd	a4,16(a5)
    pxIterator->pxNext = pxNewListItem;
    80000740:	67e2                	ld	a5,24(sp)
    80000742:	6702                	ld	a4,0(sp)
    80000744:	e798                	sd	a4,8(a5)

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    80000746:	6782                	ld	a5,0(sp)
    80000748:	6722                	ld	a4,8(sp)
    8000074a:	f398                	sd	a4,32(a5)

    ( pxList->uxNumberOfItems )++;
    8000074c:	67a2                	ld	a5,8(sp)
    8000074e:	639c                	ld	a5,0(a5)
    80000750:	00178713          	addi	a4,a5,1
    80000754:	67a2                	ld	a5,8(sp)
    80000756:	e398                	sd	a4,0(a5)
}
    80000758:	0001                	nop
    8000075a:	6105                	addi	sp,sp,32
    8000075c:	8082                	ret

000000008000075e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    8000075e:	1101                	addi	sp,sp,-32
    80000760:	e42a                	sd	a0,8(sp)
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    80000762:	67a2                	ld	a5,8(sp)
    80000764:	739c                	ld	a5,32(a5)
    80000766:	ec3e                	sd	a5,24(sp)

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    80000768:	67a2                	ld	a5,8(sp)
    8000076a:	679c                	ld	a5,8(a5)
    8000076c:	6722                	ld	a4,8(sp)
    8000076e:	6b18                	ld	a4,16(a4)
    80000770:	eb98                	sd	a4,16(a5)
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    80000772:	67a2                	ld	a5,8(sp)
    80000774:	6b9c                	ld	a5,16(a5)
    80000776:	6722                	ld	a4,8(sp)
    80000778:	6718                	ld	a4,8(a4)
    8000077a:	e798                	sd	a4,8(a5)

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    8000077c:	67e2                	ld	a5,24(sp)
    8000077e:	679c                	ld	a5,8(a5)
    80000780:	6722                	ld	a4,8(sp)
    80000782:	00f71663          	bne	a4,a5,8000078e <uxListRemove+0x30>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    80000786:	67a2                	ld	a5,8(sp)
    80000788:	6b98                	ld	a4,16(a5)
    8000078a:	67e2                	ld	a5,24(sp)
    8000078c:	e798                	sd	a4,8(a5)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    8000078e:	67a2                	ld	a5,8(sp)
    80000790:	0207b023          	sd	zero,32(a5)
    ( pxList->uxNumberOfItems )--;
    80000794:	67e2                	ld	a5,24(sp)
    80000796:	639c                	ld	a5,0(a5)
    80000798:	fff78713          	addi	a4,a5,-1
    8000079c:	67e2                	ld	a5,24(sp)
    8000079e:	e398                	sd	a4,0(a5)

    return pxList->uxNumberOfItems;
    800007a0:	67e2                	ld	a5,24(sp)
    800007a2:	639c                	ld	a5,0(a5)
}
    800007a4:	853e                	mv	a0,a5
    800007a6:	6105                	addi	sp,sp,32
    800007a8:	8082                	ret

00000000800007aa <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    800007aa:	7179                	addi	sp,sp,-48
    800007ac:	f406                	sd	ra,40(sp)
    800007ae:	e42a                	sd	a0,8(sp)
    800007b0:	e02e                	sd	a1,0(sp)
    Queue_t * const pxQueue = xQueue;
    800007b2:	67a2                	ld	a5,8(sp)
    800007b4:	ec3e                	sd	a5,24(sp)

    configASSERT( pxQueue );
    800007b6:	67e2                	ld	a5,24(sp)
    800007b8:	e781                	bnez	a5,800007c0 <xQueueGenericReset+0x16>
    800007ba:	30047073          	csrci	mstatus,8
    800007be:	a001                	j	800007be <xQueueGenericReset+0x14>

    taskENTER_CRITICAL();
    800007c0:	40d020ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    800007c4:	67e2                	ld	a5,24(sp)
    800007c6:	6398                	ld	a4,0(a5)
    800007c8:	67e2                	ld	a5,24(sp)
    800007ca:	7fb4                	ld	a3,120(a5)
    800007cc:	67e2                	ld	a5,24(sp)
    800007ce:	63dc                	ld	a5,128(a5)
    800007d0:	02f687b3          	mul	a5,a3,a5
    800007d4:	973e                	add	a4,a4,a5
    800007d6:	67e2                	ld	a5,24(sp)
    800007d8:	eb98                	sd	a4,16(a5)
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    800007da:	67e2                	ld	a5,24(sp)
    800007dc:	0607b823          	sd	zero,112(a5)
        pxQueue->pcWriteTo = pxQueue->pcHead;
    800007e0:	67e2                	ld	a5,24(sp)
    800007e2:	6398                	ld	a4,0(a5)
    800007e4:	67e2                	ld	a5,24(sp)
    800007e6:	e798                	sd	a4,8(a5)
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    800007e8:	67e2                	ld	a5,24(sp)
    800007ea:	6398                	ld	a4,0(a5)
    800007ec:	67e2                	ld	a5,24(sp)
    800007ee:	7fbc                	ld	a5,120(a5)
    800007f0:	fff78693          	addi	a3,a5,-1
    800007f4:	67e2                	ld	a5,24(sp)
    800007f6:	63dc                	ld	a5,128(a5)
    800007f8:	02f687b3          	mul	a5,a3,a5
    800007fc:	973e                	add	a4,a4,a5
    800007fe:	67e2                	ld	a5,24(sp)
    80000800:	ef98                	sd	a4,24(a5)
        pxQueue->cRxLock = queueUNLOCKED;
    80000802:	67e2                	ld	a5,24(sp)
    80000804:	577d                	li	a4,-1
    80000806:	08e78423          	sb	a4,136(a5)
        pxQueue->cTxLock = queueUNLOCKED;
    8000080a:	67e2                	ld	a5,24(sp)
    8000080c:	577d                	li	a4,-1
    8000080e:	08e784a3          	sb	a4,137(a5)

        if( xNewQueue == pdFALSE )
    80000812:	6782                	ld	a5,0(sp)
    80000814:	ef99                	bnez	a5,80000832 <xQueueGenericReset+0x88>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    80000816:	67e2                	ld	a5,24(sp)
    80000818:	739c                	ld	a5,32(a5)
    8000081a:	cb85                	beqz	a5,8000084a <xQueueGenericReset+0xa0>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    8000081c:	67e2                	ld	a5,24(sp)
    8000081e:	02078793          	addi	a5,a5,32
    80000822:	853e                	mv	a0,a5
    80000824:	224020ef          	jal	ra,80002a48 <xTaskRemoveFromEventList>
    80000828:	87aa                	mv	a5,a0
    8000082a:	c385                	beqz	a5,8000084a <xQueueGenericReset+0xa0>
                {
                    queueYIELD_IF_USING_PREEMPTION();
    8000082c:	00000073          	ecall
    80000830:	a829                	j	8000084a <xQueueGenericReset+0xa0>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    80000832:	67e2                	ld	a5,24(sp)
    80000834:	02078793          	addi	a5,a5,32
    80000838:	853e                	mv	a0,a5
    8000083a:	e37ff0ef          	jal	ra,80000670 <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    8000083e:	67e2                	ld	a5,24(sp)
    80000840:	04878793          	addi	a5,a5,72
    80000844:	853e                	mv	a0,a5
    80000846:	e2bff0ef          	jal	ra,80000670 <vListInitialise>
        }
    }
    taskEXIT_CRITICAL();
    8000084a:	3b1020ef          	jal	ra,800033fa <vTaskExitCritical>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
    8000084e:	4785                	li	a5,1
}
    80000850:	853e                	mv	a0,a5
    80000852:	70a2                	ld	ra,40(sp)
    80000854:	6145                	addi	sp,sp,48
    80000856:	8082                	ret

0000000080000858 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    80000858:	715d                	addi	sp,sp,-80
    8000085a:	e486                	sd	ra,72(sp)
    8000085c:	ec2a                	sd	a0,24(sp)
    8000085e:	e82e                	sd	a1,16(sp)
    80000860:	87b2                	mv	a5,a2
    80000862:	00f107a3          	sb	a5,15(sp)
        Queue_t * pxNewQueue;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    80000866:	67e2                	ld	a5,24(sp)
    80000868:	e781                	bnez	a5,80000870 <xQueueGenericCreate+0x18>
    8000086a:	30047073          	csrci	mstatus,8
    8000086e:	a001                	j	8000086e <xQueueGenericCreate+0x16>

        /* Allocate enough space to hold the maximum number of items that
         * can be in the queue at any time.  It is valid for uxItemSize to be
         * zero in the case the queue is used as a semaphore. */
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    80000870:	6762                	ld	a4,24(sp)
    80000872:	67c2                	ld	a5,16(sp)
    80000874:	02f707b3          	mul	a5,a4,a5
    80000878:	fc3e                	sd	a5,56(sp)

        /* Check for multiplication overflow. */
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
    8000087a:	67c2                	ld	a5,16(sp)
    8000087c:	cb81                	beqz	a5,8000088c <xQueueGenericCreate+0x34>
    8000087e:	7762                	ld	a4,56(sp)
    80000880:	67c2                	ld	a5,16(sp)
    80000882:	02f757b3          	divu	a5,a4,a5
    80000886:	6762                	ld	a4,24(sp)
    80000888:	00f71463          	bne	a4,a5,80000890 <xQueueGenericCreate+0x38>
    8000088c:	4785                	li	a5,1
    8000088e:	a011                	j	80000892 <xQueueGenericCreate+0x3a>
    80000890:	4781                	li	a5,0
    80000892:	e781                	bnez	a5,8000089a <xQueueGenericCreate+0x42>
    80000894:	30047073          	csrci	mstatus,8
    80000898:	a001                	j	80000898 <xQueueGenericCreate+0x40>
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    8000089a:	77e2                	ld	a5,56(sp)
    8000089c:	0a078793          	addi	a5,a5,160
    800008a0:	853e                	mv	a0,a5
    800008a2:	1be040ef          	jal	ra,80004a60 <pvPortMalloc>
    800008a6:	f82a                	sd	a0,48(sp)

        if( pxNewQueue != NULL )
    800008a8:	77c2                	ld	a5,48(sp)
    800008aa:	c385                	beqz	a5,800008ca <xQueueGenericCreate+0x72>
        {
            /* Jump past the queue structure to find the location of the queue
             * storage area. */
            pucQueueStorage = ( uint8_t * ) pxNewQueue;
    800008ac:	77c2                	ld	a5,48(sp)
    800008ae:	f43e                	sd	a5,40(sp)
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    800008b0:	77a2                	ld	a5,40(sp)
    800008b2:	0a078793          	addi	a5,a5,160
    800008b6:	f43e                	sd	a5,40(sp)
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
            #endif /* configSUPPORT_STATIC_ALLOCATION */

            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    800008b8:	00f14783          	lbu	a5,15(sp)
    800008bc:	7742                	ld	a4,48(sp)
    800008be:	86be                	mv	a3,a5
    800008c0:	7622                	ld	a2,40(sp)
    800008c2:	65c2                	ld	a1,16(sp)
    800008c4:	6562                	ld	a0,24(sp)
    800008c6:	00e000ef          	jal	ra,800008d4 <prvInitialiseNewQueue>
        {
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    800008ca:	77c2                	ld	a5,48(sp)
    }
    800008cc:	853e                	mv	a0,a5
    800008ce:	60a6                	ld	ra,72(sp)
    800008d0:	6161                	addi	sp,sp,80
    800008d2:	8082                	ret

00000000800008d4 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    800008d4:	7139                	addi	sp,sp,-64
    800008d6:	fc06                	sd	ra,56(sp)
    800008d8:	f42a                	sd	a0,40(sp)
    800008da:	f02e                	sd	a1,32(sp)
    800008dc:	ec32                	sd	a2,24(sp)
    800008de:	87b6                	mv	a5,a3
    800008e0:	e43a                	sd	a4,8(sp)
    800008e2:	00f10ba3          	sb	a5,23(sp)
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    800008e6:	7782                	ld	a5,32(sp)
    800008e8:	e789                	bnez	a5,800008f2 <prvInitialiseNewQueue+0x1e>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    800008ea:	67a2                	ld	a5,8(sp)
    800008ec:	6722                	ld	a4,8(sp)
    800008ee:	e398                	sd	a4,0(a5)
    800008f0:	a021                	j	800008f8 <prvInitialiseNewQueue+0x24>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    800008f2:	67a2                	ld	a5,8(sp)
    800008f4:	6762                	ld	a4,24(sp)
    800008f6:	e398                	sd	a4,0(a5)
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    800008f8:	67a2                	ld	a5,8(sp)
    800008fa:	7722                	ld	a4,40(sp)
    800008fc:	ffb8                	sd	a4,120(a5)
    pxNewQueue->uxItemSize = uxItemSize;
    800008fe:	67a2                	ld	a5,8(sp)
    80000900:	7702                	ld	a4,32(sp)
    80000902:	e3d8                	sd	a4,128(a5)
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    80000904:	4585                	li	a1,1
    80000906:	6522                	ld	a0,8(sp)
    80000908:	ea3ff0ef          	jal	ra,800007aa <xQueueGenericReset>

    #if ( configUSE_TRACE_FACILITY == 1 )
        {
            pxNewQueue->ucQueueType = ucQueueType;
    8000090c:	67a2                	ld	a5,8(sp)
    8000090e:	01714703          	lbu	a4,23(sp)
    80000912:	08e78c23          	sb	a4,152(a5)
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    80000916:	0001                	nop
    80000918:	70e2                	ld	ra,56(sp)
    8000091a:	6121                	addi	sp,sp,64
    8000091c:	8082                	ret

000000008000091e <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
    8000091e:	1101                	addi	sp,sp,-32
    80000920:	ec06                	sd	ra,24(sp)
    80000922:	e42a                	sd	a0,8(sp)
        if( pxNewQueue != NULL )
    80000924:	67a2                	ld	a5,8(sp)
    80000926:	c385                	beqz	a5,80000946 <prvInitialiseMutex+0x28>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    80000928:	67a2                	ld	a5,8(sp)
    8000092a:	0007b823          	sd	zero,16(a5)
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    8000092e:	67a2                	ld	a5,8(sp)
    80000930:	0007b023          	sd	zero,0(a5)

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    80000934:	67a2                	ld	a5,8(sp)
    80000936:	0007bc23          	sd	zero,24(a5)

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    8000093a:	4681                	li	a3,0
    8000093c:	4601                	li	a2,0
    8000093e:	4581                	li	a1,0
    80000940:	6522                	ld	a0,8(sp)
    80000942:	130000ef          	jal	ra,80000a72 <xQueueGenericSend>
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
    80000946:	0001                	nop
    80000948:	60e2                	ld	ra,24(sp)
    8000094a:	6105                	addi	sp,sp,32
    8000094c:	8082                	ret

000000008000094e <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
    8000094e:	7139                	addi	sp,sp,-64
    80000950:	fc06                	sd	ra,56(sp)
    80000952:	87aa                	mv	a5,a0
    80000954:	00f107a3          	sb	a5,15(sp)
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    80000958:	4785                	li	a5,1
    8000095a:	f43e                	sd	a5,40(sp)
    8000095c:	f002                	sd	zero,32(sp)

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    8000095e:	00f14783          	lbu	a5,15(sp)
    80000962:	863e                	mv	a2,a5
    80000964:	7582                	ld	a1,32(sp)
    80000966:	7522                	ld	a0,40(sp)
    80000968:	ef1ff0ef          	jal	ra,80000858 <xQueueGenericCreate>
    8000096c:	ec2a                	sd	a0,24(sp)
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    8000096e:	6562                	ld	a0,24(sp)
    80000970:	fafff0ef          	jal	ra,8000091e <prvInitialiseMutex>

        return xNewQueue;
    80000974:	67e2                	ld	a5,24(sp)
    }
    80000976:	853e                	mv	a0,a5
    80000978:	70e2                	ld	ra,56(sp)
    8000097a:	6121                	addi	sp,sp,64
    8000097c:	8082                	ret

000000008000097e <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
    {
    8000097e:	7179                	addi	sp,sp,-48
    80000980:	f406                	sd	ra,40(sp)
    80000982:	f022                	sd	s0,32(sp)
    80000984:	e42a                	sd	a0,8(sp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    80000986:	67a2                	ld	a5,8(sp)
    80000988:	e83e                	sd	a5,16(sp)

        configASSERT( pxMutex );
    8000098a:	67c2                	ld	a5,16(sp)
    8000098c:	e781                	bnez	a5,80000994 <xQueueGiveMutexRecursive+0x16>
    8000098e:	30047073          	csrci	mstatus,8
    80000992:	a001                	j	80000992 <xQueueGiveMutexRecursive+0x14>
         * change outside of this task.  If this task does not hold the mutex then
         * pxMutexHolder can never coincidentally equal the tasks handle, and as
         * this is the only condition we are interested in it does not matter if
         * pxMutexHolder is accessed simultaneously by another task.  Therefore no
         * mutual exclusion is required to test the pxMutexHolder variable. */
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    80000994:	67c2                	ld	a5,16(sp)
    80000996:	6b80                	ld	s0,16(a5)
    80000998:	6b2020ef          	jal	ra,8000304a <xTaskGetCurrentTaskHandle>
    8000099c:	87aa                	mv	a5,a0
    8000099e:	02f41463          	bne	s0,a5,800009c6 <xQueueGiveMutexRecursive+0x48>
            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
             * the task handle, therefore no underflow check is required.  Also,
             * uxRecursiveCallCount is only modified by the mutex holder, and as
             * there can only be one, no mutual exclusion is required to modify the
             * uxRecursiveCallCount member. */
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
    800009a2:	67c2                	ld	a5,16(sp)
    800009a4:	6f9c                	ld	a5,24(a5)
    800009a6:	fff78713          	addi	a4,a5,-1
    800009aa:	67c2                	ld	a5,16(sp)
    800009ac:	ef98                	sd	a4,24(a5)

            /* Has the recursive call count unwound to 0? */
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
    800009ae:	67c2                	ld	a5,16(sp)
    800009b0:	6f9c                	ld	a5,24(a5)
    800009b2:	e799                	bnez	a5,800009c0 <xQueueGiveMutexRecursive+0x42>
            {
                /* Return the mutex.  This will automatically unblock any other
                 * task that might be waiting to access the mutex. */
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    800009b4:	4681                	li	a3,0
    800009b6:	4601                	li	a2,0
    800009b8:	4581                	li	a1,0
    800009ba:	6542                	ld	a0,16(sp)
    800009bc:	0b6000ef          	jal	ra,80000a72 <xQueueGenericSend>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    800009c0:	4785                	li	a5,1
    800009c2:	ec3e                	sd	a5,24(sp)
    800009c4:	a011                	j	800009c8 <xQueueGiveMutexRecursive+0x4a>
        }
        else
        {
            /* The mutex cannot be given because the calling task is not the
             * holder. */
            xReturn = pdFAIL;
    800009c6:	ec02                	sd	zero,24(sp)

            traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
        }

        return xReturn;
    800009c8:	67e2                	ld	a5,24(sp)
    }
    800009ca:	853e                	mv	a0,a5
    800009cc:	70a2                	ld	ra,40(sp)
    800009ce:	7402                	ld	s0,32(sp)
    800009d0:	6145                	addi	sp,sp,48
    800009d2:	8082                	ret

00000000800009d4 <xQueueTakeMutexRecursive>:

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
                                         TickType_t xTicksToWait )
    {
    800009d4:	7179                	addi	sp,sp,-48
    800009d6:	f406                	sd	ra,40(sp)
    800009d8:	f022                	sd	s0,32(sp)
    800009da:	e42a                	sd	a0,8(sp)
    800009dc:	e02e                	sd	a1,0(sp)
        BaseType_t xReturn;
        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    800009de:	67a2                	ld	a5,8(sp)
    800009e0:	e83e                	sd	a5,16(sp)

        configASSERT( pxMutex );
    800009e2:	67c2                	ld	a5,16(sp)
    800009e4:	e781                	bnez	a5,800009ec <xQueueTakeMutexRecursive+0x18>
    800009e6:	30047073          	csrci	mstatus,8
    800009ea:	a001                	j	800009ea <xQueueTakeMutexRecursive+0x16>
        /* Comments regarding mutual exclusion as per those within
         * xQueueGiveMutexRecursive(). */

        traceTAKE_MUTEX_RECURSIVE( pxMutex );

        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
    800009ec:	67c2                	ld	a5,16(sp)
    800009ee:	6b80                	ld	s0,16(a5)
    800009f0:	65a020ef          	jal	ra,8000304a <xTaskGetCurrentTaskHandle>
    800009f4:	87aa                	mv	a5,a0
    800009f6:	00f41b63          	bne	s0,a5,80000a0c <xQueueTakeMutexRecursive+0x38>
        {
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    800009fa:	67c2                	ld	a5,16(sp)
    800009fc:	6f9c                	ld	a5,24(a5)
    800009fe:	00178713          	addi	a4,a5,1
    80000a02:	67c2                	ld	a5,16(sp)
    80000a04:	ef98                	sd	a4,24(a5)
            xReturn = pdPASS;
    80000a06:	4785                	li	a5,1
    80000a08:	ec3e                	sd	a5,24(sp)
    80000a0a:	a831                	j	80000a26 <xQueueTakeMutexRecursive+0x52>
        }
        else
        {
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
    80000a0c:	6582                	ld	a1,0(sp)
    80000a0e:	6542                	ld	a0,16(sp)
    80000a10:	50a000ef          	jal	ra,80000f1a <xQueueSemaphoreTake>
    80000a14:	ec2a                	sd	a0,24(sp)

            /* pdPASS will only be returned if the mutex was successfully
             * obtained.  The calling task may have entered the Blocked state
             * before reaching here. */
            if( xReturn != pdFAIL )
    80000a16:	67e2                	ld	a5,24(sp)
    80000a18:	c799                	beqz	a5,80000a26 <xQueueTakeMutexRecursive+0x52>
            {
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
    80000a1a:	67c2                	ld	a5,16(sp)
    80000a1c:	6f9c                	ld	a5,24(a5)
    80000a1e:	00178713          	addi	a4,a5,1
    80000a22:	67c2                	ld	a5,16(sp)
    80000a24:	ef98                	sd	a4,24(a5)
            {
                traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
            }
        }

        return xReturn;
    80000a26:	67e2                	ld	a5,24(sp)
    }
    80000a28:	853e                	mv	a0,a5
    80000a2a:	70a2                	ld	ra,40(sp)
    80000a2c:	7402                	ld	s0,32(sp)
    80000a2e:	6145                	addi	sp,sp,48
    80000a30:	8082                	ret

0000000080000a32 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
    80000a32:	7179                	addi	sp,sp,-48
    80000a34:	f406                	sd	ra,40(sp)
    80000a36:	e42a                	sd	a0,8(sp)
    80000a38:	e02e                	sd	a1,0(sp)
        QueueHandle_t xHandle;

        configASSERT( uxMaxCount != 0 );
    80000a3a:	67a2                	ld	a5,8(sp)
    80000a3c:	e781                	bnez	a5,80000a44 <xQueueCreateCountingSemaphore+0x12>
    80000a3e:	30047073          	csrci	mstatus,8
    80000a42:	a001                	j	80000a42 <xQueueCreateCountingSemaphore+0x10>
        configASSERT( uxInitialCount <= uxMaxCount );
    80000a44:	6702                	ld	a4,0(sp)
    80000a46:	67a2                	ld	a5,8(sp)
    80000a48:	00e7f563          	bgeu	a5,a4,80000a52 <xQueueCreateCountingSemaphore+0x20>
    80000a4c:	30047073          	csrci	mstatus,8
    80000a50:	a001                	j	80000a50 <xQueueCreateCountingSemaphore+0x1e>

        xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    80000a52:	4609                	li	a2,2
    80000a54:	4581                	li	a1,0
    80000a56:	6522                	ld	a0,8(sp)
    80000a58:	e01ff0ef          	jal	ra,80000858 <xQueueGenericCreate>
    80000a5c:	ec2a                	sd	a0,24(sp)

        if( xHandle != NULL )
    80000a5e:	67e2                	ld	a5,24(sp)
    80000a60:	c781                	beqz	a5,80000a68 <xQueueCreateCountingSemaphore+0x36>
        {
            ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    80000a62:	67e2                	ld	a5,24(sp)
    80000a64:	6702                	ld	a4,0(sp)
    80000a66:	fbb8                	sd	a4,112(a5)
        else
        {
            traceCREATE_COUNTING_SEMAPHORE_FAILED();
        }

        return xHandle;
    80000a68:	67e2                	ld	a5,24(sp)
    }
    80000a6a:	853e                	mv	a0,a5
    80000a6c:	70a2                	ld	ra,40(sp)
    80000a6e:	6145                	addi	sp,sp,48
    80000a70:	8082                	ret

0000000080000a72 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    80000a72:	711d                	addi	sp,sp,-96
    80000a74:	ec86                	sd	ra,88(sp)
    80000a76:	ec2a                	sd	a0,24(sp)
    80000a78:	e82e                	sd	a1,16(sp)
    80000a7a:	e432                	sd	a2,8(sp)
    80000a7c:	e036                	sd	a3,0(sp)
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    80000a7e:	e482                	sd	zero,72(sp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    80000a80:	67e2                	ld	a5,24(sp)
    80000a82:	e0be                	sd	a5,64(sp)

    configASSERT( pxQueue );
    80000a84:	6786                	ld	a5,64(sp)
    80000a86:	e781                	bnez	a5,80000a8e <xQueueGenericSend+0x1c>
    80000a88:	30047073          	csrci	mstatus,8
    80000a8c:	a001                	j	80000a8c <xQueueGenericSend+0x1a>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    80000a8e:	67c2                	ld	a5,16(sp)
    80000a90:	e781                	bnez	a5,80000a98 <xQueueGenericSend+0x26>
    80000a92:	6786                	ld	a5,64(sp)
    80000a94:	63dc                	ld	a5,128(a5)
    80000a96:	e399                	bnez	a5,80000a9c <xQueueGenericSend+0x2a>
    80000a98:	4785                	li	a5,1
    80000a9a:	a011                	j	80000a9e <xQueueGenericSend+0x2c>
    80000a9c:	4781                	li	a5,0
    80000a9e:	e781                	bnez	a5,80000aa6 <xQueueGenericSend+0x34>
    80000aa0:	30047073          	csrci	mstatus,8
    80000aa4:	a001                	j	80000aa4 <xQueueGenericSend+0x32>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    80000aa6:	6702                	ld	a4,0(sp)
    80000aa8:	4789                	li	a5,2
    80000aaa:	00f71763          	bne	a4,a5,80000ab8 <xQueueGenericSend+0x46>
    80000aae:	6786                	ld	a5,64(sp)
    80000ab0:	7fb8                	ld	a4,120(a5)
    80000ab2:	4785                	li	a5,1
    80000ab4:	00f71463          	bne	a4,a5,80000abc <xQueueGenericSend+0x4a>
    80000ab8:	4785                	li	a5,1
    80000aba:	a011                	j	80000abe <xQueueGenericSend+0x4c>
    80000abc:	4781                	li	a5,0
    80000abe:	e781                	bnez	a5,80000ac6 <xQueueGenericSend+0x54>
    80000ac0:	30047073          	csrci	mstatus,8
    80000ac4:	a001                	j	80000ac4 <xQueueGenericSend+0x52>
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    80000ac6:	59a020ef          	jal	ra,80003060 <xTaskGetSchedulerState>
    80000aca:	87aa                	mv	a5,a0
    80000acc:	e399                	bnez	a5,80000ad2 <xQueueGenericSend+0x60>
    80000ace:	67a2                	ld	a5,8(sp)
    80000ad0:	e399                	bnez	a5,80000ad6 <xQueueGenericSend+0x64>
    80000ad2:	4785                	li	a5,1
    80000ad4:	a011                	j	80000ad8 <xQueueGenericSend+0x66>
    80000ad6:	4781                	li	a5,0
    80000ad8:	e781                	bnez	a5,80000ae0 <xQueueGenericSend+0x6e>
    80000ada:	30047073          	csrci	mstatus,8
    80000ade:	a001                	j	80000ade <xQueueGenericSend+0x6c>
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    80000ae0:	0ed020ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    80000ae4:	6786                	ld	a5,64(sp)
    80000ae6:	7bb8                	ld	a4,112(a5)
    80000ae8:	6786                	ld	a5,64(sp)
    80000aea:	7fbc                	ld	a5,120(a5)
    80000aec:	00f76663          	bltu	a4,a5,80000af8 <xQueueGenericSend+0x86>
    80000af0:	6702                	ld	a4,0(sp)
    80000af2:	4789                	li	a5,2
    80000af4:	02f71e63          	bne	a4,a5,80000b30 <xQueueGenericSend+0xbe>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    80000af8:	6602                	ld	a2,0(sp)
    80000afa:	65c2                	ld	a1,16(sp)
    80000afc:	6506                	ld	a0,64(sp)
    80000afe:	145000ef          	jal	ra,80001442 <prvCopyDataToQueue>
    80000b02:	fc2a                	sd	a0,56(sp)

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    80000b04:	6786                	ld	a5,64(sp)
    80000b06:	67bc                	ld	a5,72(a5)
    80000b08:	cf81                	beqz	a5,80000b20 <xQueueGenericSend+0xae>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    80000b0a:	6786                	ld	a5,64(sp)
    80000b0c:	04878793          	addi	a5,a5,72
    80000b10:	853e                	mv	a0,a5
    80000b12:	737010ef          	jal	ra,80002a48 <xTaskRemoveFromEventList>
    80000b16:	87aa                	mv	a5,a0
    80000b18:	cb81                	beqz	a5,80000b28 <xQueueGenericSend+0xb6>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    80000b1a:	00000073          	ecall
    80000b1e:	a029                	j	80000b28 <xQueueGenericSend+0xb6>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    80000b20:	77e2                	ld	a5,56(sp)
    80000b22:	c399                	beqz	a5,80000b28 <xQueueGenericSend+0xb6>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    80000b24:	00000073          	ecall
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    80000b28:	0d3020ef          	jal	ra,800033fa <vTaskExitCritical>
                return pdPASS;
    80000b2c:	4785                	li	a5,1
    80000b2e:	a87d                	j	80000bec <xQueueGenericSend+0x17a>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    80000b30:	67a2                	ld	a5,8(sp)
    80000b32:	e789                	bnez	a5,80000b3c <xQueueGenericSend+0xca>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    80000b34:	0c7020ef          	jal	ra,800033fa <vTaskExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    80000b38:	4781                	li	a5,0
    80000b3a:	a84d                	j	80000bec <xQueueGenericSend+0x17a>
                }
                else if( xEntryTimeSet == pdFALSE )
    80000b3c:	67a6                	ld	a5,72(sp)
    80000b3e:	e799                	bnez	a5,80000b4c <xQueueGenericSend+0xda>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    80000b40:	103c                	addi	a5,sp,40
    80000b42:	853e                	mv	a0,a5
    80000b44:	0bc020ef          	jal	ra,80002c00 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    80000b48:	4785                	li	a5,1
    80000b4a:	e4be                	sd	a5,72(sp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    80000b4c:	0af020ef          	jal	ra,800033fa <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    80000b50:	7f4010ef          	jal	ra,80002344 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    80000b54:	079020ef          	jal	ra,800033cc <vTaskEnterCritical>
    80000b58:	6786                	ld	a5,64(sp)
    80000b5a:	0887c783          	lbu	a5,136(a5)
    80000b5e:	0187979b          	slliw	a5,a5,0x18
    80000b62:	4187d79b          	sraiw	a5,a5,0x18
    80000b66:	873e                	mv	a4,a5
    80000b68:	57fd                	li	a5,-1
    80000b6a:	00f71563          	bne	a4,a5,80000b74 <xQueueGenericSend+0x102>
    80000b6e:	6786                	ld	a5,64(sp)
    80000b70:	08078423          	sb	zero,136(a5)
    80000b74:	6786                	ld	a5,64(sp)
    80000b76:	0897c783          	lbu	a5,137(a5)
    80000b7a:	0187979b          	slliw	a5,a5,0x18
    80000b7e:	4187d79b          	sraiw	a5,a5,0x18
    80000b82:	873e                	mv	a4,a5
    80000b84:	57fd                	li	a5,-1
    80000b86:	00f71563          	bne	a4,a5,80000b90 <xQueueGenericSend+0x11e>
    80000b8a:	6786                	ld	a5,64(sp)
    80000b8c:	080784a3          	sb	zero,137(a5)
    80000b90:	06b020ef          	jal	ra,800033fa <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    80000b94:	0038                	addi	a4,sp,8
    80000b96:	103c                	addi	a5,sp,40
    80000b98:	85ba                	mv	a1,a4
    80000b9a:	853e                	mv	a0,a5
    80000b9c:	08a020ef          	jal	ra,80002c26 <xTaskCheckForTimeOut>
    80000ba0:	87aa                	mv	a5,a0
    80000ba2:	ef9d                	bnez	a5,80000be0 <xQueueGenericSend+0x16e>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    80000ba4:	6506                	ld	a0,64(sp)
    80000ba6:	2c7000ef          	jal	ra,8000166c <prvIsQueueFull>
    80000baa:	87aa                	mv	a5,a0
    80000bac:	c785                	beqz	a5,80000bd4 <xQueueGenericSend+0x162>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    80000bae:	6786                	ld	a5,64(sp)
    80000bb0:	02078793          	addi	a5,a5,32
    80000bb4:	6722                	ld	a4,8(sp)
    80000bb6:	85ba                	mv	a1,a4
    80000bb8:	853e                	mv	a0,a5
    80000bba:	5b5010ef          	jal	ra,8000296e <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    80000bbe:	6506                	ld	a0,64(sp)
    80000bc0:	1a1000ef          	jal	ra,80001560 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    80000bc4:	79c010ef          	jal	ra,80002360 <xTaskResumeAll>
    80000bc8:	87aa                	mv	a5,a0
    80000bca:	f0079be3          	bnez	a5,80000ae0 <xQueueGenericSend+0x6e>
                {
                    portYIELD_WITHIN_API();
    80000bce:	00000073          	ecall
    80000bd2:	b739                	j	80000ae0 <xQueueGenericSend+0x6e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    80000bd4:	6506                	ld	a0,64(sp)
    80000bd6:	18b000ef          	jal	ra,80001560 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    80000bda:	786010ef          	jal	ra,80002360 <xTaskResumeAll>
    80000bde:	b709                	j	80000ae0 <xQueueGenericSend+0x6e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    80000be0:	6506                	ld	a0,64(sp)
    80000be2:	17f000ef          	jal	ra,80001560 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    80000be6:	77a010ef          	jal	ra,80002360 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    80000bea:	4781                	li	a5,0
        }
    } /*lint -restore */
}
    80000bec:	853e                	mv	a0,a5
    80000bee:	60e6                	ld	ra,88(sp)
    80000bf0:	6125                	addi	sp,sp,96
    80000bf2:	8082                	ret

0000000080000bf4 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    80000bf4:	711d                	addi	sp,sp,-96
    80000bf6:	ec86                	sd	ra,88(sp)
    80000bf8:	ec2a                	sd	a0,24(sp)
    80000bfa:	e82e                	sd	a1,16(sp)
    80000bfc:	e432                	sd	a2,8(sp)
    80000bfe:	e036                	sd	a3,0(sp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    80000c00:	67e2                	ld	a5,24(sp)
    80000c02:	e0be                	sd	a5,64(sp)

    configASSERT( pxQueue );
    80000c04:	6786                	ld	a5,64(sp)
    80000c06:	e781                	bnez	a5,80000c0e <xQueueGenericSendFromISR+0x1a>
    80000c08:	30047073          	csrci	mstatus,8
    80000c0c:	a001                	j	80000c0c <xQueueGenericSendFromISR+0x18>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    80000c0e:	67c2                	ld	a5,16(sp)
    80000c10:	e781                	bnez	a5,80000c18 <xQueueGenericSendFromISR+0x24>
    80000c12:	6786                	ld	a5,64(sp)
    80000c14:	63dc                	ld	a5,128(a5)
    80000c16:	e399                	bnez	a5,80000c1c <xQueueGenericSendFromISR+0x28>
    80000c18:	4785                	li	a5,1
    80000c1a:	a011                	j	80000c1e <xQueueGenericSendFromISR+0x2a>
    80000c1c:	4781                	li	a5,0
    80000c1e:	e781                	bnez	a5,80000c26 <xQueueGenericSendFromISR+0x32>
    80000c20:	30047073          	csrci	mstatus,8
    80000c24:	a001                	j	80000c24 <xQueueGenericSendFromISR+0x30>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    80000c26:	6702                	ld	a4,0(sp)
    80000c28:	4789                	li	a5,2
    80000c2a:	00f71763          	bne	a4,a5,80000c38 <xQueueGenericSendFromISR+0x44>
    80000c2e:	6786                	ld	a5,64(sp)
    80000c30:	7fb8                	ld	a4,120(a5)
    80000c32:	4785                	li	a5,1
    80000c34:	00f71463          	bne	a4,a5,80000c3c <xQueueGenericSendFromISR+0x48>
    80000c38:	4785                	li	a5,1
    80000c3a:	a011                	j	80000c3e <xQueueGenericSendFromISR+0x4a>
    80000c3c:	4781                	li	a5,0
    80000c3e:	e781                	bnez	a5,80000c46 <xQueueGenericSendFromISR+0x52>
    80000c40:	30047073          	csrci	mstatus,8
    80000c44:	a001                	j	80000c44 <xQueueGenericSendFromISR+0x50>
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    80000c46:	fc02                	sd	zero,56(sp)
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    80000c48:	6786                	ld	a5,64(sp)
    80000c4a:	7bb8                	ld	a4,112(a5)
    80000c4c:	6786                	ld	a5,64(sp)
    80000c4e:	7fbc                	ld	a5,120(a5)
    80000c50:	00f76663          	bltu	a4,a5,80000c5c <xQueueGenericSendFromISR+0x68>
    80000c54:	6702                	ld	a4,0(sp)
    80000c56:	4789                	li	a5,2
    80000c58:	08f71263          	bne	a4,a5,80000cdc <xQueueGenericSendFromISR+0xe8>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    80000c5c:	6786                	ld	a5,64(sp)
    80000c5e:	0897c783          	lbu	a5,137(a5)
    80000c62:	02f10ba3          	sb	a5,55(sp)
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    80000c66:	6786                	ld	a5,64(sp)
    80000c68:	7bbc                	ld	a5,112(a5)
    80000c6a:	f43e                	sd	a5,40(sp)
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    80000c6c:	6602                	ld	a2,0(sp)
    80000c6e:	65c2                	ld	a1,16(sp)
    80000c70:	6506                	ld	a0,64(sp)
    80000c72:	7d0000ef          	jal	ra,80001442 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    80000c76:	03714783          	lbu	a5,55(sp)
    80000c7a:	0ff7f713          	andi	a4,a5,255
    80000c7e:	0ff00793          	li	a5,255
    80000c82:	02f71363          	bne	a4,a5,80000ca8 <xQueueGenericSendFromISR+0xb4>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    80000c86:	6786                	ld	a5,64(sp)
    80000c88:	67bc                	ld	a5,72(a5)
    80000c8a:	c7b1                	beqz	a5,80000cd6 <xQueueGenericSendFromISR+0xe2>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    80000c8c:	6786                	ld	a5,64(sp)
    80000c8e:	04878793          	addi	a5,a5,72
    80000c92:	853e                	mv	a0,a5
    80000c94:	5b5010ef          	jal	ra,80002a48 <xTaskRemoveFromEventList>
    80000c98:	87aa                	mv	a5,a0
    80000c9a:	cf95                	beqz	a5,80000cd6 <xQueueGenericSendFromISR+0xe2>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    80000c9c:	67a2                	ld	a5,8(sp)
    80000c9e:	cf85                	beqz	a5,80000cd6 <xQueueGenericSendFromISR+0xe2>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    80000ca0:	67a2                	ld	a5,8(sp)
    80000ca2:	4705                	li	a4,1
    80000ca4:	e398                	sd	a4,0(a5)
    80000ca6:	a805                	j	80000cd6 <xQueueGenericSendFromISR+0xe2>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );
    80000ca8:	03714783          	lbu	a5,55(sp)
    80000cac:	0ff7f713          	andi	a4,a5,255
    80000cb0:	07f00793          	li	a5,127
    80000cb4:	00f71563          	bne	a4,a5,80000cbe <xQueueGenericSendFromISR+0xca>
    80000cb8:	30047073          	csrci	mstatus,8
    80000cbc:	a001                	j	80000cbc <xQueueGenericSendFromISR+0xc8>

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    80000cbe:	03714783          	lbu	a5,55(sp)
    80000cc2:	2785                	addiw	a5,a5,1
    80000cc4:	0ff7f793          	andi	a5,a5,255
    80000cc8:	0187971b          	slliw	a4,a5,0x18
    80000ccc:	4187571b          	sraiw	a4,a4,0x18
    80000cd0:	6786                	ld	a5,64(sp)
    80000cd2:	08e784a3          	sb	a4,137(a5)
            }

            xReturn = pdPASS;
    80000cd6:	4785                	li	a5,1
    80000cd8:	e4be                	sd	a5,72(sp)
        {
    80000cda:	a011                	j	80000cde <xQueueGenericSendFromISR+0xea>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    80000cdc:	e482                	sd	zero,72(sp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    80000cde:	67a6                	ld	a5,72(sp)
}
    80000ce0:	853e                	mv	a0,a5
    80000ce2:	60e6                	ld	ra,88(sp)
    80000ce4:	6125                	addi	sp,sp,96
    80000ce6:	8082                	ret

0000000080000ce8 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    80000ce8:	715d                	addi	sp,sp,-80
    80000cea:	e486                	sd	ra,72(sp)
    80000cec:	e42a                	sd	a0,8(sp)
    80000cee:	e02e                	sd	a1,0(sp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    80000cf0:	67a2                	ld	a5,8(sp)
    80000cf2:	f83e                	sd	a5,48(sp)
     * item size is 0.  Don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */

    configASSERT( pxQueue );
    80000cf4:	77c2                	ld	a5,48(sp)
    80000cf6:	e781                	bnez	a5,80000cfe <xQueueGiveFromISR+0x16>
    80000cf8:	30047073          	csrci	mstatus,8
    80000cfc:	a001                	j	80000cfc <xQueueGiveFromISR+0x14>

    /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
     * if the item size is not 0. */
    configASSERT( pxQueue->uxItemSize == 0 );
    80000cfe:	77c2                	ld	a5,48(sp)
    80000d00:	63dc                	ld	a5,128(a5)
    80000d02:	c781                	beqz	a5,80000d0a <xQueueGiveFromISR+0x22>
    80000d04:	30047073          	csrci	mstatus,8
    80000d08:	a001                	j	80000d08 <xQueueGiveFromISR+0x20>

    /* Normally a mutex would not be given from an interrupt, especially if
     * there is a mutex holder, as priority inheritance makes no sense for an
     * interrupts, only tasks. */
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
    80000d0a:	77c2                	ld	a5,48(sp)
    80000d0c:	639c                	ld	a5,0(a5)
    80000d0e:	e781                	bnez	a5,80000d16 <xQueueGiveFromISR+0x2e>
    80000d10:	77c2                	ld	a5,48(sp)
    80000d12:	6b9c                	ld	a5,16(a5)
    80000d14:	e399                	bnez	a5,80000d1a <xQueueGiveFromISR+0x32>
    80000d16:	4785                	li	a5,1
    80000d18:	a011                	j	80000d1c <xQueueGiveFromISR+0x34>
    80000d1a:	4781                	li	a5,0
    80000d1c:	e781                	bnez	a5,80000d24 <xQueueGiveFromISR+0x3c>
    80000d1e:	30047073          	csrci	mstatus,8
    80000d22:	a001                	j	80000d22 <xQueueGiveFromISR+0x3a>
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    80000d24:	f402                	sd	zero,40(sp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    80000d26:	77c2                	ld	a5,48(sp)
    80000d28:	7bbc                	ld	a5,112(a5)
    80000d2a:	f03e                	sd	a5,32(sp)

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    80000d2c:	77c2                	ld	a5,48(sp)
    80000d2e:	7fbc                	ld	a5,120(a5)
    80000d30:	7702                	ld	a4,32(sp)
    80000d32:	06f77f63          	bgeu	a4,a5,80000db0 <xQueueGiveFromISR+0xc8>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    80000d36:	77c2                	ld	a5,48(sp)
    80000d38:	0897c783          	lbu	a5,137(a5)
    80000d3c:	00f10fa3          	sb	a5,31(sp)
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    80000d40:	7782                	ld	a5,32(sp)
    80000d42:	00178713          	addi	a4,a5,1
    80000d46:	77c2                	ld	a5,48(sp)
    80000d48:	fbb8                	sd	a4,112(a5)

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    80000d4a:	01f14783          	lbu	a5,31(sp)
    80000d4e:	0ff7f713          	andi	a4,a5,255
    80000d52:	0ff00793          	li	a5,255
    80000d56:	02f71363          	bne	a4,a5,80000d7c <xQueueGiveFromISR+0x94>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    80000d5a:	77c2                	ld	a5,48(sp)
    80000d5c:	67bc                	ld	a5,72(a5)
    80000d5e:	c7b1                	beqz	a5,80000daa <xQueueGiveFromISR+0xc2>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    80000d60:	77c2                	ld	a5,48(sp)
    80000d62:	04878793          	addi	a5,a5,72
    80000d66:	853e                	mv	a0,a5
    80000d68:	4e1010ef          	jal	ra,80002a48 <xTaskRemoveFromEventList>
    80000d6c:	87aa                	mv	a5,a0
    80000d6e:	cf95                	beqz	a5,80000daa <xQueueGiveFromISR+0xc2>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    80000d70:	6782                	ld	a5,0(sp)
    80000d72:	cf85                	beqz	a5,80000daa <xQueueGiveFromISR+0xc2>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    80000d74:	6782                	ld	a5,0(sp)
    80000d76:	4705                	li	a4,1
    80000d78:	e398                	sd	a4,0(a5)
    80000d7a:	a805                	j	80000daa <xQueueGiveFromISR+0xc2>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );
    80000d7c:	01f14783          	lbu	a5,31(sp)
    80000d80:	0ff7f713          	andi	a4,a5,255
    80000d84:	07f00793          	li	a5,127
    80000d88:	00f71563          	bne	a4,a5,80000d92 <xQueueGiveFromISR+0xaa>
    80000d8c:	30047073          	csrci	mstatus,8
    80000d90:	a001                	j	80000d90 <xQueueGiveFromISR+0xa8>

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    80000d92:	01f14783          	lbu	a5,31(sp)
    80000d96:	2785                	addiw	a5,a5,1
    80000d98:	0ff7f793          	andi	a5,a5,255
    80000d9c:	0187971b          	slliw	a4,a5,0x18
    80000da0:	4187571b          	sraiw	a4,a4,0x18
    80000da4:	77c2                	ld	a5,48(sp)
    80000da6:	08e784a3          	sb	a4,137(a5)
            }

            xReturn = pdPASS;
    80000daa:	4785                	li	a5,1
    80000dac:	fc3e                	sd	a5,56(sp)
    80000dae:	a011                	j	80000db2 <xQueueGiveFromISR+0xca>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    80000db0:	fc02                	sd	zero,56(sp)
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    80000db2:	77e2                	ld	a5,56(sp)
}
    80000db4:	853e                	mv	a0,a5
    80000db6:	60a6                	ld	ra,72(sp)
    80000db8:	6161                	addi	sp,sp,80
    80000dba:	8082                	ret

0000000080000dbc <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    80000dbc:	711d                	addi	sp,sp,-96
    80000dbe:	ec86                	sd	ra,88(sp)
    80000dc0:	ec2a                	sd	a0,24(sp)
    80000dc2:	e82e                	sd	a1,16(sp)
    80000dc4:	e432                	sd	a2,8(sp)
    BaseType_t xEntryTimeSet = pdFALSE;
    80000dc6:	e482                	sd	zero,72(sp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    80000dc8:	67e2                	ld	a5,24(sp)
    80000dca:	e0be                	sd	a5,64(sp)

    /* Check the pointer is not NULL. */
    configASSERT( ( pxQueue ) );
    80000dcc:	6786                	ld	a5,64(sp)
    80000dce:	e781                	bnez	a5,80000dd6 <xQueueReceive+0x1a>
    80000dd0:	30047073          	csrci	mstatus,8
    80000dd4:	a001                	j	80000dd4 <xQueueReceive+0x18>

    /* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer). */
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    80000dd6:	67c2                	ld	a5,16(sp)
    80000dd8:	e781                	bnez	a5,80000de0 <xQueueReceive+0x24>
    80000dda:	6786                	ld	a5,64(sp)
    80000ddc:	63dc                	ld	a5,128(a5)
    80000dde:	e399                	bnez	a5,80000de4 <xQueueReceive+0x28>
    80000de0:	4785                	li	a5,1
    80000de2:	a011                	j	80000de6 <xQueueReceive+0x2a>
    80000de4:	4781                	li	a5,0
    80000de6:	e781                	bnez	a5,80000dee <xQueueReceive+0x32>
    80000de8:	30047073          	csrci	mstatus,8
    80000dec:	a001                	j	80000dec <xQueueReceive+0x30>

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    80000dee:	272020ef          	jal	ra,80003060 <xTaskGetSchedulerState>
    80000df2:	87aa                	mv	a5,a0
    80000df4:	e399                	bnez	a5,80000dfa <xQueueReceive+0x3e>
    80000df6:	67a2                	ld	a5,8(sp)
    80000df8:	e399                	bnez	a5,80000dfe <xQueueReceive+0x42>
    80000dfa:	4785                	li	a5,1
    80000dfc:	a011                	j	80000e00 <xQueueReceive+0x44>
    80000dfe:	4781                	li	a5,0
    80000e00:	e781                	bnez	a5,80000e08 <xQueueReceive+0x4c>
    80000e02:	30047073          	csrci	mstatus,8
    80000e06:	a001                	j	80000e06 <xQueueReceive+0x4a>
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    80000e08:	5c4020ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    80000e0c:	6786                	ld	a5,64(sp)
    80000e0e:	7bbc                	ld	a5,112(a5)
    80000e10:	fc3e                	sd	a5,56(sp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    80000e12:	77e2                	ld	a5,56(sp)
    80000e14:	cb9d                	beqz	a5,80000e4a <xQueueReceive+0x8e>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    80000e16:	65c2                	ld	a1,16(sp)
    80000e18:	6506                	ld	a0,64(sp)
    80000e1a:	6fc000ef          	jal	ra,80001516 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    80000e1e:	77e2                	ld	a5,56(sp)
    80000e20:	fff78713          	addi	a4,a5,-1
    80000e24:	6786                	ld	a5,64(sp)
    80000e26:	fbb8                	sd	a4,112(a5)

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    80000e28:	6786                	ld	a5,64(sp)
    80000e2a:	739c                	ld	a5,32(a5)
    80000e2c:	cb99                	beqz	a5,80000e42 <xQueueReceive+0x86>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    80000e2e:	6786                	ld	a5,64(sp)
    80000e30:	02078793          	addi	a5,a5,32
    80000e34:	853e                	mv	a0,a5
    80000e36:	413010ef          	jal	ra,80002a48 <xTaskRemoveFromEventList>
    80000e3a:	87aa                	mv	a5,a0
    80000e3c:	c399                	beqz	a5,80000e42 <xQueueReceive+0x86>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    80000e3e:	00000073          	ecall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    80000e42:	5b8020ef          	jal	ra,800033fa <vTaskExitCritical>
                return pdPASS;
    80000e46:	4785                	li	a5,1
    80000e48:	a0e9                	j	80000f12 <xQueueReceive+0x156>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    80000e4a:	67a2                	ld	a5,8(sp)
    80000e4c:	e789                	bnez	a5,80000e56 <xQueueReceive+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    80000e4e:	5ac020ef          	jal	ra,800033fa <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    80000e52:	4781                	li	a5,0
    80000e54:	a87d                	j	80000f12 <xQueueReceive+0x156>
                }
                else if( xEntryTimeSet == pdFALSE )
    80000e56:	67a6                	ld	a5,72(sp)
    80000e58:	e799                	bnez	a5,80000e66 <xQueueReceive+0xaa>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    80000e5a:	103c                	addi	a5,sp,40
    80000e5c:	853e                	mv	a0,a5
    80000e5e:	5a3010ef          	jal	ra,80002c00 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    80000e62:	4785                	li	a5,1
    80000e64:	e4be                	sd	a5,72(sp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    80000e66:	594020ef          	jal	ra,800033fa <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    80000e6a:	4da010ef          	jal	ra,80002344 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    80000e6e:	55e020ef          	jal	ra,800033cc <vTaskEnterCritical>
    80000e72:	6786                	ld	a5,64(sp)
    80000e74:	0887c783          	lbu	a5,136(a5)
    80000e78:	0187979b          	slliw	a5,a5,0x18
    80000e7c:	4187d79b          	sraiw	a5,a5,0x18
    80000e80:	873e                	mv	a4,a5
    80000e82:	57fd                	li	a5,-1
    80000e84:	00f71563          	bne	a4,a5,80000e8e <xQueueReceive+0xd2>
    80000e88:	6786                	ld	a5,64(sp)
    80000e8a:	08078423          	sb	zero,136(a5)
    80000e8e:	6786                	ld	a5,64(sp)
    80000e90:	0897c783          	lbu	a5,137(a5)
    80000e94:	0187979b          	slliw	a5,a5,0x18
    80000e98:	4187d79b          	sraiw	a5,a5,0x18
    80000e9c:	873e                	mv	a4,a5
    80000e9e:	57fd                	li	a5,-1
    80000ea0:	00f71563          	bne	a4,a5,80000eaa <xQueueReceive+0xee>
    80000ea4:	6786                	ld	a5,64(sp)
    80000ea6:	080784a3          	sb	zero,137(a5)
    80000eaa:	550020ef          	jal	ra,800033fa <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    80000eae:	0038                	addi	a4,sp,8
    80000eb0:	103c                	addi	a5,sp,40
    80000eb2:	85ba                	mv	a1,a4
    80000eb4:	853e                	mv	a0,a5
    80000eb6:	571010ef          	jal	ra,80002c26 <xTaskCheckForTimeOut>
    80000eba:	87aa                	mv	a5,a0
    80000ebc:	ef9d                	bnez	a5,80000efa <xQueueReceive+0x13e>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    80000ebe:	6506                	ld	a0,64(sp)
    80000ec0:	75e000ef          	jal	ra,8000161e <prvIsQueueEmpty>
    80000ec4:	87aa                	mv	a5,a0
    80000ec6:	c785                	beqz	a5,80000eee <xQueueReceive+0x132>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    80000ec8:	6786                	ld	a5,64(sp)
    80000eca:	04878793          	addi	a5,a5,72
    80000ece:	6722                	ld	a4,8(sp)
    80000ed0:	85ba                	mv	a1,a4
    80000ed2:	853e                	mv	a0,a5
    80000ed4:	29b010ef          	jal	ra,8000296e <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    80000ed8:	6506                	ld	a0,64(sp)
    80000eda:	686000ef          	jal	ra,80001560 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    80000ede:	482010ef          	jal	ra,80002360 <xTaskResumeAll>
    80000ee2:	87aa                	mv	a5,a0
    80000ee4:	f20792e3          	bnez	a5,80000e08 <xQueueReceive+0x4c>
                {
                    portYIELD_WITHIN_API();
    80000ee8:	00000073          	ecall
    80000eec:	bf31                	j	80000e08 <xQueueReceive+0x4c>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    80000eee:	6506                	ld	a0,64(sp)
    80000ef0:	670000ef          	jal	ra,80001560 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    80000ef4:	46c010ef          	jal	ra,80002360 <xTaskResumeAll>
    80000ef8:	bf01                	j	80000e08 <xQueueReceive+0x4c>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    80000efa:	6506                	ld	a0,64(sp)
    80000efc:	664000ef          	jal	ra,80001560 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    80000f00:	460010ef          	jal	ra,80002360 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    80000f04:	6506                	ld	a0,64(sp)
    80000f06:	718000ef          	jal	ra,8000161e <prvIsQueueEmpty>
    80000f0a:	87aa                	mv	a5,a0
    80000f0c:	ee078ee3          	beqz	a5,80000e08 <xQueueReceive+0x4c>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    80000f10:	4781                	li	a5,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    80000f12:	853e                	mv	a0,a5
    80000f14:	60e6                	ld	ra,88(sp)
    80000f16:	6125                	addi	sp,sp,96
    80000f18:	8082                	ret

0000000080000f1a <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    80000f1a:	711d                	addi	sp,sp,-96
    80000f1c:	ec86                	sd	ra,88(sp)
    80000f1e:	e42a                	sd	a0,8(sp)
    80000f20:	e02e                	sd	a1,0(sp)
    BaseType_t xEntryTimeSet = pdFALSE;
    80000f22:	e482                	sd	zero,72(sp)
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    80000f24:	67a2                	ld	a5,8(sp)
    80000f26:	fc3e                	sd	a5,56(sp)

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
    80000f28:	e082                	sd	zero,64(sp)
    #endif

    /* Check the queue pointer is not NULL. */
    configASSERT( ( pxQueue ) );
    80000f2a:	77e2                	ld	a5,56(sp)
    80000f2c:	e781                	bnez	a5,80000f34 <xQueueSemaphoreTake+0x1a>
    80000f2e:	30047073          	csrci	mstatus,8
    80000f32:	a001                	j	80000f32 <xQueueSemaphoreTake+0x18>

    /* Check this really is a semaphore, in which case the item size will be
     * 0. */
    configASSERT( pxQueue->uxItemSize == 0 );
    80000f34:	77e2                	ld	a5,56(sp)
    80000f36:	63dc                	ld	a5,128(a5)
    80000f38:	c781                	beqz	a5,80000f40 <xQueueSemaphoreTake+0x26>
    80000f3a:	30047073          	csrci	mstatus,8
    80000f3e:	a001                	j	80000f3e <xQueueSemaphoreTake+0x24>

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    80000f40:	120020ef          	jal	ra,80003060 <xTaskGetSchedulerState>
    80000f44:	87aa                	mv	a5,a0
    80000f46:	e399                	bnez	a5,80000f4c <xQueueSemaphoreTake+0x32>
    80000f48:	6782                	ld	a5,0(sp)
    80000f4a:	e399                	bnez	a5,80000f50 <xQueueSemaphoreTake+0x36>
    80000f4c:	4785                	li	a5,1
    80000f4e:	a011                	j	80000f52 <xQueueSemaphoreTake+0x38>
    80000f50:	4781                	li	a5,0
    80000f52:	e781                	bnez	a5,80000f5a <xQueueSemaphoreTake+0x40>
    80000f54:	30047073          	csrci	mstatus,8
    80000f58:	a001                	j	80000f58 <xQueueSemaphoreTake+0x3e>
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    80000f5a:	472020ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    80000f5e:	77e2                	ld	a5,56(sp)
    80000f60:	7bbc                	ld	a5,112(a5)
    80000f62:	f83e                	sd	a5,48(sp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    80000f64:	77c2                	ld	a5,48(sp)
    80000f66:	cf9d                	beqz	a5,80000fa4 <xQueueSemaphoreTake+0x8a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    80000f68:	77c2                	ld	a5,48(sp)
    80000f6a:	fff78713          	addi	a4,a5,-1
    80000f6e:	77e2                	ld	a5,56(sp)
    80000f70:	fbb8                	sd	a4,112(a5)

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    80000f72:	77e2                	ld	a5,56(sp)
    80000f74:	639c                	ld	a5,0(a5)
    80000f76:	e791                	bnez	a5,80000f82 <xQueueSemaphoreTake+0x68>
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    80000f78:	4f8020ef          	jal	ra,80003470 <pvTaskIncrementMutexHeldCount>
    80000f7c:	872a                	mv	a4,a0
    80000f7e:	77e2                	ld	a5,56(sp)
    80000f80:	eb98                	sd	a4,16(a5)
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    80000f82:	77e2                	ld	a5,56(sp)
    80000f84:	739c                	ld	a5,32(a5)
    80000f86:	cb99                	beqz	a5,80000f9c <xQueueSemaphoreTake+0x82>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    80000f88:	77e2                	ld	a5,56(sp)
    80000f8a:	02078793          	addi	a5,a5,32
    80000f8e:	853e                	mv	a0,a5
    80000f90:	2b9010ef          	jal	ra,80002a48 <xTaskRemoveFromEventList>
    80000f94:	87aa                	mv	a5,a0
    80000f96:	c399                	beqz	a5,80000f9c <xQueueSemaphoreTake+0x82>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    80000f98:	00000073          	ecall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    80000f9c:	45e020ef          	jal	ra,800033fa <vTaskExitCritical>
                return pdPASS;
    80000fa0:	4785                	li	a5,1
    80000fa2:	a239                	j	800010b0 <xQueueSemaphoreTake+0x196>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    80000fa4:	6782                	ld	a5,0(sp)
    80000fa6:	eb91                	bnez	a5,80000fba <xQueueSemaphoreTake+0xa0>
                    /* For inheritance to have occurred there must have been an
                     * initial timeout, and an adjusted timeout cannot become 0, as
                     * if it were 0 the function would have exited. */
                    #if ( configUSE_MUTEXES == 1 )
                        {
                            configASSERT( xInheritanceOccurred == pdFALSE );
    80000fa8:	6786                	ld	a5,64(sp)
    80000faa:	c781                	beqz	a5,80000fb2 <xQueueSemaphoreTake+0x98>
    80000fac:	30047073          	csrci	mstatus,8
    80000fb0:	a001                	j	80000fb0 <xQueueSemaphoreTake+0x96>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    80000fb2:	448020ef          	jal	ra,800033fa <vTaskExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    80000fb6:	4781                	li	a5,0
    80000fb8:	a8e5                	j	800010b0 <xQueueSemaphoreTake+0x196>
                }
                else if( xEntryTimeSet == pdFALSE )
    80000fba:	67a6                	ld	a5,72(sp)
    80000fbc:	e799                	bnez	a5,80000fca <xQueueSemaphoreTake+0xb0>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    80000fbe:	083c                	addi	a5,sp,24
    80000fc0:	853e                	mv	a0,a5
    80000fc2:	43f010ef          	jal	ra,80002c00 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    80000fc6:	4785                	li	a5,1
    80000fc8:	e4be                	sd	a5,72(sp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    80000fca:	430020ef          	jal	ra,800033fa <vTaskExitCritical>

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    80000fce:	376010ef          	jal	ra,80002344 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    80000fd2:	3fa020ef          	jal	ra,800033cc <vTaskEnterCritical>
    80000fd6:	77e2                	ld	a5,56(sp)
    80000fd8:	0887c783          	lbu	a5,136(a5)
    80000fdc:	0187979b          	slliw	a5,a5,0x18
    80000fe0:	4187d79b          	sraiw	a5,a5,0x18
    80000fe4:	873e                	mv	a4,a5
    80000fe6:	57fd                	li	a5,-1
    80000fe8:	00f71563          	bne	a4,a5,80000ff2 <xQueueSemaphoreTake+0xd8>
    80000fec:	77e2                	ld	a5,56(sp)
    80000fee:	08078423          	sb	zero,136(a5)
    80000ff2:	77e2                	ld	a5,56(sp)
    80000ff4:	0897c783          	lbu	a5,137(a5)
    80000ff8:	0187979b          	slliw	a5,a5,0x18
    80000ffc:	4187d79b          	sraiw	a5,a5,0x18
    80001000:	873e                	mv	a4,a5
    80001002:	57fd                	li	a5,-1
    80001004:	00f71563          	bne	a4,a5,8000100e <xQueueSemaphoreTake+0xf4>
    80001008:	77e2                	ld	a5,56(sp)
    8000100a:	080784a3          	sb	zero,137(a5)
    8000100e:	3ec020ef          	jal	ra,800033fa <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    80001012:	870a                	mv	a4,sp
    80001014:	083c                	addi	a5,sp,24
    80001016:	85ba                	mv	a1,a4
    80001018:	853e                	mv	a0,a5
    8000101a:	40d010ef          	jal	ra,80002c26 <xTaskCheckForTimeOut>
    8000101e:	87aa                	mv	a5,a0
    80001020:	efa1                	bnez	a5,80001078 <xQueueSemaphoreTake+0x15e>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    80001022:	7562                	ld	a0,56(sp)
    80001024:	5fa000ef          	jal	ra,8000161e <prvIsQueueEmpty>
    80001028:	87aa                	mv	a5,a0
    8000102a:	c3a9                	beqz	a5,8000106c <xQueueSemaphoreTake+0x152>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    8000102c:	77e2                	ld	a5,56(sp)
    8000102e:	639c                	ld	a5,0(a5)
    80001030:	eb99                	bnez	a5,80001046 <xQueueSemaphoreTake+0x12c>
                        {
                            taskENTER_CRITICAL();
    80001032:	39a020ef          	jal	ra,800033cc <vTaskEnterCritical>
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    80001036:	77e2                	ld	a5,56(sp)
    80001038:	6b9c                	ld	a5,16(a5)
    8000103a:	853e                	mv	a0,a5
    8000103c:	054020ef          	jal	ra,80003090 <xTaskPriorityInherit>
    80001040:	e0aa                	sd	a0,64(sp)
                            }
                            taskEXIT_CRITICAL();
    80001042:	3b8020ef          	jal	ra,800033fa <vTaskExitCritical>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    80001046:	77e2                	ld	a5,56(sp)
    80001048:	04878793          	addi	a5,a5,72
    8000104c:	6702                	ld	a4,0(sp)
    8000104e:	85ba                	mv	a1,a4
    80001050:	853e                	mv	a0,a5
    80001052:	11d010ef          	jal	ra,8000296e <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    80001056:	7562                	ld	a0,56(sp)
    80001058:	508000ef          	jal	ra,80001560 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    8000105c:	304010ef          	jal	ra,80002360 <xTaskResumeAll>
    80001060:	87aa                	mv	a5,a0
    80001062:	ee079ce3          	bnez	a5,80000f5a <xQueueSemaphoreTake+0x40>
                {
                    portYIELD_WITHIN_API();
    80001066:	00000073          	ecall
    8000106a:	bdc5                	j	80000f5a <xQueueSemaphoreTake+0x40>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    8000106c:	7562                	ld	a0,56(sp)
    8000106e:	4f2000ef          	jal	ra,80001560 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    80001072:	2ee010ef          	jal	ra,80002360 <xTaskResumeAll>
    80001076:	b5d5                	j	80000f5a <xQueueSemaphoreTake+0x40>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    80001078:	7562                	ld	a0,56(sp)
    8000107a:	4e6000ef          	jal	ra,80001560 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    8000107e:	2e2010ef          	jal	ra,80002360 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    80001082:	7562                	ld	a0,56(sp)
    80001084:	59a000ef          	jal	ra,8000161e <prvIsQueueEmpty>
    80001088:	87aa                	mv	a5,a0
    8000108a:	ec0788e3          	beqz	a5,80000f5a <xQueueSemaphoreTake+0x40>
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
    8000108e:	6786                	ld	a5,64(sp)
    80001090:	cf99                	beqz	a5,800010ae <xQueueSemaphoreTake+0x194>
                        {
                            taskENTER_CRITICAL();
    80001092:	33a020ef          	jal	ra,800033cc <vTaskEnterCritical>
                                /* This task blocking on the mutex caused another
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    80001096:	7562                	ld	a0,56(sp)
    80001098:	386000ef          	jal	ra,8000141e <prvGetDisinheritPriorityAfterTimeout>
    8000109c:	f42a                	sd	a0,40(sp)
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    8000109e:	77e2                	ld	a5,56(sp)
    800010a0:	6b9c                	ld	a5,16(a5)
    800010a2:	75a2                	ld	a1,40(sp)
    800010a4:	853e                	mv	a0,a5
    800010a6:	202020ef          	jal	ra,800032a8 <vTaskPriorityDisinheritAfterTimeout>
                            }
                            taskEXIT_CRITICAL();
    800010aa:	350020ef          	jal	ra,800033fa <vTaskExitCritical>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    800010ae:	4781                	li	a5,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    800010b0:	853e                	mv	a0,a5
    800010b2:	60e6                	ld	ra,88(sp)
    800010b4:	6125                	addi	sp,sp,96
    800010b6:	8082                	ret

00000000800010b8 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    800010b8:	711d                	addi	sp,sp,-96
    800010ba:	ec86                	sd	ra,88(sp)
    800010bc:	ec2a                	sd	a0,24(sp)
    800010be:	e82e                	sd	a1,16(sp)
    800010c0:	e432                	sd	a2,8(sp)
    BaseType_t xEntryTimeSet = pdFALSE;
    800010c2:	e482                	sd	zero,72(sp)
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    800010c4:	67e2                	ld	a5,24(sp)
    800010c6:	e0be                	sd	a5,64(sp)

    /* Check the pointer is not NULL. */
    configASSERT( ( pxQueue ) );
    800010c8:	6786                	ld	a5,64(sp)
    800010ca:	e781                	bnez	a5,800010d2 <xQueuePeek+0x1a>
    800010cc:	30047073          	csrci	mstatus,8
    800010d0:	a001                	j	800010d0 <xQueuePeek+0x18>

    /* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer. */
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    800010d2:	67c2                	ld	a5,16(sp)
    800010d4:	e781                	bnez	a5,800010dc <xQueuePeek+0x24>
    800010d6:	6786                	ld	a5,64(sp)
    800010d8:	63dc                	ld	a5,128(a5)
    800010da:	e399                	bnez	a5,800010e0 <xQueuePeek+0x28>
    800010dc:	4785                	li	a5,1
    800010de:	a011                	j	800010e2 <xQueuePeek+0x2a>
    800010e0:	4781                	li	a5,0
    800010e2:	e781                	bnez	a5,800010ea <xQueuePeek+0x32>
    800010e4:	30047073          	csrci	mstatus,8
    800010e8:	a001                	j	800010e8 <xQueuePeek+0x30>

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    800010ea:	777010ef          	jal	ra,80003060 <xTaskGetSchedulerState>
    800010ee:	87aa                	mv	a5,a0
    800010f0:	e399                	bnez	a5,800010f6 <xQueuePeek+0x3e>
    800010f2:	67a2                	ld	a5,8(sp)
    800010f4:	e399                	bnez	a5,800010fa <xQueuePeek+0x42>
    800010f6:	4785                	li	a5,1
    800010f8:	a011                	j	800010fc <xQueuePeek+0x44>
    800010fa:	4781                	li	a5,0
    800010fc:	e781                	bnez	a5,80001104 <xQueuePeek+0x4c>
    800010fe:	30047073          	csrci	mstatus,8
    80001102:	a001                	j	80001102 <xQueuePeek+0x4a>
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    80001104:	2c8020ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    80001108:	6786                	ld	a5,64(sp)
    8000110a:	7bbc                	ld	a5,112(a5)
    8000110c:	fc3e                	sd	a5,56(sp)

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    8000110e:	77e2                	ld	a5,56(sp)
    80001110:	cf85                	beqz	a5,80001148 <xQueuePeek+0x90>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    80001112:	6786                	ld	a5,64(sp)
    80001114:	6f9c                	ld	a5,24(a5)
    80001116:	f83e                	sd	a5,48(sp)

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    80001118:	65c2                	ld	a1,16(sp)
    8000111a:	6506                	ld	a0,64(sp)
    8000111c:	3fa000ef          	jal	ra,80001516 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    80001120:	6786                	ld	a5,64(sp)
    80001122:	7742                	ld	a4,48(sp)
    80001124:	ef98                	sd	a4,24(a5)

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    80001126:	6786                	ld	a5,64(sp)
    80001128:	67bc                	ld	a5,72(a5)
    8000112a:	cb99                	beqz	a5,80001140 <xQueuePeek+0x88>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    8000112c:	6786                	ld	a5,64(sp)
    8000112e:	04878793          	addi	a5,a5,72
    80001132:	853e                	mv	a0,a5
    80001134:	115010ef          	jal	ra,80002a48 <xTaskRemoveFromEventList>
    80001138:	87aa                	mv	a5,a0
    8000113a:	c399                	beqz	a5,80001140 <xQueuePeek+0x88>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    8000113c:	00000073          	ecall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    80001140:	2ba020ef          	jal	ra,800033fa <vTaskExitCritical>
                return pdPASS;
    80001144:	4785                	li	a5,1
    80001146:	a0e9                	j	80001210 <xQueuePeek+0x158>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    80001148:	67a2                	ld	a5,8(sp)
    8000114a:	e789                	bnez	a5,80001154 <xQueuePeek+0x9c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    8000114c:	2ae020ef          	jal	ra,800033fa <vTaskExitCritical>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    80001150:	4781                	li	a5,0
    80001152:	a87d                	j	80001210 <xQueuePeek+0x158>
                }
                else if( xEntryTimeSet == pdFALSE )
    80001154:	67a6                	ld	a5,72(sp)
    80001156:	e799                	bnez	a5,80001164 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    80001158:	101c                	addi	a5,sp,32
    8000115a:	853e                	mv	a0,a5
    8000115c:	2a5010ef          	jal	ra,80002c00 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    80001160:	4785                	li	a5,1
    80001162:	e4be                	sd	a5,72(sp)
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    80001164:	296020ef          	jal	ra,800033fa <vTaskExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    80001168:	1dc010ef          	jal	ra,80002344 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    8000116c:	260020ef          	jal	ra,800033cc <vTaskEnterCritical>
    80001170:	6786                	ld	a5,64(sp)
    80001172:	0887c783          	lbu	a5,136(a5)
    80001176:	0187979b          	slliw	a5,a5,0x18
    8000117a:	4187d79b          	sraiw	a5,a5,0x18
    8000117e:	873e                	mv	a4,a5
    80001180:	57fd                	li	a5,-1
    80001182:	00f71563          	bne	a4,a5,8000118c <xQueuePeek+0xd4>
    80001186:	6786                	ld	a5,64(sp)
    80001188:	08078423          	sb	zero,136(a5)
    8000118c:	6786                	ld	a5,64(sp)
    8000118e:	0897c783          	lbu	a5,137(a5)
    80001192:	0187979b          	slliw	a5,a5,0x18
    80001196:	4187d79b          	sraiw	a5,a5,0x18
    8000119a:	873e                	mv	a4,a5
    8000119c:	57fd                	li	a5,-1
    8000119e:	00f71563          	bne	a4,a5,800011a8 <xQueuePeek+0xf0>
    800011a2:	6786                	ld	a5,64(sp)
    800011a4:	080784a3          	sb	zero,137(a5)
    800011a8:	252020ef          	jal	ra,800033fa <vTaskExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    800011ac:	0038                	addi	a4,sp,8
    800011ae:	101c                	addi	a5,sp,32
    800011b0:	85ba                	mv	a1,a4
    800011b2:	853e                	mv	a0,a5
    800011b4:	273010ef          	jal	ra,80002c26 <xTaskCheckForTimeOut>
    800011b8:	87aa                	mv	a5,a0
    800011ba:	ef9d                	bnez	a5,800011f8 <xQueuePeek+0x140>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    800011bc:	6506                	ld	a0,64(sp)
    800011be:	460000ef          	jal	ra,8000161e <prvIsQueueEmpty>
    800011c2:	87aa                	mv	a5,a0
    800011c4:	c785                	beqz	a5,800011ec <xQueuePeek+0x134>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    800011c6:	6786                	ld	a5,64(sp)
    800011c8:	04878793          	addi	a5,a5,72
    800011cc:	6722                	ld	a4,8(sp)
    800011ce:	85ba                	mv	a1,a4
    800011d0:	853e                	mv	a0,a5
    800011d2:	79c010ef          	jal	ra,8000296e <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    800011d6:	6506                	ld	a0,64(sp)
    800011d8:	388000ef          	jal	ra,80001560 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    800011dc:	184010ef          	jal	ra,80002360 <xTaskResumeAll>
    800011e0:	87aa                	mv	a5,a0
    800011e2:	f20791e3          	bnez	a5,80001104 <xQueuePeek+0x4c>
                {
                    portYIELD_WITHIN_API();
    800011e6:	00000073          	ecall
    800011ea:	bf29                	j	80001104 <xQueuePeek+0x4c>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    800011ec:	6506                	ld	a0,64(sp)
    800011ee:	372000ef          	jal	ra,80001560 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    800011f2:	16e010ef          	jal	ra,80002360 <xTaskResumeAll>
    800011f6:	b739                	j	80001104 <xQueuePeek+0x4c>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    800011f8:	6506                	ld	a0,64(sp)
    800011fa:	366000ef          	jal	ra,80001560 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    800011fe:	162010ef          	jal	ra,80002360 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    80001202:	6506                	ld	a0,64(sp)
    80001204:	41a000ef          	jal	ra,8000161e <prvIsQueueEmpty>
    80001208:	87aa                	mv	a5,a0
    8000120a:	ee078de3          	beqz	a5,80001104 <xQueuePeek+0x4c>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    8000120e:	4781                	li	a5,0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    80001210:	853e                	mv	a0,a5
    80001212:	60e6                	ld	ra,88(sp)
    80001214:	6125                	addi	sp,sp,96
    80001216:	8082                	ret

0000000080001218 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    80001218:	711d                	addi	sp,sp,-96
    8000121a:	ec86                	sd	ra,88(sp)
    8000121c:	ec2a                	sd	a0,24(sp)
    8000121e:	e82e                	sd	a1,16(sp)
    80001220:	e432                	sd	a2,8(sp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    80001222:	67e2                	ld	a5,24(sp)
    80001224:	e0be                	sd	a5,64(sp)

    configASSERT( pxQueue );
    80001226:	6786                	ld	a5,64(sp)
    80001228:	e781                	bnez	a5,80001230 <xQueueReceiveFromISR+0x18>
    8000122a:	30047073          	csrci	mstatus,8
    8000122e:	a001                	j	8000122e <xQueueReceiveFromISR+0x16>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    80001230:	67c2                	ld	a5,16(sp)
    80001232:	e781                	bnez	a5,8000123a <xQueueReceiveFromISR+0x22>
    80001234:	6786                	ld	a5,64(sp)
    80001236:	63dc                	ld	a5,128(a5)
    80001238:	e399                	bnez	a5,8000123e <xQueueReceiveFromISR+0x26>
    8000123a:	4785                	li	a5,1
    8000123c:	a011                	j	80001240 <xQueueReceiveFromISR+0x28>
    8000123e:	4781                	li	a5,0
    80001240:	e781                	bnez	a5,80001248 <xQueueReceiveFromISR+0x30>
    80001242:	30047073          	csrci	mstatus,8
    80001246:	a001                	j	80001246 <xQueueReceiveFromISR+0x2e>
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    80001248:	fc02                	sd	zero,56(sp)
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    8000124a:	6786                	ld	a5,64(sp)
    8000124c:	7bbc                	ld	a5,112(a5)
    8000124e:	f83e                	sd	a5,48(sp)

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    80001250:	77c2                	ld	a5,48(sp)
    80001252:	c3d1                	beqz	a5,800012d6 <xQueueReceiveFromISR+0xbe>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    80001254:	6786                	ld	a5,64(sp)
    80001256:	0887c783          	lbu	a5,136(a5)
    8000125a:	02f107a3          	sb	a5,47(sp)

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    8000125e:	65c2                	ld	a1,16(sp)
    80001260:	6506                	ld	a0,64(sp)
    80001262:	2b4000ef          	jal	ra,80001516 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    80001266:	77c2                	ld	a5,48(sp)
    80001268:	fff78713          	addi	a4,a5,-1
    8000126c:	6786                	ld	a5,64(sp)
    8000126e:	fbb8                	sd	a4,112(a5)

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    80001270:	02f14783          	lbu	a5,47(sp)
    80001274:	0ff7f713          	andi	a4,a5,255
    80001278:	0ff00793          	li	a5,255
    8000127c:	02f71363          	bne	a4,a5,800012a2 <xQueueReceiveFromISR+0x8a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    80001280:	6786                	ld	a5,64(sp)
    80001282:	739c                	ld	a5,32(a5)
    80001284:	c7b1                	beqz	a5,800012d0 <xQueueReceiveFromISR+0xb8>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    80001286:	6786                	ld	a5,64(sp)
    80001288:	02078793          	addi	a5,a5,32
    8000128c:	853e                	mv	a0,a5
    8000128e:	7ba010ef          	jal	ra,80002a48 <xTaskRemoveFromEventList>
    80001292:	87aa                	mv	a5,a0
    80001294:	cf95                	beqz	a5,800012d0 <xQueueReceiveFromISR+0xb8>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    80001296:	67a2                	ld	a5,8(sp)
    80001298:	cf85                	beqz	a5,800012d0 <xQueueReceiveFromISR+0xb8>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    8000129a:	67a2                	ld	a5,8(sp)
    8000129c:	4705                	li	a4,1
    8000129e:	e398                	sd	a4,0(a5)
    800012a0:	a805                	j	800012d0 <xQueueReceiveFromISR+0xb8>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );
    800012a2:	02f14783          	lbu	a5,47(sp)
    800012a6:	0ff7f713          	andi	a4,a5,255
    800012aa:	07f00793          	li	a5,127
    800012ae:	00f71563          	bne	a4,a5,800012b8 <xQueueReceiveFromISR+0xa0>
    800012b2:	30047073          	csrci	mstatus,8
    800012b6:	a001                	j	800012b6 <xQueueReceiveFromISR+0x9e>

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    800012b8:	02f14783          	lbu	a5,47(sp)
    800012bc:	2785                	addiw	a5,a5,1
    800012be:	0ff7f793          	andi	a5,a5,255
    800012c2:	0187971b          	slliw	a4,a5,0x18
    800012c6:	4187571b          	sraiw	a4,a4,0x18
    800012ca:	6786                	ld	a5,64(sp)
    800012cc:	08e78423          	sb	a4,136(a5)
            }

            xReturn = pdPASS;
    800012d0:	4785                	li	a5,1
    800012d2:	e4be                	sd	a5,72(sp)
    800012d4:	a011                	j	800012d8 <xQueueReceiveFromISR+0xc0>
        }
        else
        {
            xReturn = pdFAIL;
    800012d6:	e482                	sd	zero,72(sp)
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    800012d8:	67a6                	ld	a5,72(sp)
}
    800012da:	853e                	mv	a0,a5
    800012dc:	60e6                	ld	ra,88(sp)
    800012de:	6125                	addi	sp,sp,96
    800012e0:	8082                	ret

00000000800012e2 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    800012e2:	7139                	addi	sp,sp,-64
    800012e4:	fc06                	sd	ra,56(sp)
    800012e6:	e42a                	sd	a0,8(sp)
    800012e8:	e02e                	sd	a1,0(sp)
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    800012ea:	67a2                	ld	a5,8(sp)
    800012ec:	f03e                	sd	a5,32(sp)

    configASSERT( pxQueue );
    800012ee:	7782                	ld	a5,32(sp)
    800012f0:	e781                	bnez	a5,800012f8 <xQueuePeekFromISR+0x16>
    800012f2:	30047073          	csrci	mstatus,8
    800012f6:	a001                	j	800012f6 <xQueuePeekFromISR+0x14>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    800012f8:	6782                	ld	a5,0(sp)
    800012fa:	e781                	bnez	a5,80001302 <xQueuePeekFromISR+0x20>
    800012fc:	7782                	ld	a5,32(sp)
    800012fe:	63dc                	ld	a5,128(a5)
    80001300:	e399                	bnez	a5,80001306 <xQueuePeekFromISR+0x24>
    80001302:	4785                	li	a5,1
    80001304:	a011                	j	80001308 <xQueuePeekFromISR+0x26>
    80001306:	4781                	li	a5,0
    80001308:	e781                	bnez	a5,80001310 <xQueuePeekFromISR+0x2e>
    8000130a:	30047073          	csrci	mstatus,8
    8000130e:	a001                	j	8000130e <xQueuePeekFromISR+0x2c>
    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
    80001310:	7782                	ld	a5,32(sp)
    80001312:	63dc                	ld	a5,128(a5)
    80001314:	e781                	bnez	a5,8000131c <xQueuePeekFromISR+0x3a>
    80001316:	30047073          	csrci	mstatus,8
    8000131a:	a001                	j	8000131a <xQueuePeekFromISR+0x38>
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    8000131c:	ec02                	sd	zero,24(sp)
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    8000131e:	7782                	ld	a5,32(sp)
    80001320:	7bbc                	ld	a5,112(a5)
    80001322:	cf91                	beqz	a5,8000133e <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    80001324:	7782                	ld	a5,32(sp)
    80001326:	6f9c                	ld	a5,24(a5)
    80001328:	e83e                	sd	a5,16(sp)
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    8000132a:	6582                	ld	a1,0(sp)
    8000132c:	7502                	ld	a0,32(sp)
    8000132e:	1e8000ef          	jal	ra,80001516 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    80001332:	7782                	ld	a5,32(sp)
    80001334:	6742                	ld	a4,16(sp)
    80001336:	ef98                	sd	a4,24(a5)

            xReturn = pdPASS;
    80001338:	4785                	li	a5,1
    8000133a:	f43e                	sd	a5,40(sp)
    8000133c:	a011                	j	80001340 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    8000133e:	f402                	sd	zero,40(sp)
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    80001340:	77a2                	ld	a5,40(sp)
}
    80001342:	853e                	mv	a0,a5
    80001344:	70e2                	ld	ra,56(sp)
    80001346:	6121                	addi	sp,sp,64
    80001348:	8082                	ret

000000008000134a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    8000134a:	7179                	addi	sp,sp,-48
    8000134c:	f406                	sd	ra,40(sp)
    8000134e:	e42a                	sd	a0,8(sp)
    UBaseType_t uxReturn;

    configASSERT( xQueue );
    80001350:	67a2                	ld	a5,8(sp)
    80001352:	e781                	bnez	a5,8000135a <uxQueueMessagesWaiting+0x10>
    80001354:	30047073          	csrci	mstatus,8
    80001358:	a001                	j	80001358 <uxQueueMessagesWaiting+0xe>

    taskENTER_CRITICAL();
    8000135a:	072020ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    8000135e:	67a2                	ld	a5,8(sp)
    80001360:	7bbc                	ld	a5,112(a5)
    80001362:	ec3e                	sd	a5,24(sp)
    }
    taskEXIT_CRITICAL();
    80001364:	096020ef          	jal	ra,800033fa <vTaskExitCritical>

    return uxReturn;
    80001368:	67e2                	ld	a5,24(sp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    8000136a:	853e                	mv	a0,a5
    8000136c:	70a2                	ld	ra,40(sp)
    8000136e:	6145                	addi	sp,sp,48
    80001370:	8082                	ret

0000000080001372 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    80001372:	7179                	addi	sp,sp,-48
    80001374:	f406                	sd	ra,40(sp)
    80001376:	e42a                	sd	a0,8(sp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    80001378:	67a2                	ld	a5,8(sp)
    8000137a:	ec3e                	sd	a5,24(sp)

    configASSERT( pxQueue );
    8000137c:	67e2                	ld	a5,24(sp)
    8000137e:	e781                	bnez	a5,80001386 <uxQueueSpacesAvailable+0x14>
    80001380:	30047073          	csrci	mstatus,8
    80001384:	a001                	j	80001384 <uxQueueSpacesAvailable+0x12>

    taskENTER_CRITICAL();
    80001386:	046020ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    8000138a:	67e2                	ld	a5,24(sp)
    8000138c:	7fb8                	ld	a4,120(a5)
    8000138e:	67e2                	ld	a5,24(sp)
    80001390:	7bbc                	ld	a5,112(a5)
    80001392:	40f707b3          	sub	a5,a4,a5
    80001396:	e83e                	sd	a5,16(sp)
    }
    taskEXIT_CRITICAL();
    80001398:	062020ef          	jal	ra,800033fa <vTaskExitCritical>

    return uxReturn;
    8000139c:	67c2                	ld	a5,16(sp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    8000139e:	853e                	mv	a0,a5
    800013a0:	70a2                	ld	ra,40(sp)
    800013a2:	6145                	addi	sp,sp,48
    800013a4:	8082                	ret

00000000800013a6 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    800013a6:	1101                	addi	sp,sp,-32
    800013a8:	e42a                	sd	a0,8(sp)
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    800013aa:	67a2                	ld	a5,8(sp)
    800013ac:	ec3e                	sd	a5,24(sp)

    configASSERT( pxQueue );
    800013ae:	67e2                	ld	a5,24(sp)
    800013b0:	e781                	bnez	a5,800013b8 <uxQueueMessagesWaitingFromISR+0x12>
    800013b2:	30047073          	csrci	mstatus,8
    800013b6:	a001                	j	800013b6 <uxQueueMessagesWaitingFromISR+0x10>
    uxReturn = pxQueue->uxMessagesWaiting;
    800013b8:	67e2                	ld	a5,24(sp)
    800013ba:	7bbc                	ld	a5,112(a5)
    800013bc:	e83e                	sd	a5,16(sp)

    return uxReturn;
    800013be:	67c2                	ld	a5,16(sp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    800013c0:	853e                	mv	a0,a5
    800013c2:	6105                	addi	sp,sp,32
    800013c4:	8082                	ret

00000000800013c6 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    800013c6:	7179                	addi	sp,sp,-48
    800013c8:	f406                	sd	ra,40(sp)
    800013ca:	e42a                	sd	a0,8(sp)
    Queue_t * const pxQueue = xQueue;
    800013cc:	67a2                	ld	a5,8(sp)
    800013ce:	ec3e                	sd	a5,24(sp)

    configASSERT( pxQueue );
    800013d0:	67e2                	ld	a5,24(sp)
    800013d2:	e781                	bnez	a5,800013da <vQueueDelete+0x14>
    800013d4:	30047073          	csrci	mstatus,8
    800013d8:	a001                	j	800013d8 <vQueueDelete+0x12>
    traceQUEUE_DELETE( pxQueue );

    #if ( configQUEUE_REGISTRY_SIZE > 0 )
        {
            vQueueUnregisterQueue( pxQueue );
    800013da:	6562                	ld	a0,24(sp)
    800013dc:	38c000ef          	jal	ra,80001768 <vQueueUnregisterQueue>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    800013e0:	6562                	ld	a0,24(sp)
    800013e2:	7b0030ef          	jal	ra,80004b92 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    800013e6:	0001                	nop
    800013e8:	70a2                	ld	ra,40(sp)
    800013ea:	6145                	addi	sp,sp,48
    800013ec:	8082                	ret

00000000800013ee <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
    {
    800013ee:	1141                	addi	sp,sp,-16
    800013f0:	e42a                	sd	a0,8(sp)
        return ( ( Queue_t * ) xQueue )->uxQueueNumber;
    800013f2:	67a2                	ld	a5,8(sp)
    800013f4:	6bdc                	ld	a5,144(a5)
    }
    800013f6:	853e                	mv	a0,a5
    800013f8:	0141                	addi	sp,sp,16
    800013fa:	8082                	ret

00000000800013fc <vQueueSetQueueNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

    void vQueueSetQueueNumber( QueueHandle_t xQueue,
                               UBaseType_t uxQueueNumber )
    {
    800013fc:	1141                	addi	sp,sp,-16
    800013fe:	e42a                	sd	a0,8(sp)
    80001400:	e02e                	sd	a1,0(sp)
        ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
    80001402:	67a2                	ld	a5,8(sp)
    80001404:	6702                	ld	a4,0(sp)
    80001406:	ebd8                	sd	a4,144(a5)
    }
    80001408:	0001                	nop
    8000140a:	0141                	addi	sp,sp,16
    8000140c:	8082                	ret

000000008000140e <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
    {
    8000140e:	1141                	addi	sp,sp,-16
    80001410:	e42a                	sd	a0,8(sp)
        return ( ( Queue_t * ) xQueue )->ucQueueType;
    80001412:	67a2                	ld	a5,8(sp)
    80001414:	0987c783          	lbu	a5,152(a5)
    }
    80001418:	853e                	mv	a0,a5
    8000141a:	0141                	addi	sp,sp,16
    8000141c:	8082                	ret

000000008000141e <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
    8000141e:	1101                	addi	sp,sp,-32
    80001420:	e42a                	sd	a0,8(sp)
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    80001422:	67a2                	ld	a5,8(sp)
    80001424:	67bc                	ld	a5,72(a5)
    80001426:	cb89                	beqz	a5,80001438 <prvGetDisinheritPriorityAfterTimeout+0x1a>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    80001428:	67a2                	ld	a5,8(sp)
    8000142a:	73bc                	ld	a5,96(a5)
    8000142c:	639c                	ld	a5,0(a5)
    8000142e:	4715                	li	a4,5
    80001430:	40f707b3          	sub	a5,a4,a5
    80001434:	ec3e                	sd	a5,24(sp)
    80001436:	a011                	j	8000143a <prvGetDisinheritPriorityAfterTimeout+0x1c>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    80001438:	ec02                	sd	zero,24(sp)
        }

        return uxHighestPriorityOfWaitingTasks;
    8000143a:	67e2                	ld	a5,24(sp)
    }
    8000143c:	853e                	mv	a0,a5
    8000143e:	6105                	addi	sp,sp,32
    80001440:	8082                	ret

0000000080001442 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    80001442:	7139                	addi	sp,sp,-64
    80001444:	fc06                	sd	ra,56(sp)
    80001446:	ec2a                	sd	a0,24(sp)
    80001448:	e82e                	sd	a1,16(sp)
    8000144a:	e432                	sd	a2,8(sp)
    BaseType_t xReturn = pdFALSE;
    8000144c:	f402                	sd	zero,40(sp)
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    8000144e:	67e2                	ld	a5,24(sp)
    80001450:	7bbc                	ld	a5,112(a5)
    80001452:	f03e                	sd	a5,32(sp)

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    80001454:	67e2                	ld	a5,24(sp)
    80001456:	63dc                	ld	a5,128(a5)
    80001458:	ef91                	bnez	a5,80001474 <prvCopyDataToQueue+0x32>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    8000145a:	67e2                	ld	a5,24(sp)
    8000145c:	639c                	ld	a5,0(a5)
    8000145e:	e3d5                	bnez	a5,80001502 <prvCopyDataToQueue+0xc0>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    80001460:	67e2                	ld	a5,24(sp)
    80001462:	6b9c                	ld	a5,16(a5)
    80001464:	853e                	mv	a0,a5
    80001466:	555010ef          	jal	ra,800031ba <xTaskPriorityDisinherit>
    8000146a:	f42a                	sd	a0,40(sp)
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
    8000146c:	67e2                	ld	a5,24(sp)
    8000146e:	0007b823          	sd	zero,16(a5)
    80001472:	a841                	j	80001502 <prvCopyDataToQueue+0xc0>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    80001474:	67a2                	ld	a5,8(sp)
    80001476:	ef85                	bnez	a5,800014ae <prvCopyDataToQueue+0x6c>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    80001478:	67e2                	ld	a5,24(sp)
    8000147a:	6798                	ld	a4,8(a5)
    8000147c:	67e2                	ld	a5,24(sp)
    8000147e:	63dc                	ld	a5,128(a5)
    80001480:	863e                	mv	a2,a5
    80001482:	65c2                	ld	a1,16(sp)
    80001484:	853a                	mv	a0,a4
    80001486:	7d3060ef          	jal	ra,80008458 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    8000148a:	67e2                	ld	a5,24(sp)
    8000148c:	6798                	ld	a4,8(a5)
    8000148e:	67e2                	ld	a5,24(sp)
    80001490:	63dc                	ld	a5,128(a5)
    80001492:	973e                	add	a4,a4,a5
    80001494:	67e2                	ld	a5,24(sp)
    80001496:	e798                	sd	a4,8(a5)

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    80001498:	67e2                	ld	a5,24(sp)
    8000149a:	6798                	ld	a4,8(a5)
    8000149c:	67e2                	ld	a5,24(sp)
    8000149e:	6b9c                	ld	a5,16(a5)
    800014a0:	06f76163          	bltu	a4,a5,80001502 <prvCopyDataToQueue+0xc0>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    800014a4:	67e2                	ld	a5,24(sp)
    800014a6:	6398                	ld	a4,0(a5)
    800014a8:	67e2                	ld	a5,24(sp)
    800014aa:	e798                	sd	a4,8(a5)
    800014ac:	a899                	j	80001502 <prvCopyDataToQueue+0xc0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    800014ae:	67e2                	ld	a5,24(sp)
    800014b0:	6f98                	ld	a4,24(a5)
    800014b2:	67e2                	ld	a5,24(sp)
    800014b4:	63dc                	ld	a5,128(a5)
    800014b6:	863e                	mv	a2,a5
    800014b8:	65c2                	ld	a1,16(sp)
    800014ba:	853a                	mv	a0,a4
    800014bc:	79d060ef          	jal	ra,80008458 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    800014c0:	67e2                	ld	a5,24(sp)
    800014c2:	6f98                	ld	a4,24(a5)
    800014c4:	67e2                	ld	a5,24(sp)
    800014c6:	63dc                	ld	a5,128(a5)
    800014c8:	40f007b3          	neg	a5,a5
    800014cc:	973e                	add	a4,a4,a5
    800014ce:	67e2                	ld	a5,24(sp)
    800014d0:	ef98                	sd	a4,24(a5)

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    800014d2:	67e2                	ld	a5,24(sp)
    800014d4:	6f98                	ld	a4,24(a5)
    800014d6:	67e2                	ld	a5,24(sp)
    800014d8:	639c                	ld	a5,0(a5)
    800014da:	00f77b63          	bgeu	a4,a5,800014f0 <prvCopyDataToQueue+0xae>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    800014de:	67e2                	ld	a5,24(sp)
    800014e0:	6b98                	ld	a4,16(a5)
    800014e2:	67e2                	ld	a5,24(sp)
    800014e4:	63dc                	ld	a5,128(a5)
    800014e6:	40f007b3          	neg	a5,a5
    800014ea:	973e                	add	a4,a4,a5
    800014ec:	67e2                	ld	a5,24(sp)
    800014ee:	ef98                	sd	a4,24(a5)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    800014f0:	6722                	ld	a4,8(sp)
    800014f2:	4789                	li	a5,2
    800014f4:	00f71763          	bne	a4,a5,80001502 <prvCopyDataToQueue+0xc0>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    800014f8:	7782                	ld	a5,32(sp)
    800014fa:	c781                	beqz	a5,80001502 <prvCopyDataToQueue+0xc0>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    800014fc:	7782                	ld	a5,32(sp)
    800014fe:	17fd                	addi	a5,a5,-1
    80001500:	f03e                	sd	a5,32(sp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    80001502:	7782                	ld	a5,32(sp)
    80001504:	00178713          	addi	a4,a5,1
    80001508:	67e2                	ld	a5,24(sp)
    8000150a:	fbb8                	sd	a4,112(a5)

    return xReturn;
    8000150c:	77a2                	ld	a5,40(sp)
}
    8000150e:	853e                	mv	a0,a5
    80001510:	70e2                	ld	ra,56(sp)
    80001512:	6121                	addi	sp,sp,64
    80001514:	8082                	ret

0000000080001516 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    80001516:	1101                	addi	sp,sp,-32
    80001518:	ec06                	sd	ra,24(sp)
    8000151a:	e42a                	sd	a0,8(sp)
    8000151c:	e02e                	sd	a1,0(sp)
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    8000151e:	67a2                	ld	a5,8(sp)
    80001520:	63dc                	ld	a5,128(a5)
    80001522:	cb9d                	beqz	a5,80001558 <prvCopyDataFromQueue+0x42>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    80001524:	67a2                	ld	a5,8(sp)
    80001526:	6f98                	ld	a4,24(a5)
    80001528:	67a2                	ld	a5,8(sp)
    8000152a:	63dc                	ld	a5,128(a5)
    8000152c:	973e                	add	a4,a4,a5
    8000152e:	67a2                	ld	a5,8(sp)
    80001530:	ef98                	sd	a4,24(a5)

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    80001532:	67a2                	ld	a5,8(sp)
    80001534:	6f98                	ld	a4,24(a5)
    80001536:	67a2                	ld	a5,8(sp)
    80001538:	6b9c                	ld	a5,16(a5)
    8000153a:	00f76663          	bltu	a4,a5,80001546 <prvCopyDataFromQueue+0x30>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    8000153e:	67a2                	ld	a5,8(sp)
    80001540:	6398                	ld	a4,0(a5)
    80001542:	67a2                	ld	a5,8(sp)
    80001544:	ef98                	sd	a4,24(a5)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    80001546:	67a2                	ld	a5,8(sp)
    80001548:	6f98                	ld	a4,24(a5)
    8000154a:	67a2                	ld	a5,8(sp)
    8000154c:	63dc                	ld	a5,128(a5)
    8000154e:	863e                	mv	a2,a5
    80001550:	85ba                	mv	a1,a4
    80001552:	6502                	ld	a0,0(sp)
    80001554:	705060ef          	jal	ra,80008458 <memcpy>
    }
}
    80001558:	0001                	nop
    8000155a:	60e2                	ld	ra,24(sp)
    8000155c:	6105                	addi	sp,sp,32
    8000155e:	8082                	ret

0000000080001560 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    80001560:	7179                	addi	sp,sp,-48
    80001562:	f406                	sd	ra,40(sp)
    80001564:	e42a                	sd	a0,8(sp)

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    80001566:	667010ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
    8000156a:	67a2                	ld	a5,8(sp)
    8000156c:	0897c783          	lbu	a5,137(a5)
    80001570:	00f10fa3          	sb	a5,31(sp)

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    80001574:	a02d                	j	8000159e <prvUnlockQueue+0x3e>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    80001576:	67a2                	ld	a5,8(sp)
    80001578:	67bc                	ld	a5,72(a5)
    8000157a:	cb9d                	beqz	a5,800015b0 <prvUnlockQueue+0x50>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    8000157c:	67a2                	ld	a5,8(sp)
    8000157e:	04878793          	addi	a5,a5,72
    80001582:	853e                	mv	a0,a5
    80001584:	4c4010ef          	jal	ra,80002a48 <xTaskRemoveFromEventList>
    80001588:	87aa                	mv	a5,a0
    8000158a:	c399                	beqz	a5,80001590 <prvUnlockQueue+0x30>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    8000158c:	740010ef          	jal	ra,80002ccc <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    80001590:	01f14783          	lbu	a5,31(sp)
    80001594:	37fd                	addiw	a5,a5,-1
    80001596:	0ff7f793          	andi	a5,a5,255
    8000159a:	00f10fa3          	sb	a5,31(sp)
        while( cTxLock > queueLOCKED_UNMODIFIED )
    8000159e:	01f14783          	lbu	a5,31(sp)
    800015a2:	0187979b          	slliw	a5,a5,0x18
    800015a6:	4187d79b          	sraiw	a5,a5,0x18
    800015aa:	fcf046e3          	bgtz	a5,80001576 <prvUnlockQueue+0x16>
    800015ae:	a011                	j	800015b2 <prvUnlockQueue+0x52>
                        break;
    800015b0:	0001                	nop
        }

        pxQueue->cTxLock = queueUNLOCKED;
    800015b2:	67a2                	ld	a5,8(sp)
    800015b4:	577d                	li	a4,-1
    800015b6:	08e784a3          	sb	a4,137(a5)
    }
    taskEXIT_CRITICAL();
    800015ba:	641010ef          	jal	ra,800033fa <vTaskExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    800015be:	60f010ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
    800015c2:	67a2                	ld	a5,8(sp)
    800015c4:	0887c783          	lbu	a5,136(a5)
    800015c8:	00f10f23          	sb	a5,30(sp)

        while( cRxLock > queueLOCKED_UNMODIFIED )
    800015cc:	a02d                	j	800015f6 <prvUnlockQueue+0x96>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    800015ce:	67a2                	ld	a5,8(sp)
    800015d0:	739c                	ld	a5,32(a5)
    800015d2:	cb9d                	beqz	a5,80001608 <prvUnlockQueue+0xa8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    800015d4:	67a2                	ld	a5,8(sp)
    800015d6:	02078793          	addi	a5,a5,32
    800015da:	853e                	mv	a0,a5
    800015dc:	46c010ef          	jal	ra,80002a48 <xTaskRemoveFromEventList>
    800015e0:	87aa                	mv	a5,a0
    800015e2:	c399                	beqz	a5,800015e8 <prvUnlockQueue+0x88>
                {
                    vTaskMissedYield();
    800015e4:	6e8010ef          	jal	ra,80002ccc <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    800015e8:	01e14783          	lbu	a5,30(sp)
    800015ec:	37fd                	addiw	a5,a5,-1
    800015ee:	0ff7f793          	andi	a5,a5,255
    800015f2:	00f10f23          	sb	a5,30(sp)
        while( cRxLock > queueLOCKED_UNMODIFIED )
    800015f6:	01e14783          	lbu	a5,30(sp)
    800015fa:	0187979b          	slliw	a5,a5,0x18
    800015fe:	4187d79b          	sraiw	a5,a5,0x18
    80001602:	fcf046e3          	bgtz	a5,800015ce <prvUnlockQueue+0x6e>
    80001606:	a011                	j	8000160a <prvUnlockQueue+0xaa>
            }
            else
            {
                break;
    80001608:	0001                	nop
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    8000160a:	67a2                	ld	a5,8(sp)
    8000160c:	577d                	li	a4,-1
    8000160e:	08e78423          	sb	a4,136(a5)
    }
    taskEXIT_CRITICAL();
    80001612:	5e9010ef          	jal	ra,800033fa <vTaskExitCritical>
}
    80001616:	0001                	nop
    80001618:	70a2                	ld	ra,40(sp)
    8000161a:	6145                	addi	sp,sp,48
    8000161c:	8082                	ret

000000008000161e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    8000161e:	7179                	addi	sp,sp,-48
    80001620:	f406                	sd	ra,40(sp)
    80001622:	e42a                	sd	a0,8(sp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    80001624:	5a9010ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    80001628:	67a2                	ld	a5,8(sp)
    8000162a:	7bbc                	ld	a5,112(a5)
    8000162c:	e781                	bnez	a5,80001634 <prvIsQueueEmpty+0x16>
        {
            xReturn = pdTRUE;
    8000162e:	4785                	li	a5,1
    80001630:	ec3e                	sd	a5,24(sp)
    80001632:	a011                	j	80001636 <prvIsQueueEmpty+0x18>
        }
        else
        {
            xReturn = pdFALSE;
    80001634:	ec02                	sd	zero,24(sp)
        }
    }
    taskEXIT_CRITICAL();
    80001636:	5c5010ef          	jal	ra,800033fa <vTaskExitCritical>

    return xReturn;
    8000163a:	67e2                	ld	a5,24(sp)
}
    8000163c:	853e                	mv	a0,a5
    8000163e:	70a2                	ld	ra,40(sp)
    80001640:	6145                	addi	sp,sp,48
    80001642:	8082                	ret

0000000080001644 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    80001644:	1101                	addi	sp,sp,-32
    80001646:	e42a                	sd	a0,8(sp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    80001648:	67a2                	ld	a5,8(sp)
    8000164a:	e83e                	sd	a5,16(sp)

    configASSERT( pxQueue );
    8000164c:	67c2                	ld	a5,16(sp)
    8000164e:	e781                	bnez	a5,80001656 <xQueueIsQueueEmptyFromISR+0x12>
    80001650:	30047073          	csrci	mstatus,8
    80001654:	a001                	j	80001654 <xQueueIsQueueEmptyFromISR+0x10>

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    80001656:	67c2                	ld	a5,16(sp)
    80001658:	7bbc                	ld	a5,112(a5)
    8000165a:	e781                	bnez	a5,80001662 <xQueueIsQueueEmptyFromISR+0x1e>
    {
        xReturn = pdTRUE;
    8000165c:	4785                	li	a5,1
    8000165e:	ec3e                	sd	a5,24(sp)
    80001660:	a011                	j	80001664 <xQueueIsQueueEmptyFromISR+0x20>
    }
    else
    {
        xReturn = pdFALSE;
    80001662:	ec02                	sd	zero,24(sp)
    }

    return xReturn;
    80001664:	67e2                	ld	a5,24(sp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    80001666:	853e                	mv	a0,a5
    80001668:	6105                	addi	sp,sp,32
    8000166a:	8082                	ret

000000008000166c <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    8000166c:	7179                	addi	sp,sp,-48
    8000166e:	f406                	sd	ra,40(sp)
    80001670:	e42a                	sd	a0,8(sp)
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    80001672:	55b010ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    80001676:	67a2                	ld	a5,8(sp)
    80001678:	7bb8                	ld	a4,112(a5)
    8000167a:	67a2                	ld	a5,8(sp)
    8000167c:	7fbc                	ld	a5,120(a5)
    8000167e:	00f71563          	bne	a4,a5,80001688 <prvIsQueueFull+0x1c>
        {
            xReturn = pdTRUE;
    80001682:	4785                	li	a5,1
    80001684:	ec3e                	sd	a5,24(sp)
    80001686:	a011                	j	8000168a <prvIsQueueFull+0x1e>
        }
        else
        {
            xReturn = pdFALSE;
    80001688:	ec02                	sd	zero,24(sp)
        }
    }
    taskEXIT_CRITICAL();
    8000168a:	571010ef          	jal	ra,800033fa <vTaskExitCritical>

    return xReturn;
    8000168e:	67e2                	ld	a5,24(sp)
}
    80001690:	853e                	mv	a0,a5
    80001692:	70a2                	ld	ra,40(sp)
    80001694:	6145                	addi	sp,sp,48
    80001696:	8082                	ret

0000000080001698 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    80001698:	1101                	addi	sp,sp,-32
    8000169a:	e42a                	sd	a0,8(sp)
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    8000169c:	67a2                	ld	a5,8(sp)
    8000169e:	e83e                	sd	a5,16(sp)

    configASSERT( pxQueue );
    800016a0:	67c2                	ld	a5,16(sp)
    800016a2:	e781                	bnez	a5,800016aa <xQueueIsQueueFullFromISR+0x12>
    800016a4:	30047073          	csrci	mstatus,8
    800016a8:	a001                	j	800016a8 <xQueueIsQueueFullFromISR+0x10>

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    800016aa:	67c2                	ld	a5,16(sp)
    800016ac:	7bb8                	ld	a4,112(a5)
    800016ae:	67c2                	ld	a5,16(sp)
    800016b0:	7fbc                	ld	a5,120(a5)
    800016b2:	00f71563          	bne	a4,a5,800016bc <xQueueIsQueueFullFromISR+0x24>
    {
        xReturn = pdTRUE;
    800016b6:	4785                	li	a5,1
    800016b8:	ec3e                	sd	a5,24(sp)
    800016ba:	a011                	j	800016be <xQueueIsQueueFullFromISR+0x26>
    }
    else
    {
        xReturn = pdFALSE;
    800016bc:	ec02                	sd	zero,24(sp)
    }

    return xReturn;
    800016be:	67e2                	ld	a5,24(sp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    800016c0:	853e                	mv	a0,a5
    800016c2:	6105                	addi	sp,sp,32
    800016c4:	8082                	ret

00000000800016c6 <vQueueAddToRegistry>:

#if ( configQUEUE_REGISTRY_SIZE > 0 )

    void vQueueAddToRegistry( QueueHandle_t xQueue,
                              const char * pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    800016c6:	1101                	addi	sp,sp,-32
    800016c8:	e42a                	sd	a0,8(sp)
    800016ca:	e02e                	sd	a1,0(sp)
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    800016cc:	ec02                	sd	zero,24(sp)
    800016ce:	a081                	j	8000170e <vQueueAddToRegistry+0x48>
        {
            if( xQueueRegistry[ ux ].pcQueueName == NULL )
    800016d0:	00105717          	auipc	a4,0x105
    800016d4:	71070713          	addi	a4,a4,1808 # 80106de0 <xQueueRegistry>
    800016d8:	67e2                	ld	a5,24(sp)
    800016da:	0792                	slli	a5,a5,0x4
    800016dc:	97ba                	add	a5,a5,a4
    800016de:	639c                	ld	a5,0(a5)
    800016e0:	e785                	bnez	a5,80001708 <vQueueAddToRegistry+0x42>
            {
                /* Store the information on this queue. */
                xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    800016e2:	00105717          	auipc	a4,0x105
    800016e6:	6fe70713          	addi	a4,a4,1790 # 80106de0 <xQueueRegistry>
    800016ea:	67e2                	ld	a5,24(sp)
    800016ec:	0792                	slli	a5,a5,0x4
    800016ee:	97ba                	add	a5,a5,a4
    800016f0:	6702                	ld	a4,0(sp)
    800016f2:	e398                	sd	a4,0(a5)
                xQueueRegistry[ ux ].xHandle = xQueue;
    800016f4:	00105717          	auipc	a4,0x105
    800016f8:	6ec70713          	addi	a4,a4,1772 # 80106de0 <xQueueRegistry>
    800016fc:	67e2                	ld	a5,24(sp)
    800016fe:	0792                	slli	a5,a5,0x4
    80001700:	97ba                	add	a5,a5,a4
    80001702:	6722                	ld	a4,8(sp)
    80001704:	e798                	sd	a4,8(a5)

                traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
                break;
    80001706:	a809                	j	80001718 <vQueueAddToRegistry+0x52>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    80001708:	67e2                	ld	a5,24(sp)
    8000170a:	0785                	addi	a5,a5,1
    8000170c:	ec3e                	sd	a5,24(sp)
    8000170e:	6762                	ld	a4,24(sp)
    80001710:	479d                	li	a5,7
    80001712:	fae7ffe3          	bgeu	a5,a4,800016d0 <vQueueAddToRegistry+0xa>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    80001716:	0001                	nop
    80001718:	0001                	nop
    8000171a:	6105                	addi	sp,sp,32
    8000171c:	8082                	ret

000000008000171e <pcQueueGetName>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

    const char * pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    8000171e:	1101                	addi	sp,sp,-32
    80001720:	e42a                	sd	a0,8(sp)
        UBaseType_t ux;
        const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    80001722:	e802                	sd	zero,16(sp)

        /* Note there is nothing here to protect against another task adding or
         * removing entries from the registry while it is being searched. */

        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    80001724:	ec02                	sd	zero,24(sp)
    80001726:	a80d                	j	80001758 <pcQueueGetName+0x3a>
        {
            if( xQueueRegistry[ ux ].xHandle == xQueue )
    80001728:	00105717          	auipc	a4,0x105
    8000172c:	6b870713          	addi	a4,a4,1720 # 80106de0 <xQueueRegistry>
    80001730:	67e2                	ld	a5,24(sp)
    80001732:	0792                	slli	a5,a5,0x4
    80001734:	97ba                	add	a5,a5,a4
    80001736:	679c                	ld	a5,8(a5)
    80001738:	6722                	ld	a4,8(sp)
    8000173a:	00f71c63          	bne	a4,a5,80001752 <pcQueueGetName+0x34>
            {
                pcReturn = xQueueRegistry[ ux ].pcQueueName;
    8000173e:	00105717          	auipc	a4,0x105
    80001742:	6a270713          	addi	a4,a4,1698 # 80106de0 <xQueueRegistry>
    80001746:	67e2                	ld	a5,24(sp)
    80001748:	0792                	slli	a5,a5,0x4
    8000174a:	97ba                	add	a5,a5,a4
    8000174c:	639c                	ld	a5,0(a5)
    8000174e:	e83e                	sd	a5,16(sp)
                break;
    80001750:	a801                	j	80001760 <pcQueueGetName+0x42>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    80001752:	67e2                	ld	a5,24(sp)
    80001754:	0785                	addi	a5,a5,1
    80001756:	ec3e                	sd	a5,24(sp)
    80001758:	6762                	ld	a4,24(sp)
    8000175a:	479d                	li	a5,7
    8000175c:	fce7f6e3          	bgeu	a5,a4,80001728 <pcQueueGetName+0xa>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        return pcReturn;
    80001760:	67c2                	ld	a5,16(sp)
    } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
    80001762:	853e                	mv	a0,a5
    80001764:	6105                	addi	sp,sp,32
    80001766:	8082                	ret

0000000080001768 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

    void vQueueUnregisterQueue( QueueHandle_t xQueue )
    {
    80001768:	1101                	addi	sp,sp,-32
    8000176a:	e42a                	sd	a0,8(sp)
        UBaseType_t ux;

        /* See if the handle of the queue being unregistered in actually in the
         * registry. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    8000176c:	ec02                	sd	zero,24(sp)
    8000176e:	a091                	j	800017b2 <vQueueUnregisterQueue+0x4a>
        {
            if( xQueueRegistry[ ux ].xHandle == xQueue )
    80001770:	00105717          	auipc	a4,0x105
    80001774:	67070713          	addi	a4,a4,1648 # 80106de0 <xQueueRegistry>
    80001778:	67e2                	ld	a5,24(sp)
    8000177a:	0792                	slli	a5,a5,0x4
    8000177c:	97ba                	add	a5,a5,a4
    8000177e:	679c                	ld	a5,8(a5)
    80001780:	6722                	ld	a4,8(sp)
    80001782:	02f71563          	bne	a4,a5,800017ac <vQueueUnregisterQueue+0x44>
            {
                /* Set the name to NULL to show that this slot if free again. */
                xQueueRegistry[ ux ].pcQueueName = NULL;
    80001786:	00105717          	auipc	a4,0x105
    8000178a:	65a70713          	addi	a4,a4,1626 # 80106de0 <xQueueRegistry>
    8000178e:	67e2                	ld	a5,24(sp)
    80001790:	0792                	slli	a5,a5,0x4
    80001792:	97ba                	add	a5,a5,a4
    80001794:	0007b023          	sd	zero,0(a5)

                /* Set the handle to NULL to ensure the same queue handle cannot
                 * appear in the registry twice if it is added, removed, then
                 * added again. */
                xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
    80001798:	00105717          	auipc	a4,0x105
    8000179c:	64870713          	addi	a4,a4,1608 # 80106de0 <xQueueRegistry>
    800017a0:	67e2                	ld	a5,24(sp)
    800017a2:	0792                	slli	a5,a5,0x4
    800017a4:	97ba                	add	a5,a5,a4
    800017a6:	0007b423          	sd	zero,8(a5)
                break;
    800017aa:	a809                	j	800017bc <vQueueUnregisterQueue+0x54>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    800017ac:	67e2                	ld	a5,24(sp)
    800017ae:	0785                	addi	a5,a5,1
    800017b0:	ec3e                	sd	a5,24(sp)
    800017b2:	6762                	ld	a4,24(sp)
    800017b4:	479d                	li	a5,7
    800017b6:	fae7fde3          	bgeu	a5,a4,80001770 <vQueueUnregisterQueue+0x8>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    800017ba:	0001                	nop
    800017bc:	0001                	nop
    800017be:	6105                	addi	sp,sp,32
    800017c0:	8082                	ret

00000000800017c2 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    800017c2:	7139                	addi	sp,sp,-64
    800017c4:	fc06                	sd	ra,56(sp)
    800017c6:	ec2a                	sd	a0,24(sp)
    800017c8:	e82e                	sd	a1,16(sp)
    800017ca:	e432                	sd	a2,8(sp)
        Queue_t * const pxQueue = xQueue;
    800017cc:	67e2                	ld	a5,24(sp)
    800017ce:	f43e                	sd	a5,40(sp)
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    800017d0:	3fd010ef          	jal	ra,800033cc <vTaskEnterCritical>
    800017d4:	77a2                	ld	a5,40(sp)
    800017d6:	0887c783          	lbu	a5,136(a5)
    800017da:	0187979b          	slliw	a5,a5,0x18
    800017de:	4187d79b          	sraiw	a5,a5,0x18
    800017e2:	873e                	mv	a4,a5
    800017e4:	57fd                	li	a5,-1
    800017e6:	00f71563          	bne	a4,a5,800017f0 <vQueueWaitForMessageRestricted+0x2e>
    800017ea:	77a2                	ld	a5,40(sp)
    800017ec:	08078423          	sb	zero,136(a5)
    800017f0:	77a2                	ld	a5,40(sp)
    800017f2:	0897c783          	lbu	a5,137(a5)
    800017f6:	0187979b          	slliw	a5,a5,0x18
    800017fa:	4187d79b          	sraiw	a5,a5,0x18
    800017fe:	873e                	mv	a4,a5
    80001800:	57fd                	li	a5,-1
    80001802:	00f71563          	bne	a4,a5,8000180c <vQueueWaitForMessageRestricted+0x4a>
    80001806:	77a2                	ld	a5,40(sp)
    80001808:	080784a3          	sb	zero,137(a5)
    8000180c:	3ef010ef          	jal	ra,800033fa <vTaskExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    80001810:	77a2                	ld	a5,40(sp)
    80001812:	7bbc                	ld	a5,112(a5)
    80001814:	eb89                	bnez	a5,80001826 <vQueueWaitForMessageRestricted+0x64>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    80001816:	77a2                	ld	a5,40(sp)
    80001818:	04878793          	addi	a5,a5,72
    8000181c:	6622                	ld	a2,8(sp)
    8000181e:	65c2                	ld	a1,16(sp)
    80001820:	853e                	mv	a0,a5
    80001822:	1e4010ef          	jal	ra,80002a06 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    80001826:	7522                	ld	a0,40(sp)
    80001828:	d39ff0ef          	jal	ra,80001560 <prvUnlockQueue>
    }
    8000182c:	0001                	nop
    8000182e:	70e2                	ld	ra,56(sp)
    80001830:	6121                	addi	sp,sp,64
    80001832:	8082                	ret

0000000080001834 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    80001834:	711d                	addi	sp,sp,-96
    80001836:	ec86                	sd	ra,88(sp)
    80001838:	f42a                	sd	a0,40(sp)
    8000183a:	f02e                	sd	a1,32(sp)
    8000183c:	e836                	sd	a3,16(sp)
    8000183e:	e43a                	sd	a4,8(sp)
    80001840:	e03e                	sd	a5,0(sp)
    80001842:	87b2                	mv	a5,a2
    80001844:	00f11f23          	sh	a5,30(sp)
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    80001848:	01e15783          	lhu	a5,30(sp)
    8000184c:	078e                	slli	a5,a5,0x3
    8000184e:	853e                	mv	a0,a5
    80001850:	210030ef          	jal	ra,80004a60 <pvPortMalloc>
    80001854:	fc2a                	sd	a0,56(sp)

                if( pxStack != NULL )
    80001856:	77e2                	ld	a5,56(sp)
    80001858:	c385                	beqz	a5,80001878 <xTaskCreate+0x44>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    8000185a:	0a800513          	li	a0,168
    8000185e:	202030ef          	jal	ra,80004a60 <pvPortMalloc>
    80001862:	e4aa                	sd	a0,72(sp)

                    if( pxNewTCB != NULL )
    80001864:	67a6                	ld	a5,72(sp)
    80001866:	c789                	beqz	a5,80001870 <xTaskCreate+0x3c>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    80001868:	67a6                	ld	a5,72(sp)
    8000186a:	7762                	ld	a4,56(sp)
    8000186c:	f3b8                	sd	a4,96(a5)
    8000186e:	a031                	j	8000187a <xTaskCreate+0x46>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
    80001870:	7562                	ld	a0,56(sp)
    80001872:	320030ef          	jal	ra,80004b92 <vPortFree>
    80001876:	a011                	j	8000187a <xTaskCreate+0x46>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    80001878:	e482                	sd	zero,72(sp)
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    8000187a:	67a6                	ld	a5,72(sp)
    8000187c:	c785                	beqz	a5,800018a4 <xTaskCreate+0x70>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    8000187e:	01e15783          	lhu	a5,30(sp)
    80001882:	0007861b          	sext.w	a2,a5
    80001886:	4881                	li	a7,0
    80001888:	6826                	ld	a6,72(sp)
    8000188a:	6782                	ld	a5,0(sp)
    8000188c:	6722                	ld	a4,8(sp)
    8000188e:	66c2                	ld	a3,16(sp)
    80001890:	7582                	ld	a1,32(sp)
    80001892:	7522                	ld	a0,40(sp)
    80001894:	01e000ef          	jal	ra,800018b2 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    80001898:	6526                	ld	a0,72(sp)
    8000189a:	144000ef          	jal	ra,800019de <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    8000189e:	4785                	li	a5,1
    800018a0:	e0be                	sd	a5,64(sp)
    800018a2:	a019                	j	800018a8 <xTaskCreate+0x74>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    800018a4:	57fd                	li	a5,-1
    800018a6:	e0be                	sd	a5,64(sp)
        }

        return xReturn;
    800018a8:	6786                	ld	a5,64(sp)
    }
    800018aa:	853e                	mv	a0,a5
    800018ac:	60e6                	ld	ra,88(sp)
    800018ae:	6125                	addi	sp,sp,96
    800018b0:	8082                	ret

00000000800018b2 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    800018b2:	711d                	addi	sp,sp,-96
    800018b4:	ec86                	sd	ra,88(sp)
    800018b6:	fc2a                	sd	a0,56(sp)
    800018b8:	f82e                	sd	a1,48(sp)
    800018ba:	f036                	sd	a3,32(sp)
    800018bc:	ec3a                	sd	a4,24(sp)
    800018be:	e83e                	sd	a5,16(sp)
    800018c0:	e442                	sd	a6,8(sp)
    800018c2:	e046                	sd	a7,0(sp)
    800018c4:	87b2                	mv	a5,a2
    800018c6:	d63e                	sw	a5,44(sp)

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    800018c8:	67a2                	ld	a5,8(sp)
    800018ca:	73b8                	ld	a4,96(a5)
    800018cc:	02c16783          	lwu	a5,44(sp)
    800018d0:	078e                	slli	a5,a5,0x3
    800018d2:	863e                	mv	a2,a5
    800018d4:	0a500593          	li	a1,165
    800018d8:	853a                	mv	a0,a4
    800018da:	45d060ef          	jal	ra,80008536 <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    800018de:	67a2                	ld	a5,8(sp)
    800018e0:	73b8                	ld	a4,96(a5)
    800018e2:	57b2                	lw	a5,44(sp)
    800018e4:	37fd                	addiw	a5,a5,-1
    800018e6:	2781                	sext.w	a5,a5
    800018e8:	1782                	slli	a5,a5,0x20
    800018ea:	9381                	srli	a5,a5,0x20
    800018ec:	078e                	slli	a5,a5,0x3
    800018ee:	97ba                	add	a5,a5,a4
    800018f0:	e0be                	sd	a5,64(sp)
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
    800018f2:	6786                	ld	a5,64(sp)
    800018f4:	9bc1                	andi	a5,a5,-16
    800018f6:	e0be                	sd	a5,64(sp)

            /* Check the alignment of the calculated top of stack is correct. */
            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    800018f8:	6786                	ld	a5,64(sp)
    800018fa:	8bbd                	andi	a5,a5,15
    800018fc:	c781                	beqz	a5,80001904 <prvInitialiseNewTask+0x52>
    800018fe:	30047073          	csrci	mstatus,8
    80001902:	a001                	j	80001902 <prvInitialiseNewTask+0x50>
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    80001904:	77c2                	ld	a5,48(sp)
    80001906:	c3a1                	beqz	a5,80001946 <prvInitialiseNewTask+0x94>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    80001908:	e482                	sd	zero,72(sp)
    8000190a:	a025                	j	80001932 <prvInitialiseNewTask+0x80>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    8000190c:	7742                	ld	a4,48(sp)
    8000190e:	67a6                	ld	a5,72(sp)
    80001910:	97ba                	add	a5,a5,a4
    80001912:	0007c703          	lbu	a4,0(a5)
    80001916:	66a2                	ld	a3,8(sp)
    80001918:	67a6                	ld	a5,72(sp)
    8000191a:	97b6                	add	a5,a5,a3
    8000191c:	06e78423          	sb	a4,104(a5)

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    80001920:	7742                	ld	a4,48(sp)
    80001922:	67a6                	ld	a5,72(sp)
    80001924:	97ba                	add	a5,a5,a4
    80001926:	0007c783          	lbu	a5,0(a5)
    8000192a:	cb89                	beqz	a5,8000193c <prvInitialiseNewTask+0x8a>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    8000192c:	67a6                	ld	a5,72(sp)
    8000192e:	0785                	addi	a5,a5,1
    80001930:	e4be                	sd	a5,72(sp)
    80001932:	6726                	ld	a4,72(sp)
    80001934:	47bd                	li	a5,15
    80001936:	fce7fbe3          	bgeu	a5,a4,8000190c <prvInitialiseNewTask+0x5a>
    8000193a:	a011                	j	8000193e <prvInitialiseNewTask+0x8c>
            {
                break;
    8000193c:	0001                	nop
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    8000193e:	67a2                	ld	a5,8(sp)
    80001940:	06078ba3          	sb	zero,119(a5)
    80001944:	a021                	j	8000194c <prvInitialiseNewTask+0x9a>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    80001946:	67a2                	ld	a5,8(sp)
    80001948:	06078423          	sb	zero,104(a5)
    }

    /* This is used as an array index so must ensure it's not too large.  First
     * remove the privilege bit if one is present. */
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    8000194c:	6762                	ld	a4,24(sp)
    8000194e:	4791                	li	a5,4
    80001950:	00e7f463          	bgeu	a5,a4,80001958 <prvInitialiseNewTask+0xa6>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    80001954:	4791                	li	a5,4
    80001956:	ec3e                	sd	a5,24(sp)
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    80001958:	67a2                	ld	a5,8(sp)
    8000195a:	6762                	ld	a4,24(sp)
    8000195c:	efb8                	sd	a4,88(a5)
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
    8000195e:	67a2                	ld	a5,8(sp)
    80001960:	6762                	ld	a4,24(sp)
    80001962:	ebd8                	sd	a4,144(a5)
            pxNewTCB->uxMutexesHeld = 0;
    80001964:	67a2                	ld	a5,8(sp)
    80001966:	0807bc23          	sd	zero,152(a5)
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    8000196a:	67a2                	ld	a5,8(sp)
    8000196c:	07a1                	addi	a5,a5,8
    8000196e:	853e                	mv	a0,a5
    80001970:	d35fe0ef          	jal	ra,800006a4 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    80001974:	67a2                	ld	a5,8(sp)
    80001976:	03078793          	addi	a5,a5,48
    8000197a:	853e                	mv	a0,a5
    8000197c:	d29fe0ef          	jal	ra,800006a4 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    80001980:	67a2                	ld	a5,8(sp)
    80001982:	6722                	ld	a4,8(sp)
    80001984:	f398                	sd	a4,32(a5)

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    80001986:	4715                	li	a4,5
    80001988:	67e2                	ld	a5,24(sp)
    8000198a:	8f1d                	sub	a4,a4,a5
    8000198c:	67a2                	ld	a5,8(sp)
    8000198e:	fb98                	sd	a4,48(a5)
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    80001990:	67a2                	ld	a5,8(sp)
    80001992:	6722                	ld	a4,8(sp)
    80001994:	e7b8                	sd	a4,72(a5)

    #if ( portCRITICAL_NESTING_IN_TCB == 1 )
        {
            pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
    80001996:	67a2                	ld	a5,8(sp)
    80001998:	0607bc23          	sd	zero,120(a5)
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    8000199c:	67a2                	ld	a5,8(sp)
    8000199e:	0a078793          	addi	a5,a5,160
    800019a2:	4611                	li	a2,4
    800019a4:	4581                	li	a1,0
    800019a6:	853e                	mv	a0,a5
    800019a8:	38f060ef          	jal	ra,80008536 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    800019ac:	67a2                	ld	a5,8(sp)
    800019ae:	0a478793          	addi	a5,a5,164
    800019b2:	4605                	li	a2,1
    800019b4:	4581                	li	a1,0
    800019b6:	853e                	mv	a0,a5
    800019b8:	37f060ef          	jal	ra,80008536 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    800019bc:	7602                	ld	a2,32(sp)
    800019be:	75e2                	ld	a1,56(sp)
    800019c0:	6506                	ld	a0,64(sp)
    800019c2:	c3ffe0ef          	jal	ra,80000600 <pxPortInitialiseStack>
    800019c6:	872a                	mv	a4,a0
    800019c8:	67a2                	ld	a5,8(sp)
    800019ca:	e398                	sd	a4,0(a5)
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    800019cc:	67c2                	ld	a5,16(sp)
    800019ce:	c781                	beqz	a5,800019d6 <prvInitialiseNewTask+0x124>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    800019d0:	67c2                	ld	a5,16(sp)
    800019d2:	6722                	ld	a4,8(sp)
    800019d4:	e398                	sd	a4,0(a5)
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    800019d6:	0001                	nop
    800019d8:	60e6                	ld	ra,88(sp)
    800019da:	6125                	addi	sp,sp,96
    800019dc:	8082                	ret

00000000800019de <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    800019de:	1101                	addi	sp,sp,-32
    800019e0:	ec06                	sd	ra,24(sp)
    800019e2:	e42a                	sd	a0,8(sp)
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    800019e4:	1e9010ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        uxCurrentNumberOfTasks++;
    800019e8:	0000b797          	auipc	a5,0xb
    800019ec:	30078793          	addi	a5,a5,768 # 8000cce8 <uxCurrentNumberOfTasks>
    800019f0:	639c                	ld	a5,0(a5)
    800019f2:	00178713          	addi	a4,a5,1
    800019f6:	0000b797          	auipc	a5,0xb
    800019fa:	2f278793          	addi	a5,a5,754 # 8000cce8 <uxCurrentNumberOfTasks>
    800019fe:	e398                	sd	a4,0(a5)

        if( pxCurrentTCB == NULL )
    80001a00:	00009797          	auipc	a5,0x9
    80001a04:	1d078793          	addi	a5,a5,464 # 8000abd0 <pxCurrentTCB>
    80001a08:	639c                	ld	a5,0(a5)
    80001a0a:	e395                	bnez	a5,80001a2e <prvAddNewTaskToReadyList+0x50>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    80001a0c:	00009797          	auipc	a5,0x9
    80001a10:	1c478793          	addi	a5,a5,452 # 8000abd0 <pxCurrentTCB>
    80001a14:	6722                	ld	a4,8(sp)
    80001a16:	e398                	sd	a4,0(a5)

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    80001a18:	0000b797          	auipc	a5,0xb
    80001a1c:	2d078793          	addi	a5,a5,720 # 8000cce8 <uxCurrentNumberOfTasks>
    80001a20:	6398                	ld	a4,0(a5)
    80001a22:	4785                	li	a5,1
    80001a24:	02f71b63          	bne	a4,a5,80001a5a <prvAddNewTaskToReadyList+0x7c>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    80001a28:	30c010ef          	jal	ra,80002d34 <prvInitialiseTaskLists>
    80001a2c:	a03d                	j	80001a5a <prvAddNewTaskToReadyList+0x7c>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    80001a2e:	0000b797          	auipc	a5,0xb
    80001a32:	2d278793          	addi	a5,a5,722 # 8000cd00 <xSchedulerRunning>
    80001a36:	639c                	ld	a5,0(a5)
    80001a38:	e38d                	bnez	a5,80001a5a <prvAddNewTaskToReadyList+0x7c>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    80001a3a:	00009797          	auipc	a5,0x9
    80001a3e:	19678793          	addi	a5,a5,406 # 8000abd0 <pxCurrentTCB>
    80001a42:	639c                	ld	a5,0(a5)
    80001a44:	6fb8                	ld	a4,88(a5)
    80001a46:	67a2                	ld	a5,8(sp)
    80001a48:	6fbc                	ld	a5,88(a5)
    80001a4a:	00e7e863          	bltu	a5,a4,80001a5a <prvAddNewTaskToReadyList+0x7c>
                {
                    pxCurrentTCB = pxNewTCB;
    80001a4e:	00009797          	auipc	a5,0x9
    80001a52:	18278793          	addi	a5,a5,386 # 8000abd0 <pxCurrentTCB>
    80001a56:	6722                	ld	a4,8(sp)
    80001a58:	e398                	sd	a4,0(a5)
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    80001a5a:	0000b797          	auipc	a5,0xb
    80001a5e:	2c678793          	addi	a5,a5,710 # 8000cd20 <uxTaskNumber>
    80001a62:	639c                	ld	a5,0(a5)
    80001a64:	00178713          	addi	a4,a5,1
    80001a68:	0000b797          	auipc	a5,0xb
    80001a6c:	2b878793          	addi	a5,a5,696 # 8000cd20 <uxTaskNumber>
    80001a70:	e398                	sd	a4,0(a5)

        #if ( configUSE_TRACE_FACILITY == 1 )
            {
                /* Add a counter into the TCB for tracing only. */
                pxNewTCB->uxTCBNumber = uxTaskNumber;
    80001a72:	0000b797          	auipc	a5,0xb
    80001a76:	2ae78793          	addi	a5,a5,686 # 8000cd20 <uxTaskNumber>
    80001a7a:	6398                	ld	a4,0(a5)
    80001a7c:	67a2                	ld	a5,8(sp)
    80001a7e:	e3d8                	sd	a4,128(a5)
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    80001a80:	67a2                	ld	a5,8(sp)
    80001a82:	6fbc                	ld	a5,88(a5)
    80001a84:	2781                	sext.w	a5,a5
    80001a86:	873e                	mv	a4,a5
    80001a88:	4785                	li	a5,1
    80001a8a:	00e79733          	sll	a4,a5,a4
    80001a8e:	0000b797          	auipc	a5,0xb
    80001a92:	26a78793          	addi	a5,a5,618 # 8000ccf8 <uxTopReadyPriority>
    80001a96:	639c                	ld	a5,0(a5)
    80001a98:	8f5d                	or	a4,a4,a5
    80001a9a:	0000b797          	auipc	a5,0xb
    80001a9e:	25e78793          	addi	a5,a5,606 # 8000ccf8 <uxTopReadyPriority>
    80001aa2:	e398                	sd	a4,0(a5)
    80001aa4:	67a2                	ld	a5,8(sp)
    80001aa6:	6fb8                	ld	a4,88(a5)
    80001aa8:	87ba                	mv	a5,a4
    80001aaa:	078a                	slli	a5,a5,0x2
    80001aac:	97ba                	add	a5,a5,a4
    80001aae:	078e                	slli	a5,a5,0x3
    80001ab0:	0000b717          	auipc	a4,0xb
    80001ab4:	09070713          	addi	a4,a4,144 # 8000cb40 <pxReadyTasksLists>
    80001ab8:	973e                	add	a4,a4,a5
    80001aba:	67a2                	ld	a5,8(sp)
    80001abc:	07a1                	addi	a5,a5,8
    80001abe:	85be                	mv	a1,a5
    80001ac0:	853a                	mv	a0,a4
    80001ac2:	bf3fe0ef          	jal	ra,800006b4 <vListInsertEnd>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    80001ac6:	135010ef          	jal	ra,800033fa <vTaskExitCritical>

    if( xSchedulerRunning != pdFALSE )
    80001aca:	0000b797          	auipc	a5,0xb
    80001ace:	23678793          	addi	a5,a5,566 # 8000cd00 <xSchedulerRunning>
    80001ad2:	639c                	ld	a5,0(a5)
    80001ad4:	cf89                	beqz	a5,80001aee <prvAddNewTaskToReadyList+0x110>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    80001ad6:	00009797          	auipc	a5,0x9
    80001ada:	0fa78793          	addi	a5,a5,250 # 8000abd0 <pxCurrentTCB>
    80001ade:	639c                	ld	a5,0(a5)
    80001ae0:	6fb8                	ld	a4,88(a5)
    80001ae2:	67a2                	ld	a5,8(sp)
    80001ae4:	6fbc                	ld	a5,88(a5)
    80001ae6:	00f77463          	bgeu	a4,a5,80001aee <prvAddNewTaskToReadyList+0x110>
        {
            taskYIELD_IF_USING_PREEMPTION();
    80001aea:	00000073          	ecall
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    80001aee:	0001                	nop
    80001af0:	60e2                	ld	ra,24(sp)
    80001af2:	6105                	addi	sp,sp,32
    80001af4:	8082                	ret

0000000080001af6 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    80001af6:	7179                	addi	sp,sp,-48
    80001af8:	f406                	sd	ra,40(sp)
    80001afa:	e42a                	sd	a0,8(sp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    80001afc:	0d1010ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    80001b00:	67a2                	ld	a5,8(sp)
    80001b02:	e799                	bnez	a5,80001b10 <vTaskDelete+0x1a>
    80001b04:	00009797          	auipc	a5,0x9
    80001b08:	0cc78793          	addi	a5,a5,204 # 8000abd0 <pxCurrentTCB>
    80001b0c:	639c                	ld	a5,0(a5)
    80001b0e:	a011                	j	80001b12 <vTaskDelete+0x1c>
    80001b10:	67a2                	ld	a5,8(sp)
    80001b12:	ec3e                	sd	a5,24(sp)

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    80001b14:	67e2                	ld	a5,24(sp)
    80001b16:	07a1                	addi	a5,a5,8
    80001b18:	853e                	mv	a0,a5
    80001b1a:	c45fe0ef          	jal	ra,8000075e <uxListRemove>
    80001b1e:	87aa                	mv	a5,a0
    80001b20:	e3b1                	bnez	a5,80001b64 <vTaskDelete+0x6e>
            {
                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    80001b22:	67e2                	ld	a5,24(sp)
    80001b24:	6fb8                	ld	a4,88(a5)
    80001b26:	0000b697          	auipc	a3,0xb
    80001b2a:	01a68693          	addi	a3,a3,26 # 8000cb40 <pxReadyTasksLists>
    80001b2e:	87ba                	mv	a5,a4
    80001b30:	078a                	slli	a5,a5,0x2
    80001b32:	97ba                	add	a5,a5,a4
    80001b34:	078e                	slli	a5,a5,0x3
    80001b36:	97b6                	add	a5,a5,a3
    80001b38:	639c                	ld	a5,0(a5)
    80001b3a:	e78d                	bnez	a5,80001b64 <vTaskDelete+0x6e>
    80001b3c:	67e2                	ld	a5,24(sp)
    80001b3e:	6fbc                	ld	a5,88(a5)
    80001b40:	2781                	sext.w	a5,a5
    80001b42:	873e                	mv	a4,a5
    80001b44:	4785                	li	a5,1
    80001b46:	00e797b3          	sll	a5,a5,a4
    80001b4a:	fff7c713          	not	a4,a5
    80001b4e:	0000b797          	auipc	a5,0xb
    80001b52:	1aa78793          	addi	a5,a5,426 # 8000ccf8 <uxTopReadyPriority>
    80001b56:	639c                	ld	a5,0(a5)
    80001b58:	8f7d                	and	a4,a4,a5
    80001b5a:	0000b797          	auipc	a5,0xb
    80001b5e:	19e78793          	addi	a5,a5,414 # 8000ccf8 <uxTopReadyPriority>
    80001b62:	e398                	sd	a4,0(a5)
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    80001b64:	67e2                	ld	a5,24(sp)
    80001b66:	6bbc                	ld	a5,80(a5)
    80001b68:	c799                	beqz	a5,80001b76 <vTaskDelete+0x80>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    80001b6a:	67e2                	ld	a5,24(sp)
    80001b6c:	03078793          	addi	a5,a5,48
    80001b70:	853e                	mv	a0,a5
    80001b72:	bedfe0ef          	jal	ra,8000075e <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    80001b76:	0000b797          	auipc	a5,0xb
    80001b7a:	1aa78793          	addi	a5,a5,426 # 8000cd20 <uxTaskNumber>
    80001b7e:	639c                	ld	a5,0(a5)
    80001b80:	00178713          	addi	a4,a5,1
    80001b84:	0000b797          	auipc	a5,0xb
    80001b88:	19c78793          	addi	a5,a5,412 # 8000cd20 <uxTaskNumber>
    80001b8c:	e398                	sd	a4,0(a5)

            if( pxTCB == pxCurrentTCB )
    80001b8e:	00009797          	auipc	a5,0x9
    80001b92:	04278793          	addi	a5,a5,66 # 8000abd0 <pxCurrentTCB>
    80001b96:	639c                	ld	a5,0(a5)
    80001b98:	6762                	ld	a4,24(sp)
    80001b9a:	02f71863          	bne	a4,a5,80001bca <vTaskDelete+0xd4>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    80001b9e:	67e2                	ld	a5,24(sp)
    80001ba0:	07a1                	addi	a5,a5,8
    80001ba2:	85be                	mv	a1,a5
    80001ba4:	0000b517          	auipc	a0,0xb
    80001ba8:	0ec50513          	addi	a0,a0,236 # 8000cc90 <xTasksWaitingTermination>
    80001bac:	b09fe0ef          	jal	ra,800006b4 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    80001bb0:	0000b797          	auipc	a5,0xb
    80001bb4:	10878793          	addi	a5,a5,264 # 8000ccb8 <uxDeletedTasksWaitingCleanUp>
    80001bb8:	639c                	ld	a5,0(a5)
    80001bba:	00178713          	addi	a4,a5,1
    80001bbe:	0000b797          	auipc	a5,0xb
    80001bc2:	0fa78793          	addi	a5,a5,250 # 8000ccb8 <uxDeletedTasksWaitingCleanUp>
    80001bc6:	e398                	sd	a4,0(a5)
    80001bc8:	a015                	j	80001bec <vTaskDelete+0xf6>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    80001bca:	0000b797          	auipc	a5,0xb
    80001bce:	11e78793          	addi	a5,a5,286 # 8000cce8 <uxCurrentNumberOfTasks>
    80001bd2:	639c                	ld	a5,0(a5)
    80001bd4:	fff78713          	addi	a4,a5,-1
    80001bd8:	0000b797          	auipc	a5,0xb
    80001bdc:	11078793          	addi	a5,a5,272 # 8000cce8 <uxCurrentNumberOfTasks>
    80001be0:	e398                	sd	a4,0(a5)
                traceTASK_DELETE( pxTCB );
                prvDeleteTCB( pxTCB );
    80001be2:	6562                	ld	a0,24(sp)
    80001be4:	410010ef          	jal	ra,80002ff4 <prvDeleteTCB>

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    80001be8:	42a010ef          	jal	ra,80003012 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    80001bec:	00f010ef          	jal	ra,800033fa <vTaskExitCritical>

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    80001bf0:	0000b797          	auipc	a5,0xb
    80001bf4:	11078793          	addi	a5,a5,272 # 8000cd00 <xSchedulerRunning>
    80001bf8:	639c                	ld	a5,0(a5)
    80001bfa:	c785                	beqz	a5,80001c22 <vTaskDelete+0x12c>
        {
            if( pxTCB == pxCurrentTCB )
    80001bfc:	00009797          	auipc	a5,0x9
    80001c00:	fd478793          	addi	a5,a5,-44 # 8000abd0 <pxCurrentTCB>
    80001c04:	639c                	ld	a5,0(a5)
    80001c06:	6762                	ld	a4,24(sp)
    80001c08:	00f71d63          	bne	a4,a5,80001c22 <vTaskDelete+0x12c>
            {
                configASSERT( uxSchedulerSuspended == 0 );
    80001c0c:	0000b797          	auipc	a5,0xb
    80001c10:	12c78793          	addi	a5,a5,300 # 8000cd38 <uxSchedulerSuspended>
    80001c14:	639c                	ld	a5,0(a5)
    80001c16:	c781                	beqz	a5,80001c1e <vTaskDelete+0x128>
    80001c18:	30047073          	csrci	mstatus,8
    80001c1c:	a001                	j	80001c1c <vTaskDelete+0x126>
                portYIELD_WITHIN_API();
    80001c1e:	00000073          	ecall
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    80001c22:	0001                	nop
    80001c24:	70a2                	ld	ra,40(sp)
    80001c26:	6145                	addi	sp,sp,48
    80001c28:	8082                	ret

0000000080001c2a <vTaskDelayUntil>:

#if ( INCLUDE_vTaskDelayUntil == 1 )

    void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                          const TickType_t xTimeIncrement )
    {
    80001c2a:	7139                	addi	sp,sp,-64
    80001c2c:	fc06                	sd	ra,56(sp)
    80001c2e:	e42a                	sd	a0,8(sp)
    80001c30:	e02e                	sd	a1,0(sp)
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    80001c32:	f402                	sd	zero,40(sp)

        configASSERT( pxPreviousWakeTime );
    80001c34:	67a2                	ld	a5,8(sp)
    80001c36:	e781                	bnez	a5,80001c3e <vTaskDelayUntil+0x14>
    80001c38:	30047073          	csrci	mstatus,8
    80001c3c:	a001                	j	80001c3c <vTaskDelayUntil+0x12>
        configASSERT( ( xTimeIncrement > 0U ) );
    80001c3e:	6782                	ld	a5,0(sp)
    80001c40:	e781                	bnez	a5,80001c48 <vTaskDelayUntil+0x1e>
    80001c42:	30047073          	csrci	mstatus,8
    80001c46:	a001                	j	80001c46 <vTaskDelayUntil+0x1c>
        configASSERT( uxSchedulerSuspended == 0 );
    80001c48:	0000b797          	auipc	a5,0xb
    80001c4c:	0f078793          	addi	a5,a5,240 # 8000cd38 <uxSchedulerSuspended>
    80001c50:	639c                	ld	a5,0(a5)
    80001c52:	c781                	beqz	a5,80001c5a <vTaskDelayUntil+0x30>
    80001c54:	30047073          	csrci	mstatus,8
    80001c58:	a001                	j	80001c58 <vTaskDelayUntil+0x2e>

        vTaskSuspendAll();
    80001c5a:	6ea000ef          	jal	ra,80002344 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    80001c5e:	0000b797          	auipc	a5,0xb
    80001c62:	09278793          	addi	a5,a5,146 # 8000ccf0 <xTickCount>
    80001c66:	639c                	ld	a5,0(a5)
    80001c68:	f03e                	sd	a5,32(sp)

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    80001c6a:	67a2                	ld	a5,8(sp)
    80001c6c:	639c                	ld	a5,0(a5)
    80001c6e:	6702                	ld	a4,0(sp)
    80001c70:	97ba                	add	a5,a5,a4
    80001c72:	ec3e                	sd	a5,24(sp)

            if( xConstTickCount < *pxPreviousWakeTime )
    80001c74:	67a2                	ld	a5,8(sp)
    80001c76:	639c                	ld	a5,0(a5)
    80001c78:	7702                	ld	a4,32(sp)
    80001c7a:	00f77e63          	bgeu	a4,a5,80001c96 <vTaskDelayUntil+0x6c>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    80001c7e:	67a2                	ld	a5,8(sp)
    80001c80:	639c                	ld	a5,0(a5)
    80001c82:	6762                	ld	a4,24(sp)
    80001c84:	02f77463          	bgeu	a4,a5,80001cac <vTaskDelayUntil+0x82>
    80001c88:	6762                	ld	a4,24(sp)
    80001c8a:	7782                	ld	a5,32(sp)
    80001c8c:	02e7f063          	bgeu	a5,a4,80001cac <vTaskDelayUntil+0x82>
                {
                    xShouldDelay = pdTRUE;
    80001c90:	4785                	li	a5,1
    80001c92:	f43e                	sd	a5,40(sp)
    80001c94:	a821                	j	80001cac <vTaskDelayUntil+0x82>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    80001c96:	67a2                	ld	a5,8(sp)
    80001c98:	639c                	ld	a5,0(a5)
    80001c9a:	6762                	ld	a4,24(sp)
    80001c9c:	00f76663          	bltu	a4,a5,80001ca8 <vTaskDelayUntil+0x7e>
    80001ca0:	6762                	ld	a4,24(sp)
    80001ca2:	7782                	ld	a5,32(sp)
    80001ca4:	00e7f463          	bgeu	a5,a4,80001cac <vTaskDelayUntil+0x82>
                {
                    xShouldDelay = pdTRUE;
    80001ca8:	4785                	li	a5,1
    80001caa:	f43e                	sd	a5,40(sp)
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    80001cac:	67a2                	ld	a5,8(sp)
    80001cae:	6762                	ld	a4,24(sp)
    80001cb0:	e398                	sd	a4,0(a5)

            if( xShouldDelay != pdFALSE )
    80001cb2:	77a2                	ld	a5,40(sp)
    80001cb4:	cb89                	beqz	a5,80001cc6 <vTaskDelayUntil+0x9c>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    80001cb6:	6762                	ld	a4,24(sp)
    80001cb8:	7782                	ld	a5,32(sp)
    80001cba:	40f707b3          	sub	a5,a4,a5
    80001cbe:	4581                	li	a1,0
    80001cc0:	853e                	mv	a0,a5
    80001cc2:	78f010ef          	jal	ra,80003c50 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    80001cc6:	69a000ef          	jal	ra,80002360 <xTaskResumeAll>
    80001cca:	e82a                	sd	a0,16(sp)

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    80001ccc:	67c2                	ld	a5,16(sp)
    80001cce:	e399                	bnez	a5,80001cd4 <vTaskDelayUntil+0xaa>
        {
            portYIELD_WITHIN_API();
    80001cd0:	00000073          	ecall
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    80001cd4:	0001                	nop
    80001cd6:	70e2                	ld	ra,56(sp)
    80001cd8:	6121                	addi	sp,sp,64
    80001cda:	8082                	ret

0000000080001cdc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    80001cdc:	7179                	addi	sp,sp,-48
    80001cde:	f406                	sd	ra,40(sp)
    80001ce0:	e42a                	sd	a0,8(sp)
        BaseType_t xAlreadyYielded = pdFALSE;
    80001ce2:	ec02                	sd	zero,24(sp)

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    80001ce4:	67a2                	ld	a5,8(sp)
    80001ce6:	c39d                	beqz	a5,80001d0c <vTaskDelay+0x30>
        {
            configASSERT( uxSchedulerSuspended == 0 );
    80001ce8:	0000b797          	auipc	a5,0xb
    80001cec:	05078793          	addi	a5,a5,80 # 8000cd38 <uxSchedulerSuspended>
    80001cf0:	639c                	ld	a5,0(a5)
    80001cf2:	c781                	beqz	a5,80001cfa <vTaskDelay+0x1e>
    80001cf4:	30047073          	csrci	mstatus,8
    80001cf8:	a001                	j	80001cf8 <vTaskDelay+0x1c>
            vTaskSuspendAll();
    80001cfa:	64a000ef          	jal	ra,80002344 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    80001cfe:	4581                	li	a1,0
    80001d00:	6522                	ld	a0,8(sp)
    80001d02:	74f010ef          	jal	ra,80003c50 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    80001d06:	65a000ef          	jal	ra,80002360 <xTaskResumeAll>
    80001d0a:	ec2a                	sd	a0,24(sp)
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    80001d0c:	67e2                	ld	a5,24(sp)
    80001d0e:	e399                	bnez	a5,80001d14 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    80001d10:	00000073          	ecall
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    80001d14:	0001                	nop
    80001d16:	70a2                	ld	ra,40(sp)
    80001d18:	6145                	addi	sp,sp,48
    80001d1a:	8082                	ret

0000000080001d1c <eTaskGetState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )

    eTaskState eTaskGetState( TaskHandle_t xTask )
    {
    80001d1c:	715d                	addi	sp,sp,-80
    80001d1e:	e486                	sd	ra,72(sp)
    80001d20:	e42a                	sd	a0,8(sp)
        eTaskState eReturn;
        List_t const * pxStateList, * pxDelayedList, * pxOverflowedDelayedList;
        const TCB_t * const pxTCB = xTask;
    80001d22:	67a2                	ld	a5,8(sp)
    80001d24:	f43e                	sd	a5,40(sp)

        configASSERT( pxTCB );
    80001d26:	77a2                	ld	a5,40(sp)
    80001d28:	e781                	bnez	a5,80001d30 <eTaskGetState+0x14>
    80001d2a:	30047073          	csrci	mstatus,8
    80001d2e:	a001                	j	80001d2e <eTaskGetState+0x12>

        if( pxTCB == pxCurrentTCB )
    80001d30:	00009797          	auipc	a5,0x9
    80001d34:	ea078793          	addi	a5,a5,-352 # 8000abd0 <pxCurrentTCB>
    80001d38:	639c                	ld	a5,0(a5)
    80001d3a:	7722                	ld	a4,40(sp)
    80001d3c:	00f71463          	bne	a4,a5,80001d44 <eTaskGetState+0x28>
        {
            /* The task calling this function is querying its own state. */
            eReturn = eRunning;
    80001d40:	de02                	sw	zero,60(sp)
    80001d42:	a05d                	j	80001de8 <eTaskGetState+0xcc>
        }
        else
        {
            taskENTER_CRITICAL();
    80001d44:	688010ef          	jal	ra,800033cc <vTaskEnterCritical>
            {
                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
    80001d48:	77a2                	ld	a5,40(sp)
    80001d4a:	779c                	ld	a5,40(a5)
    80001d4c:	f03e                	sd	a5,32(sp)
                pxDelayedList = pxDelayedTaskList;
    80001d4e:	0000b797          	auipc	a5,0xb
    80001d52:	f0a78793          	addi	a5,a5,-246 # 8000cc58 <pxDelayedTaskList>
    80001d56:	639c                	ld	a5,0(a5)
    80001d58:	ec3e                	sd	a5,24(sp)
                pxOverflowedDelayedList = pxOverflowDelayedTaskList;
    80001d5a:	0000b797          	auipc	a5,0xb
    80001d5e:	f0678793          	addi	a5,a5,-250 # 8000cc60 <pxOverflowDelayedTaskList>
    80001d62:	639c                	ld	a5,0(a5)
    80001d64:	e83e                	sd	a5,16(sp)
            }
            taskEXIT_CRITICAL();
    80001d66:	694010ef          	jal	ra,800033fa <vTaskExitCritical>

            if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
    80001d6a:	7702                	ld	a4,32(sp)
    80001d6c:	67e2                	ld	a5,24(sp)
    80001d6e:	00f70663          	beq	a4,a5,80001d7a <eTaskGetState+0x5e>
    80001d72:	7702                	ld	a4,32(sp)
    80001d74:	67c2                	ld	a5,16(sp)
    80001d76:	00f71563          	bne	a4,a5,80001d80 <eTaskGetState+0x64>
            {
                /* The task being queried is referenced from one of the Blocked
                 * lists. */
                eReturn = eBlocked;
    80001d7a:	4789                	li	a5,2
    80001d7c:	de3e                	sw	a5,60(sp)
    80001d7e:	a0ad                	j	80001de8 <eTaskGetState+0xcc>
            }

            #if ( INCLUDE_vTaskSuspend == 1 )
                else if( pxStateList == &xSuspendedTaskList )
    80001d80:	7702                	ld	a4,32(sp)
    80001d82:	0000b797          	auipc	a5,0xb
    80001d86:	f3e78793          	addi	a5,a5,-194 # 8000ccc0 <xSuspendedTaskList>
    80001d8a:	04f71163          	bne	a4,a5,80001dcc <eTaskGetState+0xb0>
                {
                    /* The task being queried is referenced from the suspended
                     * list.  Is it genuinely suspended or is it blocked
                     * indefinitely? */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
    80001d8e:	77a2                	ld	a5,40(sp)
    80001d90:	6bbc                	ld	a5,80(a5)
    80001d92:	eb95                	bnez	a5,80001dc6 <eTaskGetState+0xaa>
                                /* The task does not appear on the event list item of
                                 * and of the RTOS objects, but could still be in the
                                 * blocked state if it is waiting on its notification
                                 * rather than waiting on an object.  If not, is
                                 * suspended. */
                                eReturn = eSuspended;
    80001d94:	478d                	li	a5,3
    80001d96:	de3e                	sw	a5,60(sp)

                                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    80001d98:	f802                	sd	zero,48(sp)
    80001d9a:	a015                	j	80001dbe <eTaskGetState+0xa2>
                                {
                                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
    80001d9c:	7722                	ld	a4,40(sp)
    80001d9e:	77c2                	ld	a5,48(sp)
    80001da0:	97ba                	add	a5,a5,a4
    80001da2:	0a47c783          	lbu	a5,164(a5)
    80001da6:	0ff7f793          	andi	a5,a5,255
    80001daa:	873e                	mv	a4,a5
    80001dac:	4785                	li	a5,1
    80001dae:	00f71563          	bne	a4,a5,80001db8 <eTaskGetState+0x9c>
                                    {
                                        eReturn = eBlocked;
    80001db2:	4789                	li	a5,2
    80001db4:	de3e                	sw	a5,60(sp)
                                        break;
    80001db6:	a80d                	j	80001de8 <eTaskGetState+0xcc>
                                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    80001db8:	77c2                	ld	a5,48(sp)
    80001dba:	0785                	addi	a5,a5,1
    80001dbc:	f83e                	sd	a5,48(sp)
    80001dbe:	77c2                	ld	a5,48(sp)
    80001dc0:	fcf05ee3          	blez	a5,80001d9c <eTaskGetState+0x80>
    80001dc4:	a015                	j	80001de8 <eTaskGetState+0xcc>
                            }
                        #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
                    }
                    else
                    {
                        eReturn = eBlocked;
    80001dc6:	4789                	li	a5,2
    80001dc8:	de3e                	sw	a5,60(sp)
    80001dca:	a839                	j	80001de8 <eTaskGetState+0xcc>
                    }
                }
            #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */

            #if ( INCLUDE_vTaskDelete == 1 )
                else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
    80001dcc:	7702                	ld	a4,32(sp)
    80001dce:	0000b797          	auipc	a5,0xb
    80001dd2:	ec278793          	addi	a5,a5,-318 # 8000cc90 <xTasksWaitingTermination>
    80001dd6:	00f70463          	beq	a4,a5,80001dde <eTaskGetState+0xc2>
    80001dda:	7782                	ld	a5,32(sp)
    80001ddc:	e781                	bnez	a5,80001de4 <eTaskGetState+0xc8>
                {
                    /* The task being queried is referenced from the deleted
                     * tasks list, or it is not referenced from any lists at
                     * all. */
                    eReturn = eDeleted;
    80001dde:	4791                	li	a5,4
    80001de0:	de3e                	sw	a5,60(sp)
    80001de2:	a019                	j	80001de8 <eTaskGetState+0xcc>

            else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
            {
                /* If the task is not in any other state, it must be in the
                 * Ready (including pending ready) state. */
                eReturn = eReady;
    80001de4:	4785                	li	a5,1
    80001de6:	de3e                	sw	a5,60(sp)
            }
        }

        return eReturn;
    80001de8:	57f2                	lw	a5,60(sp)
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    80001dea:	853e                	mv	a0,a5
    80001dec:	60a6                	ld	ra,72(sp)
    80001dee:	6161                	addi	sp,sp,80
    80001df0:	8082                	ret

0000000080001df2 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
    {
    80001df2:	7179                	addi	sp,sp,-48
    80001df4:	f406                	sd	ra,40(sp)
    80001df6:	e42a                	sd	a0,8(sp)
        TCB_t const * pxTCB;
        UBaseType_t uxReturn;

        taskENTER_CRITICAL();
    80001df8:	5d4010ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the task
             * that called uxTaskPriorityGet() that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
    80001dfc:	67a2                	ld	a5,8(sp)
    80001dfe:	e799                	bnez	a5,80001e0c <uxTaskPriorityGet+0x1a>
    80001e00:	00009797          	auipc	a5,0x9
    80001e04:	dd078793          	addi	a5,a5,-560 # 8000abd0 <pxCurrentTCB>
    80001e08:	639c                	ld	a5,0(a5)
    80001e0a:	a011                	j	80001e0e <uxTaskPriorityGet+0x1c>
    80001e0c:	67a2                	ld	a5,8(sp)
    80001e0e:	ec3e                	sd	a5,24(sp)
            uxReturn = pxTCB->uxPriority;
    80001e10:	67e2                	ld	a5,24(sp)
    80001e12:	6fbc                	ld	a5,88(a5)
    80001e14:	e83e                	sd	a5,16(sp)
        }
        taskEXIT_CRITICAL();
    80001e16:	5e4010ef          	jal	ra,800033fa <vTaskExitCritical>

        return uxReturn;
    80001e1a:	67c2                	ld	a5,16(sp)
    }
    80001e1c:	853e                	mv	a0,a5
    80001e1e:	70a2                	ld	ra,40(sp)
    80001e20:	6145                	addi	sp,sp,48
    80001e22:	8082                	ret

0000000080001e24 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
    {
    80001e24:	7179                	addi	sp,sp,-48
    80001e26:	e42a                	sd	a0,8(sp)
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    80001e28:	f402                	sd	zero,40(sp)
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being queried. */
            pxTCB = prvGetTCBFromHandle( xTask );
    80001e2a:	67a2                	ld	a5,8(sp)
    80001e2c:	e799                	bnez	a5,80001e3a <uxTaskPriorityGetFromISR+0x16>
    80001e2e:	00009797          	auipc	a5,0x9
    80001e32:	da278793          	addi	a5,a5,-606 # 8000abd0 <pxCurrentTCB>
    80001e36:	639c                	ld	a5,0(a5)
    80001e38:	a011                	j	80001e3c <uxTaskPriorityGetFromISR+0x18>
    80001e3a:	67a2                	ld	a5,8(sp)
    80001e3c:	f03e                	sd	a5,32(sp)
            uxReturn = pxTCB->uxPriority;
    80001e3e:	7782                	ld	a5,32(sp)
    80001e40:	6fbc                	ld	a5,88(a5)
    80001e42:	ec3e                	sd	a5,24(sp)
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

        return uxReturn;
    80001e44:	67e2                	ld	a5,24(sp)
    }
    80001e46:	853e                	mv	a0,a5
    80001e48:	6145                	addi	sp,sp,48
    80001e4a:	8082                	ret

0000000080001e4c <vTaskPrioritySet>:

#if ( INCLUDE_vTaskPrioritySet == 1 )

    void vTaskPrioritySet( TaskHandle_t xTask,
                           UBaseType_t uxNewPriority )
    {
    80001e4c:	7139                	addi	sp,sp,-64
    80001e4e:	fc06                	sd	ra,56(sp)
    80001e50:	e42a                	sd	a0,8(sp)
    80001e52:	e02e                	sd	a1,0(sp)
        TCB_t * pxTCB;
        UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
        BaseType_t xYieldRequired = pdFALSE;
    80001e54:	f402                	sd	zero,40(sp)

        configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
    80001e56:	6702                	ld	a4,0(sp)
    80001e58:	4791                	li	a5,4
    80001e5a:	00e7f563          	bgeu	a5,a4,80001e64 <vTaskPrioritySet+0x18>
    80001e5e:	30047073          	csrci	mstatus,8
    80001e62:	a001                	j	80001e62 <vTaskPrioritySet+0x16>

        /* Ensure the new priority is valid. */
        if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    80001e64:	6702                	ld	a4,0(sp)
    80001e66:	4791                	li	a5,4
    80001e68:	00e7f463          	bgeu	a5,a4,80001e70 <vTaskPrioritySet+0x24>
        {
            uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    80001e6c:	4791                	li	a5,4
    80001e6e:	e03e                	sd	a5,0(sp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        taskENTER_CRITICAL();
    80001e70:	55c010ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the priority of the calling
             * task that is being changed. */
            pxTCB = prvGetTCBFromHandle( xTask );
    80001e74:	67a2                	ld	a5,8(sp)
    80001e76:	e799                	bnez	a5,80001e84 <vTaskPrioritySet+0x38>
    80001e78:	00009797          	auipc	a5,0x9
    80001e7c:	d5878793          	addi	a5,a5,-680 # 8000abd0 <pxCurrentTCB>
    80001e80:	639c                	ld	a5,0(a5)
    80001e82:	a011                	j	80001e86 <vTaskPrioritySet+0x3a>
    80001e84:	67a2                	ld	a5,8(sp)
    80001e86:	f03e                	sd	a5,32(sp)

            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

            #if ( configUSE_MUTEXES == 1 )
                {
                    uxCurrentBasePriority = pxTCB->uxBasePriority;
    80001e88:	7782                	ld	a5,32(sp)
    80001e8a:	6bdc                	ld	a5,144(a5)
    80001e8c:	ec3e                	sd	a5,24(sp)
                {
                    uxCurrentBasePriority = pxTCB->uxPriority;
                }
            #endif

            if( uxCurrentBasePriority != uxNewPriority )
    80001e8e:	6762                	ld	a4,24(sp)
    80001e90:	6782                	ld	a5,0(sp)
    80001e92:	10f70d63          	beq	a4,a5,80001fac <vTaskPrioritySet+0x160>
            {
                /* The priority change may have readied a task of higher
                 * priority than the calling task. */
                if( uxNewPriority > uxCurrentBasePriority )
    80001e96:	6702                	ld	a4,0(sp)
    80001e98:	67e2                	ld	a5,24(sp)
    80001e9a:	02e7f663          	bgeu	a5,a4,80001ec6 <vTaskPrioritySet+0x7a>
                {
                    if( pxTCB != pxCurrentTCB )
    80001e9e:	00009797          	auipc	a5,0x9
    80001ea2:	d3278793          	addi	a5,a5,-718 # 8000abd0 <pxCurrentTCB>
    80001ea6:	639c                	ld	a5,0(a5)
    80001ea8:	7702                	ld	a4,32(sp)
    80001eaa:	02f70863          	beq	a4,a5,80001eda <vTaskPrioritySet+0x8e>
                    {
                        /* The priority of a task other than the currently
                         * running task is being raised.  Is the priority being
                         * raised above that of the running task? */
                        if( uxNewPriority >= pxCurrentTCB->uxPriority )
    80001eae:	00009797          	auipc	a5,0x9
    80001eb2:	d2278793          	addi	a5,a5,-734 # 8000abd0 <pxCurrentTCB>
    80001eb6:	639c                	ld	a5,0(a5)
    80001eb8:	6fbc                	ld	a5,88(a5)
    80001eba:	6702                	ld	a4,0(sp)
    80001ebc:	00f76f63          	bltu	a4,a5,80001eda <vTaskPrioritySet+0x8e>
                        {
                            xYieldRequired = pdTRUE;
    80001ec0:	4785                	li	a5,1
    80001ec2:	f43e                	sd	a5,40(sp)
    80001ec4:	a819                	j	80001eda <vTaskPrioritySet+0x8e>
                        /* The priority of the running task is being raised,
                         * but the running task must already be the highest
                         * priority task able to run so no yield is required. */
                    }
                }
                else if( pxTCB == pxCurrentTCB )
    80001ec6:	00009797          	auipc	a5,0x9
    80001eca:	d0a78793          	addi	a5,a5,-758 # 8000abd0 <pxCurrentTCB>
    80001ece:	639c                	ld	a5,0(a5)
    80001ed0:	7702                	ld	a4,32(sp)
    80001ed2:	00f71463          	bne	a4,a5,80001eda <vTaskPrioritySet+0x8e>
                {
                    /* Setting the priority of the running task down means
                     * there may now be another task of higher priority that
                     * is ready to execute. */
                    xYieldRequired = pdTRUE;
    80001ed6:	4785                	li	a5,1
    80001ed8:	f43e                	sd	a5,40(sp)
                }

                /* Remember the ready list the task might be referenced from
                 * before its uxPriority member is changed so the
                 * taskRESET_READY_PRIORITY() macro can function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
    80001eda:	7782                	ld	a5,32(sp)
    80001edc:	6fbc                	ld	a5,88(a5)
    80001ede:	e83e                	sd	a5,16(sp)

                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* Only change the priority being used if the task is not
                         * currently using an inherited priority. */
                        if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    80001ee0:	7782                	ld	a5,32(sp)
    80001ee2:	6bd8                	ld	a4,144(a5)
    80001ee4:	7782                	ld	a5,32(sp)
    80001ee6:	6fbc                	ld	a5,88(a5)
    80001ee8:	00f71563          	bne	a4,a5,80001ef2 <vTaskPrioritySet+0xa6>
                        {
                            pxTCB->uxPriority = uxNewPriority;
    80001eec:	7782                	ld	a5,32(sp)
    80001eee:	6702                	ld	a4,0(sp)
    80001ef0:	efb8                	sd	a4,88(a5)
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        /* The base priority gets set whatever. */
                        pxTCB->uxBasePriority = uxNewPriority;
    80001ef2:	7782                	ld	a5,32(sp)
    80001ef4:	6702                	ld	a4,0(sp)
    80001ef6:	ebd8                	sd	a4,144(a5)
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                /* Only reset the event list item value if the value is not
                 * being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    80001ef8:	7782                	ld	a5,32(sp)
    80001efa:	7b98                	ld	a4,48(a5)
    80001efc:	4785                	li	a5,1
    80001efe:	07fe                	slli	a5,a5,0x1f
    80001f00:	8ff9                	and	a5,a5,a4
    80001f02:	e791                	bnez	a5,80001f0e <vTaskPrioritySet+0xc2>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    80001f04:	4715                	li	a4,5
    80001f06:	6782                	ld	a5,0(sp)
    80001f08:	8f1d                	sub	a4,a4,a5
    80001f0a:	7782                	ld	a5,32(sp)
    80001f0c:	fb98                	sd	a4,48(a5)

                /* If the task is in the blocked or suspended list we need do
                 * nothing more than change its priority variable. However, if
                 * the task is in a ready list it needs to be removed and placed
                 * in the list appropriate to its new priority. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    80001f0e:	7782                	ld	a5,32(sp)
    80001f10:	7794                	ld	a3,40(a5)
    80001f12:	6742                	ld	a4,16(sp)
    80001f14:	87ba                	mv	a5,a4
    80001f16:	078a                	slli	a5,a5,0x2
    80001f18:	97ba                	add	a5,a5,a4
    80001f1a:	078e                	slli	a5,a5,0x3
    80001f1c:	0000b717          	auipc	a4,0xb
    80001f20:	c2470713          	addi	a4,a4,-988 # 8000cb40 <pxReadyTasksLists>
    80001f24:	97ba                	add	a5,a5,a4
    80001f26:	06f69f63          	bne	a3,a5,80001fa4 <vTaskPrioritySet+0x158>
                {
                    /* The task is currently in its ready list - remove before
                     * adding it to it's new ready list.  As we are in a critical
                     * section we can do this even if the scheduler is suspended. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    80001f2a:	7782                	ld	a5,32(sp)
    80001f2c:	07a1                	addi	a5,a5,8
    80001f2e:	853e                	mv	a0,a5
    80001f30:	82ffe0ef          	jal	ra,8000075e <uxListRemove>
    80001f34:	87aa                	mv	a5,a0
    80001f36:	e785                	bnez	a5,80001f5e <vTaskPrioritySet+0x112>
                    {
                        /* It is known that the task is in its ready list so
                         * there is no need to check again and the port level
                         * reset macro can be called directly. */
                        portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
    80001f38:	67c2                	ld	a5,16(sp)
    80001f3a:	2781                	sext.w	a5,a5
    80001f3c:	873e                	mv	a4,a5
    80001f3e:	4785                	li	a5,1
    80001f40:	00e797b3          	sll	a5,a5,a4
    80001f44:	fff7c713          	not	a4,a5
    80001f48:	0000b797          	auipc	a5,0xb
    80001f4c:	db078793          	addi	a5,a5,-592 # 8000ccf8 <uxTopReadyPriority>
    80001f50:	639c                	ld	a5,0(a5)
    80001f52:	8f7d                	and	a4,a4,a5
    80001f54:	0000b797          	auipc	a5,0xb
    80001f58:	da478793          	addi	a5,a5,-604 # 8000ccf8 <uxTopReadyPriority>
    80001f5c:	e398                	sd	a4,0(a5)
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    prvAddTaskToReadyList( pxTCB );
    80001f5e:	7782                	ld	a5,32(sp)
    80001f60:	6fbc                	ld	a5,88(a5)
    80001f62:	2781                	sext.w	a5,a5
    80001f64:	873e                	mv	a4,a5
    80001f66:	4785                	li	a5,1
    80001f68:	00e79733          	sll	a4,a5,a4
    80001f6c:	0000b797          	auipc	a5,0xb
    80001f70:	d8c78793          	addi	a5,a5,-628 # 8000ccf8 <uxTopReadyPriority>
    80001f74:	639c                	ld	a5,0(a5)
    80001f76:	8f5d                	or	a4,a4,a5
    80001f78:	0000b797          	auipc	a5,0xb
    80001f7c:	d8078793          	addi	a5,a5,-640 # 8000ccf8 <uxTopReadyPriority>
    80001f80:	e398                	sd	a4,0(a5)
    80001f82:	7782                	ld	a5,32(sp)
    80001f84:	6fb8                	ld	a4,88(a5)
    80001f86:	87ba                	mv	a5,a4
    80001f88:	078a                	slli	a5,a5,0x2
    80001f8a:	97ba                	add	a5,a5,a4
    80001f8c:	078e                	slli	a5,a5,0x3
    80001f8e:	0000b717          	auipc	a4,0xb
    80001f92:	bb270713          	addi	a4,a4,-1102 # 8000cb40 <pxReadyTasksLists>
    80001f96:	973e                	add	a4,a4,a5
    80001f98:	7782                	ld	a5,32(sp)
    80001f9a:	07a1                	addi	a5,a5,8
    80001f9c:	85be                	mv	a1,a5
    80001f9e:	853a                	mv	a0,a4
    80001fa0:	f14fe0ef          	jal	ra,800006b4 <vListInsertEnd>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                if( xYieldRequired != pdFALSE )
    80001fa4:	77a2                	ld	a5,40(sp)
    80001fa6:	c399                	beqz	a5,80001fac <vTaskPrioritySet+0x160>
                {
                    taskYIELD_IF_USING_PREEMPTION();
    80001fa8:	00000073          	ecall
                /* Remove compiler warning about unused variables when the port
                 * optimised task selection is not being used. */
                ( void ) uxPriorityUsedOnEntry;
            }
        }
        taskEXIT_CRITICAL();
    80001fac:	44e010ef          	jal	ra,800033fa <vTaskExitCritical>
    }
    80001fb0:	0001                	nop
    80001fb2:	70e2                	ld	ra,56(sp)
    80001fb4:	6121                	addi	sp,sp,64
    80001fb6:	8082                	ret

0000000080001fb8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
    80001fb8:	7179                	addi	sp,sp,-48
    80001fba:	f406                	sd	ra,40(sp)
    80001fbc:	e42a                	sd	a0,8(sp)
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    80001fbe:	40e010ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    80001fc2:	67a2                	ld	a5,8(sp)
    80001fc4:	e799                	bnez	a5,80001fd2 <vTaskSuspend+0x1a>
    80001fc6:	00009797          	auipc	a5,0x9
    80001fca:	c0a78793          	addi	a5,a5,-1014 # 8000abd0 <pxCurrentTCB>
    80001fce:	639c                	ld	a5,0(a5)
    80001fd0:	a011                	j	80001fd4 <vTaskSuspend+0x1c>
    80001fd2:	67a2                	ld	a5,8(sp)
    80001fd4:	e83e                	sd	a5,16(sp)

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    80001fd6:	67c2                	ld	a5,16(sp)
    80001fd8:	07a1                	addi	a5,a5,8
    80001fda:	853e                	mv	a0,a5
    80001fdc:	f82fe0ef          	jal	ra,8000075e <uxListRemove>
    80001fe0:	87aa                	mv	a5,a0
    80001fe2:	e3b1                	bnez	a5,80002026 <vTaskSuspend+0x6e>
            {
                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    80001fe4:	67c2                	ld	a5,16(sp)
    80001fe6:	6fb8                	ld	a4,88(a5)
    80001fe8:	0000b697          	auipc	a3,0xb
    80001fec:	b5868693          	addi	a3,a3,-1192 # 8000cb40 <pxReadyTasksLists>
    80001ff0:	87ba                	mv	a5,a4
    80001ff2:	078a                	slli	a5,a5,0x2
    80001ff4:	97ba                	add	a5,a5,a4
    80001ff6:	078e                	slli	a5,a5,0x3
    80001ff8:	97b6                	add	a5,a5,a3
    80001ffa:	639c                	ld	a5,0(a5)
    80001ffc:	e78d                	bnez	a5,80002026 <vTaskSuspend+0x6e>
    80001ffe:	67c2                	ld	a5,16(sp)
    80002000:	6fbc                	ld	a5,88(a5)
    80002002:	2781                	sext.w	a5,a5
    80002004:	873e                	mv	a4,a5
    80002006:	4785                	li	a5,1
    80002008:	00e797b3          	sll	a5,a5,a4
    8000200c:	fff7c713          	not	a4,a5
    80002010:	0000b797          	auipc	a5,0xb
    80002014:	ce878793          	addi	a5,a5,-792 # 8000ccf8 <uxTopReadyPriority>
    80002018:	639c                	ld	a5,0(a5)
    8000201a:	8f7d                	and	a4,a4,a5
    8000201c:	0000b797          	auipc	a5,0xb
    80002020:	cdc78793          	addi	a5,a5,-804 # 8000ccf8 <uxTopReadyPriority>
    80002024:	e398                	sd	a4,0(a5)
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    80002026:	67c2                	ld	a5,16(sp)
    80002028:	6bbc                	ld	a5,80(a5)
    8000202a:	c799                	beqz	a5,80002038 <vTaskSuspend+0x80>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    8000202c:	67c2                	ld	a5,16(sp)
    8000202e:	03078793          	addi	a5,a5,48
    80002032:	853e                	mv	a0,a5
    80002034:	f2afe0ef          	jal	ra,8000075e <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    80002038:	67c2                	ld	a5,16(sp)
    8000203a:	07a1                	addi	a5,a5,8
    8000203c:	85be                	mv	a1,a5
    8000203e:	0000b517          	auipc	a0,0xb
    80002042:	c8250513          	addi	a0,a0,-894 # 8000ccc0 <xSuspendedTaskList>
    80002046:	e6efe0ef          	jal	ra,800006b4 <vListInsertEnd>

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    8000204a:	ec02                	sd	zero,24(sp)
    8000204c:	a025                	j	80002074 <vTaskSuspend+0xbc>
                    {
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
    8000204e:	6742                	ld	a4,16(sp)
    80002050:	67e2                	ld	a5,24(sp)
    80002052:	97ba                	add	a5,a5,a4
    80002054:	0a47c783          	lbu	a5,164(a5)
    80002058:	0ff7f793          	andi	a5,a5,255
    8000205c:	873e                	mv	a4,a5
    8000205e:	4785                	li	a5,1
    80002060:	00f71763          	bne	a4,a5,8000206e <vTaskSuspend+0xb6>
                        {
                            /* The task was blocked to wait for a notification, but is
                             * now suspended, so no notification was received. */
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
    80002064:	6742                	ld	a4,16(sp)
    80002066:	67e2                	ld	a5,24(sp)
    80002068:	97ba                	add	a5,a5,a4
    8000206a:	0a078223          	sb	zero,164(a5)
                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    8000206e:	67e2                	ld	a5,24(sp)
    80002070:	0785                	addi	a5,a5,1
    80002072:	ec3e                	sd	a5,24(sp)
    80002074:	67e2                	ld	a5,24(sp)
    80002076:	fcf05ce3          	blez	a5,8000204e <vTaskSuspend+0x96>
                        }
                    }
                }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
    8000207a:	380010ef          	jal	ra,800033fa <vTaskExitCritical>

        if( xSchedulerRunning != pdFALSE )
    8000207e:	0000b797          	auipc	a5,0xb
    80002082:	c8278793          	addi	a5,a5,-894 # 8000cd00 <xSchedulerRunning>
    80002086:	639c                	ld	a5,0(a5)
    80002088:	c799                	beqz	a5,80002096 <vTaskSuspend+0xde>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
    8000208a:	342010ef          	jal	ra,800033cc <vTaskEnterCritical>
            {
                prvResetNextTaskUnblockTime();
    8000208e:	785000ef          	jal	ra,80003012 <prvResetNextTaskUnblockTime>
            }
            taskEXIT_CRITICAL();
    80002092:	368010ef          	jal	ra,800033fa <vTaskExitCritical>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
    80002096:	00009797          	auipc	a5,0x9
    8000209a:	b3a78793          	addi	a5,a5,-1222 # 8000abd0 <pxCurrentTCB>
    8000209e:	639c                	ld	a5,0(a5)
    800020a0:	6742                	ld	a4,16(sp)
    800020a2:	04f71963          	bne	a4,a5,800020f4 <vTaskSuspend+0x13c>
        {
            if( xSchedulerRunning != pdFALSE )
    800020a6:	0000b797          	auipc	a5,0xb
    800020aa:	c5a78793          	addi	a5,a5,-934 # 8000cd00 <xSchedulerRunning>
    800020ae:	639c                	ld	a5,0(a5)
    800020b0:	cf89                	beqz	a5,800020ca <vTaskSuspend+0x112>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
    800020b2:	0000b797          	auipc	a5,0xb
    800020b6:	c8678793          	addi	a5,a5,-890 # 8000cd38 <uxSchedulerSuspended>
    800020ba:	639c                	ld	a5,0(a5)
    800020bc:	c781                	beqz	a5,800020c4 <vTaskSuspend+0x10c>
    800020be:	30047073          	csrci	mstatus,8
    800020c2:	a001                	j	800020c2 <vTaskSuspend+0x10a>
                portYIELD_WITHIN_API();
    800020c4:	00000073          	ecall
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    800020c8:	a035                	j	800020f4 <vTaskSuspend+0x13c>
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    800020ca:	0000b797          	auipc	a5,0xb
    800020ce:	bf678793          	addi	a5,a5,-1034 # 8000ccc0 <xSuspendedTaskList>
    800020d2:	6398                	ld	a4,0(a5)
    800020d4:	0000b797          	auipc	a5,0xb
    800020d8:	c1478793          	addi	a5,a5,-1004 # 8000cce8 <uxCurrentNumberOfTasks>
    800020dc:	639c                	ld	a5,0(a5)
    800020de:	00f71963          	bne	a4,a5,800020f0 <vTaskSuspend+0x138>
                    pxCurrentTCB = NULL;
    800020e2:	00009797          	auipc	a5,0x9
    800020e6:	aee78793          	addi	a5,a5,-1298 # 8000abd0 <pxCurrentTCB>
    800020ea:	0007b023          	sd	zero,0(a5)
    }
    800020ee:	a019                	j	800020f4 <vTaskSuspend+0x13c>
                    vTaskSwitchContext();
    800020f0:	752000ef          	jal	ra,80002842 <vTaskSwitchContext>
    }
    800020f4:	0001                	nop
    800020f6:	70a2                	ld	ra,40(sp)
    800020f8:	6145                	addi	sp,sp,48
    800020fa:	8082                	ret

00000000800020fc <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
    800020fc:	1101                	addi	sp,sp,-32
    800020fe:	e42a                	sd	a0,8(sp)
        BaseType_t xReturn = pdFALSE;
    80002100:	ec02                	sd	zero,24(sp)
        const TCB_t * const pxTCB = xTask;
    80002102:	67a2                	ld	a5,8(sp)
    80002104:	e83e                	sd	a5,16(sp)

        /* Accesses xPendingReadyList so must be called from a critical
         * section. */

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );
    80002106:	67a2                	ld	a5,8(sp)
    80002108:	e781                	bnez	a5,80002110 <prvTaskIsTaskSuspended+0x14>
    8000210a:	30047073          	csrci	mstatus,8
    8000210e:	a001                	j	8000210e <prvTaskIsTaskSuspended+0x12>

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    80002110:	67c2                	ld	a5,16(sp)
    80002112:	7798                	ld	a4,40(a5)
    80002114:	0000b797          	auipc	a5,0xb
    80002118:	bac78793          	addi	a5,a5,-1108 # 8000ccc0 <xSuspendedTaskList>
    8000211c:	00f71f63          	bne	a4,a5,8000213a <prvTaskIsTaskSuspended+0x3e>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    80002120:	67c2                	ld	a5,16(sp)
    80002122:	6bb8                	ld	a4,80(a5)
    80002124:	0000b797          	auipc	a5,0xb
    80002128:	b4478793          	addi	a5,a5,-1212 # 8000cc68 <xPendingReadyList>
    8000212c:	00f70763          	beq	a4,a5,8000213a <prvTaskIsTaskSuspended+0x3e>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    80002130:	67c2                	ld	a5,16(sp)
    80002132:	6bbc                	ld	a5,80(a5)
    80002134:	e399                	bnez	a5,8000213a <prvTaskIsTaskSuspended+0x3e>
                {
                    xReturn = pdTRUE;
    80002136:	4785                	li	a5,1
    80002138:	ec3e                	sd	a5,24(sp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    8000213a:	67e2                	ld	a5,24(sp)
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    8000213c:	853e                	mv	a0,a5
    8000213e:	6105                	addi	sp,sp,32
    80002140:	8082                	ret

0000000080002142 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
    80002142:	7179                	addi	sp,sp,-48
    80002144:	f406                	sd	ra,40(sp)
    80002146:	e42a                	sd	a0,8(sp)
        TCB_t * const pxTCB = xTaskToResume;
    80002148:	67a2                	ld	a5,8(sp)
    8000214a:	ec3e                	sd	a5,24(sp)

        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );
    8000214c:	67a2                	ld	a5,8(sp)
    8000214e:	e781                	bnez	a5,80002156 <vTaskResume+0x14>
    80002150:	30047073          	csrci	mstatus,8
    80002154:	a001                	j	80002154 <vTaskResume+0x12>

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    80002156:	00009797          	auipc	a5,0x9
    8000215a:	a7a78793          	addi	a5,a5,-1414 # 8000abd0 <pxCurrentTCB>
    8000215e:	639c                	ld	a5,0(a5)
    80002160:	6762                	ld	a4,24(sp)
    80002162:	08f70163          	beq	a4,a5,800021e4 <vTaskResume+0xa2>
    80002166:	67e2                	ld	a5,24(sp)
    80002168:	cfb5                	beqz	a5,800021e4 <vTaskResume+0xa2>
        {
            taskENTER_CRITICAL();
    8000216a:	262010ef          	jal	ra,800033cc <vTaskEnterCritical>
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    8000216e:	6562                	ld	a0,24(sp)
    80002170:	f8dff0ef          	jal	ra,800020fc <prvTaskIsTaskSuspended>
    80002174:	87aa                	mv	a5,a0
    80002176:	c7ad                	beqz	a5,800021e0 <vTaskResume+0x9e>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    80002178:	67e2                	ld	a5,24(sp)
    8000217a:	07a1                	addi	a5,a5,8
    8000217c:	853e                	mv	a0,a5
    8000217e:	de0fe0ef          	jal	ra,8000075e <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    80002182:	67e2                	ld	a5,24(sp)
    80002184:	6fbc                	ld	a5,88(a5)
    80002186:	2781                	sext.w	a5,a5
    80002188:	873e                	mv	a4,a5
    8000218a:	4785                	li	a5,1
    8000218c:	00e79733          	sll	a4,a5,a4
    80002190:	0000b797          	auipc	a5,0xb
    80002194:	b6878793          	addi	a5,a5,-1176 # 8000ccf8 <uxTopReadyPriority>
    80002198:	639c                	ld	a5,0(a5)
    8000219a:	8f5d                	or	a4,a4,a5
    8000219c:	0000b797          	auipc	a5,0xb
    800021a0:	b5c78793          	addi	a5,a5,-1188 # 8000ccf8 <uxTopReadyPriority>
    800021a4:	e398                	sd	a4,0(a5)
    800021a6:	67e2                	ld	a5,24(sp)
    800021a8:	6fb8                	ld	a4,88(a5)
    800021aa:	87ba                	mv	a5,a4
    800021ac:	078a                	slli	a5,a5,0x2
    800021ae:	97ba                	add	a5,a5,a4
    800021b0:	078e                	slli	a5,a5,0x3
    800021b2:	0000b717          	auipc	a4,0xb
    800021b6:	98e70713          	addi	a4,a4,-1650 # 8000cb40 <pxReadyTasksLists>
    800021ba:	973e                	add	a4,a4,a5
    800021bc:	67e2                	ld	a5,24(sp)
    800021be:	07a1                	addi	a5,a5,8
    800021c0:	85be                	mv	a1,a5
    800021c2:	853a                	mv	a0,a4
    800021c4:	cf0fe0ef          	jal	ra,800006b4 <vListInsertEnd>

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    800021c8:	67e2                	ld	a5,24(sp)
    800021ca:	6fb8                	ld	a4,88(a5)
    800021cc:	00009797          	auipc	a5,0x9
    800021d0:	a0478793          	addi	a5,a5,-1532 # 8000abd0 <pxCurrentTCB>
    800021d4:	639c                	ld	a5,0(a5)
    800021d6:	6fbc                	ld	a5,88(a5)
    800021d8:	00f76463          	bltu	a4,a5,800021e0 <vTaskResume+0x9e>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
    800021dc:	00000073          	ecall
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    800021e0:	21a010ef          	jal	ra,800033fa <vTaskExitCritical>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    800021e4:	0001                	nop
    800021e6:	70a2                	ld	ra,40(sp)
    800021e8:	6145                	addi	sp,sp,48
    800021ea:	8082                	ret

00000000800021ec <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
    800021ec:	7139                	addi	sp,sp,-64
    800021ee:	fc06                	sd	ra,56(sp)
    800021f0:	e42a                	sd	a0,8(sp)
        BaseType_t xYieldRequired = pdFALSE;
    800021f2:	f402                	sd	zero,40(sp)
        TCB_t * const pxTCB = xTaskToResume;
    800021f4:	67a2                	ld	a5,8(sp)
    800021f6:	f03e                	sd	a5,32(sp)
        UBaseType_t uxSavedInterruptStatus;

        configASSERT( xTaskToResume );
    800021f8:	67a2                	ld	a5,8(sp)
    800021fa:	e781                	bnez	a5,80002202 <xTaskResumeFromISR+0x16>
    800021fc:	30047073          	csrci	mstatus,8
    80002200:	a001                	j	80002200 <xTaskResumeFromISR+0x14>
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    80002202:	ec02                	sd	zero,24(sp)
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    80002204:	7502                	ld	a0,32(sp)
    80002206:	ef7ff0ef          	jal	ra,800020fc <prvTaskIsTaskSuspended>
    8000220a:	87aa                	mv	a5,a0
    8000220c:	c7d1                	beqz	a5,80002298 <xTaskResumeFromISR+0xac>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    8000220e:	0000b797          	auipc	a5,0xb
    80002212:	b2a78793          	addi	a5,a5,-1238 # 8000cd38 <uxSchedulerSuspended>
    80002216:	639c                	ld	a5,0(a5)
    80002218:	e7b5                	bnez	a5,80002284 <xTaskResumeFromISR+0x98>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    8000221a:	7782                	ld	a5,32(sp)
    8000221c:	6fb8                	ld	a4,88(a5)
    8000221e:	00009797          	auipc	a5,0x9
    80002222:	9b278793          	addi	a5,a5,-1614 # 8000abd0 <pxCurrentTCB>
    80002226:	639c                	ld	a5,0(a5)
    80002228:	6fbc                	ld	a5,88(a5)
    8000222a:	00f76463          	bltu	a4,a5,80002232 <xTaskResumeFromISR+0x46>
                    {
                        xYieldRequired = pdTRUE;
    8000222e:	4785                	li	a5,1
    80002230:	f43e                	sd	a5,40(sp)
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    80002232:	7782                	ld	a5,32(sp)
    80002234:	07a1                	addi	a5,a5,8
    80002236:	853e                	mv	a0,a5
    80002238:	d26fe0ef          	jal	ra,8000075e <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    8000223c:	7782                	ld	a5,32(sp)
    8000223e:	6fbc                	ld	a5,88(a5)
    80002240:	2781                	sext.w	a5,a5
    80002242:	873e                	mv	a4,a5
    80002244:	4785                	li	a5,1
    80002246:	00e79733          	sll	a4,a5,a4
    8000224a:	0000b797          	auipc	a5,0xb
    8000224e:	aae78793          	addi	a5,a5,-1362 # 8000ccf8 <uxTopReadyPriority>
    80002252:	639c                	ld	a5,0(a5)
    80002254:	8f5d                	or	a4,a4,a5
    80002256:	0000b797          	auipc	a5,0xb
    8000225a:	aa278793          	addi	a5,a5,-1374 # 8000ccf8 <uxTopReadyPriority>
    8000225e:	e398                	sd	a4,0(a5)
    80002260:	7782                	ld	a5,32(sp)
    80002262:	6fb8                	ld	a4,88(a5)
    80002264:	87ba                	mv	a5,a4
    80002266:	078a                	slli	a5,a5,0x2
    80002268:	97ba                	add	a5,a5,a4
    8000226a:	078e                	slli	a5,a5,0x3
    8000226c:	0000b717          	auipc	a4,0xb
    80002270:	8d470713          	addi	a4,a4,-1836 # 8000cb40 <pxReadyTasksLists>
    80002274:	973e                	add	a4,a4,a5
    80002276:	7782                	ld	a5,32(sp)
    80002278:	07a1                	addi	a5,a5,8
    8000227a:	85be                	mv	a1,a5
    8000227c:	853a                	mv	a0,a4
    8000227e:	c36fe0ef          	jal	ra,800006b4 <vListInsertEnd>
    80002282:	a819                	j	80002298 <xTaskResumeFromISR+0xac>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    80002284:	7782                	ld	a5,32(sp)
    80002286:	03078793          	addi	a5,a5,48
    8000228a:	85be                	mv	a1,a5
    8000228c:	0000b517          	auipc	a0,0xb
    80002290:	9dc50513          	addi	a0,a0,-1572 # 8000cc68 <xPendingReadyList>
    80002294:	c20fe0ef          	jal	ra,800006b4 <vListInsertEnd>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    80002298:	77a2                	ld	a5,40(sp)
    }
    8000229a:	853e                	mv	a0,a5
    8000229c:	70e2                	ld	ra,56(sp)
    8000229e:	6121                	addi	sp,sp,64
    800022a0:	8082                	ret

00000000800022a2 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    800022a2:	1101                	addi	sp,sp,-32
    800022a4:	ec06                	sd	ra,24(sp)
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    800022a6:	0000b797          	auipc	a5,0xb
    800022aa:	a8a78793          	addi	a5,a5,-1398 # 8000cd30 <xIdleTaskHandle>
    800022ae:	4701                	li	a4,0
    800022b0:	4681                	li	a3,0
    800022b2:	6605                	lui	a2,0x1
    800022b4:	00007597          	auipc	a1,0x7
    800022b8:	0a458593          	addi	a1,a1,164 # 80009358 <__rodata_start>
    800022bc:	00001517          	auipc	a0,0x1
    800022c0:	a5850513          	addi	a0,a0,-1448 # 80002d14 <prvIdleTask>
    800022c4:	d70ff0ef          	jal	ra,80001834 <xTaskCreate>
    800022c8:	e42a                	sd	a0,8(sp)
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    800022ca:	6722                	ld	a4,8(sp)
    800022cc:	4785                	li	a5,1
    800022ce:	00f71563          	bne	a4,a5,800022d8 <vTaskStartScheduler+0x36>
            {
                xReturn = xTimerCreateTimerTask();
    800022d2:	281010ef          	jal	ra,80003d52 <xTimerCreateTimerTask>
    800022d6:	e42a                	sd	a0,8(sp)
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    800022d8:	6722                	ld	a4,8(sp)
    800022da:	4785                	li	a5,1
    800022dc:	02f71963          	bne	a4,a5,8000230e <vTaskStartScheduler+0x6c>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    800022e0:	30047073          	csrci	mstatus,8
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    800022e4:	0000b797          	auipc	a5,0xb
    800022e8:	a4478793          	addi	a5,a5,-1468 # 8000cd28 <xNextTaskUnblockTime>
    800022ec:	577d                	li	a4,-1
    800022ee:	e398                	sd	a4,0(a5)
        xSchedulerRunning = pdTRUE;
    800022f0:	0000b797          	auipc	a5,0xb
    800022f4:	a1078793          	addi	a5,a5,-1520 # 8000cd00 <xSchedulerRunning>
    800022f8:	4705                	li	a4,1
    800022fa:	e398                	sd	a4,0(a5)
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    800022fc:	0000b797          	auipc	a5,0xb
    80002300:	9f478793          	addi	a5,a5,-1548 # 8000ccf0 <xTickCount>
    80002304:	0007b023          	sd	zero,0(a5)

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    80002308:	ee3fd0ef          	jal	ra,800001ea <xPortStartScheduler>
    }

    /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;
}
    8000230c:	a801                	j	8000231c <vTaskStartScheduler+0x7a>
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    8000230e:	6722                	ld	a4,8(sp)
    80002310:	57fd                	li	a5,-1
    80002312:	00f71563          	bne	a4,a5,8000231c <vTaskStartScheduler+0x7a>
    80002316:	30047073          	csrci	mstatus,8
    8000231a:	a001                	j	8000231a <vTaskStartScheduler+0x78>
}
    8000231c:	0001                	nop
    8000231e:	60e2                	ld	ra,24(sp)
    80002320:	6105                	addi	sp,sp,32
    80002322:	8082                	ret

0000000080002324 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    80002324:	1141                	addi	sp,sp,-16
    80002326:	e406                	sd	ra,8(sp)
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    80002328:	30047073          	csrci	mstatus,8
    xSchedulerRunning = pdFALSE;
    8000232c:	0000b797          	auipc	a5,0xb
    80002330:	9d478793          	addi	a5,a5,-1580 # 8000cd00 <xSchedulerRunning>
    80002334:	0007b023          	sd	zero,0(a5)
    vPortEndScheduler();
    80002338:	f17fd0ef          	jal	ra,8000024e <vPortEndScheduler>
}
    8000233c:	0001                	nop
    8000233e:	60a2                	ld	ra,8(sp)
    80002340:	0141                	addi	sp,sp,16
    80002342:	8082                	ret

0000000080002344 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    80002344:	0000b797          	auipc	a5,0xb
    80002348:	9f478793          	addi	a5,a5,-1548 # 8000cd38 <uxSchedulerSuspended>
    8000234c:	639c                	ld	a5,0(a5)
    8000234e:	00178713          	addi	a4,a5,1
    80002352:	0000b797          	auipc	a5,0xb
    80002356:	9e678793          	addi	a5,a5,-1562 # 8000cd38 <uxSchedulerSuspended>
    8000235a:	e398                	sd	a4,0(a5)

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    8000235c:	0001                	nop
    8000235e:	8082                	ret

0000000080002360 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    80002360:	7179                	addi	sp,sp,-48
    80002362:	f406                	sd	ra,40(sp)
    TCB_t * pxTCB = NULL;
    80002364:	ec02                	sd	zero,24(sp)
    BaseType_t xAlreadyYielded = pdFALSE;
    80002366:	e802                	sd	zero,16(sp)

    /* If uxSchedulerSuspended is zero then this function does not match a
     * previous call to vTaskSuspendAll(). */
    configASSERT( uxSchedulerSuspended );
    80002368:	0000b797          	auipc	a5,0xb
    8000236c:	9d078793          	addi	a5,a5,-1584 # 8000cd38 <uxSchedulerSuspended>
    80002370:	639c                	ld	a5,0(a5)
    80002372:	e781                	bnez	a5,8000237a <xTaskResumeAll+0x1a>
    80002374:	30047073          	csrci	mstatus,8
    80002378:	a001                	j	80002378 <xTaskResumeAll+0x18>
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    8000237a:	052010ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        --uxSchedulerSuspended;
    8000237e:	0000b797          	auipc	a5,0xb
    80002382:	9ba78793          	addi	a5,a5,-1606 # 8000cd38 <uxSchedulerSuspended>
    80002386:	639c                	ld	a5,0(a5)
    80002388:	fff78713          	addi	a4,a5,-1
    8000238c:	0000b797          	auipc	a5,0xb
    80002390:	9ac78793          	addi	a5,a5,-1620 # 8000cd38 <uxSchedulerSuspended>
    80002394:	e398                	sd	a4,0(a5)

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    80002396:	0000b797          	auipc	a5,0xb
    8000239a:	9a278793          	addi	a5,a5,-1630 # 8000cd38 <uxSchedulerSuspended>
    8000239e:	639c                	ld	a5,0(a5)
    800023a0:	10079063          	bnez	a5,800024a0 <xTaskResumeAll+0x140>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    800023a4:	0000b797          	auipc	a5,0xb
    800023a8:	94478793          	addi	a5,a5,-1724 # 8000cce8 <uxCurrentNumberOfTasks>
    800023ac:	639c                	ld	a5,0(a5)
    800023ae:	0e078963          	beqz	a5,800024a0 <xTaskResumeAll+0x140>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    800023b2:	a071                	j	8000243e <xTaskResumeAll+0xde>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    800023b4:	0000b797          	auipc	a5,0xb
    800023b8:	8b478793          	addi	a5,a5,-1868 # 8000cc68 <xPendingReadyList>
    800023bc:	6f9c                	ld	a5,24(a5)
    800023be:	6f9c                	ld	a5,24(a5)
    800023c0:	ec3e                	sd	a5,24(sp)
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    800023c2:	67e2                	ld	a5,24(sp)
    800023c4:	03078793          	addi	a5,a5,48
    800023c8:	853e                	mv	a0,a5
    800023ca:	b94fe0ef          	jal	ra,8000075e <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    800023ce:	67e2                	ld	a5,24(sp)
    800023d0:	07a1                	addi	a5,a5,8
    800023d2:	853e                	mv	a0,a5
    800023d4:	b8afe0ef          	jal	ra,8000075e <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    800023d8:	67e2                	ld	a5,24(sp)
    800023da:	6fbc                	ld	a5,88(a5)
    800023dc:	2781                	sext.w	a5,a5
    800023de:	873e                	mv	a4,a5
    800023e0:	4785                	li	a5,1
    800023e2:	00e79733          	sll	a4,a5,a4
    800023e6:	0000b797          	auipc	a5,0xb
    800023ea:	91278793          	addi	a5,a5,-1774 # 8000ccf8 <uxTopReadyPriority>
    800023ee:	639c                	ld	a5,0(a5)
    800023f0:	8f5d                	or	a4,a4,a5
    800023f2:	0000b797          	auipc	a5,0xb
    800023f6:	90678793          	addi	a5,a5,-1786 # 8000ccf8 <uxTopReadyPriority>
    800023fa:	e398                	sd	a4,0(a5)
    800023fc:	67e2                	ld	a5,24(sp)
    800023fe:	6fb8                	ld	a4,88(a5)
    80002400:	87ba                	mv	a5,a4
    80002402:	078a                	slli	a5,a5,0x2
    80002404:	97ba                	add	a5,a5,a4
    80002406:	078e                	slli	a5,a5,0x3
    80002408:	0000a717          	auipc	a4,0xa
    8000240c:	73870713          	addi	a4,a4,1848 # 8000cb40 <pxReadyTasksLists>
    80002410:	973e                	add	a4,a4,a5
    80002412:	67e2                	ld	a5,24(sp)
    80002414:	07a1                	addi	a5,a5,8
    80002416:	85be                	mv	a1,a5
    80002418:	853a                	mv	a0,a4
    8000241a:	a9afe0ef          	jal	ra,800006b4 <vListInsertEnd>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    8000241e:	67e2                	ld	a5,24(sp)
    80002420:	6fb8                	ld	a4,88(a5)
    80002422:	00008797          	auipc	a5,0x8
    80002426:	7ae78793          	addi	a5,a5,1966 # 8000abd0 <pxCurrentTCB>
    8000242a:	639c                	ld	a5,0(a5)
    8000242c:	6fbc                	ld	a5,88(a5)
    8000242e:	00f76863          	bltu	a4,a5,8000243e <xTaskResumeAll+0xde>
                    {
                        xYieldPending = pdTRUE;
    80002432:	0000b797          	auipc	a5,0xb
    80002436:	8de78793          	addi	a5,a5,-1826 # 8000cd10 <xYieldPending>
    8000243a:	4705                	li	a4,1
    8000243c:	e398                	sd	a4,0(a5)
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    8000243e:	0000b797          	auipc	a5,0xb
    80002442:	82a78793          	addi	a5,a5,-2006 # 8000cc68 <xPendingReadyList>
    80002446:	639c                	ld	a5,0(a5)
    80002448:	f7b5                	bnez	a5,800023b4 <xTaskResumeAll+0x54>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    8000244a:	67e2                	ld	a5,24(sp)
    8000244c:	c399                	beqz	a5,80002452 <xTaskResumeAll+0xf2>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    8000244e:	3c5000ef          	jal	ra,80003012 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    80002452:	0000b797          	auipc	a5,0xb
    80002456:	8b678793          	addi	a5,a5,-1866 # 8000cd08 <xPendedTicks>
    8000245a:	639c                	ld	a5,0(a5)
    8000245c:	e43e                	sd	a5,8(sp)

                    if( xPendedCounts > ( TickType_t ) 0U )
    8000245e:	67a2                	ld	a5,8(sp)
    80002460:	c795                	beqz	a5,8000248c <xTaskResumeAll+0x12c>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    80002462:	220000ef          	jal	ra,80002682 <xTaskIncrementTick>
    80002466:	87aa                	mv	a5,a0
    80002468:	c799                	beqz	a5,80002476 <xTaskResumeAll+0x116>
                            {
                                xYieldPending = pdTRUE;
    8000246a:	0000b797          	auipc	a5,0xb
    8000246e:	8a678793          	addi	a5,a5,-1882 # 8000cd10 <xYieldPending>
    80002472:	4705                	li	a4,1
    80002474:	e398                	sd	a4,0(a5)
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    80002476:	67a2                	ld	a5,8(sp)
    80002478:	17fd                	addi	a5,a5,-1
    8000247a:	e43e                	sd	a5,8(sp)
                        } while( xPendedCounts > ( TickType_t ) 0U );
    8000247c:	67a2                	ld	a5,8(sp)
    8000247e:	f3f5                	bnez	a5,80002462 <xTaskResumeAll+0x102>

                        xPendedTicks = 0;
    80002480:	0000b797          	auipc	a5,0xb
    80002484:	88878793          	addi	a5,a5,-1912 # 8000cd08 <xPendedTicks>
    80002488:	0007b023          	sd	zero,0(a5)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    8000248c:	0000b797          	auipc	a5,0xb
    80002490:	88478793          	addi	a5,a5,-1916 # 8000cd10 <xYieldPending>
    80002494:	639c                	ld	a5,0(a5)
    80002496:	c789                	beqz	a5,800024a0 <xTaskResumeAll+0x140>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    80002498:	4785                	li	a5,1
    8000249a:	e83e                	sd	a5,16(sp)
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    8000249c:	00000073          	ecall
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    800024a0:	75b000ef          	jal	ra,800033fa <vTaskExitCritical>

    return xAlreadyYielded;
    800024a4:	67c2                	ld	a5,16(sp)
}
    800024a6:	853e                	mv	a0,a5
    800024a8:	70a2                	ld	ra,40(sp)
    800024aa:	6145                	addi	sp,sp,48
    800024ac:	8082                	ret

00000000800024ae <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    800024ae:	1141                	addi	sp,sp,-16
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
    800024b0:	0000b797          	auipc	a5,0xb
    800024b4:	84078793          	addi	a5,a5,-1984 # 8000ccf0 <xTickCount>
    800024b8:	639c                	ld	a5,0(a5)
    800024ba:	e43e                	sd	a5,8(sp)
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
    800024bc:	67a2                	ld	a5,8(sp)
}
    800024be:	853e                	mv	a0,a5
    800024c0:	0141                	addi	sp,sp,16
    800024c2:	8082                	ret

00000000800024c4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    800024c4:	1141                	addi	sp,sp,-16
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    800024c6:	e402                	sd	zero,8(sp)
    {
        xReturn = xTickCount;
    800024c8:	0000b797          	auipc	a5,0xb
    800024cc:	82878793          	addi	a5,a5,-2008 # 8000ccf0 <xTickCount>
    800024d0:	639c                	ld	a5,0(a5)
    800024d2:	e03e                	sd	a5,0(sp)
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    800024d4:	6782                	ld	a5,0(sp)
}
    800024d6:	853e                	mv	a0,a5
    800024d8:	0141                	addi	sp,sp,16
    800024da:	8082                	ret

00000000800024dc <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    800024dc:	0000b797          	auipc	a5,0xb
    800024e0:	80c78793          	addi	a5,a5,-2036 # 8000cce8 <uxCurrentNumberOfTasks>
    800024e4:	639c                	ld	a5,0(a5)
}
    800024e6:	853e                	mv	a0,a5
    800024e8:	8082                	ret

00000000800024ea <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    800024ea:	1101                	addi	sp,sp,-32
    800024ec:	e42a                	sd	a0,8(sp)
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    800024ee:	67a2                	ld	a5,8(sp)
    800024f0:	e799                	bnez	a5,800024fe <pcTaskGetName+0x14>
    800024f2:	00008797          	auipc	a5,0x8
    800024f6:	6de78793          	addi	a5,a5,1758 # 8000abd0 <pxCurrentTCB>
    800024fa:	639c                	ld	a5,0(a5)
    800024fc:	a011                	j	80002500 <pcTaskGetName+0x16>
    800024fe:	67a2                	ld	a5,8(sp)
    80002500:	ec3e                	sd	a5,24(sp)
    configASSERT( pxTCB );
    80002502:	67e2                	ld	a5,24(sp)
    80002504:	e781                	bnez	a5,8000250c <pcTaskGetName+0x22>
    80002506:	30047073          	csrci	mstatus,8
    8000250a:	a001                	j	8000250a <pcTaskGetName+0x20>
    return &( pxTCB->pcTaskName[ 0 ] );
    8000250c:	67e2                	ld	a5,24(sp)
    8000250e:	06878793          	addi	a5,a5,104
}
    80002512:	853e                	mv	a0,a5
    80002514:	6105                	addi	sp,sp,32
    80002516:	8082                	ret

0000000080002518 <uxTaskGetSystemState>:
#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
                                      const UBaseType_t uxArraySize,
                                      uint32_t * const pulTotalRunTime )
    {
    80002518:	7139                	addi	sp,sp,-64
    8000251a:	fc06                	sd	ra,56(sp)
    8000251c:	ec2a                	sd	a0,24(sp)
    8000251e:	e82e                	sd	a1,16(sp)
    80002520:	e432                	sd	a2,8(sp)
        UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
    80002522:	f402                	sd	zero,40(sp)
    80002524:	4795                	li	a5,5
    80002526:	f03e                	sd	a5,32(sp)

        vTaskSuspendAll();
    80002528:	e1dff0ef          	jal	ra,80002344 <vTaskSuspendAll>
        {
            /* Is there a space in the array for each task in the system? */
            if( uxArraySize >= uxCurrentNumberOfTasks )
    8000252c:	0000a797          	auipc	a5,0xa
    80002530:	7bc78793          	addi	a5,a5,1980 # 8000cce8 <uxCurrentNumberOfTasks>
    80002534:	639c                	ld	a5,0(a5)
    80002536:	6742                	ld	a4,16(sp)
    80002538:	0ef76c63          	bltu	a4,a5,80002630 <uxTaskGetSystemState+0x118>
            {
                /* Fill in an TaskStatus_t structure with information on each
                 * task in the Ready state. */
                do
                {
                    uxQueue--;
    8000253c:	7782                	ld	a5,32(sp)
    8000253e:	17fd                	addi	a5,a5,-1
    80002540:	f03e                	sd	a5,32(sp)
                    uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
    80002542:	7722                	ld	a4,40(sp)
    80002544:	87ba                	mv	a5,a4
    80002546:	078e                	slli	a5,a5,0x3
    80002548:	97ba                	add	a5,a5,a4
    8000254a:	078e                	slli	a5,a5,0x3
    8000254c:	873e                	mv	a4,a5
    8000254e:	67e2                	ld	a5,24(sp)
    80002550:	00e786b3          	add	a3,a5,a4
    80002554:	7702                	ld	a4,32(sp)
    80002556:	87ba                	mv	a5,a4
    80002558:	078a                	slli	a5,a5,0x2
    8000255a:	97ba                	add	a5,a5,a4
    8000255c:	078e                	slli	a5,a5,0x3
    8000255e:	0000a717          	auipc	a4,0xa
    80002562:	5e270713          	addi	a4,a4,1506 # 8000cb40 <pxReadyTasksLists>
    80002566:	97ba                	add	a5,a5,a4
    80002568:	4605                	li	a2,1
    8000256a:	85be                	mv	a1,a5
    8000256c:	8536                	mv	a0,a3
    8000256e:	1ad000ef          	jal	ra,80002f1a <prvListTasksWithinSingleList>
    80002572:	872a                	mv	a4,a0
    80002574:	77a2                	ld	a5,40(sp)
    80002576:	97ba                	add	a5,a5,a4
    80002578:	f43e                	sd	a5,40(sp)
                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    8000257a:	7782                	ld	a5,32(sp)
    8000257c:	f3e1                	bnez	a5,8000253c <uxTaskGetSystemState+0x24>

                /* Fill in an TaskStatus_t structure with information on each
                 * task in the Blocked state. */
                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
    8000257e:	7722                	ld	a4,40(sp)
    80002580:	87ba                	mv	a5,a4
    80002582:	078e                	slli	a5,a5,0x3
    80002584:	97ba                	add	a5,a5,a4
    80002586:	078e                	slli	a5,a5,0x3
    80002588:	873e                	mv	a4,a5
    8000258a:	67e2                	ld	a5,24(sp)
    8000258c:	973e                	add	a4,a4,a5
    8000258e:	0000a797          	auipc	a5,0xa
    80002592:	6ca78793          	addi	a5,a5,1738 # 8000cc58 <pxDelayedTaskList>
    80002596:	639c                	ld	a5,0(a5)
    80002598:	4609                	li	a2,2
    8000259a:	85be                	mv	a1,a5
    8000259c:	853a                	mv	a0,a4
    8000259e:	17d000ef          	jal	ra,80002f1a <prvListTasksWithinSingleList>
    800025a2:	872a                	mv	a4,a0
    800025a4:	77a2                	ld	a5,40(sp)
    800025a6:	97ba                	add	a5,a5,a4
    800025a8:	f43e                	sd	a5,40(sp)
                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
    800025aa:	7722                	ld	a4,40(sp)
    800025ac:	87ba                	mv	a5,a4
    800025ae:	078e                	slli	a5,a5,0x3
    800025b0:	97ba                	add	a5,a5,a4
    800025b2:	078e                	slli	a5,a5,0x3
    800025b4:	873e                	mv	a4,a5
    800025b6:	67e2                	ld	a5,24(sp)
    800025b8:	973e                	add	a4,a4,a5
    800025ba:	0000a797          	auipc	a5,0xa
    800025be:	6a678793          	addi	a5,a5,1702 # 8000cc60 <pxOverflowDelayedTaskList>
    800025c2:	639c                	ld	a5,0(a5)
    800025c4:	4609                	li	a2,2
    800025c6:	85be                	mv	a1,a5
    800025c8:	853a                	mv	a0,a4
    800025ca:	151000ef          	jal	ra,80002f1a <prvListTasksWithinSingleList>
    800025ce:	872a                	mv	a4,a0
    800025d0:	77a2                	ld	a5,40(sp)
    800025d2:	97ba                	add	a5,a5,a4
    800025d4:	f43e                	sd	a5,40(sp)

                #if ( INCLUDE_vTaskDelete == 1 )
                    {
                        /* Fill in an TaskStatus_t structure with information on
                         * each task that has been deleted but not yet cleaned up. */
                        uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
    800025d6:	7722                	ld	a4,40(sp)
    800025d8:	87ba                	mv	a5,a4
    800025da:	078e                	slli	a5,a5,0x3
    800025dc:	97ba                	add	a5,a5,a4
    800025de:	078e                	slli	a5,a5,0x3
    800025e0:	873e                	mv	a4,a5
    800025e2:	67e2                	ld	a5,24(sp)
    800025e4:	97ba                	add	a5,a5,a4
    800025e6:	4611                	li	a2,4
    800025e8:	0000a597          	auipc	a1,0xa
    800025ec:	6a858593          	addi	a1,a1,1704 # 8000cc90 <xTasksWaitingTermination>
    800025f0:	853e                	mv	a0,a5
    800025f2:	129000ef          	jal	ra,80002f1a <prvListTasksWithinSingleList>
    800025f6:	872a                	mv	a4,a0
    800025f8:	77a2                	ld	a5,40(sp)
    800025fa:	97ba                	add	a5,a5,a4
    800025fc:	f43e                	sd	a5,40(sp)

                #if ( INCLUDE_vTaskSuspend == 1 )
                    {
                        /* Fill in an TaskStatus_t structure with information on
                         * each task in the Suspended state. */
                        uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
    800025fe:	7722                	ld	a4,40(sp)
    80002600:	87ba                	mv	a5,a4
    80002602:	078e                	slli	a5,a5,0x3
    80002604:	97ba                	add	a5,a5,a4
    80002606:	078e                	slli	a5,a5,0x3
    80002608:	873e                	mv	a4,a5
    8000260a:	67e2                	ld	a5,24(sp)
    8000260c:	97ba                	add	a5,a5,a4
    8000260e:	460d                	li	a2,3
    80002610:	0000a597          	auipc	a1,0xa
    80002614:	6b058593          	addi	a1,a1,1712 # 8000ccc0 <xSuspendedTaskList>
    80002618:	853e                	mv	a0,a5
    8000261a:	101000ef          	jal	ra,80002f1a <prvListTasksWithinSingleList>
    8000261e:	872a                	mv	a4,a0
    80002620:	77a2                	ld	a5,40(sp)
    80002622:	97ba                	add	a5,a5,a4
    80002624:	f43e                	sd	a5,40(sp)
                            #endif
                        }
                    }
                #else /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
                    {
                        if( pulTotalRunTime != NULL )
    80002626:	67a2                	ld	a5,8(sp)
    80002628:	c781                	beqz	a5,80002630 <uxTaskGetSystemState+0x118>
                        {
                            *pulTotalRunTime = 0;
    8000262a:	67a2                	ld	a5,8(sp)
    8000262c:	0007a023          	sw	zero,0(a5)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        ( void ) xTaskResumeAll();
    80002630:	d31ff0ef          	jal	ra,80002360 <xTaskResumeAll>

        return uxTask;
    80002634:	77a2                	ld	a5,40(sp)
    }
    80002636:	853e                	mv	a0,a5
    80002638:	70e2                	ld	ra,56(sp)
    8000263a:	6121                	addi	sp,sp,64
    8000263c:	8082                	ret

000000008000263e <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    8000263e:	7179                	addi	sp,sp,-48
    80002640:	f406                	sd	ra,40(sp)
    80002642:	e42a                	sd	a0,8(sp)
    BaseType_t xYieldOccurred;

    /* Must not be called with the scheduler suspended as the implementation
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );
    80002644:	0000a797          	auipc	a5,0xa
    80002648:	6f478793          	addi	a5,a5,1780 # 8000cd38 <uxSchedulerSuspended>
    8000264c:	639c                	ld	a5,0(a5)
    8000264e:	c781                	beqz	a5,80002656 <xTaskCatchUpTicks+0x18>
    80002650:	30047073          	csrci	mstatus,8
    80002654:	a001                	j	80002654 <xTaskCatchUpTicks+0x16>

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    80002656:	cefff0ef          	jal	ra,80002344 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    8000265a:	0000a797          	auipc	a5,0xa
    8000265e:	6ae78793          	addi	a5,a5,1710 # 8000cd08 <xPendedTicks>
    80002662:	6398                	ld	a4,0(a5)
    80002664:	67a2                	ld	a5,8(sp)
    80002666:	973e                	add	a4,a4,a5
    80002668:	0000a797          	auipc	a5,0xa
    8000266c:	6a078793          	addi	a5,a5,1696 # 8000cd08 <xPendedTicks>
    80002670:	e398                	sd	a4,0(a5)
    xYieldOccurred = xTaskResumeAll();
    80002672:	cefff0ef          	jal	ra,80002360 <xTaskResumeAll>
    80002676:	ec2a                	sd	a0,24(sp)

    return xYieldOccurred;
    80002678:	67e2                	ld	a5,24(sp)
}
    8000267a:	853e                	mv	a0,a5
    8000267c:	70a2                	ld	ra,40(sp)
    8000267e:	6145                	addi	sp,sp,48
    80002680:	8082                	ret

0000000080002682 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    80002682:	7139                	addi	sp,sp,-64
    80002684:	fc06                	sd	ra,56(sp)
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    80002686:	f402                	sd	zero,40(sp)
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    80002688:	0000a797          	auipc	a5,0xa
    8000268c:	6b078793          	addi	a5,a5,1712 # 8000cd38 <uxSchedulerSuspended>
    80002690:	639c                	ld	a5,0(a5)
    80002692:	18079763          	bnez	a5,80002820 <xTaskIncrementTick+0x19e>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    80002696:	0000a797          	auipc	a5,0xa
    8000269a:	65a78793          	addi	a5,a5,1626 # 8000ccf0 <xTickCount>
    8000269e:	639c                	ld	a5,0(a5)
    800026a0:	0785                	addi	a5,a5,1
    800026a2:	f03e                	sd	a5,32(sp)

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    800026a4:	0000a797          	auipc	a5,0xa
    800026a8:	64c78793          	addi	a5,a5,1612 # 8000ccf0 <xTickCount>
    800026ac:	7702                	ld	a4,32(sp)
    800026ae:	e398                	sd	a4,0(a5)

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    800026b0:	7782                	ld	a5,32(sp)
    800026b2:	efb9                	bnez	a5,80002710 <xTaskIncrementTick+0x8e>
        {
            taskSWITCH_DELAYED_LISTS();
    800026b4:	0000a797          	auipc	a5,0xa
    800026b8:	5a478793          	addi	a5,a5,1444 # 8000cc58 <pxDelayedTaskList>
    800026bc:	639c                	ld	a5,0(a5)
    800026be:	639c                	ld	a5,0(a5)
    800026c0:	c781                	beqz	a5,800026c8 <xTaskIncrementTick+0x46>
    800026c2:	30047073          	csrci	mstatus,8
    800026c6:	a001                	j	800026c6 <xTaskIncrementTick+0x44>
    800026c8:	0000a797          	auipc	a5,0xa
    800026cc:	59078793          	addi	a5,a5,1424 # 8000cc58 <pxDelayedTaskList>
    800026d0:	639c                	ld	a5,0(a5)
    800026d2:	ec3e                	sd	a5,24(sp)
    800026d4:	0000a797          	auipc	a5,0xa
    800026d8:	58c78793          	addi	a5,a5,1420 # 8000cc60 <pxOverflowDelayedTaskList>
    800026dc:	6398                	ld	a4,0(a5)
    800026de:	0000a797          	auipc	a5,0xa
    800026e2:	57a78793          	addi	a5,a5,1402 # 8000cc58 <pxDelayedTaskList>
    800026e6:	e398                	sd	a4,0(a5)
    800026e8:	0000a797          	auipc	a5,0xa
    800026ec:	57878793          	addi	a5,a5,1400 # 8000cc60 <pxOverflowDelayedTaskList>
    800026f0:	6762                	ld	a4,24(sp)
    800026f2:	e398                	sd	a4,0(a5)
    800026f4:	0000a797          	auipc	a5,0xa
    800026f8:	62478793          	addi	a5,a5,1572 # 8000cd18 <xNumOfOverflows>
    800026fc:	639c                	ld	a5,0(a5)
    800026fe:	00178713          	addi	a4,a5,1
    80002702:	0000a797          	auipc	a5,0xa
    80002706:	61678793          	addi	a5,a5,1558 # 8000cd18 <xNumOfOverflows>
    8000270a:	e398                	sd	a4,0(a5)
    8000270c:	107000ef          	jal	ra,80003012 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    80002710:	0000a797          	auipc	a5,0xa
    80002714:	61878793          	addi	a5,a5,1560 # 8000cd28 <xNextTaskUnblockTime>
    80002718:	639c                	ld	a5,0(a5)
    8000271a:	7702                	ld	a4,32(sp)
    8000271c:	0cf76463          	bltu	a4,a5,800027e4 <xTaskIncrementTick+0x162>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    80002720:	0000a797          	auipc	a5,0xa
    80002724:	53878793          	addi	a5,a5,1336 # 8000cc58 <pxDelayedTaskList>
    80002728:	639c                	ld	a5,0(a5)
    8000272a:	639c                	ld	a5,0(a5)
    8000272c:	eb81                	bnez	a5,8000273c <xTaskIncrementTick+0xba>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    8000272e:	0000a797          	auipc	a5,0xa
    80002732:	5fa78793          	addi	a5,a5,1530 # 8000cd28 <xNextTaskUnblockTime>
    80002736:	577d                	li	a4,-1
    80002738:	e398                	sd	a4,0(a5)
                    break;
    8000273a:	a06d                	j	800027e4 <xTaskIncrementTick+0x162>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    8000273c:	0000a797          	auipc	a5,0xa
    80002740:	51c78793          	addi	a5,a5,1308 # 8000cc58 <pxDelayedTaskList>
    80002744:	639c                	ld	a5,0(a5)
    80002746:	6f9c                	ld	a5,24(a5)
    80002748:	6f9c                	ld	a5,24(a5)
    8000274a:	e83e                	sd	a5,16(sp)
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    8000274c:	67c2                	ld	a5,16(sp)
    8000274e:	679c                	ld	a5,8(a5)
    80002750:	e43e                	sd	a5,8(sp)

                    if( xConstTickCount < xItemValue )
    80002752:	7702                	ld	a4,32(sp)
    80002754:	67a2                	ld	a5,8(sp)
    80002756:	00f77963          	bgeu	a4,a5,80002768 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    8000275a:	0000a797          	auipc	a5,0xa
    8000275e:	5ce78793          	addi	a5,a5,1486 # 8000cd28 <xNextTaskUnblockTime>
    80002762:	6722                	ld	a4,8(sp)
    80002764:	e398                	sd	a4,0(a5)
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    80002766:	a8bd                	j	800027e4 <xTaskIncrementTick+0x162>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    80002768:	67c2                	ld	a5,16(sp)
    8000276a:	07a1                	addi	a5,a5,8
    8000276c:	853e                	mv	a0,a5
    8000276e:	ff1fd0ef          	jal	ra,8000075e <uxListRemove>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    80002772:	67c2                	ld	a5,16(sp)
    80002774:	6bbc                	ld	a5,80(a5)
    80002776:	c799                	beqz	a5,80002784 <xTaskIncrementTick+0x102>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    80002778:	67c2                	ld	a5,16(sp)
    8000277a:	03078793          	addi	a5,a5,48
    8000277e:	853e                	mv	a0,a5
    80002780:	fdffd0ef          	jal	ra,8000075e <uxListRemove>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    80002784:	67c2                	ld	a5,16(sp)
    80002786:	6fbc                	ld	a5,88(a5)
    80002788:	2781                	sext.w	a5,a5
    8000278a:	873e                	mv	a4,a5
    8000278c:	4785                	li	a5,1
    8000278e:	00e79733          	sll	a4,a5,a4
    80002792:	0000a797          	auipc	a5,0xa
    80002796:	56678793          	addi	a5,a5,1382 # 8000ccf8 <uxTopReadyPriority>
    8000279a:	639c                	ld	a5,0(a5)
    8000279c:	8f5d                	or	a4,a4,a5
    8000279e:	0000a797          	auipc	a5,0xa
    800027a2:	55a78793          	addi	a5,a5,1370 # 8000ccf8 <uxTopReadyPriority>
    800027a6:	e398                	sd	a4,0(a5)
    800027a8:	67c2                	ld	a5,16(sp)
    800027aa:	6fb8                	ld	a4,88(a5)
    800027ac:	87ba                	mv	a5,a4
    800027ae:	078a                	slli	a5,a5,0x2
    800027b0:	97ba                	add	a5,a5,a4
    800027b2:	078e                	slli	a5,a5,0x3
    800027b4:	0000a717          	auipc	a4,0xa
    800027b8:	38c70713          	addi	a4,a4,908 # 8000cb40 <pxReadyTasksLists>
    800027bc:	973e                	add	a4,a4,a5
    800027be:	67c2                	ld	a5,16(sp)
    800027c0:	07a1                	addi	a5,a5,8
    800027c2:	85be                	mv	a1,a5
    800027c4:	853a                	mv	a0,a4
    800027c6:	eeffd0ef          	jal	ra,800006b4 <vListInsertEnd>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    800027ca:	67c2                	ld	a5,16(sp)
    800027cc:	6fb8                	ld	a4,88(a5)
    800027ce:	00008797          	auipc	a5,0x8
    800027d2:	40278793          	addi	a5,a5,1026 # 8000abd0 <pxCurrentTCB>
    800027d6:	639c                	ld	a5,0(a5)
    800027d8:	6fbc                	ld	a5,88(a5)
    800027da:	f4f763e3          	bltu	a4,a5,80002720 <xTaskIncrementTick+0x9e>
                            {
                                xSwitchRequired = pdTRUE;
    800027de:	4785                	li	a5,1
    800027e0:	f43e                	sd	a5,40(sp)
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    800027e2:	bf3d                	j	80002720 <xTaskIncrementTick+0x9e>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    800027e4:	00008797          	auipc	a5,0x8
    800027e8:	3ec78793          	addi	a5,a5,1004 # 8000abd0 <pxCurrentTCB>
    800027ec:	639c                	ld	a5,0(a5)
    800027ee:	6fb8                	ld	a4,88(a5)
    800027f0:	0000a697          	auipc	a3,0xa
    800027f4:	35068693          	addi	a3,a3,848 # 8000cb40 <pxReadyTasksLists>
    800027f8:	87ba                	mv	a5,a4
    800027fa:	078a                	slli	a5,a5,0x2
    800027fc:	97ba                	add	a5,a5,a4
    800027fe:	078e                	slli	a5,a5,0x3
    80002800:	97b6                	add	a5,a5,a3
    80002802:	6398                	ld	a4,0(a5)
    80002804:	4785                	li	a5,1
    80002806:	00e7f463          	bgeu	a5,a4,8000280e <xTaskIncrementTick+0x18c>
                {
                    xSwitchRequired = pdTRUE;
    8000280a:	4785                	li	a5,1
    8000280c:	f43e                	sd	a5,40(sp)
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    8000280e:	0000a797          	auipc	a5,0xa
    80002812:	50278793          	addi	a5,a5,1282 # 8000cd10 <xYieldPending>
    80002816:	639c                	ld	a5,0(a5)
    80002818:	c385                	beqz	a5,80002838 <xTaskIncrementTick+0x1b6>
                {
                    xSwitchRequired = pdTRUE;
    8000281a:	4785                	li	a5,1
    8000281c:	f43e                	sd	a5,40(sp)
    8000281e:	a829                	j	80002838 <xTaskIncrementTick+0x1b6>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    80002820:	0000a797          	auipc	a5,0xa
    80002824:	4e878793          	addi	a5,a5,1256 # 8000cd08 <xPendedTicks>
    80002828:	639c                	ld	a5,0(a5)
    8000282a:	00178713          	addi	a4,a5,1
    8000282e:	0000a797          	auipc	a5,0xa
    80002832:	4da78793          	addi	a5,a5,1242 # 8000cd08 <xPendedTicks>
    80002836:	e398                	sd	a4,0(a5)
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    80002838:	77a2                	ld	a5,40(sp)
}
    8000283a:	853e                	mv	a0,a5
    8000283c:	70e2                	ld	ra,56(sp)
    8000283e:	6121                	addi	sp,sp,64
    80002840:	8082                	ret

0000000080002842 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    80002842:	7179                	addi	sp,sp,-48
    80002844:	f406                	sd	ra,40(sp)
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    80002846:	0000a797          	auipc	a5,0xa
    8000284a:	4f278793          	addi	a5,a5,1266 # 8000cd38 <uxSchedulerSuspended>
    8000284e:	639c                	ld	a5,0(a5)
    80002850:	cb81                	beqz	a5,80002860 <vTaskSwitchContext+0x1e>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    80002852:	0000a797          	auipc	a5,0xa
    80002856:	4be78793          	addi	a5,a5,1214 # 8000cd10 <xYieldPending>
    8000285a:	4705                	li	a4,1
    8000285c:	e398                	sd	a4,0(a5)
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    8000285e:	a221                	j	80002966 <vTaskSwitchContext+0x124>
        xYieldPending = pdFALSE;
    80002860:	0000a797          	auipc	a5,0xa
    80002864:	4b078793          	addi	a5,a5,1200 # 8000cd10 <xYieldPending>
    80002868:	0007b023          	sd	zero,0(a5)
        taskCHECK_FOR_STACK_OVERFLOW();
    8000286c:	00008797          	auipc	a5,0x8
    80002870:	36478793          	addi	a5,a5,868 # 8000abd0 <pxCurrentTCB>
    80002874:	639c                	ld	a5,0(a5)
    80002876:	73bc                	ld	a5,96(a5)
    80002878:	ec3e                	sd	a5,24(sp)
    8000287a:	a5a5a7b7          	lui	a5,0xa5a5a
    8000287e:	5a578793          	addi	a5,a5,1445 # ffffffffa5a5a5a5 <__stack+0xffffffff2593f355>
    80002882:	ca3e                	sw	a5,20(sp)
    80002884:	67e2                	ld	a5,24(sp)
    80002886:	4398                	lw	a4,0(a5)
    80002888:	47d2                	lw	a5,20(sp)
    8000288a:	2781                	sext.w	a5,a5
    8000288c:	02e79763          	bne	a5,a4,800028ba <vTaskSwitchContext+0x78>
    80002890:	67e2                	ld	a5,24(sp)
    80002892:	0791                	addi	a5,a5,4
    80002894:	4398                	lw	a4,0(a5)
    80002896:	47d2                	lw	a5,20(sp)
    80002898:	2781                	sext.w	a5,a5
    8000289a:	02e79063          	bne	a5,a4,800028ba <vTaskSwitchContext+0x78>
    8000289e:	67e2                	ld	a5,24(sp)
    800028a0:	07a1                	addi	a5,a5,8
    800028a2:	4398                	lw	a4,0(a5)
    800028a4:	47d2                	lw	a5,20(sp)
    800028a6:	2781                	sext.w	a5,a5
    800028a8:	00e79963          	bne	a5,a4,800028ba <vTaskSwitchContext+0x78>
    800028ac:	67e2                	ld	a5,24(sp)
    800028ae:	07b1                	addi	a5,a5,12
    800028b0:	4398                	lw	a4,0(a5)
    800028b2:	47d2                	lw	a5,20(sp)
    800028b4:	2781                	sext.w	a5,a5
    800028b6:	02e78263          	beq	a5,a4,800028da <vTaskSwitchContext+0x98>
    800028ba:	00008797          	auipc	a5,0x8
    800028be:	31678793          	addi	a5,a5,790 # 8000abd0 <pxCurrentTCB>
    800028c2:	6398                	ld	a4,0(a5)
    800028c4:	00008797          	auipc	a5,0x8
    800028c8:	30c78793          	addi	a5,a5,780 # 8000abd0 <pxCurrentTCB>
    800028cc:	639c                	ld	a5,0(a5)
    800028ce:	06878793          	addi	a5,a5,104
    800028d2:	85be                	mv	a1,a5
    800028d4:	853a                	mv	a0,a4
    800028d6:	377050ef          	jal	ra,8000844c <vApplicationStackOverflowHook>
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    800028da:	0000a797          	auipc	a5,0xa
    800028de:	41e78793          	addi	a5,a5,1054 # 8000ccf8 <uxTopReadyPriority>
    800028e2:	639c                	ld	a5,0(a5)
    800028e4:	2781                	sext.w	a5,a5
    800028e6:	1782                	slli	a5,a5,0x20
    800028e8:	9381                	srli	a5,a5,0x20
    800028ea:	853e                	mv	a0,a5
    800028ec:	595050ef          	jal	ra,80008680 <__clzdi2>
    800028f0:	87aa                	mv	a5,a0
    800028f2:	1782                	slli	a5,a5,0x20
    800028f4:	9381                	srli	a5,a5,0x20
    800028f6:	1781                	addi	a5,a5,-32
    800028f8:	2781                	sext.w	a5,a5
    800028fa:	873e                	mv	a4,a5
    800028fc:	47fd                	li	a5,31
    800028fe:	8f99                	sub	a5,a5,a4
    80002900:	e43e                	sd	a5,8(sp)
    80002902:	0000a697          	auipc	a3,0xa
    80002906:	23e68693          	addi	a3,a3,574 # 8000cb40 <pxReadyTasksLists>
    8000290a:	6722                	ld	a4,8(sp)
    8000290c:	87ba                	mv	a5,a4
    8000290e:	078a                	slli	a5,a5,0x2
    80002910:	97ba                	add	a5,a5,a4
    80002912:	078e                	slli	a5,a5,0x3
    80002914:	97b6                	add	a5,a5,a3
    80002916:	639c                	ld	a5,0(a5)
    80002918:	e781                	bnez	a5,80002920 <vTaskSwitchContext+0xde>
    8000291a:	30047073          	csrci	mstatus,8
    8000291e:	a001                	j	8000291e <vTaskSwitchContext+0xdc>
    80002920:	6722                	ld	a4,8(sp)
    80002922:	87ba                	mv	a5,a4
    80002924:	078a                	slli	a5,a5,0x2
    80002926:	97ba                	add	a5,a5,a4
    80002928:	078e                	slli	a5,a5,0x3
    8000292a:	0000a717          	auipc	a4,0xa
    8000292e:	21670713          	addi	a4,a4,534 # 8000cb40 <pxReadyTasksLists>
    80002932:	97ba                	add	a5,a5,a4
    80002934:	e03e                	sd	a5,0(sp)
    80002936:	6782                	ld	a5,0(sp)
    80002938:	679c                	ld	a5,8(a5)
    8000293a:	6798                	ld	a4,8(a5)
    8000293c:	6782                	ld	a5,0(sp)
    8000293e:	e798                	sd	a4,8(a5)
    80002940:	6782                	ld	a5,0(sp)
    80002942:	6798                	ld	a4,8(a5)
    80002944:	6782                	ld	a5,0(sp)
    80002946:	07c1                	addi	a5,a5,16
    80002948:	00f71763          	bne	a4,a5,80002956 <vTaskSwitchContext+0x114>
    8000294c:	6782                	ld	a5,0(sp)
    8000294e:	679c                	ld	a5,8(a5)
    80002950:	6798                	ld	a4,8(a5)
    80002952:	6782                	ld	a5,0(sp)
    80002954:	e798                	sd	a4,8(a5)
    80002956:	6782                	ld	a5,0(sp)
    80002958:	679c                	ld	a5,8(a5)
    8000295a:	6f98                	ld	a4,24(a5)
    8000295c:	00008797          	auipc	a5,0x8
    80002960:	27478793          	addi	a5,a5,628 # 8000abd0 <pxCurrentTCB>
    80002964:	e398                	sd	a4,0(a5)
}
    80002966:	0001                	nop
    80002968:	70a2                	ld	ra,40(sp)
    8000296a:	6145                	addi	sp,sp,48
    8000296c:	8082                	ret

000000008000296e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    8000296e:	1101                	addi	sp,sp,-32
    80002970:	ec06                	sd	ra,24(sp)
    80002972:	e42a                	sd	a0,8(sp)
    80002974:	e02e                	sd	a1,0(sp)
    configASSERT( pxEventList );
    80002976:	67a2                	ld	a5,8(sp)
    80002978:	e781                	bnez	a5,80002980 <vTaskPlaceOnEventList+0x12>
    8000297a:	30047073          	csrci	mstatus,8
    8000297e:	a001                	j	8000297e <vTaskPlaceOnEventList+0x10>

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    80002980:	00008797          	auipc	a5,0x8
    80002984:	25078793          	addi	a5,a5,592 # 8000abd0 <pxCurrentTCB>
    80002988:	639c                	ld	a5,0(a5)
    8000298a:	03078793          	addi	a5,a5,48
    8000298e:	85be                	mv	a1,a5
    80002990:	6522                	ld	a0,8(sp)
    80002992:	d63fd0ef          	jal	ra,800006f4 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    80002996:	4585                	li	a1,1
    80002998:	6502                	ld	a0,0(sp)
    8000299a:	2b6010ef          	jal	ra,80003c50 <prvAddCurrentTaskToDelayedList>
}
    8000299e:	0001                	nop
    800029a0:	60e2                	ld	ra,24(sp)
    800029a2:	6105                	addi	sp,sp,32
    800029a4:	8082                	ret

00000000800029a6 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    800029a6:	7179                	addi	sp,sp,-48
    800029a8:	f406                	sd	ra,40(sp)
    800029aa:	ec2a                	sd	a0,24(sp)
    800029ac:	e82e                	sd	a1,16(sp)
    800029ae:	e432                	sd	a2,8(sp)
    configASSERT( pxEventList );
    800029b0:	67e2                	ld	a5,24(sp)
    800029b2:	e781                	bnez	a5,800029ba <vTaskPlaceOnUnorderedEventList+0x14>
    800029b4:	30047073          	csrci	mstatus,8
    800029b8:	a001                	j	800029b8 <vTaskPlaceOnUnorderedEventList+0x12>

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event groups implementation. */
    configASSERT( uxSchedulerSuspended != 0 );
    800029ba:	0000a797          	auipc	a5,0xa
    800029be:	37e78793          	addi	a5,a5,894 # 8000cd38 <uxSchedulerSuspended>
    800029c2:	639c                	ld	a5,0(a5)
    800029c4:	e781                	bnez	a5,800029cc <vTaskPlaceOnUnorderedEventList+0x26>
    800029c6:	30047073          	csrci	mstatus,8
    800029ca:	a001                	j	800029ca <vTaskPlaceOnUnorderedEventList+0x24>

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    800029cc:	00008797          	auipc	a5,0x8
    800029d0:	20478793          	addi	a5,a5,516 # 8000abd0 <pxCurrentTCB>
    800029d4:	639c                	ld	a5,0(a5)
    800029d6:	66c2                	ld	a3,16(sp)
    800029d8:	4705                	li	a4,1
    800029da:	077e                	slli	a4,a4,0x1f
    800029dc:	8f55                	or	a4,a4,a3
    800029de:	fb98                	sd	a4,48(a5)
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    800029e0:	00008797          	auipc	a5,0x8
    800029e4:	1f078793          	addi	a5,a5,496 # 8000abd0 <pxCurrentTCB>
    800029e8:	639c                	ld	a5,0(a5)
    800029ea:	03078793          	addi	a5,a5,48
    800029ee:	85be                	mv	a1,a5
    800029f0:	6562                	ld	a0,24(sp)
    800029f2:	cc3fd0ef          	jal	ra,800006b4 <vListInsertEnd>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    800029f6:	4585                	li	a1,1
    800029f8:	6522                	ld	a0,8(sp)
    800029fa:	256010ef          	jal	ra,80003c50 <prvAddCurrentTaskToDelayedList>
}
    800029fe:	0001                	nop
    80002a00:	70a2                	ld	ra,40(sp)
    80002a02:	6145                	addi	sp,sp,48
    80002a04:	8082                	ret

0000000080002a06 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    80002a06:	7179                	addi	sp,sp,-48
    80002a08:	f406                	sd	ra,40(sp)
    80002a0a:	ec2a                	sd	a0,24(sp)
    80002a0c:	e82e                	sd	a1,16(sp)
    80002a0e:	e432                	sd	a2,8(sp)
        configASSERT( pxEventList );
    80002a10:	67e2                	ld	a5,24(sp)
    80002a12:	e781                	bnez	a5,80002a1a <vTaskPlaceOnEventListRestricted+0x14>
    80002a14:	30047073          	csrci	mstatus,8
    80002a18:	a001                	j	80002a18 <vTaskPlaceOnEventListRestricted+0x12>

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    80002a1a:	00008797          	auipc	a5,0x8
    80002a1e:	1b678793          	addi	a5,a5,438 # 8000abd0 <pxCurrentTCB>
    80002a22:	639c                	ld	a5,0(a5)
    80002a24:	03078793          	addi	a5,a5,48
    80002a28:	85be                	mv	a1,a5
    80002a2a:	6562                	ld	a0,24(sp)
    80002a2c:	c89fd0ef          	jal	ra,800006b4 <vListInsertEnd>

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    80002a30:	67a2                	ld	a5,8(sp)
    80002a32:	c399                	beqz	a5,80002a38 <vTaskPlaceOnEventListRestricted+0x32>
        {
            xTicksToWait = portMAX_DELAY;
    80002a34:	57fd                	li	a5,-1
    80002a36:	e83e                	sd	a5,16(sp)
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    80002a38:	65a2                	ld	a1,8(sp)
    80002a3a:	6542                	ld	a0,16(sp)
    80002a3c:	214010ef          	jal	ra,80003c50 <prvAddCurrentTaskToDelayedList>
    }
    80002a40:	0001                	nop
    80002a42:	70a2                	ld	ra,40(sp)
    80002a44:	6145                	addi	sp,sp,48
    80002a46:	8082                	ret

0000000080002a48 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    80002a48:	7179                	addi	sp,sp,-48
    80002a4a:	f406                	sd	ra,40(sp)
    80002a4c:	e42a                	sd	a0,8(sp)
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    80002a4e:	67a2                	ld	a5,8(sp)
    80002a50:	6f9c                	ld	a5,24(a5)
    80002a52:	6f9c                	ld	a5,24(a5)
    80002a54:	e83e                	sd	a5,16(sp)
    configASSERT( pxUnblockedTCB );
    80002a56:	67c2                	ld	a5,16(sp)
    80002a58:	e781                	bnez	a5,80002a60 <xTaskRemoveFromEventList+0x18>
    80002a5a:	30047073          	csrci	mstatus,8
    80002a5e:	a001                	j	80002a5e <xTaskRemoveFromEventList+0x16>
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    80002a60:	67c2                	ld	a5,16(sp)
    80002a62:	03078793          	addi	a5,a5,48
    80002a66:	853e                	mv	a0,a5
    80002a68:	cf7fd0ef          	jal	ra,8000075e <uxListRemove>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    80002a6c:	0000a797          	auipc	a5,0xa
    80002a70:	2cc78793          	addi	a5,a5,716 # 8000cd38 <uxSchedulerSuspended>
    80002a74:	639c                	ld	a5,0(a5)
    80002a76:	ebb1                	bnez	a5,80002aca <xTaskRemoveFromEventList+0x82>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    80002a78:	67c2                	ld	a5,16(sp)
    80002a7a:	07a1                	addi	a5,a5,8
    80002a7c:	853e                	mv	a0,a5
    80002a7e:	ce1fd0ef          	jal	ra,8000075e <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
    80002a82:	67c2                	ld	a5,16(sp)
    80002a84:	6fbc                	ld	a5,88(a5)
    80002a86:	2781                	sext.w	a5,a5
    80002a88:	873e                	mv	a4,a5
    80002a8a:	4785                	li	a5,1
    80002a8c:	00e79733          	sll	a4,a5,a4
    80002a90:	0000a797          	auipc	a5,0xa
    80002a94:	26878793          	addi	a5,a5,616 # 8000ccf8 <uxTopReadyPriority>
    80002a98:	639c                	ld	a5,0(a5)
    80002a9a:	8f5d                	or	a4,a4,a5
    80002a9c:	0000a797          	auipc	a5,0xa
    80002aa0:	25c78793          	addi	a5,a5,604 # 8000ccf8 <uxTopReadyPriority>
    80002aa4:	e398                	sd	a4,0(a5)
    80002aa6:	67c2                	ld	a5,16(sp)
    80002aa8:	6fb8                	ld	a4,88(a5)
    80002aaa:	87ba                	mv	a5,a4
    80002aac:	078a                	slli	a5,a5,0x2
    80002aae:	97ba                	add	a5,a5,a4
    80002ab0:	078e                	slli	a5,a5,0x3
    80002ab2:	0000a717          	auipc	a4,0xa
    80002ab6:	08e70713          	addi	a4,a4,142 # 8000cb40 <pxReadyTasksLists>
    80002aba:	973e                	add	a4,a4,a5
    80002abc:	67c2                	ld	a5,16(sp)
    80002abe:	07a1                	addi	a5,a5,8
    80002ac0:	85be                	mv	a1,a5
    80002ac2:	853a                	mv	a0,a4
    80002ac4:	bf1fd0ef          	jal	ra,800006b4 <vListInsertEnd>
    80002ac8:	a819                	j	80002ade <xTaskRemoveFromEventList+0x96>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    80002aca:	67c2                	ld	a5,16(sp)
    80002acc:	03078793          	addi	a5,a5,48
    80002ad0:	85be                	mv	a1,a5
    80002ad2:	0000a517          	auipc	a0,0xa
    80002ad6:	19650513          	addi	a0,a0,406 # 8000cc68 <xPendingReadyList>
    80002ada:	bdbfd0ef          	jal	ra,800006b4 <vListInsertEnd>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    80002ade:	67c2                	ld	a5,16(sp)
    80002ae0:	6fb8                	ld	a4,88(a5)
    80002ae2:	00008797          	auipc	a5,0x8
    80002ae6:	0ee78793          	addi	a5,a5,238 # 8000abd0 <pxCurrentTCB>
    80002aea:	639c                	ld	a5,0(a5)
    80002aec:	6fbc                	ld	a5,88(a5)
    80002aee:	00e7fb63          	bgeu	a5,a4,80002b04 <xTaskRemoveFromEventList+0xbc>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    80002af2:	4785                	li	a5,1
    80002af4:	ec3e                	sd	a5,24(sp)

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    80002af6:	0000a797          	auipc	a5,0xa
    80002afa:	21a78793          	addi	a5,a5,538 # 8000cd10 <xYieldPending>
    80002afe:	4705                	li	a4,1
    80002b00:	e398                	sd	a4,0(a5)
    80002b02:	a011                	j	80002b06 <xTaskRemoveFromEventList+0xbe>
    }
    else
    {
        xReturn = pdFALSE;
    80002b04:	ec02                	sd	zero,24(sp)
    }

    return xReturn;
    80002b06:	67e2                	ld	a5,24(sp)
}
    80002b08:	853e                	mv	a0,a5
    80002b0a:	70a2                	ld	ra,40(sp)
    80002b0c:	6145                	addi	sp,sp,48
    80002b0e:	8082                	ret

0000000080002b10 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    80002b10:	7179                	addi	sp,sp,-48
    80002b12:	f406                	sd	ra,40(sp)
    80002b14:	e42a                	sd	a0,8(sp)
    80002b16:	e02e                	sd	a1,0(sp)
    TCB_t * pxUnblockedTCB;

    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );
    80002b18:	0000a797          	auipc	a5,0xa
    80002b1c:	22078793          	addi	a5,a5,544 # 8000cd38 <uxSchedulerSuspended>
    80002b20:	639c                	ld	a5,0(a5)
    80002b22:	e781                	bnez	a5,80002b2a <vTaskRemoveFromUnorderedEventList+0x1a>
    80002b24:	30047073          	csrci	mstatus,8
    80002b28:	a001                	j	80002b28 <vTaskRemoveFromUnorderedEventList+0x18>

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    80002b2a:	6702                	ld	a4,0(sp)
    80002b2c:	4785                	li	a5,1
    80002b2e:	07fe                	slli	a5,a5,0x1f
    80002b30:	8f5d                	or	a4,a4,a5
    80002b32:	67a2                	ld	a5,8(sp)
    80002b34:	e398                	sd	a4,0(a5)

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    80002b36:	67a2                	ld	a5,8(sp)
    80002b38:	6f9c                	ld	a5,24(a5)
    80002b3a:	ec3e                	sd	a5,24(sp)
    configASSERT( pxUnblockedTCB );
    80002b3c:	67e2                	ld	a5,24(sp)
    80002b3e:	e781                	bnez	a5,80002b46 <vTaskRemoveFromUnorderedEventList+0x36>
    80002b40:	30047073          	csrci	mstatus,8
    80002b44:	a001                	j	80002b44 <vTaskRemoveFromUnorderedEventList+0x34>
    ( void ) uxListRemove( pxEventListItem );
    80002b46:	6522                	ld	a0,8(sp)
    80002b48:	c17fd0ef          	jal	ra,8000075e <uxListRemove>
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    80002b4c:	67e2                	ld	a5,24(sp)
    80002b4e:	07a1                	addi	a5,a5,8
    80002b50:	853e                	mv	a0,a5
    80002b52:	c0dfd0ef          	jal	ra,8000075e <uxListRemove>
    prvAddTaskToReadyList( pxUnblockedTCB );
    80002b56:	67e2                	ld	a5,24(sp)
    80002b58:	6fbc                	ld	a5,88(a5)
    80002b5a:	2781                	sext.w	a5,a5
    80002b5c:	873e                	mv	a4,a5
    80002b5e:	4785                	li	a5,1
    80002b60:	00e79733          	sll	a4,a5,a4
    80002b64:	0000a797          	auipc	a5,0xa
    80002b68:	19478793          	addi	a5,a5,404 # 8000ccf8 <uxTopReadyPriority>
    80002b6c:	639c                	ld	a5,0(a5)
    80002b6e:	8f5d                	or	a4,a4,a5
    80002b70:	0000a797          	auipc	a5,0xa
    80002b74:	18878793          	addi	a5,a5,392 # 8000ccf8 <uxTopReadyPriority>
    80002b78:	e398                	sd	a4,0(a5)
    80002b7a:	67e2                	ld	a5,24(sp)
    80002b7c:	6fb8                	ld	a4,88(a5)
    80002b7e:	87ba                	mv	a5,a4
    80002b80:	078a                	slli	a5,a5,0x2
    80002b82:	97ba                	add	a5,a5,a4
    80002b84:	078e                	slli	a5,a5,0x3
    80002b86:	0000a717          	auipc	a4,0xa
    80002b8a:	fba70713          	addi	a4,a4,-70 # 8000cb40 <pxReadyTasksLists>
    80002b8e:	973e                	add	a4,a4,a5
    80002b90:	67e2                	ld	a5,24(sp)
    80002b92:	07a1                	addi	a5,a5,8
    80002b94:	85be                	mv	a1,a5
    80002b96:	853a                	mv	a0,a4
    80002b98:	b1dfd0ef          	jal	ra,800006b4 <vListInsertEnd>

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    80002b9c:	67e2                	ld	a5,24(sp)
    80002b9e:	6fb8                	ld	a4,88(a5)
    80002ba0:	00008797          	auipc	a5,0x8
    80002ba4:	03078793          	addi	a5,a5,48 # 8000abd0 <pxCurrentTCB>
    80002ba8:	639c                	ld	a5,0(a5)
    80002baa:	6fbc                	ld	a5,88(a5)
    80002bac:	00e7f863          	bgeu	a5,a4,80002bbc <vTaskRemoveFromUnorderedEventList+0xac>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    80002bb0:	0000a797          	auipc	a5,0xa
    80002bb4:	16078793          	addi	a5,a5,352 # 8000cd10 <xYieldPending>
    80002bb8:	4705                	li	a4,1
    80002bba:	e398                	sd	a4,0(a5)
    }
}
    80002bbc:	0001                	nop
    80002bbe:	70a2                	ld	ra,40(sp)
    80002bc0:	6145                	addi	sp,sp,48
    80002bc2:	8082                	ret

0000000080002bc4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    80002bc4:	1101                	addi	sp,sp,-32
    80002bc6:	ec06                	sd	ra,24(sp)
    80002bc8:	e42a                	sd	a0,8(sp)
    configASSERT( pxTimeOut );
    80002bca:	67a2                	ld	a5,8(sp)
    80002bcc:	e781                	bnez	a5,80002bd4 <vTaskSetTimeOutState+0x10>
    80002bce:	30047073          	csrci	mstatus,8
    80002bd2:	a001                	j	80002bd2 <vTaskSetTimeOutState+0xe>
    taskENTER_CRITICAL();
    80002bd4:	7f8000ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    80002bd8:	0000a797          	auipc	a5,0xa
    80002bdc:	14078793          	addi	a5,a5,320 # 8000cd18 <xNumOfOverflows>
    80002be0:	6398                	ld	a4,0(a5)
    80002be2:	67a2                	ld	a5,8(sp)
    80002be4:	e398                	sd	a4,0(a5)
        pxTimeOut->xTimeOnEntering = xTickCount;
    80002be6:	0000a797          	auipc	a5,0xa
    80002bea:	10a78793          	addi	a5,a5,266 # 8000ccf0 <xTickCount>
    80002bee:	6398                	ld	a4,0(a5)
    80002bf0:	67a2                	ld	a5,8(sp)
    80002bf2:	e798                	sd	a4,8(a5)
    }
    taskEXIT_CRITICAL();
    80002bf4:	007000ef          	jal	ra,800033fa <vTaskExitCritical>
}
    80002bf8:	0001                	nop
    80002bfa:	60e2                	ld	ra,24(sp)
    80002bfc:	6105                	addi	sp,sp,32
    80002bfe:	8082                	ret

0000000080002c00 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    80002c00:	1141                	addi	sp,sp,-16
    80002c02:	e42a                	sd	a0,8(sp)
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    80002c04:	0000a797          	auipc	a5,0xa
    80002c08:	11478793          	addi	a5,a5,276 # 8000cd18 <xNumOfOverflows>
    80002c0c:	6398                	ld	a4,0(a5)
    80002c0e:	67a2                	ld	a5,8(sp)
    80002c10:	e398                	sd	a4,0(a5)
    pxTimeOut->xTimeOnEntering = xTickCount;
    80002c12:	0000a797          	auipc	a5,0xa
    80002c16:	0de78793          	addi	a5,a5,222 # 8000ccf0 <xTickCount>
    80002c1a:	6398                	ld	a4,0(a5)
    80002c1c:	67a2                	ld	a5,8(sp)
    80002c1e:	e798                	sd	a4,8(a5)
}
    80002c20:	0001                	nop
    80002c22:	0141                	addi	sp,sp,16
    80002c24:	8082                	ret

0000000080002c26 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    80002c26:	7139                	addi	sp,sp,-64
    80002c28:	fc06                	sd	ra,56(sp)
    80002c2a:	e42a                	sd	a0,8(sp)
    80002c2c:	e02e                	sd	a1,0(sp)
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    80002c2e:	67a2                	ld	a5,8(sp)
    80002c30:	e781                	bnez	a5,80002c38 <xTaskCheckForTimeOut+0x12>
    80002c32:	30047073          	csrci	mstatus,8
    80002c36:	a001                	j	80002c36 <xTaskCheckForTimeOut+0x10>
    configASSERT( pxTicksToWait );
    80002c38:	6782                	ld	a5,0(sp)
    80002c3a:	e781                	bnez	a5,80002c42 <xTaskCheckForTimeOut+0x1c>
    80002c3c:	30047073          	csrci	mstatus,8
    80002c40:	a001                	j	80002c40 <xTaskCheckForTimeOut+0x1a>

    taskENTER_CRITICAL();
    80002c42:	78a000ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    80002c46:	0000a797          	auipc	a5,0xa
    80002c4a:	0aa78793          	addi	a5,a5,170 # 8000ccf0 <xTickCount>
    80002c4e:	639c                	ld	a5,0(a5)
    80002c50:	f03e                	sd	a5,32(sp)
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    80002c52:	67a2                	ld	a5,8(sp)
    80002c54:	679c                	ld	a5,8(a5)
    80002c56:	7702                	ld	a4,32(sp)
    80002c58:	40f707b3          	sub	a5,a4,a5
    80002c5c:	ec3e                	sd	a5,24(sp)
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
    80002c5e:	6782                	ld	a5,0(sp)
    80002c60:	6398                	ld	a4,0(a5)
    80002c62:	57fd                	li	a5,-1
    80002c64:	00f71463          	bne	a4,a5,80002c6c <xTaskCheckForTimeOut+0x46>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
    80002c68:	f402                	sd	zero,40(sp)
    80002c6a:	a891                	j	80002cbe <xTaskCheckForTimeOut+0x98>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    80002c6c:	67a2                	ld	a5,8(sp)
    80002c6e:	6398                	ld	a4,0(a5)
    80002c70:	0000a797          	auipc	a5,0xa
    80002c74:	0a878793          	addi	a5,a5,168 # 8000cd18 <xNumOfOverflows>
    80002c78:	639c                	ld	a5,0(a5)
    80002c7a:	00f70d63          	beq	a4,a5,80002c94 <xTaskCheckForTimeOut+0x6e>
    80002c7e:	67a2                	ld	a5,8(sp)
    80002c80:	679c                	ld	a5,8(a5)
    80002c82:	7702                	ld	a4,32(sp)
    80002c84:	00f76863          	bltu	a4,a5,80002c94 <xTaskCheckForTimeOut+0x6e>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    80002c88:	4785                	li	a5,1
    80002c8a:	f43e                	sd	a5,40(sp)
            *pxTicksToWait = ( TickType_t ) 0;
    80002c8c:	6782                	ld	a5,0(sp)
    80002c8e:	0007b023          	sd	zero,0(a5)
    80002c92:	a035                	j	80002cbe <xTaskCheckForTimeOut+0x98>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    80002c94:	6782                	ld	a5,0(sp)
    80002c96:	639c                	ld	a5,0(a5)
    80002c98:	6762                	ld	a4,24(sp)
    80002c9a:	00f77d63          	bgeu	a4,a5,80002cb4 <xTaskCheckForTimeOut+0x8e>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    80002c9e:	6782                	ld	a5,0(sp)
    80002ca0:	6398                	ld	a4,0(a5)
    80002ca2:	67e2                	ld	a5,24(sp)
    80002ca4:	8f1d                	sub	a4,a4,a5
    80002ca6:	6782                	ld	a5,0(sp)
    80002ca8:	e398                	sd	a4,0(a5)
            vTaskInternalSetTimeOutState( pxTimeOut );
    80002caa:	6522                	ld	a0,8(sp)
    80002cac:	f55ff0ef          	jal	ra,80002c00 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    80002cb0:	f402                	sd	zero,40(sp)
    80002cb2:	a031                	j	80002cbe <xTaskCheckForTimeOut+0x98>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    80002cb4:	6782                	ld	a5,0(sp)
    80002cb6:	0007b023          	sd	zero,0(a5)
            xReturn = pdTRUE;
    80002cba:	4785                	li	a5,1
    80002cbc:	f43e                	sd	a5,40(sp)
        }
    }
    taskEXIT_CRITICAL();
    80002cbe:	73c000ef          	jal	ra,800033fa <vTaskExitCritical>

    return xReturn;
    80002cc2:	77a2                	ld	a5,40(sp)
}
    80002cc4:	853e                	mv	a0,a5
    80002cc6:	70e2                	ld	ra,56(sp)
    80002cc8:	6121                	addi	sp,sp,64
    80002cca:	8082                	ret

0000000080002ccc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    80002ccc:	0000a797          	auipc	a5,0xa
    80002cd0:	04478793          	addi	a5,a5,68 # 8000cd10 <xYieldPending>
    80002cd4:	4705                	li	a4,1
    80002cd6:	e398                	sd	a4,0(a5)
}
    80002cd8:	0001                	nop
    80002cda:	8082                	ret

0000000080002cdc <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
    {
    80002cdc:	1101                	addi	sp,sp,-32
    80002cde:	e42a                	sd	a0,8(sp)
        UBaseType_t uxReturn;
        TCB_t const * pxTCB;

        if( xTask != NULL )
    80002ce0:	67a2                	ld	a5,8(sp)
    80002ce2:	c799                	beqz	a5,80002cf0 <uxTaskGetTaskNumber+0x14>
        {
            pxTCB = xTask;
    80002ce4:	67a2                	ld	a5,8(sp)
    80002ce6:	e83e                	sd	a5,16(sp)
            uxReturn = pxTCB->uxTaskNumber;
    80002ce8:	67c2                	ld	a5,16(sp)
    80002cea:	67dc                	ld	a5,136(a5)
    80002cec:	ec3e                	sd	a5,24(sp)
    80002cee:	a011                	j	80002cf2 <uxTaskGetTaskNumber+0x16>
        }
        else
        {
            uxReturn = 0U;
    80002cf0:	ec02                	sd	zero,24(sp)
        }

        return uxReturn;
    80002cf2:	67e2                	ld	a5,24(sp)
    }
    80002cf4:	853e                	mv	a0,a5
    80002cf6:	6105                	addi	sp,sp,32
    80002cf8:	8082                	ret

0000000080002cfa <vTaskSetTaskNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

    void vTaskSetTaskNumber( TaskHandle_t xTask,
                             const UBaseType_t uxHandle )
    {
    80002cfa:	1101                	addi	sp,sp,-32
    80002cfc:	e42a                	sd	a0,8(sp)
    80002cfe:	e02e                	sd	a1,0(sp)
        TCB_t * pxTCB;

        if( xTask != NULL )
    80002d00:	67a2                	ld	a5,8(sp)
    80002d02:	c791                	beqz	a5,80002d0e <vTaskSetTaskNumber+0x14>
        {
            pxTCB = xTask;
    80002d04:	67a2                	ld	a5,8(sp)
    80002d06:	ec3e                	sd	a5,24(sp)
            pxTCB->uxTaskNumber = uxHandle;
    80002d08:	67e2                	ld	a5,24(sp)
    80002d0a:	6702                	ld	a4,0(sp)
    80002d0c:	e7d8                	sd	a4,136(a5)
        }
    }
    80002d0e:	0001                	nop
    80002d10:	6105                	addi	sp,sp,32
    80002d12:	8082                	ret

0000000080002d14 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    80002d14:	1101                	addi	sp,sp,-32
    80002d16:	ec06                	sd	ra,24(sp)
    80002d18:	e42a                	sd	a0,8(sp)

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    80002d1a:	0b2000ef          	jal	ra,80002dcc <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    80002d1e:	0000a797          	auipc	a5,0xa
    80002d22:	e2278793          	addi	a5,a5,-478 # 8000cb40 <pxReadyTasksLists>
    80002d26:	6398                	ld	a4,0(a5)
    80002d28:	4785                	li	a5,1
    80002d2a:	fee7f8e3          	bgeu	a5,a4,80002d1a <prvIdleTask+0x6>
                {
                    taskYIELD();
    80002d2e:	00000073          	ecall
        prvCheckTasksWaitingTermination();
    80002d32:	b7e5                	j	80002d1a <prvIdleTask+0x6>

0000000080002d34 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    80002d34:	1101                	addi	sp,sp,-32
    80002d36:	ec06                	sd	ra,24(sp)
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    80002d38:	e402                	sd	zero,8(sp)
    80002d3a:	a00d                	j	80002d5c <prvInitialiseTaskLists+0x28>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    80002d3c:	6722                	ld	a4,8(sp)
    80002d3e:	87ba                	mv	a5,a4
    80002d40:	078a                	slli	a5,a5,0x2
    80002d42:	97ba                	add	a5,a5,a4
    80002d44:	078e                	slli	a5,a5,0x3
    80002d46:	0000a717          	auipc	a4,0xa
    80002d4a:	dfa70713          	addi	a4,a4,-518 # 8000cb40 <pxReadyTasksLists>
    80002d4e:	97ba                	add	a5,a5,a4
    80002d50:	853e                	mv	a0,a5
    80002d52:	91ffd0ef          	jal	ra,80000670 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    80002d56:	67a2                	ld	a5,8(sp)
    80002d58:	0785                	addi	a5,a5,1
    80002d5a:	e43e                	sd	a5,8(sp)
    80002d5c:	6722                	ld	a4,8(sp)
    80002d5e:	4791                	li	a5,4
    80002d60:	fce7fee3          	bgeu	a5,a4,80002d3c <prvInitialiseTaskLists+0x8>
    }

    vListInitialise( &xDelayedTaskList1 );
    80002d64:	0000a517          	auipc	a0,0xa
    80002d68:	ea450513          	addi	a0,a0,-348 # 8000cc08 <xDelayedTaskList1>
    80002d6c:	905fd0ef          	jal	ra,80000670 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    80002d70:	0000a517          	auipc	a0,0xa
    80002d74:	ec050513          	addi	a0,a0,-320 # 8000cc30 <xDelayedTaskList2>
    80002d78:	8f9fd0ef          	jal	ra,80000670 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    80002d7c:	0000a517          	auipc	a0,0xa
    80002d80:	eec50513          	addi	a0,a0,-276 # 8000cc68 <xPendingReadyList>
    80002d84:	8edfd0ef          	jal	ra,80000670 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    80002d88:	0000a517          	auipc	a0,0xa
    80002d8c:	f0850513          	addi	a0,a0,-248 # 8000cc90 <xTasksWaitingTermination>
    80002d90:	8e1fd0ef          	jal	ra,80000670 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
    80002d94:	0000a517          	auipc	a0,0xa
    80002d98:	f2c50513          	addi	a0,a0,-212 # 8000ccc0 <xSuspendedTaskList>
    80002d9c:	8d5fd0ef          	jal	ra,80000670 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    80002da0:	0000a797          	auipc	a5,0xa
    80002da4:	eb878793          	addi	a5,a5,-328 # 8000cc58 <pxDelayedTaskList>
    80002da8:	0000a717          	auipc	a4,0xa
    80002dac:	e6070713          	addi	a4,a4,-416 # 8000cc08 <xDelayedTaskList1>
    80002db0:	e398                	sd	a4,0(a5)
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    80002db2:	0000a797          	auipc	a5,0xa
    80002db6:	eae78793          	addi	a5,a5,-338 # 8000cc60 <pxOverflowDelayedTaskList>
    80002dba:	0000a717          	auipc	a4,0xa
    80002dbe:	e7670713          	addi	a4,a4,-394 # 8000cc30 <xDelayedTaskList2>
    80002dc2:	e398                	sd	a4,0(a5)
}
    80002dc4:	0001                	nop
    80002dc6:	60e2                	ld	ra,24(sp)
    80002dc8:	6105                	addi	sp,sp,32
    80002dca:	8082                	ret

0000000080002dcc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    80002dcc:	1101                	addi	sp,sp,-32
    80002dce:	ec06                	sd	ra,24(sp)
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    80002dd0:	a8a1                	j	80002e28 <prvCheckTasksWaitingTermination+0x5c>
            {
                taskENTER_CRITICAL();
    80002dd2:	5fa000ef          	jal	ra,800033cc <vTaskEnterCritical>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    80002dd6:	0000a797          	auipc	a5,0xa
    80002dda:	eba78793          	addi	a5,a5,-326 # 8000cc90 <xTasksWaitingTermination>
    80002dde:	6f9c                	ld	a5,24(a5)
    80002de0:	6f9c                	ld	a5,24(a5)
    80002de2:	e43e                	sd	a5,8(sp)
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    80002de4:	67a2                	ld	a5,8(sp)
    80002de6:	07a1                	addi	a5,a5,8
    80002de8:	853e                	mv	a0,a5
    80002dea:	975fd0ef          	jal	ra,8000075e <uxListRemove>
                    --uxCurrentNumberOfTasks;
    80002dee:	0000a797          	auipc	a5,0xa
    80002df2:	efa78793          	addi	a5,a5,-262 # 8000cce8 <uxCurrentNumberOfTasks>
    80002df6:	639c                	ld	a5,0(a5)
    80002df8:	fff78713          	addi	a4,a5,-1
    80002dfc:	0000a797          	auipc	a5,0xa
    80002e00:	eec78793          	addi	a5,a5,-276 # 8000cce8 <uxCurrentNumberOfTasks>
    80002e04:	e398                	sd	a4,0(a5)
                    --uxDeletedTasksWaitingCleanUp;
    80002e06:	0000a797          	auipc	a5,0xa
    80002e0a:	eb278793          	addi	a5,a5,-334 # 8000ccb8 <uxDeletedTasksWaitingCleanUp>
    80002e0e:	639c                	ld	a5,0(a5)
    80002e10:	fff78713          	addi	a4,a5,-1
    80002e14:	0000a797          	auipc	a5,0xa
    80002e18:	ea478793          	addi	a5,a5,-348 # 8000ccb8 <uxDeletedTasksWaitingCleanUp>
    80002e1c:	e398                	sd	a4,0(a5)
                }
                taskEXIT_CRITICAL();
    80002e1e:	5dc000ef          	jal	ra,800033fa <vTaskExitCritical>

                prvDeleteTCB( pxTCB );
    80002e22:	6522                	ld	a0,8(sp)
    80002e24:	1d0000ef          	jal	ra,80002ff4 <prvDeleteTCB>
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    80002e28:	0000a797          	auipc	a5,0xa
    80002e2c:	e9078793          	addi	a5,a5,-368 # 8000ccb8 <uxDeletedTasksWaitingCleanUp>
    80002e30:	639c                	ld	a5,0(a5)
    80002e32:	f3c5                	bnez	a5,80002dd2 <prvCheckTasksWaitingTermination+0x6>
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    80002e34:	0001                	nop
    80002e36:	0001                	nop
    80002e38:	60e2                	ld	ra,24(sp)
    80002e3a:	6105                	addi	sp,sp,32
    80002e3c:	8082                	ret

0000000080002e3e <vTaskGetInfo>:

    void vTaskGetInfo( TaskHandle_t xTask,
                       TaskStatus_t * pxTaskStatus,
                       BaseType_t xGetFreeStackSpace,
                       eTaskState eState )
    {
    80002e3e:	7139                	addi	sp,sp,-64
    80002e40:	fc06                	sd	ra,56(sp)
    80002e42:	ec2a                	sd	a0,24(sp)
    80002e44:	e82e                	sd	a1,16(sp)
    80002e46:	e432                	sd	a2,8(sp)
    80002e48:	87b6                	mv	a5,a3
    80002e4a:	c23e                	sw	a5,4(sp)
        TCB_t * pxTCB;

        /* xTask is NULL then get the state of the calling task. */
        pxTCB = prvGetTCBFromHandle( xTask );
    80002e4c:	67e2                	ld	a5,24(sp)
    80002e4e:	e799                	bnez	a5,80002e5c <vTaskGetInfo+0x1e>
    80002e50:	00008797          	auipc	a5,0x8
    80002e54:	d8078793          	addi	a5,a5,-640 # 8000abd0 <pxCurrentTCB>
    80002e58:	639c                	ld	a5,0(a5)
    80002e5a:	a011                	j	80002e5e <vTaskGetInfo+0x20>
    80002e5c:	67e2                	ld	a5,24(sp)
    80002e5e:	f43e                	sd	a5,40(sp)

        pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
    80002e60:	67c2                	ld	a5,16(sp)
    80002e62:	7722                	ld	a4,40(sp)
    80002e64:	e398                	sd	a4,0(a5)
        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
    80002e66:	77a2                	ld	a5,40(sp)
    80002e68:	06878713          	addi	a4,a5,104
    80002e6c:	67c2                	ld	a5,16(sp)
    80002e6e:	e798                	sd	a4,8(a5)
        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
    80002e70:	77a2                	ld	a5,40(sp)
    80002e72:	6fb8                	ld	a4,88(a5)
    80002e74:	67c2                	ld	a5,16(sp)
    80002e76:	f398                	sd	a4,32(a5)
        pxTaskStatus->pxStackBase = pxTCB->pxStack;
    80002e78:	77a2                	ld	a5,40(sp)
    80002e7a:	73b8                	ld	a4,96(a5)
    80002e7c:	67c2                	ld	a5,16(sp)
    80002e7e:	ff98                	sd	a4,56(a5)
        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
    80002e80:	77a2                	ld	a5,40(sp)
    80002e82:	63d8                	ld	a4,128(a5)
    80002e84:	67c2                	ld	a5,16(sp)
    80002e86:	eb98                	sd	a4,16(a5)

        #if ( configUSE_MUTEXES == 1 )
            {
                pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
    80002e88:	77a2                	ld	a5,40(sp)
    80002e8a:	6bd8                	ld	a4,144(a5)
    80002e8c:	67c2                	ld	a5,16(sp)
    80002e8e:	f798                	sd	a4,40(a5)
            {
                pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
            }
        #else
            {
                pxTaskStatus->ulRunTimeCounter = 0;
    80002e90:	67c2                	ld	a5,16(sp)
    80002e92:	0207a823          	sw	zero,48(a5)
        #endif

        /* Obtaining the task state is a little fiddly, so is only done if the
         * value of eState passed into this function is eInvalid - otherwise the
         * state is just set to whatever is passed in. */
        if( eState != eInvalid )
    80002e96:	4792                	lw	a5,4(sp)
    80002e98:	0007871b          	sext.w	a4,a5
    80002e9c:	4795                	li	a5,5
    80002e9e:	04f70263          	beq	a4,a5,80002ee2 <vTaskGetInfo+0xa4>
        {
            if( pxTCB == pxCurrentTCB )
    80002ea2:	00008797          	auipc	a5,0x8
    80002ea6:	d2e78793          	addi	a5,a5,-722 # 8000abd0 <pxCurrentTCB>
    80002eaa:	639c                	ld	a5,0(a5)
    80002eac:	7722                	ld	a4,40(sp)
    80002eae:	00f71663          	bne	a4,a5,80002eba <vTaskGetInfo+0x7c>
            {
                pxTaskStatus->eCurrentState = eRunning;
    80002eb2:	67c2                	ld	a5,16(sp)
    80002eb4:	0007ac23          	sw	zero,24(a5)
    80002eb8:	a82d                	j	80002ef2 <vTaskGetInfo+0xb4>
            }
            else
            {
                pxTaskStatus->eCurrentState = eState;
    80002eba:	67c2                	ld	a5,16(sp)
    80002ebc:	4712                	lw	a4,4(sp)
    80002ebe:	cf98                	sw	a4,24(a5)
                #if ( INCLUDE_vTaskSuspend == 1 )
                    {
                        /* If the task is in the suspended list then there is a
                         *  chance it is actually just blocked indefinitely - so really
                         *  it should be reported as being in the Blocked state. */
                        if( eState == eSuspended )
    80002ec0:	4792                	lw	a5,4(sp)
    80002ec2:	0007871b          	sext.w	a4,a5
    80002ec6:	478d                	li	a5,3
    80002ec8:	02f71563          	bne	a4,a5,80002ef2 <vTaskGetInfo+0xb4>
                        {
                            vTaskSuspendAll();
    80002ecc:	c78ff0ef          	jal	ra,80002344 <vTaskSuspendAll>
                            {
                                if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    80002ed0:	77a2                	ld	a5,40(sp)
    80002ed2:	6bbc                	ld	a5,80(a5)
    80002ed4:	c781                	beqz	a5,80002edc <vTaskGetInfo+0x9e>
                                {
                                    pxTaskStatus->eCurrentState = eBlocked;
    80002ed6:	67c2                	ld	a5,16(sp)
    80002ed8:	4709                	li	a4,2
    80002eda:	cf98                	sw	a4,24(a5)
                                }
                            }
                            ( void ) xTaskResumeAll();
    80002edc:	c84ff0ef          	jal	ra,80002360 <xTaskResumeAll>
    80002ee0:	a809                	j	80002ef2 <vTaskGetInfo+0xb4>
                #endif /* INCLUDE_vTaskSuspend */
            }
        }
        else
        {
            pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
    80002ee2:	7522                	ld	a0,40(sp)
    80002ee4:	e39fe0ef          	jal	ra,80001d1c <eTaskGetState>
    80002ee8:	87aa                	mv	a5,a0
    80002eea:	0007871b          	sext.w	a4,a5
    80002eee:	67c2                	ld	a5,16(sp)
    80002ef0:	cf98                	sw	a4,24(a5)
        }

        /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
         * parameter is provided to allow it to be skipped. */
        if( xGetFreeStackSpace != pdFALSE )
    80002ef2:	67a2                	ld	a5,8(sp)
    80002ef4:	cf81                	beqz	a5,80002f0c <vTaskGetInfo+0xce>
                {
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
                }
            #else
                {
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
    80002ef6:	77a2                	ld	a5,40(sp)
    80002ef8:	73bc                	ld	a5,96(a5)
    80002efa:	853e                	mv	a0,a5
    80002efc:	0c0000ef          	jal	ra,80002fbc <prvTaskCheckFreeStackSpace>
    80002f00:	87aa                	mv	a5,a0
    80002f02:	873e                	mv	a4,a5
    80002f04:	67c2                	ld	a5,16(sp)
    80002f06:	04e79023          	sh	a4,64(a5)
        }
        else
        {
            pxTaskStatus->usStackHighWaterMark = 0;
        }
    }
    80002f0a:	a021                	j	80002f12 <vTaskGetInfo+0xd4>
            pxTaskStatus->usStackHighWaterMark = 0;
    80002f0c:	67c2                	ld	a5,16(sp)
    80002f0e:	04079023          	sh	zero,64(a5)
    }
    80002f12:	0001                	nop
    80002f14:	70e2                	ld	ra,56(sp)
    80002f16:	6121                	addi	sp,sp,64
    80002f18:	8082                	ret

0000000080002f1a <prvListTasksWithinSingleList>:
#if ( configUSE_TRACE_FACILITY == 1 )

    static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
                                                     List_t * pxList,
                                                     eTaskState eState )
    {
    80002f1a:	711d                	addi	sp,sp,-96
    80002f1c:	ec86                	sd	ra,88(sp)
    80002f1e:	ec2a                	sd	a0,24(sp)
    80002f20:	e82e                	sd	a1,16(sp)
    80002f22:	87b2                	mv	a5,a2
    80002f24:	c63e                	sw	a5,12(sp)
        configLIST_VOLATILE TCB_t * pxNextTCB, * pxFirstTCB;
        UBaseType_t uxTask = 0;
    80002f26:	e482                	sd	zero,72(sp)

        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    80002f28:	67c2                	ld	a5,16(sp)
    80002f2a:	639c                	ld	a5,0(a5)
    80002f2c:	c3d9                	beqz	a5,80002fb2 <prvListTasksWithinSingleList+0x98>
        {
            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    80002f2e:	67c2                	ld	a5,16(sp)
    80002f30:	e0be                	sd	a5,64(sp)
    80002f32:	6786                	ld	a5,64(sp)
    80002f34:	679c                	ld	a5,8(a5)
    80002f36:	6798                	ld	a4,8(a5)
    80002f38:	6786                	ld	a5,64(sp)
    80002f3a:	e798                	sd	a4,8(a5)
    80002f3c:	6786                	ld	a5,64(sp)
    80002f3e:	6798                	ld	a4,8(a5)
    80002f40:	6786                	ld	a5,64(sp)
    80002f42:	07c1                	addi	a5,a5,16
    80002f44:	00f71763          	bne	a4,a5,80002f52 <prvListTasksWithinSingleList+0x38>
    80002f48:	6786                	ld	a5,64(sp)
    80002f4a:	679c                	ld	a5,8(a5)
    80002f4c:	6798                	ld	a4,8(a5)
    80002f4e:	6786                	ld	a5,64(sp)
    80002f50:	e798                	sd	a4,8(a5)
    80002f52:	6786                	ld	a5,64(sp)
    80002f54:	679c                	ld	a5,8(a5)
    80002f56:	6f9c                	ld	a5,24(a5)
    80002f58:	fc3e                	sd	a5,56(sp)
             * pxTaskStatusArray array for each task that is referenced from
             * pxList.  See the definition of TaskStatus_t in task.h for the
             * meaning of each TaskStatus_t structure member. */
            do
            {
                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    80002f5a:	67c2                	ld	a5,16(sp)
    80002f5c:	f83e                	sd	a5,48(sp)
    80002f5e:	77c2                	ld	a5,48(sp)
    80002f60:	679c                	ld	a5,8(a5)
    80002f62:	6798                	ld	a4,8(a5)
    80002f64:	77c2                	ld	a5,48(sp)
    80002f66:	e798                	sd	a4,8(a5)
    80002f68:	77c2                	ld	a5,48(sp)
    80002f6a:	6798                	ld	a4,8(a5)
    80002f6c:	77c2                	ld	a5,48(sp)
    80002f6e:	07c1                	addi	a5,a5,16
    80002f70:	00f71763          	bne	a4,a5,80002f7e <prvListTasksWithinSingleList+0x64>
    80002f74:	77c2                	ld	a5,48(sp)
    80002f76:	679c                	ld	a5,8(a5)
    80002f78:	6798                	ld	a4,8(a5)
    80002f7a:	77c2                	ld	a5,48(sp)
    80002f7c:	e798                	sd	a4,8(a5)
    80002f7e:	77c2                	ld	a5,48(sp)
    80002f80:	679c                	ld	a5,8(a5)
    80002f82:	6f9c                	ld	a5,24(a5)
    80002f84:	f43e                	sd	a5,40(sp)
                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
    80002f86:	6726                	ld	a4,72(sp)
    80002f88:	87ba                	mv	a5,a4
    80002f8a:	078e                	slli	a5,a5,0x3
    80002f8c:	97ba                	add	a5,a5,a4
    80002f8e:	078e                	slli	a5,a5,0x3
    80002f90:	873e                	mv	a4,a5
    80002f92:	67e2                	ld	a5,24(sp)
    80002f94:	97ba                	add	a5,a5,a4
    80002f96:	4732                	lw	a4,12(sp)
    80002f98:	86ba                	mv	a3,a4
    80002f9a:	4605                	li	a2,1
    80002f9c:	85be                	mv	a1,a5
    80002f9e:	7522                	ld	a0,40(sp)
    80002fa0:	e9fff0ef          	jal	ra,80002e3e <vTaskGetInfo>
                uxTask++;
    80002fa4:	67a6                	ld	a5,72(sp)
    80002fa6:	0785                	addi	a5,a5,1
    80002fa8:	e4be                	sd	a5,72(sp)
            } while( pxNextTCB != pxFirstTCB );
    80002faa:	7722                	ld	a4,40(sp)
    80002fac:	77e2                	ld	a5,56(sp)
    80002fae:	faf716e3          	bne	a4,a5,80002f5a <prvListTasksWithinSingleList+0x40>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return uxTask;
    80002fb2:	67a6                	ld	a5,72(sp)
    }
    80002fb4:	853e                	mv	a0,a5
    80002fb6:	60e6                	ld	ra,88(sp)
    80002fb8:	6125                	addi	sp,sp,96
    80002fba:	8082                	ret

0000000080002fbc <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
    80002fbc:	1101                	addi	sp,sp,-32
    80002fbe:	e42a                	sd	a0,8(sp)
        uint32_t ulCount = 0U;
    80002fc0:	ce02                	sw	zero,28(sp)

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    80002fc2:	a039                	j	80002fd0 <prvTaskCheckFreeStackSpace+0x14>
        {
            pucStackByte -= portSTACK_GROWTH;
    80002fc4:	67a2                	ld	a5,8(sp)
    80002fc6:	0785                	addi	a5,a5,1
    80002fc8:	e43e                	sd	a5,8(sp)
            ulCount++;
    80002fca:	47f2                	lw	a5,28(sp)
    80002fcc:	2785                	addiw	a5,a5,1
    80002fce:	ce3e                	sw	a5,28(sp)
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    80002fd0:	67a2                	ld	a5,8(sp)
    80002fd2:	0007c783          	lbu	a5,0(a5)
    80002fd6:	873e                	mv	a4,a5
    80002fd8:	0a500793          	li	a5,165
    80002fdc:	fef704e3          	beq	a4,a5,80002fc4 <prvTaskCheckFreeStackSpace+0x8>
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
    80002fe0:	47f2                	lw	a5,28(sp)
    80002fe2:	0037d79b          	srliw	a5,a5,0x3
    80002fe6:	ce3e                	sw	a5,28(sp)

        return ( configSTACK_DEPTH_TYPE ) ulCount;
    80002fe8:	47f2                	lw	a5,28(sp)
    80002fea:	17c2                	slli	a5,a5,0x30
    80002fec:	93c1                	srli	a5,a5,0x30
    }
    80002fee:	853e                	mv	a0,a5
    80002ff0:	6105                	addi	sp,sp,32
    80002ff2:	8082                	ret

0000000080002ff4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    80002ff4:	1101                	addi	sp,sp,-32
    80002ff6:	ec06                	sd	ra,24(sp)
    80002ff8:	e42a                	sd	a0,8(sp)

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
    80002ffa:	67a2                	ld	a5,8(sp)
    80002ffc:	73bc                	ld	a5,96(a5)
    80002ffe:	853e                	mv	a0,a5
    80003000:	393010ef          	jal	ra,80004b92 <vPortFree>
                vPortFree( pxTCB );
    80003004:	6522                	ld	a0,8(sp)
    80003006:	38d010ef          	jal	ra,80004b92 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    8000300a:	0001                	nop
    8000300c:	60e2                	ld	ra,24(sp)
    8000300e:	6105                	addi	sp,sp,32
    80003010:	8082                	ret

0000000080003012 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    80003012:	0000a797          	auipc	a5,0xa
    80003016:	c4678793          	addi	a5,a5,-954 # 8000cc58 <pxDelayedTaskList>
    8000301a:	639c                	ld	a5,0(a5)
    8000301c:	639c                	ld	a5,0(a5)
    8000301e:	eb81                	bnez	a5,8000302e <prvResetNextTaskUnblockTime+0x1c>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    80003020:	0000a797          	auipc	a5,0xa
    80003024:	d0878793          	addi	a5,a5,-760 # 8000cd28 <xNextTaskUnblockTime>
    80003028:	577d                	li	a4,-1
    8000302a:	e398                	sd	a4,0(a5)
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
    8000302c:	a829                	j	80003046 <prvResetNextTaskUnblockTime+0x34>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    8000302e:	0000a797          	auipc	a5,0xa
    80003032:	c2a78793          	addi	a5,a5,-982 # 8000cc58 <pxDelayedTaskList>
    80003036:	639c                	ld	a5,0(a5)
    80003038:	6f9c                	ld	a5,24(a5)
    8000303a:	6398                	ld	a4,0(a5)
    8000303c:	0000a797          	auipc	a5,0xa
    80003040:	cec78793          	addi	a5,a5,-788 # 8000cd28 <xNextTaskUnblockTime>
    80003044:	e398                	sd	a4,0(a5)
}
    80003046:	0001                	nop
    80003048:	8082                	ret

000000008000304a <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    8000304a:	1141                	addi	sp,sp,-16
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    8000304c:	00008797          	auipc	a5,0x8
    80003050:	b8478793          	addi	a5,a5,-1148 # 8000abd0 <pxCurrentTCB>
    80003054:	639c                	ld	a5,0(a5)
    80003056:	e43e                	sd	a5,8(sp)

        return xReturn;
    80003058:	67a2                	ld	a5,8(sp)
    }
    8000305a:	853e                	mv	a0,a5
    8000305c:	0141                	addi	sp,sp,16
    8000305e:	8082                	ret

0000000080003060 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    80003060:	1141                	addi	sp,sp,-16
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    80003062:	0000a797          	auipc	a5,0xa
    80003066:	c9e78793          	addi	a5,a5,-866 # 8000cd00 <xSchedulerRunning>
    8000306a:	639c                	ld	a5,0(a5)
    8000306c:	e781                	bnez	a5,80003074 <xTaskGetSchedulerState+0x14>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    8000306e:	4785                	li	a5,1
    80003070:	e43e                	sd	a5,8(sp)
    80003072:	a819                	j	80003088 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    80003074:	0000a797          	auipc	a5,0xa
    80003078:	cc478793          	addi	a5,a5,-828 # 8000cd38 <uxSchedulerSuspended>
    8000307c:	639c                	ld	a5,0(a5)
    8000307e:	e781                	bnez	a5,80003086 <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    80003080:	4789                	li	a5,2
    80003082:	e43e                	sd	a5,8(sp)
    80003084:	a011                	j	80003088 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    80003086:	e402                	sd	zero,8(sp)
            }
        }

        return xReturn;
    80003088:	67a2                	ld	a5,8(sp)
    }
    8000308a:	853e                	mv	a0,a5
    8000308c:	0141                	addi	sp,sp,16
    8000308e:	8082                	ret

0000000080003090 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
    80003090:	7179                	addi	sp,sp,-48
    80003092:	f406                	sd	ra,40(sp)
    80003094:	e42a                	sd	a0,8(sp)
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    80003096:	67a2                	ld	a5,8(sp)
    80003098:	e83e                	sd	a5,16(sp)
        BaseType_t xReturn = pdFALSE;
    8000309a:	ec02                	sd	zero,24(sp)

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
    8000309c:	67a2                	ld	a5,8(sp)
    8000309e:	10078963          	beqz	a5,800031b0 <xTaskPriorityInherit+0x120>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    800030a2:	67c2                	ld	a5,16(sp)
    800030a4:	6fb8                	ld	a4,88(a5)
    800030a6:	00008797          	auipc	a5,0x8
    800030aa:	b2a78793          	addi	a5,a5,-1238 # 8000abd0 <pxCurrentTCB>
    800030ae:	639c                	ld	a5,0(a5)
    800030b0:	6fbc                	ld	a5,88(a5)
    800030b2:	0ef77363          	bgeu	a4,a5,80003198 <xTaskPriorityInherit+0x108>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    800030b6:	67c2                	ld	a5,16(sp)
    800030b8:	7b98                	ld	a4,48(a5)
    800030ba:	4785                	li	a5,1
    800030bc:	07fe                	slli	a5,a5,0x1f
    800030be:	8ff9                	and	a5,a5,a4
    800030c0:	eb99                	bnez	a5,800030d6 <xTaskPriorityInherit+0x46>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    800030c2:	00008797          	auipc	a5,0x8
    800030c6:	b0e78793          	addi	a5,a5,-1266 # 8000abd0 <pxCurrentTCB>
    800030ca:	639c                	ld	a5,0(a5)
    800030cc:	6fbc                	ld	a5,88(a5)
    800030ce:	4715                	li	a4,5
    800030d0:	8f1d                	sub	a4,a4,a5
    800030d2:	67c2                	ld	a5,16(sp)
    800030d4:	fb98                	sd	a4,48(a5)
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    800030d6:	67c2                	ld	a5,16(sp)
    800030d8:	7794                	ld	a3,40(a5)
    800030da:	67c2                	ld	a5,16(sp)
    800030dc:	6fb8                	ld	a4,88(a5)
    800030de:	87ba                	mv	a5,a4
    800030e0:	078a                	slli	a5,a5,0x2
    800030e2:	97ba                	add	a5,a5,a4
    800030e4:	078e                	slli	a5,a5,0x3
    800030e6:	0000a717          	auipc	a4,0xa
    800030ea:	a5a70713          	addi	a4,a4,-1446 # 8000cb40 <pxReadyTasksLists>
    800030ee:	97ba                	add	a5,a5,a4
    800030f0:	08f69963          	bne	a3,a5,80003182 <xTaskPriorityInherit+0xf2>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    800030f4:	67c2                	ld	a5,16(sp)
    800030f6:	07a1                	addi	a5,a5,8
    800030f8:	853e                	mv	a0,a5
    800030fa:	e64fd0ef          	jal	ra,8000075e <uxListRemove>
    800030fe:	87aa                	mv	a5,a0
    80003100:	e78d                	bnez	a5,8000312a <xTaskPriorityInherit+0x9a>
                    {
                        /* It is known that the task is in its ready list so
                         * there is no need to check again and the port level
                         * reset macro can be called directly. */
                        portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
    80003102:	67c2                	ld	a5,16(sp)
    80003104:	6fbc                	ld	a5,88(a5)
    80003106:	2781                	sext.w	a5,a5
    80003108:	873e                	mv	a4,a5
    8000310a:	4785                	li	a5,1
    8000310c:	00e797b3          	sll	a5,a5,a4
    80003110:	fff7c713          	not	a4,a5
    80003114:	0000a797          	auipc	a5,0xa
    80003118:	be478793          	addi	a5,a5,-1052 # 8000ccf8 <uxTopReadyPriority>
    8000311c:	639c                	ld	a5,0(a5)
    8000311e:	8f7d                	and	a4,a4,a5
    80003120:	0000a797          	auipc	a5,0xa
    80003124:	bd878793          	addi	a5,a5,-1064 # 8000ccf8 <uxTopReadyPriority>
    80003128:	e398                	sd	a4,0(a5)
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    8000312a:	00008797          	auipc	a5,0x8
    8000312e:	aa678793          	addi	a5,a5,-1370 # 8000abd0 <pxCurrentTCB>
    80003132:	639c                	ld	a5,0(a5)
    80003134:	6fb8                	ld	a4,88(a5)
    80003136:	67c2                	ld	a5,16(sp)
    80003138:	efb8                	sd	a4,88(a5)
                    prvAddTaskToReadyList( pxMutexHolderTCB );
    8000313a:	67c2                	ld	a5,16(sp)
    8000313c:	6fbc                	ld	a5,88(a5)
    8000313e:	2781                	sext.w	a5,a5
    80003140:	873e                	mv	a4,a5
    80003142:	4785                	li	a5,1
    80003144:	00e79733          	sll	a4,a5,a4
    80003148:	0000a797          	auipc	a5,0xa
    8000314c:	bb078793          	addi	a5,a5,-1104 # 8000ccf8 <uxTopReadyPriority>
    80003150:	639c                	ld	a5,0(a5)
    80003152:	8f5d                	or	a4,a4,a5
    80003154:	0000a797          	auipc	a5,0xa
    80003158:	ba478793          	addi	a5,a5,-1116 # 8000ccf8 <uxTopReadyPriority>
    8000315c:	e398                	sd	a4,0(a5)
    8000315e:	67c2                	ld	a5,16(sp)
    80003160:	6fb8                	ld	a4,88(a5)
    80003162:	87ba                	mv	a5,a4
    80003164:	078a                	slli	a5,a5,0x2
    80003166:	97ba                	add	a5,a5,a4
    80003168:	078e                	slli	a5,a5,0x3
    8000316a:	0000a717          	auipc	a4,0xa
    8000316e:	9d670713          	addi	a4,a4,-1578 # 8000cb40 <pxReadyTasksLists>
    80003172:	973e                	add	a4,a4,a5
    80003174:	67c2                	ld	a5,16(sp)
    80003176:	07a1                	addi	a5,a5,8
    80003178:	85be                	mv	a1,a5
    8000317a:	853a                	mv	a0,a4
    8000317c:	d38fd0ef          	jal	ra,800006b4 <vListInsertEnd>
    80003180:	a809                	j	80003192 <xTaskPriorityInherit+0x102>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    80003182:	00008797          	auipc	a5,0x8
    80003186:	a4e78793          	addi	a5,a5,-1458 # 8000abd0 <pxCurrentTCB>
    8000318a:	639c                	ld	a5,0(a5)
    8000318c:	6fb8                	ld	a4,88(a5)
    8000318e:	67c2                	ld	a5,16(sp)
    80003190:	efb8                	sd	a4,88(a5)
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
    80003192:	4785                	li	a5,1
    80003194:	ec3e                	sd	a5,24(sp)
    80003196:	a829                	j	800031b0 <xTaskPriorityInherit+0x120>
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    80003198:	67c2                	ld	a5,16(sp)
    8000319a:	6bd8                	ld	a4,144(a5)
    8000319c:	00008797          	auipc	a5,0x8
    800031a0:	a3478793          	addi	a5,a5,-1484 # 8000abd0 <pxCurrentTCB>
    800031a4:	639c                	ld	a5,0(a5)
    800031a6:	6fbc                	ld	a5,88(a5)
    800031a8:	00f77463          	bgeu	a4,a5,800031b0 <xTaskPriorityInherit+0x120>
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
    800031ac:	4785                	li	a5,1
    800031ae:	ec3e                	sd	a5,24(sp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    800031b0:	67e2                	ld	a5,24(sp)
    }
    800031b2:	853e                	mv	a0,a5
    800031b4:	70a2                	ld	ra,40(sp)
    800031b6:	6145                	addi	sp,sp,48
    800031b8:	8082                	ret

00000000800031ba <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    800031ba:	7179                	addi	sp,sp,-48
    800031bc:	f406                	sd	ra,40(sp)
    800031be:	e42a                	sd	a0,8(sp)
        TCB_t * const pxTCB = pxMutexHolder;
    800031c0:	67a2                	ld	a5,8(sp)
    800031c2:	e83e                	sd	a5,16(sp)
        BaseType_t xReturn = pdFALSE;
    800031c4:	ec02                	sd	zero,24(sp)

        if( pxMutexHolder != NULL )
    800031c6:	67a2                	ld	a5,8(sp)
    800031c8:	cbf9                	beqz	a5,8000329e <xTaskPriorityDisinherit+0xe4>
        {
            /* A task can only have an inherited priority if it holds the mutex.
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
    800031ca:	00008797          	auipc	a5,0x8
    800031ce:	a0678793          	addi	a5,a5,-1530 # 8000abd0 <pxCurrentTCB>
    800031d2:	639c                	ld	a5,0(a5)
    800031d4:	6742                	ld	a4,16(sp)
    800031d6:	00f70563          	beq	a4,a5,800031e0 <xTaskPriorityDisinherit+0x26>
    800031da:	30047073          	csrci	mstatus,8
    800031de:	a001                	j	800031de <xTaskPriorityDisinherit+0x24>
            configASSERT( pxTCB->uxMutexesHeld );
    800031e0:	67c2                	ld	a5,16(sp)
    800031e2:	6fdc                	ld	a5,152(a5)
    800031e4:	e781                	bnez	a5,800031ec <xTaskPriorityDisinherit+0x32>
    800031e6:	30047073          	csrci	mstatus,8
    800031ea:	a001                	j	800031ea <xTaskPriorityDisinherit+0x30>
            ( pxTCB->uxMutexesHeld )--;
    800031ec:	67c2                	ld	a5,16(sp)
    800031ee:	6fdc                	ld	a5,152(a5)
    800031f0:	fff78713          	addi	a4,a5,-1
    800031f4:	67c2                	ld	a5,16(sp)
    800031f6:	efd8                	sd	a4,152(a5)

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    800031f8:	67c2                	ld	a5,16(sp)
    800031fa:	6fb8                	ld	a4,88(a5)
    800031fc:	67c2                	ld	a5,16(sp)
    800031fe:	6bdc                	ld	a5,144(a5)
    80003200:	08f70f63          	beq	a4,a5,8000329e <xTaskPriorityDisinherit+0xe4>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    80003204:	67c2                	ld	a5,16(sp)
    80003206:	6fdc                	ld	a5,152(a5)
    80003208:	ebd9                	bnez	a5,8000329e <xTaskPriorityDisinherit+0xe4>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    8000320a:	67c2                	ld	a5,16(sp)
    8000320c:	07a1                	addi	a5,a5,8
    8000320e:	853e                	mv	a0,a5
    80003210:	d4efd0ef          	jal	ra,8000075e <uxListRemove>
    80003214:	87aa                	mv	a5,a0
    80003216:	e78d                	bnez	a5,80003240 <xTaskPriorityDisinherit+0x86>
                    {
                        portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
    80003218:	67c2                	ld	a5,16(sp)
    8000321a:	6fbc                	ld	a5,88(a5)
    8000321c:	2781                	sext.w	a5,a5
    8000321e:	873e                	mv	a4,a5
    80003220:	4785                	li	a5,1
    80003222:	00e797b3          	sll	a5,a5,a4
    80003226:	fff7c713          	not	a4,a5
    8000322a:	0000a797          	auipc	a5,0xa
    8000322e:	ace78793          	addi	a5,a5,-1330 # 8000ccf8 <uxTopReadyPriority>
    80003232:	639c                	ld	a5,0(a5)
    80003234:	8f7d                	and	a4,a4,a5
    80003236:	0000a797          	auipc	a5,0xa
    8000323a:	ac278793          	addi	a5,a5,-1342 # 8000ccf8 <uxTopReadyPriority>
    8000323e:	e398                	sd	a4,0(a5)
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    80003240:	67c2                	ld	a5,16(sp)
    80003242:	6bd8                	ld	a4,144(a5)
    80003244:	67c2                	ld	a5,16(sp)
    80003246:	efb8                	sd	a4,88(a5)

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    80003248:	67c2                	ld	a5,16(sp)
    8000324a:	6fbc                	ld	a5,88(a5)
    8000324c:	4715                	li	a4,5
    8000324e:	8f1d                	sub	a4,a4,a5
    80003250:	67c2                	ld	a5,16(sp)
    80003252:	fb98                	sd	a4,48(a5)
                    prvAddTaskToReadyList( pxTCB );
    80003254:	67c2                	ld	a5,16(sp)
    80003256:	6fbc                	ld	a5,88(a5)
    80003258:	2781                	sext.w	a5,a5
    8000325a:	873e                	mv	a4,a5
    8000325c:	4785                	li	a5,1
    8000325e:	00e79733          	sll	a4,a5,a4
    80003262:	0000a797          	auipc	a5,0xa
    80003266:	a9678793          	addi	a5,a5,-1386 # 8000ccf8 <uxTopReadyPriority>
    8000326a:	639c                	ld	a5,0(a5)
    8000326c:	8f5d                	or	a4,a4,a5
    8000326e:	0000a797          	auipc	a5,0xa
    80003272:	a8a78793          	addi	a5,a5,-1398 # 8000ccf8 <uxTopReadyPriority>
    80003276:	e398                	sd	a4,0(a5)
    80003278:	67c2                	ld	a5,16(sp)
    8000327a:	6fb8                	ld	a4,88(a5)
    8000327c:	87ba                	mv	a5,a4
    8000327e:	078a                	slli	a5,a5,0x2
    80003280:	97ba                	add	a5,a5,a4
    80003282:	078e                	slli	a5,a5,0x3
    80003284:	0000a717          	auipc	a4,0xa
    80003288:	8bc70713          	addi	a4,a4,-1860 # 8000cb40 <pxReadyTasksLists>
    8000328c:	973e                	add	a4,a4,a5
    8000328e:	67c2                	ld	a5,16(sp)
    80003290:	07a1                	addi	a5,a5,8
    80003292:	85be                	mv	a1,a5
    80003294:	853a                	mv	a0,a4
    80003296:	c1efd0ef          	jal	ra,800006b4 <vListInsertEnd>
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
    8000329a:	4785                	li	a5,1
    8000329c:	ec3e                	sd	a5,24(sp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    8000329e:	67e2                	ld	a5,24(sp)
    }
    800032a0:	853e                	mv	a0,a5
    800032a2:	70a2                	ld	ra,40(sp)
    800032a4:	6145                	addi	sp,sp,48
    800032a6:	8082                	ret

00000000800032a8 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
    800032a8:	7139                	addi	sp,sp,-64
    800032aa:	fc06                	sd	ra,56(sp)
    800032ac:	e42a                	sd	a0,8(sp)
    800032ae:	e02e                	sd	a1,0(sp)
        TCB_t * const pxTCB = pxMutexHolder;
    800032b0:	67a2                	ld	a5,8(sp)
    800032b2:	f03e                	sd	a5,32(sp)
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    800032b4:	4785                	li	a5,1
    800032b6:	ec3e                	sd	a5,24(sp)

        if( pxMutexHolder != NULL )
    800032b8:	67a2                	ld	a5,8(sp)
    800032ba:	10078563          	beqz	a5,800033c4 <vTaskPriorityDisinheritAfterTimeout+0x11c>
        {
            /* If pxMutexHolder is not NULL then the holder must hold at least
             * one mutex. */
            configASSERT( pxTCB->uxMutexesHeld );
    800032be:	7782                	ld	a5,32(sp)
    800032c0:	6fdc                	ld	a5,152(a5)
    800032c2:	e781                	bnez	a5,800032ca <vTaskPriorityDisinheritAfterTimeout+0x22>
    800032c4:	30047073          	csrci	mstatus,8
    800032c8:	a001                	j	800032c8 <vTaskPriorityDisinheritAfterTimeout+0x20>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    800032ca:	7782                	ld	a5,32(sp)
    800032cc:	6bdc                	ld	a5,144(a5)
    800032ce:	6702                	ld	a4,0(sp)
    800032d0:	00e7f563          	bgeu	a5,a4,800032da <vTaskPriorityDisinheritAfterTimeout+0x32>
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
    800032d4:	6782                	ld	a5,0(sp)
    800032d6:	f43e                	sd	a5,40(sp)
    800032d8:	a021                	j	800032e0 <vTaskPriorityDisinheritAfterTimeout+0x38>
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
    800032da:	7782                	ld	a5,32(sp)
    800032dc:	6bdc                	ld	a5,144(a5)
    800032de:	f43e                	sd	a5,40(sp)
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
    800032e0:	7782                	ld	a5,32(sp)
    800032e2:	6fbc                	ld	a5,88(a5)
    800032e4:	7722                	ld	a4,40(sp)
    800032e6:	0cf70f63          	beq	a4,a5,800033c4 <vTaskPriorityDisinheritAfterTimeout+0x11c>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    800032ea:	7782                	ld	a5,32(sp)
    800032ec:	6fdc                	ld	a5,152(a5)
    800032ee:	6762                	ld	a4,24(sp)
    800032f0:	0cf71a63          	bne	a4,a5,800033c4 <vTaskPriorityDisinheritAfterTimeout+0x11c>
                {
                    /* If a task has timed out because it already holds the
                     * mutex it was trying to obtain then it cannot of inherited
                     * its own priority. */
                    configASSERT( pxTCB != pxCurrentTCB );
    800032f4:	00008797          	auipc	a5,0x8
    800032f8:	8dc78793          	addi	a5,a5,-1828 # 8000abd0 <pxCurrentTCB>
    800032fc:	639c                	ld	a5,0(a5)
    800032fe:	7702                	ld	a4,32(sp)
    80003300:	00f71563          	bne	a4,a5,8000330a <vTaskPriorityDisinheritAfterTimeout+0x62>
    80003304:	30047073          	csrci	mstatus,8
    80003308:	a001                	j	80003308 <vTaskPriorityDisinheritAfterTimeout+0x60>

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
    8000330a:	7782                	ld	a5,32(sp)
    8000330c:	6fbc                	ld	a5,88(a5)
    8000330e:	e83e                	sd	a5,16(sp)
                    pxTCB->uxPriority = uxPriorityToUse;
    80003310:	7782                	ld	a5,32(sp)
    80003312:	7722                	ld	a4,40(sp)
    80003314:	efb8                	sd	a4,88(a5)

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    80003316:	7782                	ld	a5,32(sp)
    80003318:	7b98                	ld	a4,48(a5)
    8000331a:	4785                	li	a5,1
    8000331c:	07fe                	slli	a5,a5,0x1f
    8000331e:	8ff9                	and	a5,a5,a4
    80003320:	e791                	bnez	a5,8000332c <vTaskPriorityDisinheritAfterTimeout+0x84>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    80003322:	4715                	li	a4,5
    80003324:	77a2                	ld	a5,40(sp)
    80003326:	8f1d                	sub	a4,a4,a5
    80003328:	7782                	ld	a5,32(sp)
    8000332a:	fb98                	sd	a4,48(a5)
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    8000332c:	7782                	ld	a5,32(sp)
    8000332e:	7794                	ld	a3,40(a5)
    80003330:	6742                	ld	a4,16(sp)
    80003332:	87ba                	mv	a5,a4
    80003334:	078a                	slli	a5,a5,0x2
    80003336:	97ba                	add	a5,a5,a4
    80003338:	078e                	slli	a5,a5,0x3
    8000333a:	0000a717          	auipc	a4,0xa
    8000333e:	80670713          	addi	a4,a4,-2042 # 8000cb40 <pxReadyTasksLists>
    80003342:	97ba                	add	a5,a5,a4
    80003344:	08f69063          	bne	a3,a5,800033c4 <vTaskPriorityDisinheritAfterTimeout+0x11c>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    80003348:	7782                	ld	a5,32(sp)
    8000334a:	07a1                	addi	a5,a5,8
    8000334c:	853e                	mv	a0,a5
    8000334e:	c10fd0ef          	jal	ra,8000075e <uxListRemove>
    80003352:	87aa                	mv	a5,a0
    80003354:	e78d                	bnez	a5,8000337e <vTaskPriorityDisinheritAfterTimeout+0xd6>
                        {
                            /* It is known that the task is in its ready list so
                             * there is no need to check again and the port level
                             * reset macro can be called directly. */
                            portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
    80003356:	7782                	ld	a5,32(sp)
    80003358:	6fbc                	ld	a5,88(a5)
    8000335a:	2781                	sext.w	a5,a5
    8000335c:	873e                	mv	a4,a5
    8000335e:	4785                	li	a5,1
    80003360:	00e797b3          	sll	a5,a5,a4
    80003364:	fff7c713          	not	a4,a5
    80003368:	0000a797          	auipc	a5,0xa
    8000336c:	99078793          	addi	a5,a5,-1648 # 8000ccf8 <uxTopReadyPriority>
    80003370:	639c                	ld	a5,0(a5)
    80003372:	8f7d                	and	a4,a4,a5
    80003374:	0000a797          	auipc	a5,0xa
    80003378:	98478793          	addi	a5,a5,-1660 # 8000ccf8 <uxTopReadyPriority>
    8000337c:	e398                	sd	a4,0(a5)
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
    8000337e:	7782                	ld	a5,32(sp)
    80003380:	6fbc                	ld	a5,88(a5)
    80003382:	2781                	sext.w	a5,a5
    80003384:	873e                	mv	a4,a5
    80003386:	4785                	li	a5,1
    80003388:	00e79733          	sll	a4,a5,a4
    8000338c:	0000a797          	auipc	a5,0xa
    80003390:	96c78793          	addi	a5,a5,-1684 # 8000ccf8 <uxTopReadyPriority>
    80003394:	639c                	ld	a5,0(a5)
    80003396:	8f5d                	or	a4,a4,a5
    80003398:	0000a797          	auipc	a5,0xa
    8000339c:	96078793          	addi	a5,a5,-1696 # 8000ccf8 <uxTopReadyPriority>
    800033a0:	e398                	sd	a4,0(a5)
    800033a2:	7782                	ld	a5,32(sp)
    800033a4:	6fb8                	ld	a4,88(a5)
    800033a6:	87ba                	mv	a5,a4
    800033a8:	078a                	slli	a5,a5,0x2
    800033aa:	97ba                	add	a5,a5,a4
    800033ac:	078e                	slli	a5,a5,0x3
    800033ae:	00009717          	auipc	a4,0x9
    800033b2:	79270713          	addi	a4,a4,1938 # 8000cb40 <pxReadyTasksLists>
    800033b6:	973e                	add	a4,a4,a5
    800033b8:	7782                	ld	a5,32(sp)
    800033ba:	07a1                	addi	a5,a5,8
    800033bc:	85be                	mv	a1,a5
    800033be:	853a                	mv	a0,a4
    800033c0:	af4fd0ef          	jal	ra,800006b4 <vListInsertEnd>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    800033c4:	0001                	nop
    800033c6:	70e2                	ld	ra,56(sp)
    800033c8:	6121                	addi	sp,sp,64
    800033ca:	8082                	ret

00000000800033cc <vTaskEnterCritical>:

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskEnterCritical( void )
    {
        portDISABLE_INTERRUPTS();
    800033cc:	30047073          	csrci	mstatus,8

        if( xSchedulerRunning != pdFALSE )
    800033d0:	0000a797          	auipc	a5,0xa
    800033d4:	93078793          	addi	a5,a5,-1744 # 8000cd00 <xSchedulerRunning>
    800033d8:	639c                	ld	a5,0(a5)
    800033da:	cf91                	beqz	a5,800033f6 <vTaskEnterCritical+0x2a>
        {
            ( pxCurrentTCB->uxCriticalNesting )++;
    800033dc:	00007797          	auipc	a5,0x7
    800033e0:	7f478793          	addi	a5,a5,2036 # 8000abd0 <pxCurrentTCB>
    800033e4:	639c                	ld	a5,0(a5)
    800033e6:	7fb8                	ld	a4,120(a5)
    800033e8:	0705                	addi	a4,a4,1
    800033ea:	ffb8                	sd	a4,120(a5)
             * function so  assert() if it is being called from an interrupt
             * context.  Only API functions that end in "FromISR" can be used in an
             * interrupt.  Only assert if the critical nesting count is 1 to
             * protect against recursive calls if the assert function also uses a
             * critical section. */
            if( pxCurrentTCB->uxCriticalNesting == 1 )
    800033ec:	00007797          	auipc	a5,0x7
    800033f0:	7e478793          	addi	a5,a5,2020 # 8000abd0 <pxCurrentTCB>
    800033f4:	639c                	ld	a5,0(a5)
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    800033f6:	0001                	nop
    800033f8:	8082                	ret

00000000800033fa <vTaskExitCritical>:

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

    void vTaskExitCritical( void )
    {
        if( xSchedulerRunning != pdFALSE )
    800033fa:	0000a797          	auipc	a5,0xa
    800033fe:	90678793          	addi	a5,a5,-1786 # 8000cd00 <xSchedulerRunning>
    80003402:	639c                	ld	a5,0(a5)
    80003404:	cb8d                	beqz	a5,80003436 <vTaskExitCritical+0x3c>
        {
            if( pxCurrentTCB->uxCriticalNesting > 0U )
    80003406:	00007797          	auipc	a5,0x7
    8000340a:	7ca78793          	addi	a5,a5,1994 # 8000abd0 <pxCurrentTCB>
    8000340e:	639c                	ld	a5,0(a5)
    80003410:	7fbc                	ld	a5,120(a5)
    80003412:	c395                	beqz	a5,80003436 <vTaskExitCritical+0x3c>
            {
                ( pxCurrentTCB->uxCriticalNesting )--;
    80003414:	00007797          	auipc	a5,0x7
    80003418:	7bc78793          	addi	a5,a5,1980 # 8000abd0 <pxCurrentTCB>
    8000341c:	639c                	ld	a5,0(a5)
    8000341e:	7fb8                	ld	a4,120(a5)
    80003420:	177d                	addi	a4,a4,-1
    80003422:	ffb8                	sd	a4,120(a5)

                if( pxCurrentTCB->uxCriticalNesting == 0U )
    80003424:	00007797          	auipc	a5,0x7
    80003428:	7ac78793          	addi	a5,a5,1964 # 8000abd0 <pxCurrentTCB>
    8000342c:	639c                	ld	a5,0(a5)
    8000342e:	7fbc                	ld	a5,120(a5)
    80003430:	e399                	bnez	a5,80003436 <vTaskExitCritical+0x3c>
                {
                    portENABLE_INTERRUPTS();
    80003432:	30046073          	csrsi	mstatus,8
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    80003436:	0001                	nop
    80003438:	8082                	ret

000000008000343a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    8000343a:	1141                	addi	sp,sp,-16
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    8000343c:	00007797          	auipc	a5,0x7
    80003440:	79478793          	addi	a5,a5,1940 # 8000abd0 <pxCurrentTCB>
    80003444:	639c                	ld	a5,0(a5)
    80003446:	7b9c                	ld	a5,48(a5)
    80003448:	e43e                	sd	a5,8(sp)

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    8000344a:	00007797          	auipc	a5,0x7
    8000344e:	78678793          	addi	a5,a5,1926 # 8000abd0 <pxCurrentTCB>
    80003452:	639c                	ld	a5,0(a5)
    80003454:	6fb8                	ld	a4,88(a5)
    80003456:	00007797          	auipc	a5,0x7
    8000345a:	77a78793          	addi	a5,a5,1914 # 8000abd0 <pxCurrentTCB>
    8000345e:	639c                	ld	a5,0(a5)
    80003460:	4695                	li	a3,5
    80003462:	40e68733          	sub	a4,a3,a4
    80003466:	fb98                	sd	a4,48(a5)

    return uxReturn;
    80003468:	67a2                	ld	a5,8(sp)
}
    8000346a:	853e                	mv	a0,a5
    8000346c:	0141                	addi	sp,sp,16
    8000346e:	8082                	ret

0000000080003470 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    80003470:	00007797          	auipc	a5,0x7
    80003474:	76078793          	addi	a5,a5,1888 # 8000abd0 <pxCurrentTCB>
    80003478:	639c                	ld	a5,0(a5)
    8000347a:	cb89                	beqz	a5,8000348c <pvTaskIncrementMutexHeldCount+0x1c>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    8000347c:	00007797          	auipc	a5,0x7
    80003480:	75478793          	addi	a5,a5,1876 # 8000abd0 <pxCurrentTCB>
    80003484:	639c                	ld	a5,0(a5)
    80003486:	6fd8                	ld	a4,152(a5)
    80003488:	0705                	addi	a4,a4,1
    8000348a:	efd8                	sd	a4,152(a5)
        }

        return pxCurrentTCB;
    8000348c:	00007797          	auipc	a5,0x7
    80003490:	74478793          	addi	a5,a5,1860 # 8000abd0 <pxCurrentTCB>
    80003494:	639c                	ld	a5,0(a5)
    }
    80003496:	853e                	mv	a0,a5
    80003498:	8082                	ret

000000008000349a <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    8000349a:	7139                	addi	sp,sp,-64
    8000349c:	fc06                	sd	ra,56(sp)
    8000349e:	ec2a                	sd	a0,24(sp)
    800034a0:	e82e                	sd	a1,16(sp)
    800034a2:	e432                	sd	a2,8(sp)
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    800034a4:	67e2                	ld	a5,24(sp)
    800034a6:	c781                	beqz	a5,800034ae <ulTaskGenericNotifyTake+0x14>
    800034a8:	30047073          	csrci	mstatus,8
    800034ac:	a001                	j	800034ac <ulTaskGenericNotifyTake+0x12>

        taskENTER_CRITICAL();
    800034ae:	f1fff0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    800034b2:	00007797          	auipc	a5,0x7
    800034b6:	71e78793          	addi	a5,a5,1822 # 8000abd0 <pxCurrentTCB>
    800034ba:	6398                	ld	a4,0(a5)
    800034bc:	67e2                	ld	a5,24(sp)
    800034be:	02878793          	addi	a5,a5,40
    800034c2:	078a                	slli	a5,a5,0x2
    800034c4:	97ba                	add	a5,a5,a4
    800034c6:	439c                	lw	a5,0(a5)
    800034c8:	2781                	sext.w	a5,a5
    800034ca:	e39d                	bnez	a5,800034f0 <ulTaskGenericNotifyTake+0x56>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    800034cc:	00007797          	auipc	a5,0x7
    800034d0:	70478793          	addi	a5,a5,1796 # 8000abd0 <pxCurrentTCB>
    800034d4:	6398                	ld	a4,0(a5)
    800034d6:	67e2                	ld	a5,24(sp)
    800034d8:	97ba                	add	a5,a5,a4
    800034da:	4705                	li	a4,1
    800034dc:	0ae78223          	sb	a4,164(a5)

                if( xTicksToWait > ( TickType_t ) 0 )
    800034e0:	67a2                	ld	a5,8(sp)
    800034e2:	c799                	beqz	a5,800034f0 <ulTaskGenericNotifyTake+0x56>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    800034e4:	4585                	li	a1,1
    800034e6:	6522                	ld	a0,8(sp)
    800034e8:	768000ef          	jal	ra,80003c50 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    800034ec:	00000073          	ecall
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    800034f0:	f0bff0ef          	jal	ra,800033fa <vTaskExitCritical>

        taskENTER_CRITICAL();
    800034f4:	ed9ff0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    800034f8:	00007797          	auipc	a5,0x7
    800034fc:	6d878793          	addi	a5,a5,1752 # 8000abd0 <pxCurrentTCB>
    80003500:	6398                	ld	a4,0(a5)
    80003502:	67e2                	ld	a5,24(sp)
    80003504:	02878793          	addi	a5,a5,40
    80003508:	078a                	slli	a5,a5,0x2
    8000350a:	97ba                	add	a5,a5,a4
    8000350c:	439c                	lw	a5,0(a5)
    8000350e:	d63e                	sw	a5,44(sp)

            if( ulReturn != 0UL )
    80003510:	57b2                	lw	a5,44(sp)
    80003512:	2781                	sext.w	a5,a5
    80003514:	cf9d                	beqz	a5,80003552 <ulTaskGenericNotifyTake+0xb8>
            {
                if( xClearCountOnExit != pdFALSE )
    80003516:	67c2                	ld	a5,16(sp)
    80003518:	cf91                	beqz	a5,80003534 <ulTaskGenericNotifyTake+0x9a>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    8000351a:	00007797          	auipc	a5,0x7
    8000351e:	6b678793          	addi	a5,a5,1718 # 8000abd0 <pxCurrentTCB>
    80003522:	6398                	ld	a4,0(a5)
    80003524:	67e2                	ld	a5,24(sp)
    80003526:	02878793          	addi	a5,a5,40
    8000352a:	078a                	slli	a5,a5,0x2
    8000352c:	97ba                	add	a5,a5,a4
    8000352e:	0007a023          	sw	zero,0(a5)
    80003532:	a005                	j	80003552 <ulTaskGenericNotifyTake+0xb8>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    80003534:	00007797          	auipc	a5,0x7
    80003538:	69c78793          	addi	a5,a5,1692 # 8000abd0 <pxCurrentTCB>
    8000353c:	6394                	ld	a3,0(a5)
    8000353e:	57b2                	lw	a5,44(sp)
    80003540:	37fd                	addiw	a5,a5,-1
    80003542:	0007871b          	sext.w	a4,a5
    80003546:	67e2                	ld	a5,24(sp)
    80003548:	02878793          	addi	a5,a5,40
    8000354c:	078a                	slli	a5,a5,0x2
    8000354e:	97b6                	add	a5,a5,a3
    80003550:	c398                	sw	a4,0(a5)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    80003552:	00007797          	auipc	a5,0x7
    80003556:	67e78793          	addi	a5,a5,1662 # 8000abd0 <pxCurrentTCB>
    8000355a:	6398                	ld	a4,0(a5)
    8000355c:	67e2                	ld	a5,24(sp)
    8000355e:	97ba                	add	a5,a5,a4
    80003560:	0a078223          	sb	zero,164(a5)
        }
        taskEXIT_CRITICAL();
    80003564:	e97ff0ef          	jal	ra,800033fa <vTaskExitCritical>

        return ulReturn;
    80003568:	57b2                	lw	a5,44(sp)
    }
    8000356a:	853e                	mv	a0,a5
    8000356c:	70e2                	ld	ra,56(sp)
    8000356e:	6121                	addi	sp,sp,64
    80003570:	8082                	ret

0000000080003572 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    80003572:	7139                	addi	sp,sp,-64
    80003574:	fc06                	sd	ra,56(sp)
    80003576:	ec2a                	sd	a0,24(sp)
    80003578:	87ae                	mv	a5,a1
    8000357a:	e436                	sd	a3,8(sp)
    8000357c:	e03a                	sd	a4,0(sp)
    8000357e:	ca3e                	sw	a5,20(sp)
    80003580:	87b2                	mv	a5,a2
    80003582:	c83e                	sw	a5,16(sp)
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    80003584:	67e2                	ld	a5,24(sp)
    80003586:	c781                	beqz	a5,8000358e <xTaskGenericNotifyWait+0x1c>
    80003588:	30047073          	csrci	mstatus,8
    8000358c:	a001                	j	8000358c <xTaskGenericNotifyWait+0x1a>

        taskENTER_CRITICAL();
    8000358e:	e3fff0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    80003592:	00007797          	auipc	a5,0x7
    80003596:	63e78793          	addi	a5,a5,1598 # 8000abd0 <pxCurrentTCB>
    8000359a:	6398                	ld	a4,0(a5)
    8000359c:	67e2                	ld	a5,24(sp)
    8000359e:	97ba                	add	a5,a5,a4
    800035a0:	0a47c783          	lbu	a5,164(a5)
    800035a4:	0ff7f793          	andi	a5,a5,255
    800035a8:	873e                	mv	a4,a5
    800035aa:	4789                	li	a5,2
    800035ac:	04f70d63          	beq	a4,a5,80003606 <xTaskGenericNotifyWait+0x94>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    800035b0:	00007797          	auipc	a5,0x7
    800035b4:	62078793          	addi	a5,a5,1568 # 8000abd0 <pxCurrentTCB>
    800035b8:	639c                	ld	a5,0(a5)
    800035ba:	6762                	ld	a4,24(sp)
    800035bc:	02870713          	addi	a4,a4,40
    800035c0:	070a                	slli	a4,a4,0x2
    800035c2:	973e                	add	a4,a4,a5
    800035c4:	4318                	lw	a4,0(a4)
    800035c6:	0007069b          	sext.w	a3,a4
    800035ca:	4752                	lw	a4,20(sp)
    800035cc:	fff74713          	not	a4,a4
    800035d0:	2701                	sext.w	a4,a4
    800035d2:	8f75                	and	a4,a4,a3
    800035d4:	2701                	sext.w	a4,a4
    800035d6:	66e2                	ld	a3,24(sp)
    800035d8:	02868693          	addi	a3,a3,40
    800035dc:	068a                	slli	a3,a3,0x2
    800035de:	97b6                	add	a5,a5,a3
    800035e0:	c398                	sw	a4,0(a5)

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    800035e2:	00007797          	auipc	a5,0x7
    800035e6:	5ee78793          	addi	a5,a5,1518 # 8000abd0 <pxCurrentTCB>
    800035ea:	6398                	ld	a4,0(a5)
    800035ec:	67e2                	ld	a5,24(sp)
    800035ee:	97ba                	add	a5,a5,a4
    800035f0:	4705                	li	a4,1
    800035f2:	0ae78223          	sb	a4,164(a5)

                if( xTicksToWait > ( TickType_t ) 0 )
    800035f6:	6782                	ld	a5,0(sp)
    800035f8:	c799                	beqz	a5,80003606 <xTaskGenericNotifyWait+0x94>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    800035fa:	4585                	li	a1,1
    800035fc:	6502                	ld	a0,0(sp)
    800035fe:	652000ef          	jal	ra,80003c50 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    80003602:	00000073          	ecall
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    80003606:	df5ff0ef          	jal	ra,800033fa <vTaskExitCritical>

        taskENTER_CRITICAL();
    8000360a:	dc3ff0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    8000360e:	67a2                	ld	a5,8(sp)
    80003610:	c385                	beqz	a5,80003630 <xTaskGenericNotifyWait+0xbe>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    80003612:	00007797          	auipc	a5,0x7
    80003616:	5be78793          	addi	a5,a5,1470 # 8000abd0 <pxCurrentTCB>
    8000361a:	6398                	ld	a4,0(a5)
    8000361c:	67e2                	ld	a5,24(sp)
    8000361e:	02878793          	addi	a5,a5,40
    80003622:	078a                	slli	a5,a5,0x2
    80003624:	97ba                	add	a5,a5,a4
    80003626:	439c                	lw	a5,0(a5)
    80003628:	0007871b          	sext.w	a4,a5
    8000362c:	67a2                	ld	a5,8(sp)
    8000362e:	c398                	sw	a4,0(a5)

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    80003630:	00007797          	auipc	a5,0x7
    80003634:	5a078793          	addi	a5,a5,1440 # 8000abd0 <pxCurrentTCB>
    80003638:	6398                	ld	a4,0(a5)
    8000363a:	67e2                	ld	a5,24(sp)
    8000363c:	97ba                	add	a5,a5,a4
    8000363e:	0a47c783          	lbu	a5,164(a5)
    80003642:	0ff7f793          	andi	a5,a5,255
    80003646:	873e                	mv	a4,a5
    80003648:	4789                	li	a5,2
    8000364a:	00f70463          	beq	a4,a5,80003652 <xTaskGenericNotifyWait+0xe0>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    8000364e:	f402                	sd	zero,40(sp)
    80003650:	a825                	j	80003688 <xTaskGenericNotifyWait+0x116>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    80003652:	00007797          	auipc	a5,0x7
    80003656:	57e78793          	addi	a5,a5,1406 # 8000abd0 <pxCurrentTCB>
    8000365a:	639c                	ld	a5,0(a5)
    8000365c:	6762                	ld	a4,24(sp)
    8000365e:	02870713          	addi	a4,a4,40
    80003662:	070a                	slli	a4,a4,0x2
    80003664:	973e                	add	a4,a4,a5
    80003666:	4318                	lw	a4,0(a4)
    80003668:	0007069b          	sext.w	a3,a4
    8000366c:	4742                	lw	a4,16(sp)
    8000366e:	fff74713          	not	a4,a4
    80003672:	2701                	sext.w	a4,a4
    80003674:	8f75                	and	a4,a4,a3
    80003676:	2701                	sext.w	a4,a4
    80003678:	66e2                	ld	a3,24(sp)
    8000367a:	02868693          	addi	a3,a3,40
    8000367e:	068a                	slli	a3,a3,0x2
    80003680:	97b6                	add	a5,a5,a3
    80003682:	c398                	sw	a4,0(a5)
                xReturn = pdTRUE;
    80003684:	4785                	li	a5,1
    80003686:	f43e                	sd	a5,40(sp)
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    80003688:	00007797          	auipc	a5,0x7
    8000368c:	54878793          	addi	a5,a5,1352 # 8000abd0 <pxCurrentTCB>
    80003690:	6398                	ld	a4,0(a5)
    80003692:	67e2                	ld	a5,24(sp)
    80003694:	97ba                	add	a5,a5,a4
    80003696:	0a078223          	sb	zero,164(a5)
        }
        taskEXIT_CRITICAL();
    8000369a:	d61ff0ef          	jal	ra,800033fa <vTaskExitCritical>

        return xReturn;
    8000369e:	77a2                	ld	a5,40(sp)
    }
    800036a0:	853e                	mv	a0,a5
    800036a2:	70e2                	ld	ra,56(sp)
    800036a4:	6121                	addi	sp,sp,64
    800036a6:	8082                	ret

00000000800036a8 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    800036a8:	715d                	addi	sp,sp,-80
    800036aa:	e486                	sd	ra,72(sp)
    800036ac:	ec2a                	sd	a0,24(sp)
    800036ae:	e82e                	sd	a1,16(sp)
    800036b0:	87b2                	mv	a5,a2
    800036b2:	e03a                	sd	a4,0(sp)
    800036b4:	c63e                	sw	a5,12(sp)
    800036b6:	87b6                	mv	a5,a3
    800036b8:	c43e                	sw	a5,8(sp)
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    800036ba:	4785                	li	a5,1
    800036bc:	fc3e                	sd	a5,56(sp)
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    800036be:	67c2                	ld	a5,16(sp)
    800036c0:	c781                	beqz	a5,800036c8 <xTaskGenericNotify+0x20>
    800036c2:	30047073          	csrci	mstatus,8
    800036c6:	a001                	j	800036c6 <xTaskGenericNotify+0x1e>
        configASSERT( xTaskToNotify );
    800036c8:	67e2                	ld	a5,24(sp)
    800036ca:	e781                	bnez	a5,800036d2 <xTaskGenericNotify+0x2a>
    800036cc:	30047073          	csrci	mstatus,8
    800036d0:	a001                	j	800036d0 <xTaskGenericNotify+0x28>
        pxTCB = xTaskToNotify;
    800036d2:	67e2                	ld	a5,24(sp)
    800036d4:	f83e                	sd	a5,48(sp)

        taskENTER_CRITICAL();
    800036d6:	cf7ff0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            if( pulPreviousNotificationValue != NULL )
    800036da:	6782                	ld	a5,0(sp)
    800036dc:	cf81                	beqz	a5,800036f4 <xTaskGenericNotify+0x4c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    800036de:	7742                	ld	a4,48(sp)
    800036e0:	67c2                	ld	a5,16(sp)
    800036e2:	02878793          	addi	a5,a5,40
    800036e6:	078a                	slli	a5,a5,0x2
    800036e8:	97ba                	add	a5,a5,a4
    800036ea:	439c                	lw	a5,0(a5)
    800036ec:	0007871b          	sext.w	a4,a5
    800036f0:	6782                	ld	a5,0(sp)
    800036f2:	c398                	sw	a4,0(a5)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    800036f4:	7742                	ld	a4,48(sp)
    800036f6:	67c2                	ld	a5,16(sp)
    800036f8:	97ba                	add	a5,a5,a4
    800036fa:	0a47c783          	lbu	a5,164(a5)
    800036fe:	02f107a3          	sb	a5,47(sp)

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    80003702:	7742                	ld	a4,48(sp)
    80003704:	67c2                	ld	a5,16(sp)
    80003706:	97ba                	add	a5,a5,a4
    80003708:	4709                	li	a4,2
    8000370a:	0ae78223          	sb	a4,164(a5)
    8000370e:	47a2                	lw	a5,8(sp)
    80003710:	0007871b          	sext.w	a4,a5
    80003714:	4791                	li	a5,4
    80003716:	0ae7e763          	bltu	a5,a4,800037c4 <xTaskGenericNotify+0x11c>
    8000371a:	00816783          	lwu	a5,8(sp)
    8000371e:	00279713          	slli	a4,a5,0x2
    80003722:	00006797          	auipc	a5,0x6
    80003726:	c3e78793          	addi	a5,a5,-962 # 80009360 <__rodata_start+0x8>
    8000372a:	97ba                	add	a5,a5,a4
    8000372c:	439c                	lw	a5,0(a5)
    8000372e:	0007871b          	sext.w	a4,a5
    80003732:	00006797          	auipc	a5,0x6
    80003736:	c2e78793          	addi	a5,a5,-978 # 80009360 <__rodata_start+0x8>
    8000373a:	97ba                	add	a5,a5,a4
    8000373c:	8782                	jr	a5

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    8000373e:	7742                	ld	a4,48(sp)
    80003740:	67c2                	ld	a5,16(sp)
    80003742:	02878793          	addi	a5,a5,40
    80003746:	078a                	slli	a5,a5,0x2
    80003748:	97ba                	add	a5,a5,a4
    8000374a:	439c                	lw	a5,0(a5)
    8000374c:	0007871b          	sext.w	a4,a5
    80003750:	47b2                	lw	a5,12(sp)
    80003752:	8fd9                	or	a5,a5,a4
    80003754:	0007871b          	sext.w	a4,a5
    80003758:	76c2                	ld	a3,48(sp)
    8000375a:	67c2                	ld	a5,16(sp)
    8000375c:	02878793          	addi	a5,a5,40
    80003760:	078a                	slli	a5,a5,0x2
    80003762:	97b6                	add	a5,a5,a3
    80003764:	c398                	sw	a4,0(a5)
                    break;
    80003766:	a89d                	j	800037dc <xTaskGenericNotify+0x134>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    80003768:	7742                	ld	a4,48(sp)
    8000376a:	67c2                	ld	a5,16(sp)
    8000376c:	02878793          	addi	a5,a5,40
    80003770:	078a                	slli	a5,a5,0x2
    80003772:	97ba                	add	a5,a5,a4
    80003774:	439c                	lw	a5,0(a5)
    80003776:	2781                	sext.w	a5,a5
    80003778:	2785                	addiw	a5,a5,1
    8000377a:	0007871b          	sext.w	a4,a5
    8000377e:	76c2                	ld	a3,48(sp)
    80003780:	67c2                	ld	a5,16(sp)
    80003782:	02878793          	addi	a5,a5,40
    80003786:	078a                	slli	a5,a5,0x2
    80003788:	97b6                	add	a5,a5,a3
    8000378a:	c398                	sw	a4,0(a5)
                    break;
    8000378c:	a881                	j	800037dc <xTaskGenericNotify+0x134>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    8000378e:	7742                	ld	a4,48(sp)
    80003790:	67c2                	ld	a5,16(sp)
    80003792:	02878793          	addi	a5,a5,40
    80003796:	078a                	slli	a5,a5,0x2
    80003798:	97ba                	add	a5,a5,a4
    8000379a:	4732                	lw	a4,12(sp)
    8000379c:	c398                	sw	a4,0(a5)
                    break;
    8000379e:	a83d                	j	800037dc <xTaskGenericNotify+0x134>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    800037a0:	02f14783          	lbu	a5,47(sp)
    800037a4:	0ff7f713          	andi	a4,a5,255
    800037a8:	4789                	li	a5,2
    800037aa:	00f70b63          	beq	a4,a5,800037c0 <xTaskGenericNotify+0x118>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    800037ae:	7742                	ld	a4,48(sp)
    800037b0:	67c2                	ld	a5,16(sp)
    800037b2:	02878793          	addi	a5,a5,40
    800037b6:	078a                	slli	a5,a5,0x2
    800037b8:	97ba                	add	a5,a5,a4
    800037ba:	4732                	lw	a4,12(sp)
    800037bc:	c398                	sw	a4,0(a5)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
    800037be:	a839                	j	800037dc <xTaskGenericNotify+0x134>
                        xReturn = pdFAIL;
    800037c0:	fc02                	sd	zero,56(sp)
                    break;
    800037c2:	a829                	j	800037dc <xTaskGenericNotify+0x134>
                default:

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
    800037c4:	00009797          	auipc	a5,0x9
    800037c8:	52c78793          	addi	a5,a5,1324 # 8000ccf0 <xTickCount>
    800037cc:	639c                	ld	a5,0(a5)
    800037ce:	c791                	beqz	a5,800037da <xTaskGenericNotify+0x132>
    800037d0:	30047073          	csrci	mstatus,8
    800037d4:	a001                	j	800037d4 <xTaskGenericNotify+0x12c>
                    break;
    800037d6:	0001                	nop
    800037d8:	a011                	j	800037dc <xTaskGenericNotify+0x134>

                    break;
    800037da:	0001                	nop

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    800037dc:	02f14783          	lbu	a5,47(sp)
    800037e0:	0ff7f713          	andi	a4,a5,255
    800037e4:	4785                	li	a5,1
    800037e6:	06f71c63          	bne	a4,a5,8000385e <xTaskGenericNotify+0x1b6>
            {
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    800037ea:	77c2                	ld	a5,48(sp)
    800037ec:	07a1                	addi	a5,a5,8
    800037ee:	853e                	mv	a0,a5
    800037f0:	f6ffc0ef          	jal	ra,8000075e <uxListRemove>
                prvAddTaskToReadyList( pxTCB );
    800037f4:	77c2                	ld	a5,48(sp)
    800037f6:	6fbc                	ld	a5,88(a5)
    800037f8:	2781                	sext.w	a5,a5
    800037fa:	873e                	mv	a4,a5
    800037fc:	4785                	li	a5,1
    800037fe:	00e79733          	sll	a4,a5,a4
    80003802:	00009797          	auipc	a5,0x9
    80003806:	4f678793          	addi	a5,a5,1270 # 8000ccf8 <uxTopReadyPriority>
    8000380a:	639c                	ld	a5,0(a5)
    8000380c:	8f5d                	or	a4,a4,a5
    8000380e:	00009797          	auipc	a5,0x9
    80003812:	4ea78793          	addi	a5,a5,1258 # 8000ccf8 <uxTopReadyPriority>
    80003816:	e398                	sd	a4,0(a5)
    80003818:	77c2                	ld	a5,48(sp)
    8000381a:	6fb8                	ld	a4,88(a5)
    8000381c:	87ba                	mv	a5,a4
    8000381e:	078a                	slli	a5,a5,0x2
    80003820:	97ba                	add	a5,a5,a4
    80003822:	078e                	slli	a5,a5,0x3
    80003824:	00009717          	auipc	a4,0x9
    80003828:	31c70713          	addi	a4,a4,796 # 8000cb40 <pxReadyTasksLists>
    8000382c:	973e                	add	a4,a4,a5
    8000382e:	77c2                	ld	a5,48(sp)
    80003830:	07a1                	addi	a5,a5,8
    80003832:	85be                	mv	a1,a5
    80003834:	853a                	mv	a0,a4
    80003836:	e7ffc0ef          	jal	ra,800006b4 <vListInsertEnd>

                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    8000383a:	77c2                	ld	a5,48(sp)
    8000383c:	6bbc                	ld	a5,80(a5)
    8000383e:	c781                	beqz	a5,80003846 <xTaskGenericNotify+0x19e>
    80003840:	30047073          	csrci	mstatus,8
    80003844:	a001                	j	80003844 <xTaskGenericNotify+0x19c>
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    80003846:	77c2                	ld	a5,48(sp)
    80003848:	6fb8                	ld	a4,88(a5)
    8000384a:	00007797          	auipc	a5,0x7
    8000384e:	38678793          	addi	a5,a5,902 # 8000abd0 <pxCurrentTCB>
    80003852:	639c                	ld	a5,0(a5)
    80003854:	6fbc                	ld	a5,88(a5)
    80003856:	00e7f463          	bgeu	a5,a4,8000385e <xTaskGenericNotify+0x1b6>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    8000385a:	00000073          	ecall
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    8000385e:	b9dff0ef          	jal	ra,800033fa <vTaskExitCritical>

        return xReturn;
    80003862:	77e2                	ld	a5,56(sp)
    }
    80003864:	853e                	mv	a0,a5
    80003866:	60a6                	ld	ra,72(sp)
    80003868:	6161                	addi	sp,sp,80
    8000386a:	8082                	ret

000000008000386c <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    8000386c:	711d                	addi	sp,sp,-96
    8000386e:	ec86                	sd	ra,88(sp)
    80003870:	f42a                	sd	a0,40(sp)
    80003872:	f02e                	sd	a1,32(sp)
    80003874:	e83a                	sd	a4,16(sp)
    80003876:	e43e                	sd	a5,8(sp)
    80003878:	87b2                	mv	a5,a2
    8000387a:	ce3e                	sw	a5,28(sp)
    8000387c:	87b6                	mv	a5,a3
    8000387e:	cc3e                	sw	a5,24(sp)
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    80003880:	4785                	li	a5,1
    80003882:	e4be                	sd	a5,72(sp)
        UBaseType_t uxSavedInterruptStatus;

        configASSERT( xTaskToNotify );
    80003884:	77a2                	ld	a5,40(sp)
    80003886:	e781                	bnez	a5,8000388e <xTaskGenericNotifyFromISR+0x22>
    80003888:	30047073          	csrci	mstatus,8
    8000388c:	a001                	j	8000388c <xTaskGenericNotifyFromISR+0x20>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    8000388e:	7782                	ld	a5,32(sp)
    80003890:	c781                	beqz	a5,80003898 <xTaskGenericNotifyFromISR+0x2c>
    80003892:	30047073          	csrci	mstatus,8
    80003896:	a001                	j	80003896 <xTaskGenericNotifyFromISR+0x2a>
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    80003898:	77a2                	ld	a5,40(sp)
    8000389a:	e0be                	sd	a5,64(sp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    8000389c:	fc02                	sd	zero,56(sp)
        {
            if( pulPreviousNotificationValue != NULL )
    8000389e:	67c2                	ld	a5,16(sp)
    800038a0:	cf81                	beqz	a5,800038b8 <xTaskGenericNotifyFromISR+0x4c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    800038a2:	6706                	ld	a4,64(sp)
    800038a4:	7782                	ld	a5,32(sp)
    800038a6:	02878793          	addi	a5,a5,40
    800038aa:	078a                	slli	a5,a5,0x2
    800038ac:	97ba                	add	a5,a5,a4
    800038ae:	439c                	lw	a5,0(a5)
    800038b0:	0007871b          	sext.w	a4,a5
    800038b4:	67c2                	ld	a5,16(sp)
    800038b6:	c398                	sw	a4,0(a5)
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    800038b8:	6706                	ld	a4,64(sp)
    800038ba:	7782                	ld	a5,32(sp)
    800038bc:	97ba                	add	a5,a5,a4
    800038be:	0a47c783          	lbu	a5,164(a5)
    800038c2:	02f10ba3          	sb	a5,55(sp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    800038c6:	6706                	ld	a4,64(sp)
    800038c8:	7782                	ld	a5,32(sp)
    800038ca:	97ba                	add	a5,a5,a4
    800038cc:	4709                	li	a4,2
    800038ce:	0ae78223          	sb	a4,164(a5)
    800038d2:	47e2                	lw	a5,24(sp)
    800038d4:	0007871b          	sext.w	a4,a5
    800038d8:	4791                	li	a5,4
    800038da:	0ae7e763          	bltu	a5,a4,80003988 <xTaskGenericNotifyFromISR+0x11c>
    800038de:	01816783          	lwu	a5,24(sp)
    800038e2:	00279713          	slli	a4,a5,0x2
    800038e6:	00006797          	auipc	a5,0x6
    800038ea:	a8e78793          	addi	a5,a5,-1394 # 80009374 <__rodata_start+0x1c>
    800038ee:	97ba                	add	a5,a5,a4
    800038f0:	439c                	lw	a5,0(a5)
    800038f2:	0007871b          	sext.w	a4,a5
    800038f6:	00006797          	auipc	a5,0x6
    800038fa:	a7e78793          	addi	a5,a5,-1410 # 80009374 <__rodata_start+0x1c>
    800038fe:	97ba                	add	a5,a5,a4
    80003900:	8782                	jr	a5

            switch( eAction )
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    80003902:	6706                	ld	a4,64(sp)
    80003904:	7782                	ld	a5,32(sp)
    80003906:	02878793          	addi	a5,a5,40
    8000390a:	078a                	slli	a5,a5,0x2
    8000390c:	97ba                	add	a5,a5,a4
    8000390e:	439c                	lw	a5,0(a5)
    80003910:	0007871b          	sext.w	a4,a5
    80003914:	47f2                	lw	a5,28(sp)
    80003916:	8fd9                	or	a5,a5,a4
    80003918:	0007871b          	sext.w	a4,a5
    8000391c:	6686                	ld	a3,64(sp)
    8000391e:	7782                	ld	a5,32(sp)
    80003920:	02878793          	addi	a5,a5,40
    80003924:	078a                	slli	a5,a5,0x2
    80003926:	97b6                	add	a5,a5,a3
    80003928:	c398                	sw	a4,0(a5)
                    break;
    8000392a:	a89d                	j	800039a0 <xTaskGenericNotifyFromISR+0x134>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    8000392c:	6706                	ld	a4,64(sp)
    8000392e:	7782                	ld	a5,32(sp)
    80003930:	02878793          	addi	a5,a5,40
    80003934:	078a                	slli	a5,a5,0x2
    80003936:	97ba                	add	a5,a5,a4
    80003938:	439c                	lw	a5,0(a5)
    8000393a:	2781                	sext.w	a5,a5
    8000393c:	2785                	addiw	a5,a5,1
    8000393e:	0007871b          	sext.w	a4,a5
    80003942:	6686                	ld	a3,64(sp)
    80003944:	7782                	ld	a5,32(sp)
    80003946:	02878793          	addi	a5,a5,40
    8000394a:	078a                	slli	a5,a5,0x2
    8000394c:	97b6                	add	a5,a5,a3
    8000394e:	c398                	sw	a4,0(a5)
                    break;
    80003950:	a881                	j	800039a0 <xTaskGenericNotifyFromISR+0x134>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    80003952:	6706                	ld	a4,64(sp)
    80003954:	7782                	ld	a5,32(sp)
    80003956:	02878793          	addi	a5,a5,40
    8000395a:	078a                	slli	a5,a5,0x2
    8000395c:	97ba                	add	a5,a5,a4
    8000395e:	4772                	lw	a4,28(sp)
    80003960:	c398                	sw	a4,0(a5)
                    break;
    80003962:	a83d                	j	800039a0 <xTaskGenericNotifyFromISR+0x134>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    80003964:	03714783          	lbu	a5,55(sp)
    80003968:	0ff7f713          	andi	a4,a5,255
    8000396c:	4789                	li	a5,2
    8000396e:	00f70b63          	beq	a4,a5,80003984 <xTaskGenericNotifyFromISR+0x118>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    80003972:	6706                	ld	a4,64(sp)
    80003974:	7782                	ld	a5,32(sp)
    80003976:	02878793          	addi	a5,a5,40
    8000397a:	078a                	slli	a5,a5,0x2
    8000397c:	97ba                	add	a5,a5,a4
    8000397e:	4772                	lw	a4,28(sp)
    80003980:	c398                	sw	a4,0(a5)
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
    80003982:	a839                	j	800039a0 <xTaskGenericNotifyFromISR+0x134>
                        xReturn = pdFAIL;
    80003984:	e482                	sd	zero,72(sp)
                    break;
    80003986:	a829                	j	800039a0 <xTaskGenericNotifyFromISR+0x134>
                default:

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
    80003988:	00009797          	auipc	a5,0x9
    8000398c:	36878793          	addi	a5,a5,872 # 8000ccf0 <xTickCount>
    80003990:	639c                	ld	a5,0(a5)
    80003992:	c791                	beqz	a5,8000399e <xTaskGenericNotifyFromISR+0x132>
    80003994:	30047073          	csrci	mstatus,8
    80003998:	a001                	j	80003998 <xTaskGenericNotifyFromISR+0x12c>
                    break;
    8000399a:	0001                	nop
    8000399c:	a011                	j	800039a0 <xTaskGenericNotifyFromISR+0x134>
                    break;
    8000399e:	0001                	nop

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    800039a0:	03714783          	lbu	a5,55(sp)
    800039a4:	0ff7f713          	andi	a4,a5,255
    800039a8:	4785                	li	a5,1
    800039aa:	0af71663          	bne	a4,a5,80003a56 <xTaskGenericNotifyFromISR+0x1ea>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    800039ae:	6786                	ld	a5,64(sp)
    800039b0:	6bbc                	ld	a5,80(a5)
    800039b2:	c781                	beqz	a5,800039ba <xTaskGenericNotifyFromISR+0x14e>
    800039b4:	30047073          	csrci	mstatus,8
    800039b8:	a001                	j	800039b8 <xTaskGenericNotifyFromISR+0x14c>

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    800039ba:	00009797          	auipc	a5,0x9
    800039be:	37e78793          	addi	a5,a5,894 # 8000cd38 <uxSchedulerSuspended>
    800039c2:	639c                	ld	a5,0(a5)
    800039c4:	ebb1                	bnez	a5,80003a18 <xTaskGenericNotifyFromISR+0x1ac>
                {
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    800039c6:	6786                	ld	a5,64(sp)
    800039c8:	07a1                	addi	a5,a5,8
    800039ca:	853e                	mv	a0,a5
    800039cc:	d93fc0ef          	jal	ra,8000075e <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    800039d0:	6786                	ld	a5,64(sp)
    800039d2:	6fbc                	ld	a5,88(a5)
    800039d4:	2781                	sext.w	a5,a5
    800039d6:	873e                	mv	a4,a5
    800039d8:	4785                	li	a5,1
    800039da:	00e79733          	sll	a4,a5,a4
    800039de:	00009797          	auipc	a5,0x9
    800039e2:	31a78793          	addi	a5,a5,794 # 8000ccf8 <uxTopReadyPriority>
    800039e6:	639c                	ld	a5,0(a5)
    800039e8:	8f5d                	or	a4,a4,a5
    800039ea:	00009797          	auipc	a5,0x9
    800039ee:	30e78793          	addi	a5,a5,782 # 8000ccf8 <uxTopReadyPriority>
    800039f2:	e398                	sd	a4,0(a5)
    800039f4:	6786                	ld	a5,64(sp)
    800039f6:	6fb8                	ld	a4,88(a5)
    800039f8:	87ba                	mv	a5,a4
    800039fa:	078a                	slli	a5,a5,0x2
    800039fc:	97ba                	add	a5,a5,a4
    800039fe:	078e                	slli	a5,a5,0x3
    80003a00:	00009717          	auipc	a4,0x9
    80003a04:	14070713          	addi	a4,a4,320 # 8000cb40 <pxReadyTasksLists>
    80003a08:	973e                	add	a4,a4,a5
    80003a0a:	6786                	ld	a5,64(sp)
    80003a0c:	07a1                	addi	a5,a5,8
    80003a0e:	85be                	mv	a1,a5
    80003a10:	853a                	mv	a0,a4
    80003a12:	ca3fc0ef          	jal	ra,800006b4 <vListInsertEnd>
    80003a16:	a819                	j	80003a2c <xTaskGenericNotifyFromISR+0x1c0>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    80003a18:	6786                	ld	a5,64(sp)
    80003a1a:	03078793          	addi	a5,a5,48
    80003a1e:	85be                	mv	a1,a5
    80003a20:	00009517          	auipc	a0,0x9
    80003a24:	24850513          	addi	a0,a0,584 # 8000cc68 <xPendingReadyList>
    80003a28:	c8dfc0ef          	jal	ra,800006b4 <vListInsertEnd>
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    80003a2c:	6786                	ld	a5,64(sp)
    80003a2e:	6fb8                	ld	a4,88(a5)
    80003a30:	00007797          	auipc	a5,0x7
    80003a34:	1a078793          	addi	a5,a5,416 # 8000abd0 <pxCurrentTCB>
    80003a38:	639c                	ld	a5,0(a5)
    80003a3a:	6fbc                	ld	a5,88(a5)
    80003a3c:	00e7fd63          	bgeu	a5,a4,80003a56 <xTaskGenericNotifyFromISR+0x1ea>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    80003a40:	67a2                	ld	a5,8(sp)
    80003a42:	c781                	beqz	a5,80003a4a <xTaskGenericNotifyFromISR+0x1de>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    80003a44:	67a2                	ld	a5,8(sp)
    80003a46:	4705                	li	a4,1
    80003a48:	e398                	sd	a4,0(a5)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    80003a4a:	00009797          	auipc	a5,0x9
    80003a4e:	2c678793          	addi	a5,a5,710 # 8000cd10 <xYieldPending>
    80003a52:	4705                	li	a4,1
    80003a54:	e398                	sd	a4,0(a5)
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    80003a56:	67a6                	ld	a5,72(sp)
    }
    80003a58:	853e                	mv	a0,a5
    80003a5a:	60e6                	ld	ra,88(sp)
    80003a5c:	6125                	addi	sp,sp,96
    80003a5e:	8082                	ret

0000000080003a60 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    80003a60:	715d                	addi	sp,sp,-80
    80003a62:	e486                	sd	ra,72(sp)
    80003a64:	ec2a                	sd	a0,24(sp)
    80003a66:	e82e                	sd	a1,16(sp)
    80003a68:	e432                	sd	a2,8(sp)
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        UBaseType_t uxSavedInterruptStatus;

        configASSERT( xTaskToNotify );
    80003a6a:	67e2                	ld	a5,24(sp)
    80003a6c:	e781                	bnez	a5,80003a74 <vTaskGenericNotifyGiveFromISR+0x14>
    80003a6e:	30047073          	csrci	mstatus,8
    80003a72:	a001                	j	80003a72 <vTaskGenericNotifyGiveFromISR+0x12>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    80003a74:	67c2                	ld	a5,16(sp)
    80003a76:	c781                	beqz	a5,80003a7e <vTaskGenericNotifyGiveFromISR+0x1e>
    80003a78:	30047073          	csrci	mstatus,8
    80003a7c:	a001                	j	80003a7c <vTaskGenericNotifyGiveFromISR+0x1c>
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    80003a7e:	67e2                	ld	a5,24(sp)
    80003a80:	fc3e                	sd	a5,56(sp)

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    80003a82:	f802                	sd	zero,48(sp)
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    80003a84:	7762                	ld	a4,56(sp)
    80003a86:	67c2                	ld	a5,16(sp)
    80003a88:	97ba                	add	a5,a5,a4
    80003a8a:	0a47c783          	lbu	a5,164(a5)
    80003a8e:	02f107a3          	sb	a5,47(sp)
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    80003a92:	7762                	ld	a4,56(sp)
    80003a94:	67c2                	ld	a5,16(sp)
    80003a96:	97ba                	add	a5,a5,a4
    80003a98:	4709                	li	a4,2
    80003a9a:	0ae78223          	sb	a4,164(a5)

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    80003a9e:	7762                	ld	a4,56(sp)
    80003aa0:	67c2                	ld	a5,16(sp)
    80003aa2:	02878793          	addi	a5,a5,40
    80003aa6:	078a                	slli	a5,a5,0x2
    80003aa8:	97ba                	add	a5,a5,a4
    80003aaa:	439c                	lw	a5,0(a5)
    80003aac:	2781                	sext.w	a5,a5
    80003aae:	2785                	addiw	a5,a5,1
    80003ab0:	0007871b          	sext.w	a4,a5
    80003ab4:	76e2                	ld	a3,56(sp)
    80003ab6:	67c2                	ld	a5,16(sp)
    80003ab8:	02878793          	addi	a5,a5,40
    80003abc:	078a                	slli	a5,a5,0x2
    80003abe:	97b6                	add	a5,a5,a3
    80003ac0:	c398                	sw	a4,0(a5)

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    80003ac2:	02f14783          	lbu	a5,47(sp)
    80003ac6:	0ff7f713          	andi	a4,a5,255
    80003aca:	4785                	li	a5,1
    80003acc:	0af71663          	bne	a4,a5,80003b78 <vTaskGenericNotifyGiveFromISR+0x118>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    80003ad0:	77e2                	ld	a5,56(sp)
    80003ad2:	6bbc                	ld	a5,80(a5)
    80003ad4:	c781                	beqz	a5,80003adc <vTaskGenericNotifyGiveFromISR+0x7c>
    80003ad6:	30047073          	csrci	mstatus,8
    80003ada:	a001                	j	80003ada <vTaskGenericNotifyGiveFromISR+0x7a>

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    80003adc:	00009797          	auipc	a5,0x9
    80003ae0:	25c78793          	addi	a5,a5,604 # 8000cd38 <uxSchedulerSuspended>
    80003ae4:	639c                	ld	a5,0(a5)
    80003ae6:	ebb1                	bnez	a5,80003b3a <vTaskGenericNotifyGiveFromISR+0xda>
                {
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    80003ae8:	77e2                	ld	a5,56(sp)
    80003aea:	07a1                	addi	a5,a5,8
    80003aec:	853e                	mv	a0,a5
    80003aee:	c71fc0ef          	jal	ra,8000075e <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    80003af2:	77e2                	ld	a5,56(sp)
    80003af4:	6fbc                	ld	a5,88(a5)
    80003af6:	2781                	sext.w	a5,a5
    80003af8:	873e                	mv	a4,a5
    80003afa:	4785                	li	a5,1
    80003afc:	00e79733          	sll	a4,a5,a4
    80003b00:	00009797          	auipc	a5,0x9
    80003b04:	1f878793          	addi	a5,a5,504 # 8000ccf8 <uxTopReadyPriority>
    80003b08:	639c                	ld	a5,0(a5)
    80003b0a:	8f5d                	or	a4,a4,a5
    80003b0c:	00009797          	auipc	a5,0x9
    80003b10:	1ec78793          	addi	a5,a5,492 # 8000ccf8 <uxTopReadyPriority>
    80003b14:	e398                	sd	a4,0(a5)
    80003b16:	77e2                	ld	a5,56(sp)
    80003b18:	6fb8                	ld	a4,88(a5)
    80003b1a:	87ba                	mv	a5,a4
    80003b1c:	078a                	slli	a5,a5,0x2
    80003b1e:	97ba                	add	a5,a5,a4
    80003b20:	078e                	slli	a5,a5,0x3
    80003b22:	00009717          	auipc	a4,0x9
    80003b26:	01e70713          	addi	a4,a4,30 # 8000cb40 <pxReadyTasksLists>
    80003b2a:	973e                	add	a4,a4,a5
    80003b2c:	77e2                	ld	a5,56(sp)
    80003b2e:	07a1                	addi	a5,a5,8
    80003b30:	85be                	mv	a1,a5
    80003b32:	853a                	mv	a0,a4
    80003b34:	b81fc0ef          	jal	ra,800006b4 <vListInsertEnd>
    80003b38:	a819                	j	80003b4e <vTaskGenericNotifyGiveFromISR+0xee>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    80003b3a:	77e2                	ld	a5,56(sp)
    80003b3c:	03078793          	addi	a5,a5,48
    80003b40:	85be                	mv	a1,a5
    80003b42:	00009517          	auipc	a0,0x9
    80003b46:	12650513          	addi	a0,a0,294 # 8000cc68 <xPendingReadyList>
    80003b4a:	b6bfc0ef          	jal	ra,800006b4 <vListInsertEnd>
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    80003b4e:	77e2                	ld	a5,56(sp)
    80003b50:	6fb8                	ld	a4,88(a5)
    80003b52:	00007797          	auipc	a5,0x7
    80003b56:	07e78793          	addi	a5,a5,126 # 8000abd0 <pxCurrentTCB>
    80003b5a:	639c                	ld	a5,0(a5)
    80003b5c:	6fbc                	ld	a5,88(a5)
    80003b5e:	00e7fd63          	bgeu	a5,a4,80003b78 <vTaskGenericNotifyGiveFromISR+0x118>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    80003b62:	67a2                	ld	a5,8(sp)
    80003b64:	c781                	beqz	a5,80003b6c <vTaskGenericNotifyGiveFromISR+0x10c>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    80003b66:	67a2                	ld	a5,8(sp)
    80003b68:	4705                	li	a4,1
    80003b6a:	e398                	sd	a4,0(a5)
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    80003b6c:	00009797          	auipc	a5,0x9
    80003b70:	1a478793          	addi	a5,a5,420 # 8000cd10 <xYieldPending>
    80003b74:	4705                	li	a4,1
    80003b76:	e398                	sd	a4,0(a5)
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    80003b78:	0001                	nop
    80003b7a:	60a6                	ld	ra,72(sp)
    80003b7c:	6161                	addi	sp,sp,80
    80003b7e:	8082                	ret

0000000080003b80 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    80003b80:	7179                	addi	sp,sp,-48
    80003b82:	f406                	sd	ra,40(sp)
    80003b84:	e42a                	sd	a0,8(sp)
    80003b86:	e02e                	sd	a1,0(sp)
        TCB_t * pxTCB;
        BaseType_t xReturn;

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
    80003b88:	6782                	ld	a5,0(sp)
    80003b8a:	c781                	beqz	a5,80003b92 <xTaskGenericNotifyStateClear+0x12>
    80003b8c:	30047073          	csrci	mstatus,8
    80003b90:	a001                	j	80003b90 <xTaskGenericNotifyStateClear+0x10>

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    80003b92:	67a2                	ld	a5,8(sp)
    80003b94:	e799                	bnez	a5,80003ba2 <xTaskGenericNotifyStateClear+0x22>
    80003b96:	00007797          	auipc	a5,0x7
    80003b9a:	03a78793          	addi	a5,a5,58 # 8000abd0 <pxCurrentTCB>
    80003b9e:	639c                	ld	a5,0(a5)
    80003ba0:	a011                	j	80003ba4 <xTaskGenericNotifyStateClear+0x24>
    80003ba2:	67a2                	ld	a5,8(sp)
    80003ba4:	e83e                	sd	a5,16(sp)

        taskENTER_CRITICAL();
    80003ba6:	827ff0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    80003baa:	6742                	ld	a4,16(sp)
    80003bac:	6782                	ld	a5,0(sp)
    80003bae:	97ba                	add	a5,a5,a4
    80003bb0:	0a47c783          	lbu	a5,164(a5)
    80003bb4:	0ff7f793          	andi	a5,a5,255
    80003bb8:	873e                	mv	a4,a5
    80003bba:	4789                	li	a5,2
    80003bbc:	00f71a63          	bne	a4,a5,80003bd0 <xTaskGenericNotifyStateClear+0x50>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    80003bc0:	6742                	ld	a4,16(sp)
    80003bc2:	6782                	ld	a5,0(sp)
    80003bc4:	97ba                	add	a5,a5,a4
    80003bc6:	0a078223          	sb	zero,164(a5)
                xReturn = pdPASS;
    80003bca:	4785                	li	a5,1
    80003bcc:	ec3e                	sd	a5,24(sp)
    80003bce:	a011                	j	80003bd2 <xTaskGenericNotifyStateClear+0x52>
            }
            else
            {
                xReturn = pdFAIL;
    80003bd0:	ec02                	sd	zero,24(sp)
            }
        }
        taskEXIT_CRITICAL();
    80003bd2:	829ff0ef          	jal	ra,800033fa <vTaskExitCritical>

        return xReturn;
    80003bd6:	67e2                	ld	a5,24(sp)
    }
    80003bd8:	853e                	mv	a0,a5
    80003bda:	70a2                	ld	ra,40(sp)
    80003bdc:	6145                	addi	sp,sp,48
    80003bde:	8082                	ret

0000000080003be0 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    80003be0:	7139                	addi	sp,sp,-64
    80003be2:	fc06                	sd	ra,56(sp)
    80003be4:	ec2a                	sd	a0,24(sp)
    80003be6:	e82e                	sd	a1,16(sp)
    80003be8:	87b2                	mv	a5,a2
    80003bea:	c63e                	sw	a5,12(sp)
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    80003bec:	67e2                	ld	a5,24(sp)
    80003bee:	e799                	bnez	a5,80003bfc <ulTaskGenericNotifyValueClear+0x1c>
    80003bf0:	00007797          	auipc	a5,0x7
    80003bf4:	fe078793          	addi	a5,a5,-32 # 8000abd0 <pxCurrentTCB>
    80003bf8:	639c                	ld	a5,0(a5)
    80003bfa:	a011                	j	80003bfe <ulTaskGenericNotifyValueClear+0x1e>
    80003bfc:	67e2                	ld	a5,24(sp)
    80003bfe:	f43e                	sd	a5,40(sp)

        taskENTER_CRITICAL();
    80003c00:	fccff0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    80003c04:	7722                	ld	a4,40(sp)
    80003c06:	67c2                	ld	a5,16(sp)
    80003c08:	02878793          	addi	a5,a5,40
    80003c0c:	078a                	slli	a5,a5,0x2
    80003c0e:	97ba                	add	a5,a5,a4
    80003c10:	439c                	lw	a5,0(a5)
    80003c12:	d23e                	sw	a5,36(sp)
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    80003c14:	7722                	ld	a4,40(sp)
    80003c16:	67c2                	ld	a5,16(sp)
    80003c18:	02878793          	addi	a5,a5,40
    80003c1c:	078a                	slli	a5,a5,0x2
    80003c1e:	97ba                	add	a5,a5,a4
    80003c20:	439c                	lw	a5,0(a5)
    80003c22:	0007871b          	sext.w	a4,a5
    80003c26:	47b2                	lw	a5,12(sp)
    80003c28:	fff7c793          	not	a5,a5
    80003c2c:	2781                	sext.w	a5,a5
    80003c2e:	8ff9                	and	a5,a5,a4
    80003c30:	0007871b          	sext.w	a4,a5
    80003c34:	76a2                	ld	a3,40(sp)
    80003c36:	67c2                	ld	a5,16(sp)
    80003c38:	02878793          	addi	a5,a5,40
    80003c3c:	078a                	slli	a5,a5,0x2
    80003c3e:	97b6                	add	a5,a5,a3
    80003c40:	c398                	sw	a4,0(a5)
        }
        taskEXIT_CRITICAL();
    80003c42:	fb8ff0ef          	jal	ra,800033fa <vTaskExitCritical>

        return ulReturn;
    80003c46:	5792                	lw	a5,36(sp)
    }
    80003c48:	853e                	mv	a0,a5
    80003c4a:	70e2                	ld	ra,56(sp)
    80003c4c:	6121                	addi	sp,sp,64
    80003c4e:	8082                	ret

0000000080003c50 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    80003c50:	7179                	addi	sp,sp,-48
    80003c52:	f406                	sd	ra,40(sp)
    80003c54:	e42a                	sd	a0,8(sp)
    80003c56:	e02e                	sd	a1,0(sp)
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    80003c58:	00009797          	auipc	a5,0x9
    80003c5c:	09878793          	addi	a5,a5,152 # 8000ccf0 <xTickCount>
    80003c60:	639c                	ld	a5,0(a5)
    80003c62:	ec3e                	sd	a5,24(sp)
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    80003c64:	00007797          	auipc	a5,0x7
    80003c68:	f6c78793          	addi	a5,a5,-148 # 8000abd0 <pxCurrentTCB>
    80003c6c:	639c                	ld	a5,0(a5)
    80003c6e:	07a1                	addi	a5,a5,8
    80003c70:	853e                	mv	a0,a5
    80003c72:	aedfc0ef          	jal	ra,8000075e <uxListRemove>
    80003c76:	87aa                	mv	a5,a0
    80003c78:	eb8d                	bnez	a5,80003caa <prvAddCurrentTaskToDelayedList+0x5a>
    {
        /* The current task must be in a ready list, so there is no need to
         * check, and the port reset macro can be called directly. */
        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
    80003c7a:	00007797          	auipc	a5,0x7
    80003c7e:	f5678793          	addi	a5,a5,-170 # 8000abd0 <pxCurrentTCB>
    80003c82:	639c                	ld	a5,0(a5)
    80003c84:	6fbc                	ld	a5,88(a5)
    80003c86:	2781                	sext.w	a5,a5
    80003c88:	873e                	mv	a4,a5
    80003c8a:	4785                	li	a5,1
    80003c8c:	00e797b3          	sll	a5,a5,a4
    80003c90:	fff7c713          	not	a4,a5
    80003c94:	00009797          	auipc	a5,0x9
    80003c98:	06478793          	addi	a5,a5,100 # 8000ccf8 <uxTopReadyPriority>
    80003c9c:	639c                	ld	a5,0(a5)
    80003c9e:	8f7d                	and	a4,a4,a5
    80003ca0:	00009797          	auipc	a5,0x9
    80003ca4:	05878793          	addi	a5,a5,88 # 8000ccf8 <uxTopReadyPriority>
    80003ca8:	e398                	sd	a4,0(a5)
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    80003caa:	6722                	ld	a4,8(sp)
    80003cac:	57fd                	li	a5,-1
    80003cae:	02f71263          	bne	a4,a5,80003cd2 <prvAddCurrentTaskToDelayedList+0x82>
    80003cb2:	6782                	ld	a5,0(sp)
    80003cb4:	cf99                	beqz	a5,80003cd2 <prvAddCurrentTaskToDelayedList+0x82>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    80003cb6:	00007797          	auipc	a5,0x7
    80003cba:	f1a78793          	addi	a5,a5,-230 # 8000abd0 <pxCurrentTCB>
    80003cbe:	639c                	ld	a5,0(a5)
    80003cc0:	07a1                	addi	a5,a5,8
    80003cc2:	85be                	mv	a1,a5
    80003cc4:	00009517          	auipc	a0,0x9
    80003cc8:	ffc50513          	addi	a0,a0,-4 # 8000ccc0 <xSuspendedTaskList>
    80003ccc:	9e9fc0ef          	jal	ra,800006b4 <vListInsertEnd>

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    80003cd0:	a8ad                	j	80003d4a <prvAddCurrentTaskToDelayedList+0xfa>
                xTimeToWake = xConstTickCount + xTicksToWait;
    80003cd2:	6762                	ld	a4,24(sp)
    80003cd4:	67a2                	ld	a5,8(sp)
    80003cd6:	97ba                	add	a5,a5,a4
    80003cd8:	e83e                	sd	a5,16(sp)
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    80003cda:	00007797          	auipc	a5,0x7
    80003cde:	ef678793          	addi	a5,a5,-266 # 8000abd0 <pxCurrentTCB>
    80003ce2:	639c                	ld	a5,0(a5)
    80003ce4:	6742                	ld	a4,16(sp)
    80003ce6:	e798                	sd	a4,8(a5)
                if( xTimeToWake < xConstTickCount )
    80003ce8:	6742                	ld	a4,16(sp)
    80003cea:	67e2                	ld	a5,24(sp)
    80003cec:	02f77263          	bgeu	a4,a5,80003d10 <prvAddCurrentTaskToDelayedList+0xc0>
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    80003cf0:	00009797          	auipc	a5,0x9
    80003cf4:	f7078793          	addi	a5,a5,-144 # 8000cc60 <pxOverflowDelayedTaskList>
    80003cf8:	6398                	ld	a4,0(a5)
    80003cfa:	00007797          	auipc	a5,0x7
    80003cfe:	ed678793          	addi	a5,a5,-298 # 8000abd0 <pxCurrentTCB>
    80003d02:	639c                	ld	a5,0(a5)
    80003d04:	07a1                	addi	a5,a5,8
    80003d06:	85be                	mv	a1,a5
    80003d08:	853a                	mv	a0,a4
    80003d0a:	9ebfc0ef          	jal	ra,800006f4 <vListInsert>
}
    80003d0e:	a835                	j	80003d4a <prvAddCurrentTaskToDelayedList+0xfa>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    80003d10:	00009797          	auipc	a5,0x9
    80003d14:	f4878793          	addi	a5,a5,-184 # 8000cc58 <pxDelayedTaskList>
    80003d18:	6398                	ld	a4,0(a5)
    80003d1a:	00007797          	auipc	a5,0x7
    80003d1e:	eb678793          	addi	a5,a5,-330 # 8000abd0 <pxCurrentTCB>
    80003d22:	639c                	ld	a5,0(a5)
    80003d24:	07a1                	addi	a5,a5,8
    80003d26:	85be                	mv	a1,a5
    80003d28:	853a                	mv	a0,a4
    80003d2a:	9cbfc0ef          	jal	ra,800006f4 <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
    80003d2e:	00009797          	auipc	a5,0x9
    80003d32:	ffa78793          	addi	a5,a5,-6 # 8000cd28 <xNextTaskUnblockTime>
    80003d36:	639c                	ld	a5,0(a5)
    80003d38:	6742                	ld	a4,16(sp)
    80003d3a:	00f77863          	bgeu	a4,a5,80003d4a <prvAddCurrentTaskToDelayedList+0xfa>
                        xNextTaskUnblockTime = xTimeToWake;
    80003d3e:	00009797          	auipc	a5,0x9
    80003d42:	fea78793          	addi	a5,a5,-22 # 8000cd28 <xNextTaskUnblockTime>
    80003d46:	6742                	ld	a4,16(sp)
    80003d48:	e398                	sd	a4,0(a5)
}
    80003d4a:	0001                	nop
    80003d4c:	70a2                	ld	ra,40(sp)
    80003d4e:	6145                	addi	sp,sp,48
    80003d50:	8082                	ret

0000000080003d52 <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    80003d52:	1101                	addi	sp,sp,-32
    80003d54:	ec06                	sd	ra,24(sp)
        BaseType_t xReturn = pdFAIL;
    80003d56:	e402                	sd	zero,8(sp)

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    80003d58:	6f0000ef          	jal	ra,80004448 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    80003d5c:	00009797          	auipc	a5,0x9
    80003d60:	04478793          	addi	a5,a5,68 # 8000cda0 <xTimerQueue>
    80003d64:	639c                	ld	a5,0(a5)
    80003d66:	c39d                	beqz	a5,80003d8c <xTimerCreateTimerTask+0x3a>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    80003d68:	00009797          	auipc	a5,0x9
    80003d6c:	04078793          	addi	a5,a5,64 # 8000cda8 <xTimerTaskHandle>
    80003d70:	4709                	li	a4,2
    80003d72:	4681                	li	a3,0
    80003d74:	6605                	lui	a2,0x1
    80003d76:	00005597          	auipc	a1,0x5
    80003d7a:	61258593          	addi	a1,a1,1554 # 80009388 <__rodata_start+0x30>
    80003d7e:	00000517          	auipc	a0,0x0
    80003d82:	2ee50513          	addi	a0,a0,750 # 8000406c <prvTimerTask>
    80003d86:	aaffd0ef          	jal	ra,80001834 <xTaskCreate>
    80003d8a:	e42a                	sd	a0,8(sp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
    80003d8c:	67a2                	ld	a5,8(sp)
    80003d8e:	e781                	bnez	a5,80003d96 <xTimerCreateTimerTask+0x44>
    80003d90:	30047073          	csrci	mstatus,8
    80003d94:	a001                	j	80003d94 <xTimerCreateTimerTask+0x42>
        return xReturn;
    80003d96:	67a2                	ld	a5,8(sp)
    }
    80003d98:	853e                	mv	a0,a5
    80003d9a:	60e2                	ld	ra,24(sp)
    80003d9c:	6105                	addi	sp,sp,32
    80003d9e:	8082                	ret

0000000080003da0 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    80003da0:	715d                	addi	sp,sp,-80
    80003da2:	e486                	sd	ra,72(sp)
    80003da4:	f42a                	sd	a0,40(sp)
    80003da6:	f02e                	sd	a1,32(sp)
    80003da8:	ec32                	sd	a2,24(sp)
    80003daa:	e836                	sd	a3,16(sp)
    80003dac:	e43a                	sd	a4,8(sp)
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    80003dae:	05800513          	li	a0,88
    80003db2:	4af000ef          	jal	ra,80004a60 <pvPortMalloc>
    80003db6:	fc2a                	sd	a0,56(sp)

            if( pxNewTimer != NULL )
    80003db8:	77e2                	ld	a5,56(sp)
    80003dba:	cf81                	beqz	a5,80003dd2 <xTimerCreate+0x32>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    80003dbc:	77e2                	ld	a5,56(sp)
    80003dbe:	04078823          	sb	zero,80(a5)
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    80003dc2:	77e2                	ld	a5,56(sp)
    80003dc4:	6722                	ld	a4,8(sp)
    80003dc6:	66c2                	ld	a3,16(sp)
    80003dc8:	6662                	ld	a2,24(sp)
    80003dca:	7582                	ld	a1,32(sp)
    80003dcc:	7522                	ld	a0,40(sp)
    80003dce:	00e000ef          	jal	ra,80003ddc <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    80003dd2:	77e2                	ld	a5,56(sp)
        }
    80003dd4:	853e                	mv	a0,a5
    80003dd6:	60a6                	ld	ra,72(sp)
    80003dd8:	6161                	addi	sp,sp,80
    80003dda:	8082                	ret

0000000080003ddc <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    80003ddc:	7139                	addi	sp,sp,-64
    80003dde:	fc06                	sd	ra,56(sp)
    80003de0:	f42a                	sd	a0,40(sp)
    80003de2:	f02e                	sd	a1,32(sp)
    80003de4:	ec32                	sd	a2,24(sp)
    80003de6:	e836                	sd	a3,16(sp)
    80003de8:	e43a                	sd	a4,8(sp)
    80003dea:	e03e                	sd	a5,0(sp)
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );
    80003dec:	7782                	ld	a5,32(sp)
    80003dee:	e781                	bnez	a5,80003df6 <prvInitialiseNewTimer+0x1a>
    80003df0:	30047073          	csrci	mstatus,8
    80003df4:	a001                	j	80003df4 <prvInitialiseNewTimer+0x18>

        if( pxNewTimer != NULL )
    80003df6:	6782                	ld	a5,0(sp)
    80003df8:	c3a1                	beqz	a5,80003e38 <prvInitialiseNewTimer+0x5c>
        {
            /* Ensure the infrastructure used by the timer service task has been
             * created/initialised. */
            prvCheckForValidListAndQueue();
    80003dfa:	64e000ef          	jal	ra,80004448 <prvCheckForValidListAndQueue>

            /* Initialise the timer structure members using the function
             * parameters. */
            pxNewTimer->pcTimerName = pcTimerName;
    80003dfe:	6782                	ld	a5,0(sp)
    80003e00:	7722                	ld	a4,40(sp)
    80003e02:	e398                	sd	a4,0(a5)
            pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    80003e04:	6782                	ld	a5,0(sp)
    80003e06:	7702                	ld	a4,32(sp)
    80003e08:	fb98                	sd	a4,48(a5)
            pxNewTimer->pvTimerID = pvTimerID;
    80003e0a:	6782                	ld	a5,0(sp)
    80003e0c:	6742                	ld	a4,16(sp)
    80003e0e:	ff98                	sd	a4,56(a5)
            pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    80003e10:	6782                	ld	a5,0(sp)
    80003e12:	6722                	ld	a4,8(sp)
    80003e14:	e3b8                	sd	a4,64(a5)
            vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    80003e16:	6782                	ld	a5,0(sp)
    80003e18:	07a1                	addi	a5,a5,8
    80003e1a:	853e                	mv	a0,a5
    80003e1c:	889fc0ef          	jal	ra,800006a4 <vListInitialiseItem>

            if( uxAutoReload != pdFALSE )
    80003e20:	67e2                	ld	a5,24(sp)
    80003e22:	cb99                	beqz	a5,80003e38 <prvInitialiseNewTimer+0x5c>
            {
                pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    80003e24:	6782                	ld	a5,0(sp)
    80003e26:	0507c783          	lbu	a5,80(a5)
    80003e2a:	0047e793          	ori	a5,a5,4
    80003e2e:	0ff7f713          	andi	a4,a5,255
    80003e32:	6782                	ld	a5,0(sp)
    80003e34:	04e78823          	sb	a4,80(a5)
            }

            traceTIMER_CREATE( pxNewTimer );
        }
    }
    80003e38:	0001                	nop
    80003e3a:	70e2                	ld	ra,56(sp)
    80003e3c:	6121                	addi	sp,sp,64
    80003e3e:	8082                	ret

0000000080003e40 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    80003e40:	711d                	addi	sp,sp,-96
    80003e42:	ec86                	sd	ra,88(sp)
    80003e44:	f42a                	sd	a0,40(sp)
    80003e46:	f02e                	sd	a1,32(sp)
    80003e48:	ec32                	sd	a2,24(sp)
    80003e4a:	e836                	sd	a3,16(sp)
    80003e4c:	e43a                	sd	a4,8(sp)
        BaseType_t xReturn = pdFAIL;
    80003e4e:	e482                	sd	zero,72(sp)
        DaemonTaskMessage_t xMessage;

        configASSERT( xTimer );
    80003e50:	77a2                	ld	a5,40(sp)
    80003e52:	e781                	bnez	a5,80003e5a <xTimerGenericCommand+0x1a>
    80003e54:	30047073          	csrci	mstatus,8
    80003e58:	a001                	j	80003e58 <xTimerGenericCommand+0x18>

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    80003e5a:	00009797          	auipc	a5,0x9
    80003e5e:	f4678793          	addi	a5,a5,-186 # 8000cda0 <xTimerQueue>
    80003e62:	639c                	ld	a5,0(a5)
    80003e64:	cbb5                	beqz	a5,80003ed8 <xTimerGenericCommand+0x98>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    80003e66:	7782                	ld	a5,32(sp)
    80003e68:	f83e                	sd	a5,48(sp)
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    80003e6a:	67e2                	ld	a5,24(sp)
    80003e6c:	fc3e                	sd	a5,56(sp)
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    80003e6e:	77a2                	ld	a5,40(sp)
    80003e70:	e0be                	sd	a5,64(sp)

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    80003e72:	7702                	ld	a4,32(sp)
    80003e74:	4795                	li	a5,5
    80003e76:	04e7c463          	blt	a5,a4,80003ebe <xTimerGenericCommand+0x7e>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    80003e7a:	9e6ff0ef          	jal	ra,80003060 <xTaskGetSchedulerState>
    80003e7e:	872a                	mv	a4,a0
    80003e80:	4789                	li	a5,2
    80003e82:	02f71063          	bne	a4,a5,80003ea2 <xTimerGenericCommand+0x62>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    80003e86:	00009797          	auipc	a5,0x9
    80003e8a:	f1a78793          	addi	a5,a5,-230 # 8000cda0 <xTimerQueue>
    80003e8e:	639c                	ld	a5,0(a5)
    80003e90:	1818                	addi	a4,sp,48
    80003e92:	4681                	li	a3,0
    80003e94:	6622                	ld	a2,8(sp)
    80003e96:	85ba                	mv	a1,a4
    80003e98:	853e                	mv	a0,a5
    80003e9a:	bd9fc0ef          	jal	ra,80000a72 <xQueueGenericSend>
    80003e9e:	e4aa                	sd	a0,72(sp)
    80003ea0:	a825                	j	80003ed8 <xTimerGenericCommand+0x98>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    80003ea2:	00009797          	auipc	a5,0x9
    80003ea6:	efe78793          	addi	a5,a5,-258 # 8000cda0 <xTimerQueue>
    80003eaa:	639c                	ld	a5,0(a5)
    80003eac:	1818                	addi	a4,sp,48
    80003eae:	4681                	li	a3,0
    80003eb0:	4601                	li	a2,0
    80003eb2:	85ba                	mv	a1,a4
    80003eb4:	853e                	mv	a0,a5
    80003eb6:	bbdfc0ef          	jal	ra,80000a72 <xQueueGenericSend>
    80003eba:	e4aa                	sd	a0,72(sp)
    80003ebc:	a831                	j	80003ed8 <xTimerGenericCommand+0x98>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    80003ebe:	00009797          	auipc	a5,0x9
    80003ec2:	ee278793          	addi	a5,a5,-286 # 8000cda0 <xTimerQueue>
    80003ec6:	639c                	ld	a5,0(a5)
    80003ec8:	1818                	addi	a4,sp,48
    80003eca:	4681                	li	a3,0
    80003ecc:	6642                	ld	a2,16(sp)
    80003ece:	85ba                	mv	a1,a4
    80003ed0:	853e                	mv	a0,a5
    80003ed2:	d23fc0ef          	jal	ra,80000bf4 <xQueueGenericSendFromISR>
    80003ed6:	e4aa                	sd	a0,72(sp)
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    80003ed8:	67a6                	ld	a5,72(sp)
    }
    80003eda:	853e                	mv	a0,a5
    80003edc:	60e6                	ld	ra,88(sp)
    80003ede:	6125                	addi	sp,sp,96
    80003ee0:	8082                	ret

0000000080003ee2 <xTimerGetTimerDaemonTaskHandle>:

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
    80003ee2:	00009797          	auipc	a5,0x9
    80003ee6:	ec678793          	addi	a5,a5,-314 # 8000cda8 <xTimerTaskHandle>
    80003eea:	639c                	ld	a5,0(a5)
    80003eec:	e781                	bnez	a5,80003ef4 <xTimerGetTimerDaemonTaskHandle+0x12>
    80003eee:	30047073          	csrci	mstatus,8
    80003ef2:	a001                	j	80003ef2 <xTimerGetTimerDaemonTaskHandle+0x10>
        return xTimerTaskHandle;
    80003ef4:	00009797          	auipc	a5,0x9
    80003ef8:	eb478793          	addi	a5,a5,-332 # 8000cda8 <xTimerTaskHandle>
    80003efc:	639c                	ld	a5,0(a5)
    }
    80003efe:	853e                	mv	a0,a5
    80003f00:	8082                	ret

0000000080003f02 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    80003f02:	1101                	addi	sp,sp,-32
    80003f04:	e42a                	sd	a0,8(sp)
        Timer_t * pxTimer = xTimer;
    80003f06:	67a2                	ld	a5,8(sp)
    80003f08:	ec3e                	sd	a5,24(sp)

        configASSERT( xTimer );
    80003f0a:	67a2                	ld	a5,8(sp)
    80003f0c:	e781                	bnez	a5,80003f14 <xTimerGetPeriod+0x12>
    80003f0e:	30047073          	csrci	mstatus,8
    80003f12:	a001                	j	80003f12 <xTimerGetPeriod+0x10>
        return pxTimer->xTimerPeriodInTicks;
    80003f14:	67e2                	ld	a5,24(sp)
    80003f16:	7b9c                	ld	a5,48(a5)
    }
    80003f18:	853e                	mv	a0,a5
    80003f1a:	6105                	addi	sp,sp,32
    80003f1c:	8082                	ret

0000000080003f1e <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    80003f1e:	7179                	addi	sp,sp,-48
    80003f20:	f406                	sd	ra,40(sp)
    80003f22:	e42a                	sd	a0,8(sp)
    80003f24:	e02e                	sd	a1,0(sp)
        Timer_t * pxTimer = xTimer;
    80003f26:	67a2                	ld	a5,8(sp)
    80003f28:	ec3e                	sd	a5,24(sp)

        configASSERT( xTimer );
    80003f2a:	67a2                	ld	a5,8(sp)
    80003f2c:	e781                	bnez	a5,80003f34 <vTimerSetReloadMode+0x16>
    80003f2e:	30047073          	csrci	mstatus,8
    80003f32:	a001                	j	80003f32 <vTimerSetReloadMode+0x14>
        taskENTER_CRITICAL();
    80003f34:	c98ff0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            if( uxAutoReload != pdFALSE )
    80003f38:	6782                	ld	a5,0(sp)
    80003f3a:	cf81                	beqz	a5,80003f52 <vTimerSetReloadMode+0x34>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    80003f3c:	67e2                	ld	a5,24(sp)
    80003f3e:	0507c783          	lbu	a5,80(a5)
    80003f42:	0047e793          	ori	a5,a5,4
    80003f46:	0ff7f713          	andi	a4,a5,255
    80003f4a:	67e2                	ld	a5,24(sp)
    80003f4c:	04e78823          	sb	a4,80(a5)
    80003f50:	a811                	j	80003f64 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ~tmrSTATUS_IS_AUTORELOAD;
    80003f52:	67e2                	ld	a5,24(sp)
    80003f54:	0507c783          	lbu	a5,80(a5)
    80003f58:	9bed                	andi	a5,a5,-5
    80003f5a:	0ff7f713          	andi	a4,a5,255
    80003f5e:	67e2                	ld	a5,24(sp)
    80003f60:	04e78823          	sb	a4,80(a5)
            }
        }
        taskEXIT_CRITICAL();
    80003f64:	c96ff0ef          	jal	ra,800033fa <vTaskExitCritical>
    }
    80003f68:	0001                	nop
    80003f6a:	70a2                	ld	ra,40(sp)
    80003f6c:	6145                	addi	sp,sp,48
    80003f6e:	8082                	ret

0000000080003f70 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    80003f70:	7179                	addi	sp,sp,-48
    80003f72:	f406                	sd	ra,40(sp)
    80003f74:	e42a                	sd	a0,8(sp)
        Timer_t * pxTimer = xTimer;
    80003f76:	67a2                	ld	a5,8(sp)
    80003f78:	e83e                	sd	a5,16(sp)
        UBaseType_t uxReturn;

        configASSERT( xTimer );
    80003f7a:	67a2                	ld	a5,8(sp)
    80003f7c:	e781                	bnez	a5,80003f84 <uxTimerGetReloadMode+0x14>
    80003f7e:	30047073          	csrci	mstatus,8
    80003f82:	a001                	j	80003f82 <uxTimerGetReloadMode+0x12>
        taskENTER_CRITICAL();
    80003f84:	c48ff0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    80003f88:	67c2                	ld	a5,16(sp)
    80003f8a:	0507c783          	lbu	a5,80(a5)
    80003f8e:	2781                	sext.w	a5,a5
    80003f90:	8b91                	andi	a5,a5,4
    80003f92:	2781                	sext.w	a5,a5
    80003f94:	e399                	bnez	a5,80003f9a <uxTimerGetReloadMode+0x2a>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    80003f96:	ec02                	sd	zero,24(sp)
    80003f98:	a019                	j	80003f9e <uxTimerGetReloadMode+0x2e>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    80003f9a:	4785                	li	a5,1
    80003f9c:	ec3e                	sd	a5,24(sp)
            }
        }
        taskEXIT_CRITICAL();
    80003f9e:	c5cff0ef          	jal	ra,800033fa <vTaskExitCritical>

        return uxReturn;
    80003fa2:	67e2                	ld	a5,24(sp)
    }
    80003fa4:	853e                	mv	a0,a5
    80003fa6:	70a2                	ld	ra,40(sp)
    80003fa8:	6145                	addi	sp,sp,48
    80003faa:	8082                	ret

0000000080003fac <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    80003fac:	1101                	addi	sp,sp,-32
    80003fae:	e42a                	sd	a0,8(sp)
        Timer_t * pxTimer = xTimer;
    80003fb0:	67a2                	ld	a5,8(sp)
    80003fb2:	ec3e                	sd	a5,24(sp)
        TickType_t xReturn;

        configASSERT( xTimer );
    80003fb4:	67a2                	ld	a5,8(sp)
    80003fb6:	e781                	bnez	a5,80003fbe <xTimerGetExpiryTime+0x12>
    80003fb8:	30047073          	csrci	mstatus,8
    80003fbc:	a001                	j	80003fbc <xTimerGetExpiryTime+0x10>
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    80003fbe:	67e2                	ld	a5,24(sp)
    80003fc0:	679c                	ld	a5,8(a5)
    80003fc2:	e83e                	sd	a5,16(sp)
        return xReturn;
    80003fc4:	67c2                	ld	a5,16(sp)
    }
    80003fc6:	853e                	mv	a0,a5
    80003fc8:	6105                	addi	sp,sp,32
    80003fca:	8082                	ret

0000000080003fcc <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    80003fcc:	1101                	addi	sp,sp,-32
    80003fce:	e42a                	sd	a0,8(sp)
        Timer_t * pxTimer = xTimer;
    80003fd0:	67a2                	ld	a5,8(sp)
    80003fd2:	ec3e                	sd	a5,24(sp)

        configASSERT( xTimer );
    80003fd4:	67a2                	ld	a5,8(sp)
    80003fd6:	e781                	bnez	a5,80003fde <pcTimerGetName+0x12>
    80003fd8:	30047073          	csrci	mstatus,8
    80003fdc:	a001                	j	80003fdc <pcTimerGetName+0x10>
        return pxTimer->pcTimerName;
    80003fde:	67e2                	ld	a5,24(sp)
    80003fe0:	639c                	ld	a5,0(a5)
    }
    80003fe2:	853e                	mv	a0,a5
    80003fe4:	6105                	addi	sp,sp,32
    80003fe6:	8082                	ret

0000000080003fe8 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    80003fe8:	7179                	addi	sp,sp,-48
    80003fea:	f406                	sd	ra,40(sp)
    80003fec:	e42a                	sd	a0,8(sp)
    80003fee:	e02e                	sd	a1,0(sp)
        BaseType_t xResult;
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    80003ff0:	00009797          	auipc	a5,0x9
    80003ff4:	da078793          	addi	a5,a5,-608 # 8000cd90 <pxCurrentTimerList>
    80003ff8:	639c                	ld	a5,0(a5)
    80003ffa:	6f9c                	ld	a5,24(a5)
    80003ffc:	6f9c                	ld	a5,24(a5)
    80003ffe:	ec3e                	sd	a5,24(sp)

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    80004000:	67e2                	ld	a5,24(sp)
    80004002:	07a1                	addi	a5,a5,8
    80004004:	853e                	mv	a0,a5
    80004006:	f58fc0ef          	jal	ra,8000075e <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    8000400a:	67e2                	ld	a5,24(sp)
    8000400c:	0507c783          	lbu	a5,80(a5)
    80004010:	2781                	sext.w	a5,a5
    80004012:	8b91                	andi	a5,a5,4
    80004014:	2781                	sext.w	a5,a5
    80004016:	cb95                	beqz	a5,8000404a <prvProcessExpiredTimer+0x62>
        {
            /* The timer is inserted into a list using a time relative to anything
             * other than the current time.  It will therefore be inserted into the
             * correct list relative to the time this task thinks it is now. */
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    80004018:	67e2                	ld	a5,24(sp)
    8000401a:	7b98                	ld	a4,48(a5)
    8000401c:	67a2                	ld	a5,8(sp)
    8000401e:	97ba                	add	a5,a5,a4
    80004020:	66a2                	ld	a3,8(sp)
    80004022:	6602                	ld	a2,0(sp)
    80004024:	85be                	mv	a1,a5
    80004026:	6562                	ld	a0,24(sp)
    80004028:	16a000ef          	jal	ra,80004192 <prvInsertTimerInActiveList>
    8000402c:	87aa                	mv	a5,a0
    8000402e:	c79d                	beqz	a5,8000405c <prvProcessExpiredTimer+0x74>
            {
                /* The timer expired before it was added to the active timer
                 * list.  Reload it now.  */
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    80004030:	4701                	li	a4,0
    80004032:	4681                	li	a3,0
    80004034:	6622                	ld	a2,8(sp)
    80004036:	4581                	li	a1,0
    80004038:	6562                	ld	a0,24(sp)
    8000403a:	e07ff0ef          	jal	ra,80003e40 <xTimerGenericCommand>
    8000403e:	e82a                	sd	a0,16(sp)
                configASSERT( xResult );
    80004040:	67c2                	ld	a5,16(sp)
    80004042:	ef89                	bnez	a5,8000405c <prvProcessExpiredTimer+0x74>
    80004044:	30047073          	csrci	mstatus,8
    80004048:	a001                	j	80004048 <prvProcessExpiredTimer+0x60>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    8000404a:	67e2                	ld	a5,24(sp)
    8000404c:	0507c783          	lbu	a5,80(a5)
    80004050:	9bf9                	andi	a5,a5,-2
    80004052:	0ff7f713          	andi	a4,a5,255
    80004056:	67e2                	ld	a5,24(sp)
    80004058:	04e78823          	sb	a4,80(a5)
            mtCOVERAGE_TEST_MARKER();
        }

        /* Call the timer callback. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    8000405c:	67e2                	ld	a5,24(sp)
    8000405e:	63bc                	ld	a5,64(a5)
    80004060:	6562                	ld	a0,24(sp)
    80004062:	9782                	jalr	a5
    }
    80004064:	0001                	nop
    80004066:	70a2                	ld	ra,40(sp)
    80004068:	6145                	addi	sp,sp,48
    8000406a:	8082                	ret

000000008000406c <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    8000406c:	7179                	addi	sp,sp,-48
    8000406e:	f406                	sd	ra,40(sp)
    80004070:	e42a                	sd	a0,8(sp)

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    80004072:	081c                	addi	a5,sp,16
    80004074:	853e                	mv	a0,a5
    80004076:	09a000ef          	jal	ra,80004110 <prvGetNextExpireTime>
    8000407a:	ec2a                	sd	a0,24(sp)

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    8000407c:	67c2                	ld	a5,16(sp)
    8000407e:	85be                	mv	a1,a5
    80004080:	6562                	ld	a0,24(sp)
    80004082:	00a000ef          	jal	ra,8000408c <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    80004086:	190000ef          	jal	ra,80004216 <prvProcessReceivedCommands>
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    8000408a:	b7e5                	j	80004072 <prvTimerTask+0x6>

000000008000408c <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    8000408c:	7179                	addi	sp,sp,-48
    8000408e:	f406                	sd	ra,40(sp)
    80004090:	e42a                	sd	a0,8(sp)
    80004092:	e02e                	sd	a1,0(sp)
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    80004094:	ab0fe0ef          	jal	ra,80002344 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    80004098:	081c                	addi	a5,sp,16
    8000409a:	853e                	mv	a0,a5
    8000409c:	0b2000ef          	jal	ra,8000414e <prvSampleTimeNow>
    800040a0:	ec2a                	sd	a0,24(sp)

            if( xTimerListsWereSwitched == pdFALSE )
    800040a2:	67c2                	ld	a5,16(sp)
    800040a4:	e3a5                	bnez	a5,80004104 <prvProcessTimerOrBlockTask+0x78>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    800040a6:	6782                	ld	a5,0(sp)
    800040a8:	ef81                	bnez	a5,800040c0 <prvProcessTimerOrBlockTask+0x34>
    800040aa:	6722                	ld	a4,8(sp)
    800040ac:	67e2                	ld	a5,24(sp)
    800040ae:	00e7e963          	bltu	a5,a4,800040c0 <prvProcessTimerOrBlockTask+0x34>
                {
                    ( void ) xTaskResumeAll();
    800040b2:	aaefe0ef          	jal	ra,80002360 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    800040b6:	65e2                	ld	a1,24(sp)
    800040b8:	6522                	ld	a0,8(sp)
    800040ba:	f2fff0ef          	jal	ra,80003fe8 <prvProcessExpiredTimer>
            else
            {
                ( void ) xTaskResumeAll();
            }
        }
    }
    800040be:	a0a9                	j	80004108 <prvProcessTimerOrBlockTask+0x7c>
                    if( xListWasEmpty != pdFALSE )
    800040c0:	6782                	ld	a5,0(sp)
    800040c2:	cf81                	beqz	a5,800040da <prvProcessTimerOrBlockTask+0x4e>
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    800040c4:	00009797          	auipc	a5,0x9
    800040c8:	cd478793          	addi	a5,a5,-812 # 8000cd98 <pxOverflowTimerList>
    800040cc:	639c                	ld	a5,0(a5)
    800040ce:	639c                	ld	a5,0(a5)
    800040d0:	e399                	bnez	a5,800040d6 <prvProcessTimerOrBlockTask+0x4a>
    800040d2:	4785                	li	a5,1
    800040d4:	a011                	j	800040d8 <prvProcessTimerOrBlockTask+0x4c>
    800040d6:	4781                	li	a5,0
    800040d8:	e03e                	sd	a5,0(sp)
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    800040da:	00009797          	auipc	a5,0x9
    800040de:	cc678793          	addi	a5,a5,-826 # 8000cda0 <xTimerQueue>
    800040e2:	6394                	ld	a3,0(a5)
    800040e4:	6722                	ld	a4,8(sp)
    800040e6:	67e2                	ld	a5,24(sp)
    800040e8:	40f707b3          	sub	a5,a4,a5
    800040ec:	6602                	ld	a2,0(sp)
    800040ee:	85be                	mv	a1,a5
    800040f0:	8536                	mv	a0,a3
    800040f2:	ed0fd0ef          	jal	ra,800017c2 <vQueueWaitForMessageRestricted>
                    if( xTaskResumeAll() == pdFALSE )
    800040f6:	a6afe0ef          	jal	ra,80002360 <xTaskResumeAll>
    800040fa:	87aa                	mv	a5,a0
    800040fc:	e791                	bnez	a5,80004108 <prvProcessTimerOrBlockTask+0x7c>
                        portYIELD_WITHIN_API();
    800040fe:	00000073          	ecall
    }
    80004102:	a019                	j	80004108 <prvProcessTimerOrBlockTask+0x7c>
                ( void ) xTaskResumeAll();
    80004104:	a5cfe0ef          	jal	ra,80002360 <xTaskResumeAll>
    }
    80004108:	0001                	nop
    8000410a:	70a2                	ld	ra,40(sp)
    8000410c:	6145                	addi	sp,sp,48
    8000410e:	8082                	ret

0000000080004110 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    80004110:	1101                	addi	sp,sp,-32
    80004112:	e42a                	sd	a0,8(sp)
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    80004114:	00009797          	auipc	a5,0x9
    80004118:	c7c78793          	addi	a5,a5,-900 # 8000cd90 <pxCurrentTimerList>
    8000411c:	639c                	ld	a5,0(a5)
    8000411e:	639c                	ld	a5,0(a5)
    80004120:	e399                	bnez	a5,80004126 <prvGetNextExpireTime+0x16>
    80004122:	4785                	li	a5,1
    80004124:	a011                	j	80004128 <prvGetNextExpireTime+0x18>
    80004126:	4781                	li	a5,0
    80004128:	6722                	ld	a4,8(sp)
    8000412a:	e31c                	sd	a5,0(a4)

        if( *pxListWasEmpty == pdFALSE )
    8000412c:	67a2                	ld	a5,8(sp)
    8000412e:	639c                	ld	a5,0(a5)
    80004130:	eb91                	bnez	a5,80004144 <prvGetNextExpireTime+0x34>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    80004132:	00009797          	auipc	a5,0x9
    80004136:	c5e78793          	addi	a5,a5,-930 # 8000cd90 <pxCurrentTimerList>
    8000413a:	639c                	ld	a5,0(a5)
    8000413c:	6f9c                	ld	a5,24(a5)
    8000413e:	639c                	ld	a5,0(a5)
    80004140:	ec3e                	sd	a5,24(sp)
    80004142:	a011                	j	80004146 <prvGetNextExpireTime+0x36>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    80004144:	ec02                	sd	zero,24(sp)
        }

        return xNextExpireTime;
    80004146:	67e2                	ld	a5,24(sp)
    }
    80004148:	853e                	mv	a0,a5
    8000414a:	6105                	addi	sp,sp,32
    8000414c:	8082                	ret

000000008000414e <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    8000414e:	7179                	addi	sp,sp,-48
    80004150:	f406                	sd	ra,40(sp)
    80004152:	e42a                	sd	a0,8(sp)
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    80004154:	b5afe0ef          	jal	ra,800024ae <xTaskGetTickCount>
    80004158:	ec2a                	sd	a0,24(sp)

        if( xTimeNow < xLastTime )
    8000415a:	00009797          	auipc	a5,0x9
    8000415e:	c5678793          	addi	a5,a5,-938 # 8000cdb0 <xLastTime.2306>
    80004162:	639c                	ld	a5,0(a5)
    80004164:	6762                	ld	a4,24(sp)
    80004166:	00f77863          	bgeu	a4,a5,80004176 <prvSampleTimeNow+0x28>
        {
            prvSwitchTimerLists();
    8000416a:	206000ef          	jal	ra,80004370 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    8000416e:	67a2                	ld	a5,8(sp)
    80004170:	4705                	li	a4,1
    80004172:	e398                	sd	a4,0(a5)
    80004174:	a021                	j	8000417c <prvSampleTimeNow+0x2e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    80004176:	67a2                	ld	a5,8(sp)
    80004178:	0007b023          	sd	zero,0(a5)
        }

        xLastTime = xTimeNow;
    8000417c:	00009797          	auipc	a5,0x9
    80004180:	c3478793          	addi	a5,a5,-972 # 8000cdb0 <xLastTime.2306>
    80004184:	6762                	ld	a4,24(sp)
    80004186:	e398                	sd	a4,0(a5)

        return xTimeNow;
    80004188:	67e2                	ld	a5,24(sp)
    }
    8000418a:	853e                	mv	a0,a5
    8000418c:	70a2                	ld	ra,40(sp)
    8000418e:	6145                	addi	sp,sp,48
    80004190:	8082                	ret

0000000080004192 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    80004192:	7139                	addi	sp,sp,-64
    80004194:	fc06                	sd	ra,56(sp)
    80004196:	ec2a                	sd	a0,24(sp)
    80004198:	e82e                	sd	a1,16(sp)
    8000419a:	e432                	sd	a2,8(sp)
    8000419c:	e036                	sd	a3,0(sp)
        BaseType_t xProcessTimerNow = pdFALSE;
    8000419e:	f402                	sd	zero,40(sp)

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    800041a0:	67e2                	ld	a5,24(sp)
    800041a2:	6742                	ld	a4,16(sp)
    800041a4:	e798                	sd	a4,8(a5)
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    800041a6:	67e2                	ld	a5,24(sp)
    800041a8:	6762                	ld	a4,24(sp)
    800041aa:	f398                	sd	a4,32(a5)

        if( xNextExpiryTime <= xTimeNow )
    800041ac:	6742                	ld	a4,16(sp)
    800041ae:	67a2                	ld	a5,8(sp)
    800041b0:	02e7e863          	bltu	a5,a4,800041e0 <prvInsertTimerInActiveList+0x4e>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    800041b4:	6722                	ld	a4,8(sp)
    800041b6:	6782                	ld	a5,0(sp)
    800041b8:	8f1d                	sub	a4,a4,a5
    800041ba:	67e2                	ld	a5,24(sp)
    800041bc:	7b9c                	ld	a5,48(a5)
    800041be:	00f76563          	bltu	a4,a5,800041c8 <prvInsertTimerInActiveList+0x36>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    800041c2:	4785                	li	a5,1
    800041c4:	f43e                	sd	a5,40(sp)
    800041c6:	a099                	j	8000420c <prvInsertTimerInActiveList+0x7a>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    800041c8:	00009797          	auipc	a5,0x9
    800041cc:	bd078793          	addi	a5,a5,-1072 # 8000cd98 <pxOverflowTimerList>
    800041d0:	6398                	ld	a4,0(a5)
    800041d2:	67e2                	ld	a5,24(sp)
    800041d4:	07a1                	addi	a5,a5,8
    800041d6:	85be                	mv	a1,a5
    800041d8:	853a                	mv	a0,a4
    800041da:	d1afc0ef          	jal	ra,800006f4 <vListInsert>
    800041de:	a03d                	j	8000420c <prvInsertTimerInActiveList+0x7a>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    800041e0:	6722                	ld	a4,8(sp)
    800041e2:	6782                	ld	a5,0(sp)
    800041e4:	00f77963          	bgeu	a4,a5,800041f6 <prvInsertTimerInActiveList+0x64>
    800041e8:	6742                	ld	a4,16(sp)
    800041ea:	6782                	ld	a5,0(sp)
    800041ec:	00f76563          	bltu	a4,a5,800041f6 <prvInsertTimerInActiveList+0x64>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    800041f0:	4785                	li	a5,1
    800041f2:	f43e                	sd	a5,40(sp)
    800041f4:	a821                	j	8000420c <prvInsertTimerInActiveList+0x7a>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    800041f6:	00009797          	auipc	a5,0x9
    800041fa:	b9a78793          	addi	a5,a5,-1126 # 8000cd90 <pxCurrentTimerList>
    800041fe:	6398                	ld	a4,0(a5)
    80004200:	67e2                	ld	a5,24(sp)
    80004202:	07a1                	addi	a5,a5,8
    80004204:	85be                	mv	a1,a5
    80004206:	853a                	mv	a0,a4
    80004208:	cecfc0ef          	jal	ra,800006f4 <vListInsert>
            }
        }

        return xProcessTimerNow;
    8000420c:	77a2                	ld	a5,40(sp)
    }
    8000420e:	853e                	mv	a0,a5
    80004210:	70e2                	ld	ra,56(sp)
    80004212:	6121                	addi	sp,sp,64
    80004214:	8082                	ret

0000000080004216 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    80004216:	715d                	addi	sp,sp,-80
    80004218:	e486                	sd	ra,72(sp)
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    8000421a:	aa05                	j	8000434a <prvProcessReceivedCommands+0x134>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    8000421c:	67c2                	ld	a5,16(sp)
    8000421e:	1207c563          	bltz	a5,80004348 <prvProcessReceivedCommands+0x132>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    80004222:	7782                	ld	a5,32(sp)
    80004224:	fc3e                	sd	a5,56(sp)

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    80004226:	77e2                	ld	a5,56(sp)
    80004228:	779c                	ld	a5,40(a5)
    8000422a:	c791                	beqz	a5,80004236 <prvProcessReceivedCommands+0x20>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    8000422c:	77e2                	ld	a5,56(sp)
    8000422e:	07a1                	addi	a5,a5,8
    80004230:	853e                	mv	a0,a5
    80004232:	d2cfc0ef          	jal	ra,8000075e <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    80004236:	003c                	addi	a5,sp,8
    80004238:	853e                	mv	a0,a5
    8000423a:	f15ff0ef          	jal	ra,8000414e <prvSampleTimeNow>
    8000423e:	f82a                	sd	a0,48(sp)

                switch( xMessage.xMessageID )
    80004240:	67c2                	ld	a5,16(sp)
    80004242:	4725                	li	a4,9
    80004244:	10f76363          	bltu	a4,a5,8000434a <prvProcessReceivedCommands+0x134>
    80004248:	00279713          	slli	a4,a5,0x2
    8000424c:	00005797          	auipc	a5,0x5
    80004250:	14478793          	addi	a5,a5,324 # 80009390 <__rodata_start+0x38>
    80004254:	97ba                	add	a5,a5,a4
    80004256:	439c                	lw	a5,0(a5)
    80004258:	0007871b          	sext.w	a4,a5
    8000425c:	00005797          	auipc	a5,0x5
    80004260:	13478793          	addi	a5,a5,308 # 80009390 <__rodata_start+0x38>
    80004264:	97ba                	add	a5,a5,a4
    80004266:	8782                	jr	a5
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                    case tmrCOMMAND_START_DONT_TRACE:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    80004268:	77e2                	ld	a5,56(sp)
    8000426a:	0507c783          	lbu	a5,80(a5)
    8000426e:	0017e793          	ori	a5,a5,1
    80004272:	0ff7f713          	andi	a4,a5,255
    80004276:	77e2                	ld	a5,56(sp)
    80004278:	04e78823          	sb	a4,80(a5)

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    8000427c:	6762                	ld	a4,24(sp)
    8000427e:	77e2                	ld	a5,56(sp)
    80004280:	7b9c                	ld	a5,48(a5)
    80004282:	97ba                	add	a5,a5,a4
    80004284:	6762                	ld	a4,24(sp)
    80004286:	86ba                	mv	a3,a4
    80004288:	7642                	ld	a2,48(sp)
    8000428a:	85be                	mv	a1,a5
    8000428c:	7562                	ld	a0,56(sp)
    8000428e:	f05ff0ef          	jal	ra,80004192 <prvInsertTimerInActiveList>
    80004292:	87aa                	mv	a5,a0
    80004294:	cbdd                	beqz	a5,8000434a <prvProcessReceivedCommands+0x134>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    80004296:	77e2                	ld	a5,56(sp)
    80004298:	63bc                	ld	a5,64(a5)
    8000429a:	7562                	ld	a0,56(sp)
    8000429c:	9782                	jalr	a5
                            traceTIMER_EXPIRED( pxTimer );

                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    8000429e:	77e2                	ld	a5,56(sp)
    800042a0:	0507c783          	lbu	a5,80(a5)
    800042a4:	2781                	sext.w	a5,a5
    800042a6:	8b91                	andi	a5,a5,4
    800042a8:	2781                	sext.w	a5,a5
    800042aa:	c3c5                	beqz	a5,8000434a <prvProcessReceivedCommands+0x134>
                            {
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    800042ac:	6762                	ld	a4,24(sp)
    800042ae:	77e2                	ld	a5,56(sp)
    800042b0:	7b9c                	ld	a5,48(a5)
    800042b2:	97ba                	add	a5,a5,a4
    800042b4:	4701                	li	a4,0
    800042b6:	4681                	li	a3,0
    800042b8:	863e                	mv	a2,a5
    800042ba:	4581                	li	a1,0
    800042bc:	7562                	ld	a0,56(sp)
    800042be:	b83ff0ef          	jal	ra,80003e40 <xTimerGenericCommand>
    800042c2:	f42a                	sd	a0,40(sp)
                                configASSERT( xResult );
    800042c4:	77a2                	ld	a5,40(sp)
    800042c6:	e3d1                	bnez	a5,8000434a <prvProcessReceivedCommands+0x134>
    800042c8:	30047073          	csrci	mstatus,8
    800042cc:	a001                	j	800042cc <prvProcessReceivedCommands+0xb6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    800042ce:	77e2                	ld	a5,56(sp)
    800042d0:	0507c783          	lbu	a5,80(a5)
    800042d4:	9bf9                	andi	a5,a5,-2
    800042d6:	0ff7f713          	andi	a4,a5,255
    800042da:	77e2                	ld	a5,56(sp)
    800042dc:	04e78823          	sb	a4,80(a5)
                        break;
    800042e0:	a0ad                	j	8000434a <prvProcessReceivedCommands+0x134>

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    800042e2:	77e2                	ld	a5,56(sp)
    800042e4:	0507c783          	lbu	a5,80(a5)
    800042e8:	0017e793          	ori	a5,a5,1
    800042ec:	0ff7f713          	andi	a4,a5,255
    800042f0:	77e2                	ld	a5,56(sp)
    800042f2:	04e78823          	sb	a4,80(a5)
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    800042f6:	6762                	ld	a4,24(sp)
    800042f8:	77e2                	ld	a5,56(sp)
    800042fa:	fb98                	sd	a4,48(a5)
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    800042fc:	77e2                	ld	a5,56(sp)
    800042fe:	7b9c                	ld	a5,48(a5)
    80004300:	e781                	bnez	a5,80004308 <prvProcessReceivedCommands+0xf2>
    80004302:	30047073          	csrci	mstatus,8
    80004306:	a001                	j	80004306 <prvProcessReceivedCommands+0xf0>
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    80004308:	77e2                	ld	a5,56(sp)
    8000430a:	7b98                	ld	a4,48(a5)
    8000430c:	77c2                	ld	a5,48(sp)
    8000430e:	97ba                	add	a5,a5,a4
    80004310:	76c2                	ld	a3,48(sp)
    80004312:	7642                	ld	a2,48(sp)
    80004314:	85be                	mv	a1,a5
    80004316:	7562                	ld	a0,56(sp)
    80004318:	e7bff0ef          	jal	ra,80004192 <prvInsertTimerInActiveList>
                        break;
    8000431c:	a03d                	j	8000434a <prvProcessReceivedCommands+0x134>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    8000431e:	77e2                	ld	a5,56(sp)
    80004320:	0507c783          	lbu	a5,80(a5)
    80004324:	2781                	sext.w	a5,a5
    80004326:	8b89                	andi	a5,a5,2
    80004328:	2781                	sext.w	a5,a5
    8000432a:	e789                	bnez	a5,80004334 <prvProcessReceivedCommands+0x11e>
                                {
                                    vPortFree( pxTimer );
    8000432c:	7562                	ld	a0,56(sp)
    8000432e:	065000ef          	jal	ra,80004b92 <vPortFree>
    80004332:	a821                	j	8000434a <prvProcessReceivedCommands+0x134>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    80004334:	77e2                	ld	a5,56(sp)
    80004336:	0507c783          	lbu	a5,80(a5)
    8000433a:	9bf9                	andi	a5,a5,-2
    8000433c:	0ff7f713          	andi	a4,a5,255
    80004340:	77e2                	ld	a5,56(sp)
    80004342:	04e78823          	sb	a4,80(a5)
                                 * no need to free the memory - just mark the timer as
                                 * "not active". */
                                pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                            }
                        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
                        break;
    80004346:	a011                	j	8000434a <prvProcessReceivedCommands+0x134>

                    default:
                        /* Don't expect to get here. */
                        break;
                }
            }
    80004348:	0001                	nop
        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    8000434a:	00009797          	auipc	a5,0x9
    8000434e:	a5678793          	addi	a5,a5,-1450 # 8000cda0 <xTimerQueue>
    80004352:	639c                	ld	a5,0(a5)
    80004354:	0818                	addi	a4,sp,16
    80004356:	4601                	li	a2,0
    80004358:	85ba                	mv	a1,a4
    8000435a:	853e                	mv	a0,a5
    8000435c:	a61fc0ef          	jal	ra,80000dbc <xQueueReceive>
    80004360:	87aa                	mv	a5,a0
    80004362:	ea079de3          	bnez	a5,8000421c <prvProcessReceivedCommands+0x6>
        }
    }
    80004366:	0001                	nop
    80004368:	0001                	nop
    8000436a:	60a6                	ld	ra,72(sp)
    8000436c:	6161                	addi	sp,sp,80
    8000436e:	8082                	ret

0000000080004370 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    80004370:	7139                	addi	sp,sp,-64
    80004372:	fc06                	sd	ra,56(sp)

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    80004374:	a849                	j	80004406 <prvSwitchTimerLists+0x96>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    80004376:	00009797          	auipc	a5,0x9
    8000437a:	a1a78793          	addi	a5,a5,-1510 # 8000cd90 <pxCurrentTimerList>
    8000437e:	639c                	ld	a5,0(a5)
    80004380:	6f9c                	ld	a5,24(a5)
    80004382:	639c                	ld	a5,0(a5)
    80004384:	f03e                	sd	a5,32(sp)

            /* Remove the timer from the list. */
            pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    80004386:	00009797          	auipc	a5,0x9
    8000438a:	a0a78793          	addi	a5,a5,-1526 # 8000cd90 <pxCurrentTimerList>
    8000438e:	639c                	ld	a5,0(a5)
    80004390:	6f9c                	ld	a5,24(a5)
    80004392:	6f9c                	ld	a5,24(a5)
    80004394:	ec3e                	sd	a5,24(sp)
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    80004396:	67e2                	ld	a5,24(sp)
    80004398:	07a1                	addi	a5,a5,8
    8000439a:	853e                	mv	a0,a5
    8000439c:	bc2fc0ef          	jal	ra,8000075e <uxListRemove>
            traceTIMER_EXPIRED( pxTimer );

            /* Execute its callback, then send a command to restart the timer if
             * it is an auto-reload timer.  It cannot be restarted here as the lists
             * have not yet been switched. */
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    800043a0:	67e2                	ld	a5,24(sp)
    800043a2:	63bc                	ld	a5,64(a5)
    800043a4:	6562                	ld	a0,24(sp)
    800043a6:	9782                	jalr	a5

            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    800043a8:	67e2                	ld	a5,24(sp)
    800043aa:	0507c783          	lbu	a5,80(a5)
    800043ae:	2781                	sext.w	a5,a5
    800043b0:	8b91                	andi	a5,a5,4
    800043b2:	2781                	sext.w	a5,a5
    800043b4:	cba9                	beqz	a5,80004406 <prvSwitchTimerLists+0x96>
                 * the timer going into the same timer list then it has already expired
                 * and the timer should be re-inserted into the current list so it is
                 * processed again within this loop.  Otherwise a command should be sent
                 * to restart the timer to ensure it is only inserted into a list after
                 * the lists have been swapped. */
                xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    800043b6:	67e2                	ld	a5,24(sp)
    800043b8:	7b9c                	ld	a5,48(a5)
    800043ba:	7702                	ld	a4,32(sp)
    800043bc:	97ba                	add	a5,a5,a4
    800043be:	e83e                	sd	a5,16(sp)

                if( xReloadTime > xNextExpireTime )
    800043c0:	6742                	ld	a4,16(sp)
    800043c2:	7782                	ld	a5,32(sp)
    800043c4:	02e7f463          	bgeu	a5,a4,800043ec <prvSwitchTimerLists+0x7c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    800043c8:	67e2                	ld	a5,24(sp)
    800043ca:	6742                	ld	a4,16(sp)
    800043cc:	e798                	sd	a4,8(a5)
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    800043ce:	67e2                	ld	a5,24(sp)
    800043d0:	6762                	ld	a4,24(sp)
    800043d2:	f398                	sd	a4,32(a5)
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    800043d4:	00009797          	auipc	a5,0x9
    800043d8:	9bc78793          	addi	a5,a5,-1604 # 8000cd90 <pxCurrentTimerList>
    800043dc:	6398                	ld	a4,0(a5)
    800043de:	67e2                	ld	a5,24(sp)
    800043e0:	07a1                	addi	a5,a5,8
    800043e2:	85be                	mv	a1,a5
    800043e4:	853a                	mv	a0,a4
    800043e6:	b0efc0ef          	jal	ra,800006f4 <vListInsert>
    800043ea:	a831                	j	80004406 <prvSwitchTimerLists+0x96>
                }
                else
                {
                    xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    800043ec:	4701                	li	a4,0
    800043ee:	4681                	li	a3,0
    800043f0:	7602                	ld	a2,32(sp)
    800043f2:	4581                	li	a1,0
    800043f4:	6562                	ld	a0,24(sp)
    800043f6:	a4bff0ef          	jal	ra,80003e40 <xTimerGenericCommand>
    800043fa:	e42a                	sd	a0,8(sp)
                    configASSERT( xResult );
    800043fc:	67a2                	ld	a5,8(sp)
    800043fe:	e781                	bnez	a5,80004406 <prvSwitchTimerLists+0x96>
    80004400:	30047073          	csrci	mstatus,8
    80004404:	a001                	j	80004404 <prvSwitchTimerLists+0x94>
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    80004406:	00009797          	auipc	a5,0x9
    8000440a:	98a78793          	addi	a5,a5,-1654 # 8000cd90 <pxCurrentTimerList>
    8000440e:	639c                	ld	a5,0(a5)
    80004410:	639c                	ld	a5,0(a5)
    80004412:	f3b5                	bnez	a5,80004376 <prvSwitchTimerLists+0x6>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        pxTemp = pxCurrentTimerList;
    80004414:	00009797          	auipc	a5,0x9
    80004418:	97c78793          	addi	a5,a5,-1668 # 8000cd90 <pxCurrentTimerList>
    8000441c:	639c                	ld	a5,0(a5)
    8000441e:	f43e                	sd	a5,40(sp)
        pxCurrentTimerList = pxOverflowTimerList;
    80004420:	00009797          	auipc	a5,0x9
    80004424:	97878793          	addi	a5,a5,-1672 # 8000cd98 <pxOverflowTimerList>
    80004428:	6398                	ld	a4,0(a5)
    8000442a:	00009797          	auipc	a5,0x9
    8000442e:	96678793          	addi	a5,a5,-1690 # 8000cd90 <pxCurrentTimerList>
    80004432:	e398                	sd	a4,0(a5)
        pxOverflowTimerList = pxTemp;
    80004434:	00009797          	auipc	a5,0x9
    80004438:	96478793          	addi	a5,a5,-1692 # 8000cd98 <pxOverflowTimerList>
    8000443c:	7722                	ld	a4,40(sp)
    8000443e:	e398                	sd	a4,0(a5)
    }
    80004440:	0001                	nop
    80004442:	70e2                	ld	ra,56(sp)
    80004444:	6121                	addi	sp,sp,64
    80004446:	8082                	ret

0000000080004448 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    80004448:	1141                	addi	sp,sp,-16
    8000444a:	e406                	sd	ra,8(sp)
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    8000444c:	f81fe0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            if( xTimerQueue == NULL )
    80004450:	00009797          	auipc	a5,0x9
    80004454:	95078793          	addi	a5,a5,-1712 # 8000cda0 <xTimerQueue>
    80004458:	639c                	ld	a5,0(a5)
    8000445a:	efa5                	bnez	a5,800044d2 <prvCheckForValidListAndQueue+0x8a>
            {
                vListInitialise( &xActiveTimerList1 );
    8000445c:	00009517          	auipc	a0,0x9
    80004460:	8e450513          	addi	a0,a0,-1820 # 8000cd40 <xActiveTimerList1>
    80004464:	a0cfc0ef          	jal	ra,80000670 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    80004468:	00009517          	auipc	a0,0x9
    8000446c:	90050513          	addi	a0,a0,-1792 # 8000cd68 <xActiveTimerList2>
    80004470:	a00fc0ef          	jal	ra,80000670 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    80004474:	00009797          	auipc	a5,0x9
    80004478:	91c78793          	addi	a5,a5,-1764 # 8000cd90 <pxCurrentTimerList>
    8000447c:	00009717          	auipc	a4,0x9
    80004480:	8c470713          	addi	a4,a4,-1852 # 8000cd40 <xActiveTimerList1>
    80004484:	e398                	sd	a4,0(a5)
                pxOverflowTimerList = &xActiveTimerList2;
    80004486:	00009797          	auipc	a5,0x9
    8000448a:	91278793          	addi	a5,a5,-1774 # 8000cd98 <pxOverflowTimerList>
    8000448e:	00009717          	auipc	a4,0x9
    80004492:	8da70713          	addi	a4,a4,-1830 # 8000cd68 <xActiveTimerList2>
    80004496:	e398                	sd	a4,0(a5)

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    80004498:	4601                	li	a2,0
    8000449a:	45e1                	li	a1,24
    8000449c:	4509                	li	a0,2
    8000449e:	bbafc0ef          	jal	ra,80000858 <xQueueGenericCreate>
    800044a2:	872a                	mv	a4,a0
    800044a4:	00009797          	auipc	a5,0x9
    800044a8:	8fc78793          	addi	a5,a5,-1796 # 8000cda0 <xTimerQueue>
    800044ac:	e398                	sd	a4,0(a5)
                    }
                #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */

                #if ( configQUEUE_REGISTRY_SIZE > 0 )
                    {
                        if( xTimerQueue != NULL )
    800044ae:	00009797          	auipc	a5,0x9
    800044b2:	8f278793          	addi	a5,a5,-1806 # 8000cda0 <xTimerQueue>
    800044b6:	639c                	ld	a5,0(a5)
    800044b8:	cf89                	beqz	a5,800044d2 <prvCheckForValidListAndQueue+0x8a>
                        {
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    800044ba:	00009797          	auipc	a5,0x9
    800044be:	8e678793          	addi	a5,a5,-1818 # 8000cda0 <xTimerQueue>
    800044c2:	639c                	ld	a5,0(a5)
    800044c4:	00005597          	auipc	a1,0x5
    800044c8:	ef458593          	addi	a1,a1,-268 # 800093b8 <__rodata_start+0x60>
    800044cc:	853e                	mv	a0,a5
    800044ce:	9f8fd0ef          	jal	ra,800016c6 <vQueueAddToRegistry>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    800044d2:	f29fe0ef          	jal	ra,800033fa <vTaskExitCritical>
    }
    800044d6:	0001                	nop
    800044d8:	60a2                	ld	ra,8(sp)
    800044da:	0141                	addi	sp,sp,16
    800044dc:	8082                	ret

00000000800044de <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    800044de:	7179                	addi	sp,sp,-48
    800044e0:	f406                	sd	ra,40(sp)
    800044e2:	e42a                	sd	a0,8(sp)
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    800044e4:	67a2                	ld	a5,8(sp)
    800044e6:	e83e                	sd	a5,16(sp)

        configASSERT( xTimer );
    800044e8:	67a2                	ld	a5,8(sp)
    800044ea:	e781                	bnez	a5,800044f2 <xTimerIsTimerActive+0x14>
    800044ec:	30047073          	csrci	mstatus,8
    800044f0:	a001                	j	800044f0 <xTimerIsTimerActive+0x12>

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    800044f2:	edbfe0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    800044f6:	67c2                	ld	a5,16(sp)
    800044f8:	0507c783          	lbu	a5,80(a5)
    800044fc:	2781                	sext.w	a5,a5
    800044fe:	8b85                	andi	a5,a5,1
    80004500:	2781                	sext.w	a5,a5
    80004502:	e399                	bnez	a5,80004508 <xTimerIsTimerActive+0x2a>
            {
                xReturn = pdFALSE;
    80004504:	ec02                	sd	zero,24(sp)
    80004506:	a019                	j	8000450c <xTimerIsTimerActive+0x2e>
            }
            else
            {
                xReturn = pdTRUE;
    80004508:	4785                	li	a5,1
    8000450a:	ec3e                	sd	a5,24(sp)
            }
        }
        taskEXIT_CRITICAL();
    8000450c:	eeffe0ef          	jal	ra,800033fa <vTaskExitCritical>

        return xReturn;
    80004510:	67e2                	ld	a5,24(sp)
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    80004512:	853e                	mv	a0,a5
    80004514:	70a2                	ld	ra,40(sp)
    80004516:	6145                	addi	sp,sp,48
    80004518:	8082                	ret

000000008000451a <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    8000451a:	7179                	addi	sp,sp,-48
    8000451c:	f406                	sd	ra,40(sp)
    8000451e:	e42a                	sd	a0,8(sp)
        Timer_t * const pxTimer = xTimer;
    80004520:	67a2                	ld	a5,8(sp)
    80004522:	ec3e                	sd	a5,24(sp)
        void * pvReturn;

        configASSERT( xTimer );
    80004524:	67a2                	ld	a5,8(sp)
    80004526:	e781                	bnez	a5,8000452e <pvTimerGetTimerID+0x14>
    80004528:	30047073          	csrci	mstatus,8
    8000452c:	a001                	j	8000452c <pvTimerGetTimerID+0x12>

        taskENTER_CRITICAL();
    8000452e:	e9ffe0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            pvReturn = pxTimer->pvTimerID;
    80004532:	67e2                	ld	a5,24(sp)
    80004534:	7f9c                	ld	a5,56(a5)
    80004536:	e83e                	sd	a5,16(sp)
        }
        taskEXIT_CRITICAL();
    80004538:	ec3fe0ef          	jal	ra,800033fa <vTaskExitCritical>

        return pvReturn;
    8000453c:	67c2                	ld	a5,16(sp)
    }
    8000453e:	853e                	mv	a0,a5
    80004540:	70a2                	ld	ra,40(sp)
    80004542:	6145                	addi	sp,sp,48
    80004544:	8082                	ret

0000000080004546 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    80004546:	7179                	addi	sp,sp,-48
    80004548:	f406                	sd	ra,40(sp)
    8000454a:	e42a                	sd	a0,8(sp)
    8000454c:	e02e                	sd	a1,0(sp)
        Timer_t * const pxTimer = xTimer;
    8000454e:	67a2                	ld	a5,8(sp)
    80004550:	ec3e                	sd	a5,24(sp)

        configASSERT( xTimer );
    80004552:	67a2                	ld	a5,8(sp)
    80004554:	e781                	bnez	a5,8000455c <vTimerSetTimerID+0x16>
    80004556:	30047073          	csrci	mstatus,8
    8000455a:	a001                	j	8000455a <vTimerSetTimerID+0x14>

        taskENTER_CRITICAL();
    8000455c:	e71fe0ef          	jal	ra,800033cc <vTaskEnterCritical>
        {
            pxTimer->pvTimerID = pvNewID;
    80004560:	67e2                	ld	a5,24(sp)
    80004562:	6702                	ld	a4,0(sp)
    80004564:	ff98                	sd	a4,56(a5)
        }
        taskEXIT_CRITICAL();
    80004566:	e95fe0ef          	jal	ra,800033fa <vTaskExitCritical>
    }
    8000456a:	0001                	nop
    8000456c:	70a2                	ld	ra,40(sp)
    8000456e:	6145                	addi	sp,sp,48
    80004570:	8082                	ret

0000000080004572 <uxTimerGetTimerNumber>:
/*-----------------------------------------------------------*/

    #if ( configUSE_TRACE_FACILITY == 1 )

        UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
        {
    80004572:	1141                	addi	sp,sp,-16
    80004574:	e42a                	sd	a0,8(sp)
            return ( ( Timer_t * ) xTimer )->uxTimerNumber;
    80004576:	67a2                	ld	a5,8(sp)
    80004578:	67bc                	ld	a5,72(a5)
        }
    8000457a:	853e                	mv	a0,a5
    8000457c:	0141                	addi	sp,sp,16
    8000457e:	8082                	ret

0000000080004580 <vTimerSetTimerNumber>:

    #if ( configUSE_TRACE_FACILITY == 1 )

        void vTimerSetTimerNumber( TimerHandle_t xTimer,
                                   UBaseType_t uxTimerNumber )
        {
    80004580:	1141                	addi	sp,sp,-16
    80004582:	e42a                	sd	a0,8(sp)
    80004584:	e02e                	sd	a1,0(sp)
            ( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
    80004586:	67a2                	ld	a5,8(sp)
    80004588:	6702                	ld	a4,0(sp)
    8000458a:	e7b8                	sd	a4,72(a5)
        }
    8000458c:	0001                	nop
    8000458e:	0141                	addi	sp,sp,16
    80004590:	8082                	ret

0000000080004592 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    80004592:	1101                	addi	sp,sp,-32
    80004594:	ec06                	sd	ra,24(sp)
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    80004596:	03800513          	li	a0,56
    8000459a:	4c6000ef          	jal	ra,80004a60 <pvPortMalloc>
    8000459e:	e42a                	sd	a0,8(sp)

        if( pxEventBits != NULL )
    800045a0:	67a2                	ld	a5,8(sp)
    800045a2:	cb89                	beqz	a5,800045b4 <xEventGroupCreate+0x22>
        {
            pxEventBits->uxEventBits = 0;
    800045a4:	67a2                	ld	a5,8(sp)
    800045a6:	0007b023          	sd	zero,0(a5)
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    800045aa:	67a2                	ld	a5,8(sp)
    800045ac:	07a1                	addi	a5,a5,8
    800045ae:	853e                	mv	a0,a5
    800045b0:	8c0fc0ef          	jal	ra,80000670 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    800045b4:	67a2                	ld	a5,8(sp)
    }
    800045b6:	853e                	mv	a0,a5
    800045b8:	60e2                	ld	ra,24(sp)
    800045ba:	6105                	addi	sp,sp,32
    800045bc:	8082                	ret

00000000800045be <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    800045be:	711d                	addi	sp,sp,-96
    800045c0:	ec86                	sd	ra,88(sp)
    800045c2:	ec2a                	sd	a0,24(sp)
    800045c4:	e82e                	sd	a1,16(sp)
    800045c6:	e432                	sd	a2,8(sp)
    800045c8:	e036                	sd	a3,0(sp)
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    800045ca:	67e2                	ld	a5,24(sp)
    800045cc:	e0be                	sd	a5,64(sp)
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    800045ce:	fc02                	sd	zero,56(sp)

    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    800045d0:	6722                	ld	a4,8(sp)
    800045d2:	0ff00793          	li	a5,255
    800045d6:	07e2                	slli	a5,a5,0x18
    800045d8:	8ff9                	and	a5,a5,a4
    800045da:	c781                	beqz	a5,800045e2 <xEventGroupSync+0x24>
    800045dc:	30047073          	csrci	mstatus,8
    800045e0:	a001                	j	800045e0 <xEventGroupSync+0x22>
    configASSERT( uxBitsToWaitFor != 0 );
    800045e2:	67a2                	ld	a5,8(sp)
    800045e4:	e781                	bnez	a5,800045ec <xEventGroupSync+0x2e>
    800045e6:	30047073          	csrci	mstatus,8
    800045ea:	a001                	j	800045ea <xEventGroupSync+0x2c>
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    800045ec:	a75fe0ef          	jal	ra,80003060 <xTaskGetSchedulerState>
    800045f0:	87aa                	mv	a5,a0
    800045f2:	e399                	bnez	a5,800045f8 <xEventGroupSync+0x3a>
    800045f4:	6782                	ld	a5,0(sp)
    800045f6:	e399                	bnez	a5,800045fc <xEventGroupSync+0x3e>
    800045f8:	4785                	li	a5,1
    800045fa:	a011                	j	800045fe <xEventGroupSync+0x40>
    800045fc:	4781                	li	a5,0
    800045fe:	e781                	bnez	a5,80004606 <xEventGroupSync+0x48>
    80004600:	30047073          	csrci	mstatus,8
    80004604:	a001                	j	80004604 <xEventGroupSync+0x46>
        }
    #endif

    vTaskSuspendAll();
    80004606:	d3ffd0ef          	jal	ra,80002344 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    8000460a:	6786                	ld	a5,64(sp)
    8000460c:	639c                	ld	a5,0(a5)
    8000460e:	f83e                	sd	a5,48(sp)

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    80004610:	65c2                	ld	a1,16(sp)
    80004612:	6562                	ld	a0,24(sp)
    80004614:	266000ef          	jal	ra,8000487a <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    80004618:	7742                	ld	a4,48(sp)
    8000461a:	67c2                	ld	a5,16(sp)
    8000461c:	8f5d                	or	a4,a4,a5
    8000461e:	67a2                	ld	a5,8(sp)
    80004620:	8ff9                	and	a5,a5,a4
    80004622:	6722                	ld	a4,8(sp)
    80004624:	02f71063          	bne	a4,a5,80004644 <xEventGroupSync+0x86>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    80004628:	7742                	ld	a4,48(sp)
    8000462a:	67c2                	ld	a5,16(sp)
    8000462c:	8fd9                	or	a5,a5,a4
    8000462e:	e4be                	sd	a5,72(sp)

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    80004630:	6786                	ld	a5,64(sp)
    80004632:	6398                	ld	a4,0(a5)
    80004634:	67a2                	ld	a5,8(sp)
    80004636:	fff7c793          	not	a5,a5
    8000463a:	8f7d                	and	a4,a4,a5
    8000463c:	6786                	ld	a5,64(sp)
    8000463e:	e398                	sd	a4,0(a5)

            xTicksToWait = 0;
    80004640:	e002                	sd	zero,0(sp)
    80004642:	a035                	j	8000466e <xEventGroupSync+0xb0>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    80004644:	6782                	ld	a5,0(sp)
    80004646:	cf99                	beqz	a5,80004664 <xEventGroupSync+0xa6>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    80004648:	6786                	ld	a5,64(sp)
    8000464a:	00878693          	addi	a3,a5,8
    8000464e:	6722                	ld	a4,8(sp)
    80004650:	050007b7          	lui	a5,0x5000
    80004654:	8fd9                	or	a5,a5,a4
    80004656:	6602                	ld	a2,0(sp)
    80004658:	85be                	mv	a1,a5
    8000465a:	8536                	mv	a0,a3
    8000465c:	b4afe0ef          	jal	ra,800029a6 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    80004660:	e482                	sd	zero,72(sp)
    80004662:	a031                	j	8000466e <xEventGroupSync+0xb0>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    80004664:	6786                	ld	a5,64(sp)
    80004666:	639c                	ld	a5,0(a5)
    80004668:	e4be                	sd	a5,72(sp)
                xTimeoutOccurred = pdTRUE;
    8000466a:	4785                	li	a5,1
    8000466c:	fc3e                	sd	a5,56(sp)
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    8000466e:	cf3fd0ef          	jal	ra,80002360 <xTaskResumeAll>
    80004672:	f42a                	sd	a0,40(sp)

    if( xTicksToWait != ( TickType_t ) 0 )
    80004674:	6782                	ld	a5,0(sp)
    80004676:	cbb9                	beqz	a5,800046cc <xEventGroupSync+0x10e>
    {
        if( xAlreadyYielded == pdFALSE )
    80004678:	77a2                	ld	a5,40(sp)
    8000467a:	e399                	bnez	a5,80004680 <xEventGroupSync+0xc2>
        {
            portYIELD_WITHIN_API();
    8000467c:	00000073          	ecall

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    80004680:	dbbfe0ef          	jal	ra,8000343a <uxTaskResetEventItemValue>
    80004684:	e4aa                	sd	a0,72(sp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    80004686:	6726                	ld	a4,72(sp)
    80004688:	020007b7          	lui	a5,0x2000
    8000468c:	8ff9                	and	a5,a5,a4
    8000468e:	eb85                	bnez	a5,800046be <xEventGroupSync+0x100>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    80004690:	d3dfe0ef          	jal	ra,800033cc <vTaskEnterCritical>
            {
                uxReturn = pxEventBits->uxEventBits;
    80004694:	6786                	ld	a5,64(sp)
    80004696:	639c                	ld	a5,0(a5)
    80004698:	e4be                	sd	a5,72(sp)

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    8000469a:	6726                	ld	a4,72(sp)
    8000469c:	67a2                	ld	a5,8(sp)
    8000469e:	8ff9                	and	a5,a5,a4
    800046a0:	6722                	ld	a4,8(sp)
    800046a2:	00f71a63          	bne	a4,a5,800046b6 <xEventGroupSync+0xf8>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    800046a6:	6786                	ld	a5,64(sp)
    800046a8:	6398                	ld	a4,0(a5)
    800046aa:	67a2                	ld	a5,8(sp)
    800046ac:	fff7c793          	not	a5,a5
    800046b0:	8f7d                	and	a4,a4,a5
    800046b2:	6786                	ld	a5,64(sp)
    800046b4:	e398                	sd	a4,0(a5)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    800046b6:	d45fe0ef          	jal	ra,800033fa <vTaskExitCritical>

            xTimeoutOccurred = pdTRUE;
    800046ba:	4785                	li	a5,1
    800046bc:	fc3e                	sd	a5,56(sp)
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    800046be:	6726                	ld	a4,72(sp)
    800046c0:	f0100793          	li	a5,-255
    800046c4:	07e2                	slli	a5,a5,0x18
    800046c6:	17fd                	addi	a5,a5,-1
    800046c8:	8ff9                	and	a5,a5,a4
    800046ca:	e4be                	sd	a5,72(sp)
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    800046cc:	67a6                	ld	a5,72(sp)
}
    800046ce:	853e                	mv	a0,a5
    800046d0:	60e6                	ld	ra,88(sp)
    800046d2:	6125                	addi	sp,sp,96
    800046d4:	8082                	ret

00000000800046d6 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    800046d6:	7119                	addi	sp,sp,-128
    800046d8:	fc86                	sd	ra,120(sp)
    800046da:	f42a                	sd	a0,40(sp)
    800046dc:	f02e                	sd	a1,32(sp)
    800046de:	ec32                	sd	a2,24(sp)
    800046e0:	e836                	sd	a3,16(sp)
    800046e2:	e43a                	sd	a4,8(sp)
    EventGroup_t * pxEventBits = xEventGroup;
    800046e4:	77a2                	ld	a5,40(sp)
    800046e6:	ecbe                	sd	a5,88(sp)
    EventBits_t uxReturn, uxControlBits = 0;
    800046e8:	f082                	sd	zero,96(sp)
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    800046ea:	e882                	sd	zero,80(sp)

    /* Check the user is not attempting to wait on the bits used by the kernel
     * itself, and that at least one bit is being requested. */
    configASSERT( xEventGroup );
    800046ec:	77a2                	ld	a5,40(sp)
    800046ee:	e781                	bnez	a5,800046f6 <xEventGroupWaitBits+0x20>
    800046f0:	30047073          	csrci	mstatus,8
    800046f4:	a001                	j	800046f4 <xEventGroupWaitBits+0x1e>
    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    800046f6:	7702                	ld	a4,32(sp)
    800046f8:	0ff00793          	li	a5,255
    800046fc:	07e2                	slli	a5,a5,0x18
    800046fe:	8ff9                	and	a5,a5,a4
    80004700:	c781                	beqz	a5,80004708 <xEventGroupWaitBits+0x32>
    80004702:	30047073          	csrci	mstatus,8
    80004706:	a001                	j	80004706 <xEventGroupWaitBits+0x30>
    configASSERT( uxBitsToWaitFor != 0 );
    80004708:	7782                	ld	a5,32(sp)
    8000470a:	e781                	bnez	a5,80004712 <xEventGroupWaitBits+0x3c>
    8000470c:	30047073          	csrci	mstatus,8
    80004710:	a001                	j	80004710 <xEventGroupWaitBits+0x3a>
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    80004712:	94ffe0ef          	jal	ra,80003060 <xTaskGetSchedulerState>
    80004716:	87aa                	mv	a5,a0
    80004718:	e399                	bnez	a5,8000471e <xEventGroupWaitBits+0x48>
    8000471a:	67a2                	ld	a5,8(sp)
    8000471c:	e399                	bnez	a5,80004722 <xEventGroupWaitBits+0x4c>
    8000471e:	4785                	li	a5,1
    80004720:	a011                	j	80004724 <xEventGroupWaitBits+0x4e>
    80004722:	4781                	li	a5,0
    80004724:	e781                	bnez	a5,8000472c <xEventGroupWaitBits+0x56>
    80004726:	30047073          	csrci	mstatus,8
    8000472a:	a001                	j	8000472a <xEventGroupWaitBits+0x54>
        }
    #endif

    vTaskSuspendAll();
    8000472c:	c19fd0ef          	jal	ra,80002344 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    80004730:	67e6                	ld	a5,88(sp)
    80004732:	639c                	ld	a5,0(a5)
    80004734:	e4be                	sd	a5,72(sp)

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    80004736:	6642                	ld	a2,16(sp)
    80004738:	7582                	ld	a1,32(sp)
    8000473a:	6526                	ld	a0,72(sp)
    8000473c:	2c0000ef          	jal	ra,800049fc <prvTestWaitCondition>
    80004740:	e0aa                	sd	a0,64(sp)

        if( xWaitConditionMet != pdFALSE )
    80004742:	6786                	ld	a5,64(sp)
    80004744:	cf99                	beqz	a5,80004762 <xEventGroupWaitBits+0x8c>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    80004746:	67a6                	ld	a5,72(sp)
    80004748:	f4be                	sd	a5,104(sp)
            xTicksToWait = ( TickType_t ) 0;
    8000474a:	e402                	sd	zero,8(sp)

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    8000474c:	67e2                	ld	a5,24(sp)
    8000474e:	cbb9                	beqz	a5,800047a4 <xEventGroupWaitBits+0xce>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    80004750:	67e6                	ld	a5,88(sp)
    80004752:	6398                	ld	a4,0(a5)
    80004754:	7782                	ld	a5,32(sp)
    80004756:	fff7c793          	not	a5,a5
    8000475a:	8f7d                	and	a4,a4,a5
    8000475c:	67e6                	ld	a5,88(sp)
    8000475e:	e398                	sd	a4,0(a5)
    80004760:	a091                	j	800047a4 <xEventGroupWaitBits+0xce>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    80004762:	67a2                	ld	a5,8(sp)
    80004764:	e791                	bnez	a5,80004770 <xEventGroupWaitBits+0x9a>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    80004766:	67a6                	ld	a5,72(sp)
    80004768:	f4be                	sd	a5,104(sp)
            xTimeoutOccurred = pdTRUE;
    8000476a:	4785                	li	a5,1
    8000476c:	e8be                	sd	a5,80(sp)
    8000476e:	a81d                	j	800047a4 <xEventGroupWaitBits+0xce>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    80004770:	67e2                	ld	a5,24(sp)
    80004772:	c791                	beqz	a5,8000477e <xEventGroupWaitBits+0xa8>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    80004774:	7706                	ld	a4,96(sp)
    80004776:	010007b7          	lui	a5,0x1000
    8000477a:	8fd9                	or	a5,a5,a4
    8000477c:	f0be                	sd	a5,96(sp)
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    8000477e:	67c2                	ld	a5,16(sp)
    80004780:	c791                	beqz	a5,8000478c <xEventGroupWaitBits+0xb6>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    80004782:	7706                	ld	a4,96(sp)
    80004784:	040007b7          	lui	a5,0x4000
    80004788:	8fd9                	or	a5,a5,a4
    8000478a:	f0be                	sd	a5,96(sp)
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    8000478c:	67e6                	ld	a5,88(sp)
    8000478e:	00878693          	addi	a3,a5,8 # 4000008 <_STACK_SIZE+0x3fec008>
    80004792:	7702                	ld	a4,32(sp)
    80004794:	7786                	ld	a5,96(sp)
    80004796:	8fd9                	or	a5,a5,a4
    80004798:	6622                	ld	a2,8(sp)
    8000479a:	85be                	mv	a1,a5
    8000479c:	8536                	mv	a0,a3
    8000479e:	a08fe0ef          	jal	ra,800029a6 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    800047a2:	f482                	sd	zero,104(sp)

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    800047a4:	bbdfd0ef          	jal	ra,80002360 <xTaskResumeAll>
    800047a8:	fc2a                	sd	a0,56(sp)

    if( xTicksToWait != ( TickType_t ) 0 )
    800047aa:	67a2                	ld	a5,8(sp)
    800047ac:	cfb1                	beqz	a5,80004808 <xEventGroupWaitBits+0x132>
    {
        if( xAlreadyYielded == pdFALSE )
    800047ae:	77e2                	ld	a5,56(sp)
    800047b0:	e399                	bnez	a5,800047b6 <xEventGroupWaitBits+0xe0>
        {
            portYIELD_WITHIN_API();
    800047b2:	00000073          	ecall

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    800047b6:	c85fe0ef          	jal	ra,8000343a <uxTaskResetEventItemValue>
    800047ba:	f4aa                	sd	a0,104(sp)

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    800047bc:	7726                	ld	a4,104(sp)
    800047be:	020007b7          	lui	a5,0x2000
    800047c2:	8ff9                	and	a5,a5,a4
    800047c4:	eb9d                	bnez	a5,800047fa <xEventGroupWaitBits+0x124>
        {
            taskENTER_CRITICAL();
    800047c6:	c07fe0ef          	jal	ra,800033cc <vTaskEnterCritical>
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    800047ca:	67e6                	ld	a5,88(sp)
    800047cc:	639c                	ld	a5,0(a5)
    800047ce:	f4be                	sd	a5,104(sp)

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    800047d0:	6642                	ld	a2,16(sp)
    800047d2:	7582                	ld	a1,32(sp)
    800047d4:	7526                	ld	a0,104(sp)
    800047d6:	226000ef          	jal	ra,800049fc <prvTestWaitCondition>
    800047da:	87aa                	mv	a5,a0
    800047dc:	cb99                	beqz	a5,800047f2 <xEventGroupWaitBits+0x11c>
                {
                    if( xClearOnExit != pdFALSE )
    800047de:	67e2                	ld	a5,24(sp)
    800047e0:	cb89                	beqz	a5,800047f2 <xEventGroupWaitBits+0x11c>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    800047e2:	67e6                	ld	a5,88(sp)
    800047e4:	6398                	ld	a4,0(a5)
    800047e6:	7782                	ld	a5,32(sp)
    800047e8:	fff7c793          	not	a5,a5
    800047ec:	8f7d                	and	a4,a4,a5
    800047ee:	67e6                	ld	a5,88(sp)
    800047f0:	e398                	sd	a4,0(a5)
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    800047f2:	4785                	li	a5,1
    800047f4:	e8be                	sd	a5,80(sp)
            }
            taskEXIT_CRITICAL();
    800047f6:	c05fe0ef          	jal	ra,800033fa <vTaskExitCritical>
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    800047fa:	7726                	ld	a4,104(sp)
    800047fc:	f0100793          	li	a5,-255
    80004800:	07e2                	slli	a5,a5,0x18
    80004802:	17fd                	addi	a5,a5,-1
    80004804:	8ff9                	and	a5,a5,a4
    80004806:	f4be                	sd	a5,104(sp)
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    80004808:	77a6                	ld	a5,104(sp)
}
    8000480a:	853e                	mv	a0,a5
    8000480c:	70e6                	ld	ra,120(sp)
    8000480e:	6109                	addi	sp,sp,128
    80004810:	8082                	ret

0000000080004812 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    80004812:	7179                	addi	sp,sp,-48
    80004814:	f406                	sd	ra,40(sp)
    80004816:	e42a                	sd	a0,8(sp)
    80004818:	e02e                	sd	a1,0(sp)
    EventGroup_t * pxEventBits = xEventGroup;
    8000481a:	67a2                	ld	a5,8(sp)
    8000481c:	ec3e                	sd	a5,24(sp)
    EventBits_t uxReturn;

    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    8000481e:	67a2                	ld	a5,8(sp)
    80004820:	e781                	bnez	a5,80004828 <xEventGroupClearBits+0x16>
    80004822:	30047073          	csrci	mstatus,8
    80004826:	a001                	j	80004826 <xEventGroupClearBits+0x14>
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    80004828:	6702                	ld	a4,0(sp)
    8000482a:	0ff00793          	li	a5,255
    8000482e:	07e2                	slli	a5,a5,0x18
    80004830:	8ff9                	and	a5,a5,a4
    80004832:	c781                	beqz	a5,8000483a <xEventGroupClearBits+0x28>
    80004834:	30047073          	csrci	mstatus,8
    80004838:	a001                	j	80004838 <xEventGroupClearBits+0x26>

    taskENTER_CRITICAL();
    8000483a:	b93fe0ef          	jal	ra,800033cc <vTaskEnterCritical>
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    8000483e:	67e2                	ld	a5,24(sp)
    80004840:	639c                	ld	a5,0(a5)
    80004842:	e83e                	sd	a5,16(sp)

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    80004844:	67e2                	ld	a5,24(sp)
    80004846:	6398                	ld	a4,0(a5)
    80004848:	6782                	ld	a5,0(sp)
    8000484a:	fff7c793          	not	a5,a5
    8000484e:	8f7d                	and	a4,a4,a5
    80004850:	67e2                	ld	a5,24(sp)
    80004852:	e398                	sd	a4,0(a5)
    }
    taskEXIT_CRITICAL();
    80004854:	ba7fe0ef          	jal	ra,800033fa <vTaskExitCritical>

    return uxReturn;
    80004858:	67c2                	ld	a5,16(sp)
}
    8000485a:	853e                	mv	a0,a5
    8000485c:	70a2                	ld	ra,40(sp)
    8000485e:	6145                	addi	sp,sp,48
    80004860:	8082                	ret

0000000080004862 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    80004862:	7179                	addi	sp,sp,-48
    80004864:	e42a                	sd	a0,8(sp)
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    80004866:	67a2                	ld	a5,8(sp)
    80004868:	f43e                	sd	a5,40(sp)
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    8000486a:	f002                	sd	zero,32(sp)
    {
        uxReturn = pxEventBits->uxEventBits;
    8000486c:	77a2                	ld	a5,40(sp)
    8000486e:	639c                	ld	a5,0(a5)
    80004870:	ec3e                	sd	a5,24(sp)
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    80004872:	67e2                	ld	a5,24(sp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    80004874:	853e                	mv	a0,a5
    80004876:	6145                	addi	sp,sp,48
    80004878:	8082                	ret

000000008000487a <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    8000487a:	7159                	addi	sp,sp,-112
    8000487c:	f486                	sd	ra,104(sp)
    8000487e:	e42a                	sd	a0,8(sp)
    80004880:	e02e                	sd	a1,0(sp)
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    80004882:	e882                	sd	zero,80(sp)
    EventGroup_t * pxEventBits = xEventGroup;
    80004884:	67a2                	ld	a5,8(sp)
    80004886:	e0be                	sd	a5,64(sp)
    BaseType_t xMatchFound = pdFALSE;
    80004888:	e482                	sd	zero,72(sp)

    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    8000488a:	67a2                	ld	a5,8(sp)
    8000488c:	e781                	bnez	a5,80004894 <xEventGroupSetBits+0x1a>
    8000488e:	30047073          	csrci	mstatus,8
    80004892:	a001                	j	80004892 <xEventGroupSetBits+0x18>
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    80004894:	6702                	ld	a4,0(sp)
    80004896:	0ff00793          	li	a5,255
    8000489a:	07e2                	slli	a5,a5,0x18
    8000489c:	8ff9                	and	a5,a5,a4
    8000489e:	c781                	beqz	a5,800048a6 <xEventGroupSetBits+0x2c>
    800048a0:	30047073          	csrci	mstatus,8
    800048a4:	a001                	j	800048a4 <xEventGroupSetBits+0x2a>

    pxList = &( pxEventBits->xTasksWaitingForBits );
    800048a6:	6786                	ld	a5,64(sp)
    800048a8:	07a1                	addi	a5,a5,8
    800048aa:	fc3e                	sd	a5,56(sp)
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    800048ac:	77e2                	ld	a5,56(sp)
    800048ae:	07c1                	addi	a5,a5,16
    800048b0:	f83e                	sd	a5,48(sp)
    vTaskSuspendAll();
    800048b2:	a93fd0ef          	jal	ra,80002344 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    800048b6:	77e2                	ld	a5,56(sp)
    800048b8:	6f9c                	ld	a5,24(a5)
    800048ba:	ecbe                	sd	a5,88(sp)

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    800048bc:	6786                	ld	a5,64(sp)
    800048be:	6398                	ld	a4,0(a5)
    800048c0:	6782                	ld	a5,0(sp)
    800048c2:	8f5d                	or	a4,a4,a5
    800048c4:	6786                	ld	a5,64(sp)
    800048c6:	e398                	sd	a4,0(a5)

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    800048c8:	a049                	j	8000494a <xEventGroupSetBits+0xd0>
        {
            pxNext = listGET_NEXT( pxListItem );
    800048ca:	67e6                	ld	a5,88(sp)
    800048cc:	679c                	ld	a5,8(a5)
    800048ce:	f43e                	sd	a5,40(sp)
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    800048d0:	67e6                	ld	a5,88(sp)
    800048d2:	639c                	ld	a5,0(a5)
    800048d4:	f03e                	sd	a5,32(sp)
            xMatchFound = pdFALSE;
    800048d6:	e482                	sd	zero,72(sp)

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    800048d8:	7702                	ld	a4,32(sp)
    800048da:	0ff00793          	li	a5,255
    800048de:	07e2                	slli	a5,a5,0x18
    800048e0:	8ff9                	and	a5,a5,a4
    800048e2:	ec3e                	sd	a5,24(sp)
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    800048e4:	7702                	ld	a4,32(sp)
    800048e6:	f0100793          	li	a5,-255
    800048ea:	07e2                	slli	a5,a5,0x18
    800048ec:	17fd                	addi	a5,a5,-1
    800048ee:	8ff9                	and	a5,a5,a4
    800048f0:	f03e                	sd	a5,32(sp)

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    800048f2:	6762                	ld	a4,24(sp)
    800048f4:	040007b7          	lui	a5,0x4000
    800048f8:	8ff9                	and	a5,a5,a4
    800048fa:	eb89                	bnez	a5,8000490c <xEventGroupSetBits+0x92>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    800048fc:	6786                	ld	a5,64(sp)
    800048fe:	6398                	ld	a4,0(a5)
    80004900:	7782                	ld	a5,32(sp)
    80004902:	8ff9                	and	a5,a5,a4
    80004904:	cf89                	beqz	a5,8000491e <xEventGroupSetBits+0xa4>
                {
                    xMatchFound = pdTRUE;
    80004906:	4785                	li	a5,1
    80004908:	e4be                	sd	a5,72(sp)
    8000490a:	a811                	j	8000491e <xEventGroupSetBits+0xa4>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    8000490c:	6786                	ld	a5,64(sp)
    8000490e:	6398                	ld	a4,0(a5)
    80004910:	7782                	ld	a5,32(sp)
    80004912:	8ff9                	and	a5,a5,a4
    80004914:	7702                	ld	a4,32(sp)
    80004916:	00f71463          	bne	a4,a5,8000491e <xEventGroupSetBits+0xa4>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    8000491a:	4785                	li	a5,1
    8000491c:	e4be                	sd	a5,72(sp)
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    8000491e:	67a6                	ld	a5,72(sp)
    80004920:	c39d                	beqz	a5,80004946 <xEventGroupSetBits+0xcc>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    80004922:	6762                	ld	a4,24(sp)
    80004924:	010007b7          	lui	a5,0x1000
    80004928:	8ff9                	and	a5,a5,a4
    8000492a:	c789                	beqz	a5,80004934 <xEventGroupSetBits+0xba>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    8000492c:	6746                	ld	a4,80(sp)
    8000492e:	7782                	ld	a5,32(sp)
    80004930:	8fd9                	or	a5,a5,a4
    80004932:	e8be                	sd	a5,80(sp)
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    80004934:	6786                	ld	a5,64(sp)
    80004936:	6398                	ld	a4,0(a5)
    80004938:	020007b7          	lui	a5,0x2000
    8000493c:	8fd9                	or	a5,a5,a4
    8000493e:	85be                	mv	a1,a5
    80004940:	6566                	ld	a0,88(sp)
    80004942:	9cefe0ef          	jal	ra,80002b10 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    80004946:	77a2                	ld	a5,40(sp)
    80004948:	ecbe                	sd	a5,88(sp)
        while( pxListItem != pxListEnd )
    8000494a:	6766                	ld	a4,88(sp)
    8000494c:	77c2                	ld	a5,48(sp)
    8000494e:	f6f71ee3          	bne	a4,a5,800048ca <xEventGroupSetBits+0x50>
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    80004952:	6786                	ld	a5,64(sp)
    80004954:	6398                	ld	a4,0(a5)
    80004956:	67c6                	ld	a5,80(sp)
    80004958:	fff7c793          	not	a5,a5
    8000495c:	8f7d                	and	a4,a4,a5
    8000495e:	6786                	ld	a5,64(sp)
    80004960:	e398                	sd	a4,0(a5)
    }
    ( void ) xTaskResumeAll();
    80004962:	9fffd0ef          	jal	ra,80002360 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    80004966:	6786                	ld	a5,64(sp)
    80004968:	639c                	ld	a5,0(a5)
}
    8000496a:	853e                	mv	a0,a5
    8000496c:	70a6                	ld	ra,104(sp)
    8000496e:	6165                	addi	sp,sp,112
    80004970:	8082                	ret

0000000080004972 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    80004972:	7179                	addi	sp,sp,-48
    80004974:	f406                	sd	ra,40(sp)
    80004976:	e42a                	sd	a0,8(sp)
    EventGroup_t * pxEventBits = xEventGroup;
    80004978:	67a2                	ld	a5,8(sp)
    8000497a:	ec3e                	sd	a5,24(sp)
    const List_t * pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    8000497c:	67e2                	ld	a5,24(sp)
    8000497e:	07a1                	addi	a5,a5,8
    80004980:	e83e                	sd	a5,16(sp)

    vTaskSuspendAll();
    80004982:	9c3fd0ef          	jal	ra,80002344 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    80004986:	a00d                	j	800049a8 <vEventGroupDelete+0x36>
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
    80004988:	67c2                	ld	a5,16(sp)
    8000498a:	6f98                	ld	a4,24(a5)
    8000498c:	67c2                	ld	a5,16(sp)
    8000498e:	07c1                	addi	a5,a5,16
    80004990:	00f71563          	bne	a4,a5,8000499a <vEventGroupDelete+0x28>
    80004994:	30047073          	csrci	mstatus,8
    80004998:	a001                	j	80004998 <vEventGroupDelete+0x26>
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    8000499a:	67c2                	ld	a5,16(sp)
    8000499c:	6f9c                	ld	a5,24(a5)
    8000499e:	020005b7          	lui	a1,0x2000
    800049a2:	853e                	mv	a0,a5
    800049a4:	96cfe0ef          	jal	ra,80002b10 <vTaskRemoveFromUnorderedEventList>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    800049a8:	67c2                	ld	a5,16(sp)
    800049aa:	639c                	ld	a5,0(a5)
    800049ac:	fff1                	bnez	a5,80004988 <vEventGroupDelete+0x16>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    800049ae:	6562                	ld	a0,24(sp)
    800049b0:	1e2000ef          	jal	ra,80004b92 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    800049b4:	9adfd0ef          	jal	ra,80002360 <xTaskResumeAll>
}
    800049b8:	0001                	nop
    800049ba:	70a2                	ld	ra,40(sp)
    800049bc:	6145                	addi	sp,sp,48
    800049be:	8082                	ret

00000000800049c0 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    800049c0:	1101                	addi	sp,sp,-32
    800049c2:	ec06                	sd	ra,24(sp)
    800049c4:	e42a                	sd	a0,8(sp)
    800049c6:	87ae                	mv	a5,a1
    800049c8:	c23e                	sw	a5,4(sp)
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    800049ca:	00416783          	lwu	a5,4(sp)
    800049ce:	85be                	mv	a1,a5
    800049d0:	6522                	ld	a0,8(sp)
    800049d2:	ea9ff0ef          	jal	ra,8000487a <xEventGroupSetBits>
}
    800049d6:	0001                	nop
    800049d8:	60e2                	ld	ra,24(sp)
    800049da:	6105                	addi	sp,sp,32
    800049dc:	8082                	ret

00000000800049de <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    800049de:	1101                	addi	sp,sp,-32
    800049e0:	ec06                	sd	ra,24(sp)
    800049e2:	e42a                	sd	a0,8(sp)
    800049e4:	87ae                	mv	a5,a1
    800049e6:	c23e                	sw	a5,4(sp)
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    800049e8:	00416783          	lwu	a5,4(sp)
    800049ec:	85be                	mv	a1,a5
    800049ee:	6522                	ld	a0,8(sp)
    800049f0:	e23ff0ef          	jal	ra,80004812 <xEventGroupClearBits>
}
    800049f4:	0001                	nop
    800049f6:	60e2                	ld	ra,24(sp)
    800049f8:	6105                	addi	sp,sp,32
    800049fa:	8082                	ret

00000000800049fc <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    800049fc:	7179                	addi	sp,sp,-48
    800049fe:	ec2a                	sd	a0,24(sp)
    80004a00:	e82e                	sd	a1,16(sp)
    80004a02:	e432                	sd	a2,8(sp)
    BaseType_t xWaitConditionMet = pdFALSE;
    80004a04:	f402                	sd	zero,40(sp)

    if( xWaitForAllBits == pdFALSE )
    80004a06:	67a2                	ld	a5,8(sp)
    80004a08:	eb81                	bnez	a5,80004a18 <prvTestWaitCondition+0x1c>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    80004a0a:	6762                	ld	a4,24(sp)
    80004a0c:	67c2                	ld	a5,16(sp)
    80004a0e:	8ff9                	and	a5,a5,a4
    80004a10:	cf81                	beqz	a5,80004a28 <prvTestWaitCondition+0x2c>
        {
            xWaitConditionMet = pdTRUE;
    80004a12:	4785                	li	a5,1
    80004a14:	f43e                	sd	a5,40(sp)
    80004a16:	a809                	j	80004a28 <prvTestWaitCondition+0x2c>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    80004a18:	6762                	ld	a4,24(sp)
    80004a1a:	67c2                	ld	a5,16(sp)
    80004a1c:	8ff9                	and	a5,a5,a4
    80004a1e:	6742                	ld	a4,16(sp)
    80004a20:	00f71463          	bne	a4,a5,80004a28 <prvTestWaitCondition+0x2c>
        {
            xWaitConditionMet = pdTRUE;
    80004a24:	4785                	li	a5,1
    80004a26:	f43e                	sd	a5,40(sp)
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    80004a28:	77a2                	ld	a5,40(sp)
}
    80004a2a:	853e                	mv	a0,a5
    80004a2c:	6145                	addi	sp,sp,48
    80004a2e:	8082                	ret

0000000080004a30 <uxEventGroupGetNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxEventGroupGetNumber( void * xEventGroup )
    {
    80004a30:	1101                	addi	sp,sp,-32
    80004a32:	e42a                	sd	a0,8(sp)
        UBaseType_t xReturn;
        EventGroup_t const * pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
    80004a34:	67a2                	ld	a5,8(sp)
    80004a36:	e83e                	sd	a5,16(sp)

        if( xEventGroup == NULL )
    80004a38:	67a2                	ld	a5,8(sp)
    80004a3a:	e399                	bnez	a5,80004a40 <uxEventGroupGetNumber+0x10>
        {
            xReturn = 0;
    80004a3c:	ec02                	sd	zero,24(sp)
    80004a3e:	a021                	j	80004a46 <uxEventGroupGetNumber+0x16>
        }
        else
        {
            xReturn = pxEventBits->uxEventGroupNumber;
    80004a40:	67c2                	ld	a5,16(sp)
    80004a42:	7b9c                	ld	a5,48(a5)
    80004a44:	ec3e                	sd	a5,24(sp)
        }

        return xReturn;
    80004a46:	67e2                	ld	a5,24(sp)
    }
    80004a48:	853e                	mv	a0,a5
    80004a4a:	6105                	addi	sp,sp,32
    80004a4c:	8082                	ret

0000000080004a4e <vEventGroupSetNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

    void vEventGroupSetNumber( void * xEventGroup,
                               UBaseType_t uxEventGroupNumber )
    {
    80004a4e:	1141                	addi	sp,sp,-16
    80004a50:	e42a                	sd	a0,8(sp)
    80004a52:	e02e                	sd	a1,0(sp)
        ( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
    80004a54:	67a2                	ld	a5,8(sp)
    80004a56:	6702                	ld	a4,0(sp)
    80004a58:	fb98                	sd	a4,48(a5)
    }
    80004a5a:	0001                	nop
    80004a5c:	0141                	addi	sp,sp,16
    80004a5e:	8082                	ret

0000000080004a60 <pvPortMalloc>:
        pxIterator->pxNextFreeBlock = pxBlockToInsert;                                                                              \
    }
/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    80004a60:	715d                	addi	sp,sp,-80
    80004a62:	e486                	sd	ra,72(sp)
    80004a64:	e42a                	sd	a0,8(sp)
    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
    static BaseType_t xHeapHasBeenInitialised = pdFALSE;
    void * pvReturn = NULL;
    80004a66:	f402                	sd	zero,40(sp)

    vTaskSuspendAll();
    80004a68:	8ddfd0ef          	jal	ra,80002344 <vTaskSuspendAll>
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( xHeapHasBeenInitialised == pdFALSE )
    80004a6c:	00102797          	auipc	a5,0x102
    80004a70:	36c78793          	addi	a5,a5,876 # 80106dd8 <xHeapHasBeenInitialised.1994>
    80004a74:	639c                	ld	a5,0(a5)
    80004a76:	eb89                	bnez	a5,80004a88 <pvPortMalloc+0x28>
        {
            prvHeapInit();
    80004a78:	19a000ef          	jal	ra,80004c12 <prvHeapInit>
            xHeapHasBeenInitialised = pdTRUE;
    80004a7c:	00102797          	auipc	a5,0x102
    80004a80:	35c78793          	addi	a5,a5,860 # 80106dd8 <xHeapHasBeenInitialised.1994>
    80004a84:	4705                	li	a4,1
    80004a86:	e398                	sd	a4,0(a5)
        }

        /* The wanted size is increased so it can contain a BlockLink_t
         * structure in addition to the requested amount of bytes. */
        if( xWantedSize > 0 )
    80004a88:	67a2                	ld	a5,8(sp)
    80004a8a:	cf89                	beqz	a5,80004aa4 <pvPortMalloc+0x44>
        {
            xWantedSize += heapSTRUCT_SIZE;
    80004a8c:	47c1                	li	a5,16
    80004a8e:	873e                	mv	a4,a5
    80004a90:	67a2                	ld	a5,8(sp)
    80004a92:	97ba                	add	a5,a5,a4
    80004a94:	e43e                	sd	a5,8(sp)

            /* Ensure that blocks are always aligned to the required number of bytes. */
            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
    80004a96:	67a2                	ld	a5,8(sp)
    80004a98:	8bbd                	andi	a5,a5,15
    80004a9a:	c789                	beqz	a5,80004aa4 <pvPortMalloc+0x44>
            {
                /* Byte alignment required. */
                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    80004a9c:	67a2                	ld	a5,8(sp)
    80004a9e:	9bc1                	andi	a5,a5,-16
    80004aa0:	07c1                	addi	a5,a5,16
    80004aa2:	e43e                	sd	a5,8(sp)
            }
        }

        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    80004aa4:	67a2                	ld	a5,8(sp)
    80004aa6:	cbf9                	beqz	a5,80004b7c <pvPortMalloc+0x11c>
    80004aa8:	6722                	ld	a4,8(sp)
    80004aaa:	000fa7b7          	lui	a5,0xfa
    80004aae:	17bd                	addi	a5,a5,-17
    80004ab0:	0ce7e663          	bltu	a5,a4,80004b7c <pvPortMalloc+0x11c>
        {
            /* Blocks are stored in byte order - traverse the list from the start
             * (smallest) block until one of adequate size is found. */
            pxPreviousBlock = &xStart;
    80004ab4:	00102797          	auipc	a5,0x102
    80004ab8:	30478793          	addi	a5,a5,772 # 80106db8 <xStart>
    80004abc:	f83e                	sd	a5,48(sp)
            pxBlock = xStart.pxNextFreeBlock;
    80004abe:	00102797          	auipc	a5,0x102
    80004ac2:	2fa78793          	addi	a5,a5,762 # 80106db8 <xStart>
    80004ac6:	639c                	ld	a5,0(a5)
    80004ac8:	fc3e                	sd	a5,56(sp)

            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    80004aca:	a031                	j	80004ad6 <pvPortMalloc+0x76>
            {
                pxPreviousBlock = pxBlock;
    80004acc:	77e2                	ld	a5,56(sp)
    80004ace:	f83e                	sd	a5,48(sp)
                pxBlock = pxBlock->pxNextFreeBlock;
    80004ad0:	77e2                	ld	a5,56(sp)
    80004ad2:	639c                	ld	a5,0(a5)
    80004ad4:	fc3e                	sd	a5,56(sp)
            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    80004ad6:	77e2                	ld	a5,56(sp)
    80004ad8:	679c                	ld	a5,8(a5)
    80004ada:	6722                	ld	a4,8(sp)
    80004adc:	00e7f563          	bgeu	a5,a4,80004ae6 <pvPortMalloc+0x86>
    80004ae0:	77e2                	ld	a5,56(sp)
    80004ae2:	639c                	ld	a5,0(a5)
    80004ae4:	f7e5                	bnez	a5,80004acc <pvPortMalloc+0x6c>
            }

            /* If we found the end marker then a block of adequate size was not found. */
            if( pxBlock != &xEnd )
    80004ae6:	7762                	ld	a4,56(sp)
    80004ae8:	00102797          	auipc	a5,0x102
    80004aec:	2e078793          	addi	a5,a5,736 # 80106dc8 <xEnd>
    80004af0:	08f70663          	beq	a4,a5,80004b7c <pvPortMalloc+0x11c>
            {
                /* Return the memory space - jumping over the BlockLink_t structure
                 * at its start. */
                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    80004af4:	77c2                	ld	a5,48(sp)
    80004af6:	639c                	ld	a5,0(a5)
    80004af8:	4741                	li	a4,16
    80004afa:	97ba                	add	a5,a5,a4
    80004afc:	f43e                	sd	a5,40(sp)

                /* This block is being returned for use so must be taken out of the
                 * list of free blocks. */
                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    80004afe:	77e2                	ld	a5,56(sp)
    80004b00:	6398                	ld	a4,0(a5)
    80004b02:	77c2                	ld	a5,48(sp)
    80004b04:	e398                	sd	a4,0(a5)

                /* If the block is larger than required it can be split into two. */
                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    80004b06:	77e2                	ld	a5,56(sp)
    80004b08:	6798                	ld	a4,8(a5)
    80004b0a:	67a2                	ld	a5,8(sp)
    80004b0c:	40f707b3          	sub	a5,a4,a5
    80004b10:	4741                	li	a4,16
    80004b12:	2701                	sext.w	a4,a4
    80004b14:	0017171b          	slliw	a4,a4,0x1
    80004b18:	2701                	sext.w	a4,a4
    80004b1a:	04f77863          	bgeu	a4,a5,80004b6a <pvPortMalloc+0x10a>
                {
                    /* This block is to be split into two.  Create a new block
                     * following the number of bytes requested. The void cast is
                     * used to prevent byte alignment warnings from the compiler. */
                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    80004b1e:	7762                	ld	a4,56(sp)
    80004b20:	67a2                	ld	a5,8(sp)
    80004b22:	97ba                	add	a5,a5,a4
    80004b24:	ec3e                	sd	a5,24(sp)

                    /* Calculate the sizes of two blocks split from the single
                     * block. */
                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    80004b26:	77e2                	ld	a5,56(sp)
    80004b28:	6798                	ld	a4,8(a5)
    80004b2a:	67a2                	ld	a5,8(sp)
    80004b2c:	8f1d                	sub	a4,a4,a5
    80004b2e:	67e2                	ld	a5,24(sp)
    80004b30:	e798                	sd	a4,8(a5)
                    pxBlock->xBlockSize = xWantedSize;
    80004b32:	77e2                	ld	a5,56(sp)
    80004b34:	6722                	ld	a4,8(sp)
    80004b36:	e798                	sd	a4,8(a5)

                    /* Insert the new block into the list of free blocks. */
                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    80004b38:	67e2                	ld	a5,24(sp)
    80004b3a:	679c                	ld	a5,8(a5)
    80004b3c:	e83e                	sd	a5,16(sp)
    80004b3e:	00102797          	auipc	a5,0x102
    80004b42:	27a78793          	addi	a5,a5,634 # 80106db8 <xStart>
    80004b46:	f03e                	sd	a5,32(sp)
    80004b48:	a021                	j	80004b50 <pvPortMalloc+0xf0>
    80004b4a:	7782                	ld	a5,32(sp)
    80004b4c:	639c                	ld	a5,0(a5)
    80004b4e:	f03e                	sd	a5,32(sp)
    80004b50:	7782                	ld	a5,32(sp)
    80004b52:	639c                	ld	a5,0(a5)
    80004b54:	679c                	ld	a5,8(a5)
    80004b56:	6742                	ld	a4,16(sp)
    80004b58:	fee7e9e3          	bltu	a5,a4,80004b4a <pvPortMalloc+0xea>
    80004b5c:	7782                	ld	a5,32(sp)
    80004b5e:	6398                	ld	a4,0(a5)
    80004b60:	67e2                	ld	a5,24(sp)
    80004b62:	e398                	sd	a4,0(a5)
    80004b64:	7782                	ld	a5,32(sp)
    80004b66:	6762                	ld	a4,24(sp)
    80004b68:	e398                	sd	a4,0(a5)
                }

                xFreeBytesRemaining -= pxBlock->xBlockSize;
    80004b6a:	82818793          	addi	a5,gp,-2008 # 8000ab30 <xFreeBytesRemaining>
    80004b6e:	6398                	ld	a4,0(a5)
    80004b70:	77e2                	ld	a5,56(sp)
    80004b72:	679c                	ld	a5,8(a5)
    80004b74:	8f1d                	sub	a4,a4,a5
    80004b76:	82818793          	addi	a5,gp,-2008 # 8000ab30 <xFreeBytesRemaining>
    80004b7a:	e398                	sd	a4,0(a5)
            }
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    80004b7c:	fe4fd0ef          	jal	ra,80002360 <xTaskResumeAll>

    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
        {
            if( pvReturn == NULL )
    80004b80:	77a2                	ld	a5,40(sp)
    80004b82:	e399                	bnez	a5,80004b88 <pvPortMalloc+0x128>
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
    80004b84:	0bf030ef          	jal	ra,80008442 <vApplicationMallocFailedHook>
            }
        }
    #endif

    return pvReturn;
    80004b88:	77a2                	ld	a5,40(sp)
}
    80004b8a:	853e                	mv	a0,a5
    80004b8c:	60a6                	ld	ra,72(sp)
    80004b8e:	6161                	addi	sp,sp,80
    80004b90:	8082                	ret

0000000080004b92 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    80004b92:	7139                	addi	sp,sp,-64
    80004b94:	fc06                	sd	ra,56(sp)
    80004b96:	e42a                	sd	a0,8(sp)
    uint8_t * puc = ( uint8_t * ) pv;
    80004b98:	67a2                	ld	a5,8(sp)
    80004b9a:	f03e                	sd	a5,32(sp)
    BlockLink_t * pxLink;

    if( pv != NULL )
    80004b9c:	67a2                	ld	a5,8(sp)
    80004b9e:	cfb9                	beqz	a5,80004bfc <vPortFree+0x6a>
    {
        /* The memory being freed will have an BlockLink_t structure immediately
         * before it. */
        puc -= heapSTRUCT_SIZE;
    80004ba0:	47c1                	li	a5,16
    80004ba2:	40f007b3          	neg	a5,a5
    80004ba6:	7702                	ld	a4,32(sp)
    80004ba8:	97ba                	add	a5,a5,a4
    80004baa:	f03e                	sd	a5,32(sp)

        /* This unexpected casting is to keep some compilers from issuing
         * byte alignment warnings. */
        pxLink = ( void * ) puc;
    80004bac:	7782                	ld	a5,32(sp)
    80004bae:	ec3e                	sd	a5,24(sp)

        vTaskSuspendAll();
    80004bb0:	f94fd0ef          	jal	ra,80002344 <vTaskSuspendAll>
        {
            /* Add this block to the list of free blocks. */
            prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    80004bb4:	67e2                	ld	a5,24(sp)
    80004bb6:	679c                	ld	a5,8(a5)
    80004bb8:	e83e                	sd	a5,16(sp)
    80004bba:	00102797          	auipc	a5,0x102
    80004bbe:	1fe78793          	addi	a5,a5,510 # 80106db8 <xStart>
    80004bc2:	f43e                	sd	a5,40(sp)
    80004bc4:	a021                	j	80004bcc <vPortFree+0x3a>
    80004bc6:	77a2                	ld	a5,40(sp)
    80004bc8:	639c                	ld	a5,0(a5)
    80004bca:	f43e                	sd	a5,40(sp)
    80004bcc:	77a2                	ld	a5,40(sp)
    80004bce:	639c                	ld	a5,0(a5)
    80004bd0:	679c                	ld	a5,8(a5)
    80004bd2:	6742                	ld	a4,16(sp)
    80004bd4:	fee7e9e3          	bltu	a5,a4,80004bc6 <vPortFree+0x34>
    80004bd8:	77a2                	ld	a5,40(sp)
    80004bda:	6398                	ld	a4,0(a5)
    80004bdc:	67e2                	ld	a5,24(sp)
    80004bde:	e398                	sd	a4,0(a5)
    80004be0:	77a2                	ld	a5,40(sp)
    80004be2:	6762                	ld	a4,24(sp)
    80004be4:	e398                	sd	a4,0(a5)
            xFreeBytesRemaining += pxLink->xBlockSize;
    80004be6:	67e2                	ld	a5,24(sp)
    80004be8:	6798                	ld	a4,8(a5)
    80004bea:	82818793          	addi	a5,gp,-2008 # 8000ab30 <xFreeBytesRemaining>
    80004bee:	639c                	ld	a5,0(a5)
    80004bf0:	973e                	add	a4,a4,a5
    80004bf2:	82818793          	addi	a5,gp,-2008 # 8000ab30 <xFreeBytesRemaining>
    80004bf6:	e398                	sd	a4,0(a5)
            traceFREE( pv, pxLink->xBlockSize );
        }
        ( void ) xTaskResumeAll();
    80004bf8:	f68fd0ef          	jal	ra,80002360 <xTaskResumeAll>
    }
}
    80004bfc:	0001                	nop
    80004bfe:	70e2                	ld	ra,56(sp)
    80004c00:	6121                	addi	sp,sp,64
    80004c02:	8082                	ret

0000000080004c04 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    return xFreeBytesRemaining;
    80004c04:	82818793          	addi	a5,gp,-2008 # 8000ab30 <xFreeBytesRemaining>
    80004c08:	639c                	ld	a5,0(a5)
}
    80004c0a:	853e                	mv	a0,a5
    80004c0c:	8082                	ret

0000000080004c0e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    /* This just exists to keep the linker quiet. */
}
    80004c0e:	0001                	nop
    80004c10:	8082                	ret

0000000080004c12 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
    80004c12:	1141                	addi	sp,sp,-16
    BlockLink_t * pxFirstFreeBlock;
    uint8_t * pucAlignedHeap;

    /* Ensure the heap starts on a correctly aligned boundary. */
    pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    80004c14:	00008797          	auipc	a5,0x8
    80004c18:	1b478793          	addi	a5,a5,436 # 8000cdc8 <ucHeap+0x10>
    80004c1c:	9bc1                	andi	a5,a5,-16
    80004c1e:	e43e                	sd	a5,8(sp)

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    80004c20:	00102797          	auipc	a5,0x102
    80004c24:	19878793          	addi	a5,a5,408 # 80106db8 <xStart>
    80004c28:	6722                	ld	a4,8(sp)
    80004c2a:	e398                	sd	a4,0(a5)
    xStart.xBlockSize = ( size_t ) 0;
    80004c2c:	00102797          	auipc	a5,0x102
    80004c30:	18c78793          	addi	a5,a5,396 # 80106db8 <xStart>
    80004c34:	0007b423          	sd	zero,8(a5)

    /* xEnd is used to mark the end of the list of free blocks. */
    xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    80004c38:	00102797          	auipc	a5,0x102
    80004c3c:	19078793          	addi	a5,a5,400 # 80106dc8 <xEnd>
    80004c40:	000fa737          	lui	a4,0xfa
    80004c44:	1741                	addi	a4,a4,-16
    80004c46:	e798                	sd	a4,8(a5)
    xEnd.pxNextFreeBlock = NULL;
    80004c48:	00102797          	auipc	a5,0x102
    80004c4c:	18078793          	addi	a5,a5,384 # 80106dc8 <xEnd>
    80004c50:	0007b023          	sd	zero,0(a5)

    /* To start with there is a single free block that is sized to take up the
     * entire heap space. */
    pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    80004c54:	67a2                	ld	a5,8(sp)
    80004c56:	e03e                	sd	a5,0(sp)
    pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    80004c58:	6782                	ld	a5,0(sp)
    80004c5a:	000fa737          	lui	a4,0xfa
    80004c5e:	1741                	addi	a4,a4,-16
    80004c60:	e798                	sd	a4,8(a5)
    pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    80004c62:	6782                	ld	a5,0(sp)
    80004c64:	00102717          	auipc	a4,0x102
    80004c68:	16470713          	addi	a4,a4,356 # 80106dc8 <xEnd>
    80004c6c:	e398                	sd	a4,0(a5)
}
    80004c6e:	0001                	nop
    80004c70:	0141                	addi	sp,sp,16
    80004c72:	8082                	ret

0000000080004c74 <uart_init>:
 * @brief Initialise UART Array 
 * @details Initialises given number of UART Arrays which has 
 *          complete set of UART registers.
 */
void uart_init()
{
    80004c74:	1141                	addi	sp,sp,-16
	for(int i=0; i< MAX_UART_COUNT; i++)
    80004c76:	c602                	sw	zero,12(sp)
    80004c78:	a025                	j	80004ca0 <uart_init+0x2c>
	{
		uart_instance[i] = (uart_struct*) (UART0_START+i*UART_OFFSET);
    80004c7a:	47b2                	lw	a5,12(sp)
    80004c7c:	1137879b          	addiw	a5,a5,275
    80004c80:	2781                	sext.w	a5,a5
    80004c82:	0087979b          	slliw	a5,a5,0x8
    80004c86:	2781                	sext.w	a5,a5
    80004c88:	86be                	mv	a3,a5
    80004c8a:	00102717          	auipc	a4,0x102
    80004c8e:	1d670713          	addi	a4,a4,470 # 80106e60 <uart_instance>
    80004c92:	47b2                	lw	a5,12(sp)
    80004c94:	078e                	slli	a5,a5,0x3
    80004c96:	97ba                	add	a5,a5,a4
    80004c98:	e394                	sd	a3,0(a5)
	for(int i=0; i< MAX_UART_COUNT; i++)
    80004c9a:	47b2                	lw	a5,12(sp)
    80004c9c:	2785                	addiw	a5,a5,1
    80004c9e:	c63e                	sw	a5,12(sp)
    80004ca0:	47b2                	lw	a5,12(sp)
    80004ca2:	0007871b          	sext.w	a4,a5
    80004ca6:	4789                	li	a5,2
    80004ca8:	fce7d9e3          	bge	a5,a4,80004c7a <uart_init+0x6>
	}
}
    80004cac:	0001                	nop
    80004cae:	0001                	nop
    80004cb0:	0141                	addi	sp,sp,16
    80004cb2:	8082                	ret

0000000080004cb4 <getchar>:
 * @return integer equivalent of the received character.
 */
#undef getchar
int getchar()
{
	while((uart_instance[0]->status & STS_RX_NOT_EMPTY) == 0); 
    80004cb4:	0001                	nop
    80004cb6:	00102797          	auipc	a5,0x102
    80004cba:	1aa78793          	addi	a5,a5,426 # 80106e60 <uart_instance>
    80004cbe:	639c                	ld	a5,0(a5)
    80004cc0:	00c7c783          	lbu	a5,12(a5)
    80004cc4:	2781                	sext.w	a5,a5
    80004cc6:	8b91                	andi	a5,a5,4
    80004cc8:	2781                	sext.w	a5,a5
    80004cca:	d7f5                	beqz	a5,80004cb6 <getchar+0x2>
	return (uart_instance[0]->rcv_reg);
    80004ccc:	00102797          	auipc	a5,0x102
    80004cd0:	19478793          	addi	a5,a5,404 # 80106e60 <uart_instance>
    80004cd4:	639c                	ld	a5,0(a5)
    80004cd6:	479c                	lw	a5,8(a5)
    80004cd8:	2781                	sext.w	a5,a5
}
    80004cda:	853e                	mv	a0,a5
    80004cdc:	8082                	ret

0000000080004cde <putchar>:
 * @param character as int.
 * @return Zero
 */
#undef putchar
int putchar(int ch)
{
    80004cde:	1141                	addi	sp,sp,-16
    80004ce0:	87aa                	mv	a5,a0
    80004ce2:	c63e                	sw	a5,12(sp)
	while(uart_instance[0]->status & STS_TX_FULL);
    80004ce4:	0001                	nop
    80004ce6:	00102797          	auipc	a5,0x102
    80004cea:	17a78793          	addi	a5,a5,378 # 80106e60 <uart_instance>
    80004cee:	639c                	ld	a5,0(a5)
    80004cf0:	00c7c783          	lbu	a5,12(a5)
    80004cf4:	2781                	sext.w	a5,a5
    80004cf6:	8b89                	andi	a5,a5,2
    80004cf8:	2781                	sext.w	a5,a5
    80004cfa:	f7f5                	bnez	a5,80004ce6 <putchar+0x8>

	uart_instance[0]->tx_reg = ch;
    80004cfc:	00102797          	auipc	a5,0x102
    80004d00:	16478793          	addi	a5,a5,356 # 80106e60 <uart_instance>
    80004d04:	639c                	ld	a5,0(a5)
    80004d06:	4732                	lw	a4,12(sp)
    80004d08:	c3d8                	sw	a4,4(a5)

	return 0;
    80004d0a:	4781                	li	a5,0
}
    80004d0c:	853e                	mv	a0,a5
    80004d0e:	0141                	addi	sp,sp,16
    80004d10:	8082                	ret

0000000080004d12 <set_baud_rate>:
 * which in turn used to calculate the baud_count to set the baudrate.
 * @param UART instance
 * @param unsigned int baudrate
 */
void set_baud_rate(uart_struct *instance, unsigned int baudrate)
{
    80004d12:	1101                	addi	sp,sp,-32
    80004d14:	e42a                	sd	a0,8(sp)
    80004d16:	87ae                	mv	a5,a1
    80004d18:	c23e                	sw	a5,4(sp)
	unsigned int baud_count = 0;
    80004d1a:	ce02                	sw	zero,28(sp)
	baud_count = CLOCK_FREQUENCY / (16 * baudrate);
    80004d1c:	4792                	lw	a5,4(sp)
    80004d1e:	0047979b          	slliw	a5,a5,0x4
    80004d22:	2781                	sext.w	a5,a5
    80004d24:	02faf737          	lui	a4,0x2faf
    80004d28:	0807071b          	addiw	a4,a4,128
    80004d2c:	02f757bb          	divuw	a5,a4,a5
    80004d30:	ce3e                	sw	a5,28(sp)
	instance->baud = baud_count;
    80004d32:	47f2                	lw	a5,28(sp)
    80004d34:	03079713          	slli	a4,a5,0x30
    80004d38:	9341                	srli	a4,a4,0x30
    80004d3a:	67a2                	ld	a5,8(sp)
    80004d3c:	00e79023          	sh	a4,0(a5)
}
    80004d40:	0001                	nop
    80004d42:	6105                	addi	sp,sp,32
    80004d44:	8082                	ret

0000000080004d46 <enable_uart_interrupts>:
 * the interrupt's values.
 * @param uart instance 
 * @param unsigned char interrupt
 */
void enable_uart_interrupts(uart_struct * instance, unsigned char interrupt)
{
    80004d46:	1141                	addi	sp,sp,-16
    80004d48:	e42a                	sd	a0,8(sp)
    80004d4a:	87ae                	mv	a5,a1
    80004d4c:	00f103a3          	sb	a5,7(sp)
	instance->ien = interrupt; 
    80004d50:	67a2                	ld	a5,8(sp)
    80004d52:	00714703          	lbu	a4,7(sp)
    80004d56:	00e78c23          	sb	a4,24(a5)
}
    80004d5a:	0001                	nop
    80004d5c:	0141                	addi	sp,sp,16
    80004d5e:	8082                	ret

0000000080004d60 <write_uart_character>:
 * character.
 * @param uart instance
 * @param character.
 */
uint32_t write_uart_character(uart_struct * instance, uint8_t prn_character)
{
    80004d60:	1141                	addi	sp,sp,-16
    80004d62:	e42a                	sd	a0,8(sp)
    80004d64:	87ae                	mv	a5,a1
    80004d66:	00f103a3          	sb	a5,7(sp)
	while(instance->status & STS_TX_FULL);
    80004d6a:	0001                	nop
    80004d6c:	67a2                	ld	a5,8(sp)
    80004d6e:	00c7c783          	lbu	a5,12(a5)
    80004d72:	2781                	sext.w	a5,a5
    80004d74:	8b89                	andi	a5,a5,2
    80004d76:	2781                	sext.w	a5,a5
    80004d78:	fbf5                	bnez	a5,80004d6c <write_uart_character+0xc>

	instance->tx_reg = prn_character;
    80004d7a:	00714783          	lbu	a5,7(sp)
    80004d7e:	0007871b          	sext.w	a4,a5
    80004d82:	67a2                	ld	a5,8(sp)
    80004d84:	c3d8                	sw	a4,4(a5)

	return 0;
    80004d86:	4781                	li	a5,0
}
    80004d88:	853e                	mv	a0,a5
    80004d8a:	0141                	addi	sp,sp,16
    80004d8c:	8082                	ret

0000000080004d8e <write_uart_string>:
 * @param uart instance 
 * @param string.
 * @return Zero
 */
uint32_t write_uart_string(uart_struct * instance, uint8_t * ptr_string)
{
    80004d8e:	7179                	addi	sp,sp,-48
    80004d90:	f406                	sd	ra,40(sp)
    80004d92:	e42a                	sd	a0,8(sp)
    80004d94:	e02e                	sd	a1,0(sp)
	uint32_t i = 0;
    80004d96:	ce02                	sw	zero,28(sp)
	uint8_t temp;

	do
	{
		temp = ptr_string[i++];
    80004d98:	47f2                	lw	a5,28(sp)
    80004d9a:	0017871b          	addiw	a4,a5,1
    80004d9e:	ce3a                	sw	a4,28(sp)
    80004da0:	1782                	slli	a5,a5,0x20
    80004da2:	9381                	srli	a5,a5,0x20
    80004da4:	6702                	ld	a4,0(sp)
    80004da6:	97ba                	add	a5,a5,a4
    80004da8:	0007c783          	lbu	a5,0(a5)
    80004dac:	00f10da3          	sb	a5,27(sp)
		write_uart_character(instance, temp);
    80004db0:	01b14783          	lbu	a5,27(sp)
    80004db4:	85be                	mv	a1,a5
    80004db6:	6522                	ld	a0,8(sp)
    80004db8:	fa9ff0ef          	jal	ra,80004d60 <write_uart_character>
	} while(temp != 0);
    80004dbc:	01b14783          	lbu	a5,27(sp)
    80004dc0:	0ff7f793          	andi	a5,a5,255
    80004dc4:	fbf1                	bnez	a5,80004d98 <write_uart_string+0xa>

	return 0;
    80004dc6:	4781                	li	a5,0
}
    80004dc8:	853e                	mv	a0,a5
    80004dca:	70a2                	ld	ra,40(sp)
    80004dcc:	6145                	addi	sp,sp,48
    80004dce:	8082                	ret

0000000080004dd0 <read_uart_character>:
 * @param uart instance 
 * @param pointer to a character.
 * @return Received character value as integer
 */
uint8_t read_uart_character(uart_struct * instance, char * prn_character)
{
    80004dd0:	1101                	addi	sp,sp,-32
    80004dd2:	e42a                	sd	a0,8(sp)
    80004dd4:	e02e                	sd	a1,0(sp)
	uint8_t temp = 0;
    80004dd6:	00010fa3          	sb	zero,31(sp)

	while ((instance->status & STS_RX_NOT_EMPTY) == 0);
    80004dda:	0001                	nop
    80004ddc:	67a2                	ld	a5,8(sp)
    80004dde:	00c7c783          	lbu	a5,12(a5)
    80004de2:	2781                	sext.w	a5,a5
    80004de4:	8b91                	andi	a5,a5,4
    80004de6:	2781                	sext.w	a5,a5
    80004de8:	dbf5                	beqz	a5,80004ddc <read_uart_character+0xc>

	temp = instance->rcv_reg;
    80004dea:	67a2                	ld	a5,8(sp)
    80004dec:	479c                	lw	a5,8(a5)
    80004dee:	00f10fa3          	sb	a5,31(sp)
	*prn_character = temp;
    80004df2:	6782                	ld	a5,0(sp)
    80004df4:	01f14703          	lbu	a4,31(sp)
    80004df8:	00e78023          	sb	a4,0(a5)

	return 1;
    80004dfc:	4785                	li	a5,1
}
    80004dfe:	853e                	mv	a0,a5
    80004e00:	6105                	addi	sp,sp,32
    80004e02:	8082                	ret

0000000080004e04 <read_uart_string>:
 * @param UART instance
 * @param pointer to an array of character.
 * @return length of the received string
 */
uint8_t read_uart_string(uart_struct * instance, char * ptr_string)
{
    80004e04:	7179                	addi	sp,sp,-48
    80004e06:	f406                	sd	ra,40(sp)
    80004e08:	e42a                	sd	a0,8(sp)
    80004e0a:	e02e                	sd	a1,0(sp)
	uint32_t i = 0;
    80004e0c:	ce02                	sw	zero,28(sp)
	uint8_t temp = 0;
    80004e0e:	00010da3          	sb	zero,27(sp)

	while(1)
	{
		while ((instance->status & STS_RX_NOT_EMPTY) == 0);
    80004e12:	0001                	nop
    80004e14:	67a2                	ld	a5,8(sp)
    80004e16:	00c7c783          	lbu	a5,12(a5)
    80004e1a:	2781                	sext.w	a5,a5
    80004e1c:	8b91                	andi	a5,a5,4
    80004e1e:	2781                	sext.w	a5,a5
    80004e20:	dbf5                	beqz	a5,80004e14 <read_uart_string+0x10>

		temp = instance->rcv_reg;
    80004e22:	67a2                	ld	a5,8(sp)
    80004e24:	479c                	lw	a5,8(a5)
    80004e26:	00f10da3          	sb	a5,27(sp)
		ptr_string[i++] = temp;
    80004e2a:	47f2                	lw	a5,28(sp)
    80004e2c:	0017871b          	addiw	a4,a5,1
    80004e30:	ce3a                	sw	a4,28(sp)
    80004e32:	1782                	slli	a5,a5,0x20
    80004e34:	9381                	srli	a5,a5,0x20
    80004e36:	6702                	ld	a4,0(sp)
    80004e38:	97ba                	add	a5,a5,a4
    80004e3a:	01b14703          	lbu	a4,27(sp)
    80004e3e:	00e78023          	sb	a4,0(a5)
		putchar(temp);
    80004e42:	01b14783          	lbu	a5,27(sp)
    80004e46:	2781                	sext.w	a5,a5
    80004e48:	853e                	mv	a0,a5
    80004e4a:	e95ff0ef          	jal	ra,80004cde <putchar>

		if (temp == 0x0D)
    80004e4e:	01b14783          	lbu	a5,27(sp)
    80004e52:	0ff7f713          	andi	a4,a5,255
    80004e56:	47b5                	li	a5,13
    80004e58:	faf71de3          	bne	a4,a5,80004e12 <read_uart_string+0xe>
		{
			ptr_string[i++] = 0x0A;
    80004e5c:	47f2                	lw	a5,28(sp)
    80004e5e:	0017871b          	addiw	a4,a5,1
    80004e62:	ce3a                	sw	a4,28(sp)
    80004e64:	1782                	slli	a5,a5,0x20
    80004e66:	9381                	srli	a5,a5,0x20
    80004e68:	6702                	ld	a4,0(sp)
    80004e6a:	97ba                	add	a5,a5,a4
    80004e6c:	4729                	li	a4,10
    80004e6e:	00e78023          	sb	a4,0(a5)
			ptr_string[i++] = 0x00;
    80004e72:	47f2                	lw	a5,28(sp)
    80004e74:	0017871b          	addiw	a4,a5,1
    80004e78:	ce3a                	sw	a4,28(sp)
    80004e7a:	1782                	slli	a5,a5,0x20
    80004e7c:	9381                	srli	a5,a5,0x20
    80004e7e:	6702                	ld	a4,0(sp)
    80004e80:	97ba                	add	a5,a5,a4
    80004e82:	00078023          	sb	zero,0(a5)
			return(i);
    80004e86:	47f2                	lw	a5,28(sp)
    80004e88:	0ff7f793          	andi	a5,a5,255
		}
	}
}
    80004e8c:	853e                	mv	a0,a5
    80004e8e:	70a2                	ld	ra,40(sp)
    80004e90:	6145                	addi	sp,sp,48
    80004e92:	8082                	ret

0000000080004e94 <flush_uart>:
 * @details This function will be called to flush the previous values stored in the UART fifo queue by
 * passing UART number for different offset addresses.
 * @param UART instance.
 */
void flush_uart(uart_struct * instance)
{
    80004e94:	1101                	addi	sp,sp,-32
    80004e96:	e42a                	sd	a0,8(sp)
	__attribute__((unused)) char temp;

	while ((instance->status & STS_RX_NOT_EMPTY) != 0)
    80004e98:	a029                	j	80004ea2 <flush_uart+0xe>
	{
		temp = instance->rcv_reg ;
    80004e9a:	67a2                	ld	a5,8(sp)
    80004e9c:	479c                	lw	a5,8(a5)
    80004e9e:	00f10fa3          	sb	a5,31(sp)
	while ((instance->status & STS_RX_NOT_EMPTY) != 0)
    80004ea2:	67a2                	ld	a5,8(sp)
    80004ea4:	00c7c783          	lbu	a5,12(a5)
    80004ea8:	2781                	sext.w	a5,a5
    80004eaa:	8b91                	andi	a5,a5,4
    80004eac:	2781                	sext.w	a5,a5
    80004eae:	f7f5                	bnez	a5,80004e9a <flush_uart+0x6>
	}
}
    80004eb0:	0001                	nop
    80004eb2:	0001                	nop
    80004eb4:	6105                	addi	sp,sp,32
    80004eb6:	8082                	ret

0000000080004eb8 <mtime_low>:
 * @details return the lower half of mtime. And this is needed mostly in dealing mtime in 32 bit machines.
 * @return unsigned long
 */
static unsigned long mtime_low(void)
{
  return *(volatile unsigned long *)(CLINT_BASE + MTIME);
    80004eb8:	4000c7b7          	lui	a5,0x4000c
    80004ebc:	17e1                	addi	a5,a5,-8
    80004ebe:	639c                	ld	a5,0(a5)
}
    80004ec0:	853e                	mv	a0,a5
    80004ec2:	8082                	ret

0000000080004ec4 <mtime_high>:
 *          Incase of 64 bit core this has to be appended with lower 32 bits adn sent.
 * @return unsigned 32bit int
 */
static uint32_t mtime_high(void)
{
  return *(volatile uint32_t *)(CLINT_BASE + MTIME + 4);
    80004ec4:	4000c7b7          	lui	a5,0x4000c
    80004ec8:	17f1                	addi	a5,a5,-4
    80004eca:	439c                	lw	a5,0(a5)
    80004ecc:	2781                	sext.w	a5,a5
}
    80004ece:	853e                	mv	a0,a5
    80004ed0:	8082                	ret

0000000080004ed2 <get_timer_value>:
 * @details return the mtime value based on the __riscv_xlen. Incase of 64 bit, this joins the upper
 *          and lower 32 bits of mtime and return
 * @return unsigned 64bit int
 */
uint64_t get_timer_value()
{
    80004ed2:	1141                	addi	sp,sp,-16
    80004ed4:	e406                	sd	ra,8(sp)

#if __riscv_xlen == 32
   return ( ((uint64_t)mtime_high() << 32) | mtime_low());
#else
  return mtime_low();
    80004ed6:	fe3ff0ef          	jal	ra,80004eb8 <mtime_low>
    80004eda:	87aa                	mv	a5,a0
#endif
}
    80004edc:	853e                	mv	a0,a5
    80004ede:	60a2                	ld	ra,8(sp)
    80004ee0:	0141                	addi	sp,sp,16
    80004ee2:	8082                	ret

0000000080004ee4 <configure_counter>:
 * @brief sets up the timer
 * @details sets the mtimecmp to current mtime + delta
 * @param unsigned 64bit int (delta value after which interrupt happens)
 */
void configure_counter( uint64_t value)
{
    80004ee4:	1101                	addi	sp,sp,-32
    80004ee6:	ec06                	sd	ra,24(sp)
    80004ee8:	e42a                	sd	a0,8(sp)
	log_trace("\nconfigure_counter entered\n");
    80004eea:	00004517          	auipc	a0,0x4
    80004eee:	4d650513          	addi	a0,a0,1238 # 800093c0 <__rodata_start+0x68>
    80004ef2:	456020ef          	jal	ra,80007348 <log_trace>

	*mtimecmp = *mtime + value;
    80004ef6:	83018793          	addi	a5,gp,-2000 # 8000ab38 <mtime>
    80004efa:	639c                	ld	a5,0(a5)
    80004efc:	4394                	lw	a3,0(a5)
    80004efe:	67a2                	ld	a5,8(sp)
    80004f00:	0007871b          	sext.w	a4,a5
    80004f04:	83818793          	addi	a5,gp,-1992 # 8000ab40 <mtimecmp>
    80004f08:	639c                	ld	a5,0(a5)
    80004f0a:	9f35                	addw	a4,a4,a3
    80004f0c:	2701                	sext.w	a4,a4
    80004f0e:	c398                	sw	a4,0(a5)

	log_info("mtimecmp value = %d\n", *mtimecmp);
    80004f10:	83818793          	addi	a5,gp,-1992 # 8000ab40 <mtimecmp>
    80004f14:	639c                	ld	a5,0(a5)
    80004f16:	439c                	lw	a5,0(a5)
    80004f18:	85be                	mv	a1,a5
    80004f1a:	00004517          	auipc	a0,0x4
    80004f1e:	4c650513          	addi	a0,a0,1222 # 800093e0 <__rodata_start+0x88>
    80004f22:	43e020ef          	jal	ra,80007360 <log_info>
	log_info("mtime value = %d\n", *mtime);
    80004f26:	83018793          	addi	a5,gp,-2000 # 8000ab38 <mtime>
    80004f2a:	639c                	ld	a5,0(a5)
    80004f2c:	439c                	lw	a5,0(a5)
    80004f2e:	85be                	mv	a1,a5
    80004f30:	00004517          	auipc	a0,0x4
    80004f34:	4c850513          	addi	a0,a0,1224 # 800093f8 <__rodata_start+0xa0>
    80004f38:	428020ef          	jal	ra,80007360 <log_info>

	log_trace("\nconfigure_counter exited\n");
    80004f3c:	00004517          	auipc	a0,0x4
    80004f40:	4d450513          	addi	a0,a0,1236 # 80009410 <__rodata_start+0xb8>
    80004f44:	404020ef          	jal	ra,80007348 <log_trace>
}
    80004f48:	0001                	nop
    80004f4a:	60e2                	ld	ra,24(sp)
    80004f4c:	6105                	addi	sp,sp,32
    80004f4e:	8082                	ret

0000000080004f50 <mach_clint_handler>:
 * @details handler for machine timer interrupt. This handles the timer interrupt and sets mtimecmp to clear timer interrupt.
 * @param unsigned int ptr int_id
 * @param unsigned int ptr epc
 */
void mach_clint_handler( __attribute__((unused)) uintptr_t int_id,  __attribute__((unused)) uintptr_t epc)
{
    80004f50:	1101                	addi	sp,sp,-32
    80004f52:	ec06                	sd	ra,24(sp)
    80004f54:	e42a                	sd	a0,8(sp)
    80004f56:	e02e                	sd	a1,0(sp)
	log_trace("\nmach_clint_handler entered\n");
    80004f58:	00004517          	auipc	a0,0x4
    80004f5c:	4d850513          	addi	a0,a0,1240 # 80009430 <__rodata_start+0xd8>
    80004f60:	3e8020ef          	jal	ra,80007348 <log_trace>

	*mtimecmp = -1;
    80004f64:	83818793          	addi	a5,gp,-1992 # 8000ab40 <mtimecmp>
    80004f68:	639c                	ld	a5,0(a5)
    80004f6a:	577d                	li	a4,-1
    80004f6c:	c398                	sw	a4,0(a5)

	log_debug("mtimecmp value = %x\n", *mtimecmp);
    80004f6e:	83818793          	addi	a5,gp,-1992 # 8000ab40 <mtimecmp>
    80004f72:	639c                	ld	a5,0(a5)
    80004f74:	439c                	lw	a5,0(a5)
    80004f76:	85be                	mv	a1,a5
    80004f78:	00004517          	auipc	a0,0x4
    80004f7c:	4d850513          	addi	a0,a0,1240 # 80009450 <__rodata_start+0xf8>
    80004f80:	412020ef          	jal	ra,80007392 <log_debug>
	log_debug("mtime value = %x\n", *((uint32_t *)(0x0200bff8)));
    80004f84:	0200c7b7          	lui	a5,0x200c
    80004f88:	17e1                	addi	a5,a5,-8
    80004f8a:	439c                	lw	a5,0(a5)
    80004f8c:	85be                	mv	a1,a5
    80004f8e:	00004517          	auipc	a0,0x4
    80004f92:	4da50513          	addi	a0,a0,1242 # 80009468 <__rodata_start+0x110>
    80004f96:	3fc020ef          	jal	ra,80007392 <log_debug>

	log_trace("mach_clint_handler exited\n");
    80004f9a:	00004517          	auipc	a0,0x4
    80004f9e:	4e650513          	addi	a0,a0,1254 # 80009480 <__rodata_start+0x128>
    80004fa2:	3a6020ef          	jal	ra,80007348 <log_trace>
}
    80004fa6:	0001                	nop
    80004fa8:	60e2                	ld	ra,24(sp)
    80004faa:	6105                	addi	sp,sp,32
    80004fac:	8082                	ret

0000000080004fae <configure_spi>:
 * @details Takes the SPI Base address and then adds offset to each and every
 *          spi registers..
 * @param int* ---> offset value
 */
void configure_spi(int offset)
{
    80004fae:	1141                	addi	sp,sp,-16
    80004fb0:	87aa                	mv	a5,a0
    80004fb2:	c63e                	sw	a5,12(sp)
	spi_cr1    = (int*) (SPI_CR1 + offset);
    80004fb4:	4732                	lw	a4,12(sp)
    80004fb6:	000207b7          	lui	a5,0x20
    80004fba:	9fb9                	addw	a5,a5,a4
    80004fbc:	2781                	sext.w	a5,a5
    80004fbe:	873e                	mv	a4,a5
    80004fc0:	84018793          	addi	a5,gp,-1984 # 8000ab48 <spi_cr1>
    80004fc4:	e398                	sd	a4,0(a5)
	spi_cr2    = (int*) (SPI_CR2 + offset);
    80004fc6:	4732                	lw	a4,12(sp)
    80004fc8:	000207b7          	lui	a5,0x20
    80004fcc:	2791                	addiw	a5,a5,4
    80004fce:	9fb9                	addw	a5,a5,a4
    80004fd0:	2781                	sext.w	a5,a5
    80004fd2:	873e                	mv	a4,a5
    80004fd4:	84818793          	addi	a5,gp,-1976 # 8000ab50 <spi_cr2>
    80004fd8:	e398                	sd	a4,0(a5)
	spi_sr     = (int*) (SPI_SR + offset);
    80004fda:	4732                	lw	a4,12(sp)
    80004fdc:	000207b7          	lui	a5,0x20
    80004fe0:	27a1                	addiw	a5,a5,8
    80004fe2:	9fb9                	addw	a5,a5,a4
    80004fe4:	2781                	sext.w	a5,a5
    80004fe6:	873e                	mv	a4,a5
    80004fe8:	85018793          	addi	a5,gp,-1968 # 8000ab58 <spi_sr>
    80004fec:	e398                	sd	a4,0(a5)
	spi_dr1    = (int*) (SPI_DR1 + offset);
    80004fee:	4732                	lw	a4,12(sp)
    80004ff0:	000207b7          	lui	a5,0x20
    80004ff4:	27b1                	addiw	a5,a5,12
    80004ff6:	9fb9                	addw	a5,a5,a4
    80004ff8:	2781                	sext.w	a5,a5
    80004ffa:	873e                	mv	a4,a5
    80004ffc:	85818793          	addi	a5,gp,-1960 # 8000ab60 <spi_dr1>
    80005000:	e398                	sd	a4,0(a5)
	spi_dr2    = (int*) (SPI_DR2 + offset);
    80005002:	4732                	lw	a4,12(sp)
    80005004:	000207b7          	lui	a5,0x20
    80005008:	27c1                	addiw	a5,a5,16
    8000500a:	9fb9                	addw	a5,a5,a4
    8000500c:	2781                	sext.w	a5,a5
    8000500e:	873e                	mv	a4,a5
    80005010:	86018793          	addi	a5,gp,-1952 # 8000ab68 <spi_dr2>
    80005014:	e398                	sd	a4,0(a5)
	spi_dr3    = (int*) (SPI_DR3 + offset);
    80005016:	4732                	lw	a4,12(sp)
    80005018:	000207b7          	lui	a5,0x20
    8000501c:	27d1                	addiw	a5,a5,20
    8000501e:	9fb9                	addw	a5,a5,a4
    80005020:	2781                	sext.w	a5,a5
    80005022:	873e                	mv	a4,a5
    80005024:	86818793          	addi	a5,gp,-1944 # 8000ab70 <spi_dr3>
    80005028:	e398                	sd	a4,0(a5)
	spi_dr4    = (int*) (SPI_DR4 + offset);
    8000502a:	4732                	lw	a4,12(sp)
    8000502c:	000207b7          	lui	a5,0x20
    80005030:	27e1                	addiw	a5,a5,24
    80005032:	9fb9                	addw	a5,a5,a4
    80005034:	2781                	sext.w	a5,a5
    80005036:	873e                	mv	a4,a5
    80005038:	87018793          	addi	a5,gp,-1936 # 8000ab78 <spi_dr4>
    8000503c:	e398                	sd	a4,0(a5)
	spi_dr5    = (int*) (SPI_DR5 + offset);
    8000503e:	4732                	lw	a4,12(sp)
    80005040:	000207b7          	lui	a5,0x20
    80005044:	27f1                	addiw	a5,a5,28
    80005046:	9fb9                	addw	a5,a5,a4
    80005048:	2781                	sext.w	a5,a5
    8000504a:	873e                	mv	a4,a5
    8000504c:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    80005050:	e398                	sd	a4,0(a5)
	spi_crcpr  = (int*) (SPI_CRCPR + offset);
    80005052:	4732                	lw	a4,12(sp)
    80005054:	000207b7          	lui	a5,0x20
    80005058:	0207879b          	addiw	a5,a5,32
    8000505c:	9fb9                	addw	a5,a5,a4
    8000505e:	2781                	sext.w	a5,a5
    80005060:	873e                	mv	a4,a5
    80005062:	88018793          	addi	a5,gp,-1920 # 8000ab88 <spi_crcpr>
    80005066:	e398                	sd	a4,0(a5)
	spi_rxcrcr = (int*) (SPI_RXCRCR + offset);
    80005068:	4732                	lw	a4,12(sp)
    8000506a:	000207b7          	lui	a5,0x20
    8000506e:	0247879b          	addiw	a5,a5,36
    80005072:	9fb9                	addw	a5,a5,a4
    80005074:	2781                	sext.w	a5,a5
    80005076:	873e                	mv	a4,a5
    80005078:	88818793          	addi	a5,gp,-1912 # 8000ab90 <spi_rxcrcr>
    8000507c:	e398                	sd	a4,0(a5)
	spi_txcrcr = (int*) (SPI_TXCRCR + offset);
    8000507e:	4732                	lw	a4,12(sp)
    80005080:	000207b7          	lui	a5,0x20
    80005084:	0287879b          	addiw	a5,a5,40
    80005088:	9fb9                	addw	a5,a5,a4
    8000508a:	2781                	sext.w	a5,a5
    8000508c:	873e                	mv	a4,a5
    8000508e:	89018793          	addi	a5,gp,-1904 # 8000ab98 <spi_txcrcr>
    80005092:	e398                	sd	a4,0(a5)
}
    80005094:	0001                	nop
    80005096:	0141                	addi	sp,sp,16
    80005098:	8082                	ret

000000008000509a <set_spi>:
 * @details writes the given value to given addres (SPI).
 * @param int* addr 
 * @param int val 
 */
void set_spi(int* addr, int val)
{
    8000509a:	1141                	addi	sp,sp,-16
    8000509c:	e42a                	sd	a0,8(sp)
    8000509e:	87ae                	mv	a5,a1
    800050a0:	c23e                	sw	a5,4(sp)
	*addr = val;
    800050a2:	67a2                	ld	a5,8(sp)
    800050a4:	4712                	lw	a4,4(sp)
    800050a6:	c398                	sw	a4,0(a5)
}
    800050a8:	0001                	nop
    800050aa:	0141                	addi	sp,sp,16
    800050ac:	8082                	ret

00000000800050ae <get_spi>:
 * @details Reads the SPI register value from passed address.
 * @param int* ---> address from where read has to happen
 * @return int ---> SPI Register read value.
 */
int get_spi(int* addr)
{
    800050ae:	1141                	addi	sp,sp,-16
    800050b0:	e42a                	sd	a0,8(sp)
	return *addr;
    800050b2:	67a2                	ld	a5,8(sp)
    800050b4:	439c                	lw	a5,0(a5)
}
    800050b6:	853e                	mv	a0,a5
    800050b8:	0141                	addi	sp,sp,16
    800050ba:	8082                	ret

00000000800050bc <spi_init>:
/** @fn void spi_init(void)
 * @brief setting up baud rate and clock pole and phase 
 * @details Initialize the spi controller in Mode 3 (CPOL =1 & CPHA =1) with SCK= clk/16
 */
void spi_init(void)
{
    800050bc:	1141                	addi	sp,sp,-16
    800050be:	e406                	sd	ra,8(sp)
	set_spi(spi_cr1, (SPI_BR(7)|SPI_CPHA|SPI_CPOL));
    800050c0:	84018793          	addi	a5,gp,-1984 # 8000ab48 <spi_cr1>
    800050c4:	639c                	ld	a5,0(a5)
    800050c6:	03b00593          	li	a1,59
    800050ca:	853e                	mv	a0,a5
    800050cc:	fcfff0ef          	jal	ra,8000509a <set_spi>
}
    800050d0:	0001                	nop
    800050d2:	60a2                	ld	ra,8(sp)
    800050d4:	0141                	addi	sp,sp,16
    800050d6:	8082                	ret

00000000800050d8 <spi_tx_rx_start>:
 * @details While receiving data from flash (reading Device ID, status register and reading flash)  
 *           in master mode use this function.
 * @warning Should be set before configuring the control register 1.
 */
void spi_tx_rx_start(void)
{
    800050d8:	1141                	addi	sp,sp,-16
    800050da:	e406                	sd	ra,8(sp)
	set_spi(spi_cr2, (SPI_RX_IMM_START));
    800050dc:	84818793          	addi	a5,gp,-1976 # 8000ab50 <spi_cr2>
    800050e0:	639c                	ld	a5,0(a5)
    800050e2:	65c1                	lui	a1,0x10
    800050e4:	853e                	mv	a0,a5
    800050e6:	fb5ff0ef          	jal	ra,8000509a <set_spi>
}
    800050ea:	0001                	nop
    800050ec:	60a2                	ld	ra,8(sp)
    800050ee:	0141                	addi	sp,sp,16
    800050f0:	8082                	ret

00000000800050f2 <spi_rx_enable>:
/** @fn void spi_rx_enable(void)
 * @brief to start receive state 
 * @details This is not in used when spi is in Master mode 
 */
void spi_rx_enable(void)
{
    800050f2:	1141                	addi	sp,sp,-16
    800050f4:	e406                	sd	ra,8(sp)
	set_spi(spi_cr2, (SPI_RX_START));
    800050f6:	84818793          	addi	a5,gp,-1976 # 8000ab50 <spi_cr2>
    800050fa:	639c                	ld	a5,0(a5)
    800050fc:	65a1                	lui	a1,0x8
    800050fe:	853e                	mv	a0,a5
    80005100:	f9bff0ef          	jal	ra,8000509a <set_spi>
}
    80005104:	0001                	nop
    80005106:	60a2                	ld	ra,8(sp)
    80005108:	0141                	addi	sp,sp,16
    8000510a:	8082                	ret

000000008000510c <bitExtracted>:
 * @param int (k (number of bits to be extracted))
 * @param int (p (position from where the bits to be extracted))
 * @return int (32 bit which have k bit from "number" and rest are zero)
 */
int bitExtracted(int number, int k, int p)
{
    8000510c:	1141                	addi	sp,sp,-16
    8000510e:	87aa                	mv	a5,a0
    80005110:	86ae                	mv	a3,a1
    80005112:	8732                	mv	a4,a2
    80005114:	c63e                	sw	a5,12(sp)
    80005116:	87b6                	mv	a5,a3
    80005118:	c43e                	sw	a5,8(sp)
    8000511a:	87ba                	mv	a5,a4
    8000511c:	c23e                	sw	a5,4(sp)
	return (((1 << k) - 1) & (number >> (p - 1)));
    8000511e:	47a2                	lw	a5,8(sp)
    80005120:	4705                	li	a4,1
    80005122:	00f717bb          	sllw	a5,a4,a5
    80005126:	2781                	sext.w	a5,a5
    80005128:	37fd                	addiw	a5,a5,-1
    8000512a:	0007871b          	sext.w	a4,a5
    8000512e:	4792                	lw	a5,4(sp)
    80005130:	37fd                	addiw	a5,a5,-1
    80005132:	2781                	sext.w	a5,a5
    80005134:	46b2                	lw	a3,12(sp)
    80005136:	40f6d7bb          	sraw	a5,a3,a5
    8000513a:	2781                	sext.w	a5,a5
    8000513c:	8ff9                	and	a5,a5,a4
    8000513e:	2781                	sext.w	a5,a5
}
    80005140:	853e                	mv	a0,a5
    80005142:	0141                	addi	sp,sp,16
    80005144:	8082                	ret

0000000080005146 <spi_rxne_enable>:
 * @brief to check if receive buffer is empty or not
 * @details As soons as data come to receive buffer this bit is set.  
 * @return int (1: if there is data into the RxFIFO else 0)
 */
int spi_rxne_enable(void)
{
    80005146:	1101                	addi	sp,sp,-32
    80005148:	ec06                	sd	ra,24(sp)
	int value = 0;
    8000514a:	c602                	sw	zero,12(sp)

	while (!(value & 0x1))
    8000514c:	a829                	j	80005166 <spi_rxne_enable+0x20>
	{
		waitfor(100);
    8000514e:	06400513          	li	a0,100
    80005152:	2c1010ef          	jal	ra,80006c12 <waitfor>
		value = get_spi(spi_sr);
    80005156:	85018793          	addi	a5,gp,-1968 # 8000ab58 <spi_sr>
    8000515a:	639c                	ld	a5,0(a5)
    8000515c:	853e                	mv	a0,a5
    8000515e:	f51ff0ef          	jal	ra,800050ae <get_spi>
    80005162:	87aa                	mv	a5,a0
    80005164:	c63e                	sw	a5,12(sp)
	while (!(value & 0x1))
    80005166:	47b2                	lw	a5,12(sp)
    80005168:	8b85                	andi	a5,a5,1
    8000516a:	2781                	sext.w	a5,a5
    8000516c:	d3ed                	beqz	a5,8000514e <spi_rxne_enable+0x8>
	}
	return 1;
    8000516e:	4785                	li	a5,1
}
    80005170:	853e                	mv	a0,a5
    80005172:	60e2                	ld	ra,24(sp)
    80005174:	6105                	addi	sp,sp,32
    80005176:	8082                	ret

0000000080005178 <spi_notbusy>:
 * @details it read the status of bsy bit in spi_sr 
 * @warning One should check this bit before going to next transcation
 * @return int (0: SPI is busy in communication, 1: SPI nt busy)
 */
int spi_notbusy(void)
{
    80005178:	1101                	addi	sp,sp,-32
    8000517a:	ec06                	sd	ra,24(sp)
	int value = 0x80;
    8000517c:	08000793          	li	a5,128
    80005180:	c63e                	sw	a5,12(sp)

	while ((value & 0x80))
    80005182:	a821                	j	8000519a <spi_notbusy+0x22>
	{
		waitfor(10);
    80005184:	4529                	li	a0,10
    80005186:	28d010ef          	jal	ra,80006c12 <waitfor>
		value = get_spi(spi_sr);
    8000518a:	85018793          	addi	a5,gp,-1968 # 8000ab58 <spi_sr>
    8000518e:	639c                	ld	a5,0(a5)
    80005190:	853e                	mv	a0,a5
    80005192:	f1dff0ef          	jal	ra,800050ae <get_spi>
    80005196:	87aa                	mv	a5,a0
    80005198:	c63e                	sw	a5,12(sp)
	while ((value & 0x80))
    8000519a:	47b2                	lw	a5,12(sp)
    8000519c:	0807f793          	andi	a5,a5,128
    800051a0:	2781                	sext.w	a5,a5
    800051a2:	f3ed                	bnez	a5,80005184 <spi_notbusy+0xc>
	}

	return 1;
    800051a4:	4785                	li	a5,1
}
    800051a6:	853e                	mv	a0,a5
    800051a8:	60e2                	ld	ra,24(sp)
    800051aa:	6105                	addi	sp,sp,32
    800051ac:	8082                	ret

00000000800051ae <flash_write_enable>:
 * @details Before modifying content of flash, one should enable the WEL bit first
 * @warning Without enabling this bit one cannot erase/write into the flash
 * @return int
 */
int flash_write_enable(void)
{
    800051ae:	1141                	addi	sp,sp,-16
    800051b0:	e406                	sd	ra,8(sp)
	set_spi(spi_dr1, 0x06000000);
    800051b2:	85818793          	addi	a5,gp,-1960 # 8000ab60 <spi_dr1>
    800051b6:	639c                	ld	a5,0(a5)
    800051b8:	060005b7          	lui	a1,0x6000
    800051bc:	853e                	mv	a0,a5
    800051be:	eddff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr5, 0x06);
    800051c2:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    800051c6:	639c                	ld	a5,0(a5)
    800051c8:	4599                	li	a1,6
    800051ca:	853e                	mv	a0,a5
    800051cc:	ecfff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_cr1, (SPI_BR(7)|SPI_TOTAL_BITS_TX(8)|SPI_TOTAL_BITS_RX(0)|SPI_SPE|SPI_CPHA|SPI_CPOL));
    800051d0:	84018793          	addi	a5,gp,-1984 # 8000ab48 <spi_cr1>
    800051d4:	6398                	ld	a4,0(a5)
    800051d6:	000807b7          	lui	a5,0x80
    800051da:	07b78593          	addi	a1,a5,123 # 8007b <_STACK_SIZE+0x6c07b>
    800051de:	853a                	mv	a0,a4
    800051e0:	ebbff0ef          	jal	ra,8000509a <set_spi>
	spi_notbusy();
    800051e4:	f95ff0ef          	jal	ra,80005178 <spi_notbusy>

	return 1;
    800051e8:	4785                	li	a5,1
}
    800051ea:	853e                	mv	a0,a5
    800051ec:	60a2                	ld	ra,8(sp)
    800051ee:	0141                	addi	sp,sp,16
    800051f0:	8082                	ret

00000000800051f2 <flash_clear_sr>:
 * @details It will reset the bits of status register
 * @return int
 */

int flash_clear_sr(void)
{
    800051f2:	1141                	addi	sp,sp,-16
    800051f4:	e406                	sd	ra,8(sp)
	set_spi(spi_dr1,0x30000000);
    800051f6:	85818793          	addi	a5,gp,-1960 # 8000ab60 <spi_dr1>
    800051fa:	639c                	ld	a5,0(a5)
    800051fc:	300005b7          	lui	a1,0x30000
    80005200:	853e                	mv	a0,a5
    80005202:	e99ff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr5,0x30);
    80005206:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    8000520a:	639c                	ld	a5,0(a5)
    8000520c:	03000593          	li	a1,48
    80005210:	853e                	mv	a0,a5
    80005212:	e89ff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_cr1, (SPI_BR(7)|SPI_TOTAL_BITS_TX(8)|SPI_TOTAL_BITS_RX(0)|SPI_SPE|SPI_CPHA|SPI_CPOL));
    80005216:	84018793          	addi	a5,gp,-1984 # 8000ab48 <spi_cr1>
    8000521a:	6398                	ld	a4,0(a5)
    8000521c:	000807b7          	lui	a5,0x80
    80005220:	07b78593          	addi	a1,a5,123 # 8007b <_STACK_SIZE+0x6c07b>
    80005224:	853a                	mv	a0,a4
    80005226:	e75ff0ef          	jal	ra,8000509a <set_spi>
	spi_notbusy();
    8000522a:	f4fff0ef          	jal	ra,80005178 <spi_notbusy>

	return 1;
    8000522e:	4785                	li	a5,1
}
    80005230:	853e                	mv	a0,a5
    80005232:	60a2                	ld	ra,8(sp)
    80005234:	0141                	addi	sp,sp,16
    80005236:	8082                	ret

0000000080005238 <flash_cmd_addr>:
 * @param int (command (opcode))
 * @param int (addr (address after the opcode))
 * @return int
 */
int flash_cmd_addr(int command, int addr)
{
    80005238:	7179                	addi	sp,sp,-48
    8000523a:	f406                	sd	ra,40(sp)
    8000523c:	87aa                	mv	a5,a0
    8000523e:	872e                	mv	a4,a1
    80005240:	c63e                	sw	a5,12(sp)
    80005242:	87ba                	mv	a5,a4
    80005244:	c43e                	sw	a5,8(sp)
	int address1 = bitExtracted(addr, 24, 9);
    80005246:	47a2                	lw	a5,8(sp)
    80005248:	4625                	li	a2,9
    8000524a:	45e1                	li	a1,24
    8000524c:	853e                	mv	a0,a5
    8000524e:	ebfff0ef          	jal	ra,8000510c <bitExtracted>
    80005252:	87aa                	mv	a5,a0
    80005254:	ce3e                	sw	a5,28(sp)
	int address2 = bitExtracted(addr, 8, 1);
    80005256:	47a2                	lw	a5,8(sp)
    80005258:	4605                	li	a2,1
    8000525a:	45a1                	li	a1,8
    8000525c:	853e                	mv	a0,a5
    8000525e:	eafff0ef          	jal	ra,8000510c <bitExtracted>
    80005262:	87aa                	mv	a5,a0
    80005264:	cc3e                	sw	a5,24(sp)
	int data1 = command | address1 ;
    80005266:	4732                	lw	a4,12(sp)
    80005268:	47f2                	lw	a5,28(sp)
    8000526a:	8fd9                	or	a5,a5,a4
    8000526c:	ca3e                	sw	a5,20(sp)
	address2 = address2 << 24;
    8000526e:	47e2                	lw	a5,24(sp)
    80005270:	0187979b          	slliw	a5,a5,0x18
    80005274:	cc3e                	sw	a5,24(sp)

	set_spi(spi_dr1, data1);
    80005276:	85818793          	addi	a5,gp,-1960 # 8000ab60 <spi_dr1>
    8000527a:	639c                	ld	a5,0(a5)
    8000527c:	4752                	lw	a4,20(sp)
    8000527e:	85ba                	mv	a1,a4
    80005280:	853e                	mv	a0,a5
    80005282:	e19ff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr2, address2);
    80005286:	86018793          	addi	a5,gp,-1952 # 8000ab68 <spi_dr2>
    8000528a:	639c                	ld	a5,0(a5)
    8000528c:	4762                	lw	a4,24(sp)
    8000528e:	85ba                	mv	a1,a4
    80005290:	853e                	mv	a0,a5
    80005292:	e09ff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr5, 0);
    80005296:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    8000529a:	639c                	ld	a5,0(a5)
    8000529c:	4581                	li	a1,0
    8000529e:	853e                	mv	a0,a5
    800052a0:	dfbff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_cr1, (SPI_BR(7)|SPI_TOTAL_BITS_TX(40)|SPI_TOTAL_BITS_RX(0)|SPI_SPE|SPI_CPHA|SPI_CPOL));
    800052a4:	84018793          	addi	a5,gp,-1984 # 8000ab48 <spi_cr1>
    800052a8:	6398                	ld	a4,0(a5)
    800052aa:	002807b7          	lui	a5,0x280
    800052ae:	07b78593          	addi	a1,a5,123 # 28007b <_STACK_SIZE+0x26c07b>
    800052b2:	853a                	mv	a0,a4
    800052b4:	de7ff0ef          	jal	ra,8000509a <set_spi>
	waitfor(20);
    800052b8:	4551                	li	a0,20
    800052ba:	159010ef          	jal	ra,80006c12 <waitfor>
	spi_notbusy();
    800052be:	ebbff0ef          	jal	ra,80005178 <spi_notbusy>

	return 1;
    800052c2:	4785                	li	a5,1
}
    800052c4:	853e                	mv	a0,a5
    800052c6:	70a2                	ld	ra,40(sp)
    800052c8:	6145                	addi	sp,sp,48
    800052ca:	8082                	ret

00000000800052cc <flash_cmd_addr_data>:
 * @param int (command (opcode))
 * @param int (addr(address after the opcode))
 * @param int (data (data after the address))
 */
void flash_cmd_addr_data(int command, int addr, int data)
{
    800052cc:	7179                	addi	sp,sp,-48
    800052ce:	f406                	sd	ra,40(sp)
    800052d0:	87aa                	mv	a5,a0
    800052d2:	86ae                	mv	a3,a1
    800052d4:	8732                	mv	a4,a2
    800052d6:	c63e                	sw	a5,12(sp)
    800052d8:	87b6                	mv	a5,a3
    800052da:	c43e                	sw	a5,8(sp)
    800052dc:	87ba                	mv	a5,a4
    800052de:	c23e                	sw	a5,4(sp)
	int cmd_addr = command | ( (addr & 0xFFFFFF00)  >> 8);
    800052e0:	47a2                	lw	a5,8(sp)
    800052e2:	0087d79b          	srliw	a5,a5,0x8
    800052e6:	0007871b          	sext.w	a4,a5
    800052ea:	47b2                	lw	a5,12(sp)
    800052ec:	8fd9                	or	a5,a5,a4
    800052ee:	2781                	sext.w	a5,a5
    800052f0:	ce3e                	sw	a5,28(sp)
	int data1 = ( (addr & 0xFF)  << 24 ) |( (data & 0xFFFFFF00)  >> 8);
    800052f2:	47a2                	lw	a5,8(sp)
    800052f4:	0187979b          	slliw	a5,a5,0x18
    800052f8:	2781                	sext.w	a5,a5
    800052fa:	0007871b          	sext.w	a4,a5
    800052fe:	4792                	lw	a5,4(sp)
    80005300:	0087d79b          	srliw	a5,a5,0x8
    80005304:	2781                	sext.w	a5,a5
    80005306:	8fd9                	or	a5,a5,a4
    80005308:	2781                	sext.w	a5,a5
    8000530a:	cc3e                	sw	a5,24(sp)
	int data2 = ( (data & 0xFF)  << 24 ) & 0xFF000000;
    8000530c:	4792                	lw	a5,4(sp)
    8000530e:	0187979b          	slliw	a5,a5,0x18
    80005312:	ca3e                	sw	a5,20(sp)

	log_debug("\n cmd: %x;d1: %x; d2: %x", cmd_addr, data1, data2);
    80005314:	46d2                	lw	a3,20(sp)
    80005316:	4762                	lw	a4,24(sp)
    80005318:	47f2                	lw	a5,28(sp)
    8000531a:	863a                	mv	a2,a4
    8000531c:	85be                	mv	a1,a5
    8000531e:	00004517          	auipc	a0,0x4
    80005322:	18250513          	addi	a0,a0,386 # 800094a0 <__rodata_start+0x148>
    80005326:	06c020ef          	jal	ra,80007392 <log_debug>

	set_spi(spi_dr1, cmd_addr);
    8000532a:	85818793          	addi	a5,gp,-1960 # 8000ab60 <spi_dr1>
    8000532e:	639c                	ld	a5,0(a5)
    80005330:	4772                	lw	a4,28(sp)
    80005332:	85ba                	mv	a1,a4
    80005334:	853e                	mv	a0,a5
    80005336:	d65ff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr2, data1);
    8000533a:	86018793          	addi	a5,gp,-1952 # 8000ab68 <spi_dr2>
    8000533e:	639c                	ld	a5,0(a5)
    80005340:	4762                	lw	a4,24(sp)
    80005342:	85ba                	mv	a1,a4
    80005344:	853e                	mv	a0,a5
    80005346:	d55ff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr3, data2);
    8000534a:	86818793          	addi	a5,gp,-1944 # 8000ab70 <spi_dr3>
    8000534e:	639c                	ld	a5,0(a5)
    80005350:	4752                	lw	a4,20(sp)
    80005352:	85ba                	mv	a1,a4
    80005354:	853e                	mv	a0,a5
    80005356:	d45ff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr5, 0);
    8000535a:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    8000535e:	639c                	ld	a5,0(a5)
    80005360:	4581                	li	a1,0
    80005362:	853e                	mv	a0,a5
    80005364:	d37ff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_cr1, (SPI_BR(7)|SPI_TOTAL_BITS_TX(72)|SPI_TOTAL_BITS_RX(0)|SPI_SPE|SPI_CPHA|SPI_CPOL));
    80005368:	84018793          	addi	a5,gp,-1984 # 8000ab48 <spi_cr1>
    8000536c:	6398                	ld	a4,0(a5)
    8000536e:	004807b7          	lui	a5,0x480
    80005372:	07b78593          	addi	a1,a5,123 # 48007b <_STACK_SIZE+0x46c07b>
    80005376:	853a                	mv	a0,a4
    80005378:	d23ff0ef          	jal	ra,8000509a <set_spi>
	waitfor(20);
    8000537c:	4551                	li	a0,20
    8000537e:	095010ef          	jal	ra,80006c12 <waitfor>
	spi_notbusy();
    80005382:	df7ff0ef          	jal	ra,80005178 <spi_notbusy>
	flash_status_register_read();
    80005386:	17a000ef          	jal	ra,80005500 <flash_status_register_read>
}
    8000538a:	0001                	nop
    8000538c:	70a2                	ld	ra,40(sp)
    8000538e:	6145                	addi	sp,sp,48
    80005390:	8082                	ret

0000000080005392 <flash_write>:
 * @warning before writing into the flash one should enable the WEL bit spi_sr by using write_enable(void)
 * @param int (addres (write address))
 * @param int(data (write data))
 */
void flash_write(int address, int data)
{
    80005392:	1101                	addi	sp,sp,-32
    80005394:	ec06                	sd	ra,24(sp)
    80005396:	87aa                	mv	a5,a0
    80005398:	872e                	mv	a4,a1
    8000539a:	c63e                	sw	a5,12(sp)
    8000539c:	87ba                	mv	a5,a4
    8000539e:	c43e                	sw	a5,8(sp)
	flash_write_enable();
    800053a0:	e0fff0ef          	jal	ra,800051ae <flash_write_enable>
	flash_cmd_addr_data(0x12000000, address,data);
    800053a4:	4722                	lw	a4,8(sp)
    800053a6:	47b2                	lw	a5,12(sp)
    800053a8:	863a                	mv	a2,a4
    800053aa:	85be                	mv	a1,a5
    800053ac:	12000537          	lui	a0,0x12000
    800053b0:	f1dff0ef          	jal	ra,800052cc <flash_cmd_addr_data>
	flash_status_register_read();
    800053b4:	14c000ef          	jal	ra,80005500 <flash_status_register_read>
}
    800053b8:	0001                	nop
    800053ba:	60e2                	ld	ra,24(sp)
    800053bc:	6105                	addi	sp,sp,32
    800053be:	8082                	ret

00000000800053c0 <flash_cmd_to_read>:
 * @param int (command (opcode))
 * @param int (addr(read_address))
 * @return int 
 */
int flash_cmd_to_read(int command, int addr)
{
    800053c0:	7179                	addi	sp,sp,-48
    800053c2:	f406                	sd	ra,40(sp)
    800053c4:	87aa                	mv	a5,a0
    800053c6:	872e                	mv	a4,a1
    800053c8:	c63e                	sw	a5,12(sp)
    800053ca:	87ba                	mv	a5,a4
    800053cc:	c43e                	sw	a5,8(sp)
	int dr5;
	int address2 = bitExtracted(addr, 8, 1);
    800053ce:	47a2                	lw	a5,8(sp)
    800053d0:	4605                	li	a2,1
    800053d2:	45a1                	li	a1,8
    800053d4:	853e                	mv	a0,a5
    800053d6:	d37ff0ef          	jal	ra,8000510c <bitExtracted>
    800053da:	87aa                	mv	a5,a0
    800053dc:	cc3e                	sw	a5,24(sp)

	address2 = address2 << 24;
    800053de:	47e2                	lw	a5,24(sp)
    800053e0:	0187979b          	slliw	a5,a5,0x18
    800053e4:	cc3e                	sw	a5,24(sp)
	set_spi(spi_dr1, ( command  | ( (addr & 0xFFFFFF00) >> 8) ));
    800053e6:	85818793          	addi	a5,gp,-1960 # 8000ab60 <spi_dr1>
    800053ea:	6398                	ld	a4,0(a5)
    800053ec:	47a2                	lw	a5,8(sp)
    800053ee:	0087d79b          	srliw	a5,a5,0x8
    800053f2:	0007869b          	sext.w	a3,a5
    800053f6:	47b2                	lw	a5,12(sp)
    800053f8:	8fd5                	or	a5,a5,a3
    800053fa:	2781                	sext.w	a5,a5
    800053fc:	2781                	sext.w	a5,a5
    800053fe:	85be                	mv	a1,a5
    80005400:	853a                	mv	a0,a4
    80005402:	c99ff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr2, ( (addr & 0xFF) << 24) );
    80005406:	86018793          	addi	a5,gp,-1952 # 8000ab68 <spi_dr2>
    8000540a:	6398                	ld	a4,0(a5)
    8000540c:	47a2                	lw	a5,8(sp)
    8000540e:	0187979b          	slliw	a5,a5,0x18
    80005412:	2781                	sext.w	a5,a5
    80005414:	85be                	mv	a1,a5
    80005416:	853a                	mv	a0,a4
    80005418:	c83ff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr5, 0);
    8000541c:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    80005420:	639c                	ld	a5,0(a5)
    80005422:	4581                	li	a1,0
    80005424:	853e                	mv	a0,a5
    80005426:	c75ff0ef          	jal	ra,8000509a <set_spi>
	spi_tx_rx_start();
    8000542a:	cafff0ef          	jal	ra,800050d8 <spi_tx_rx_start>
	set_spi(spi_cr1, (SPI_BR(7)|SPI_TOTAL_BITS_TX(48)|SPI_TOTAL_BITS_RX(32)|SPI_SPE|SPI_CPHA|SPI_CPOL));
    8000542e:	84018793          	addi	a5,gp,-1984 # 8000ab48 <spi_cr1>
    80005432:	6398                	ld	a4,0(a5)
    80005434:	203007b7          	lui	a5,0x20300
    80005438:	07b78593          	addi	a1,a5,123 # 2030007b <_STACK_SIZE+0x202ec07b>
    8000543c:	853a                	mv	a0,a4
    8000543e:	c5dff0ef          	jal	ra,8000509a <set_spi>
	waitfor(2000);
    80005442:	7d000513          	li	a0,2000
    80005446:	7cc010ef          	jal	ra,80006c12 <waitfor>

	if(spi_rxne_enable()) 
    8000544a:	cfdff0ef          	jal	ra,80005146 <spi_rxne_enable>
    8000544e:	87aa                	mv	a5,a0
    80005450:	c791                	beqz	a5,8000545c <flash_cmd_to_read+0x9c>
	{
		dr5 = *spi_dr5;
    80005452:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    80005456:	639c                	ld	a5,0(a5)
    80005458:	439c                	lw	a5,0(a5)
    8000545a:	ce3e                	sw	a5,28(sp)
	}

	return dr5;
    8000545c:	47f2                	lw	a5,28(sp)

}
    8000545e:	853e                	mv	a0,a5
    80005460:	70a2                	ld	ra,40(sp)
    80005462:	6145                	addi	sp,sp,48
    80005464:	8082                	ret

0000000080005466 <flash_read>:
 * @details flash_cmd_to_read with opcode 0Bh for fast read
 * @param int (address (read address))
 * @return int 
 */
int flash_read(int address)
{
    80005466:	7179                	addi	sp,sp,-48
    80005468:	f406                	sd	ra,40(sp)
    8000546a:	87aa                	mv	a5,a0
    8000546c:	c63e                	sw	a5,12(sp)
	int read_value = flash_cmd_to_read(0x0C000000,address);
    8000546e:	47b2                	lw	a5,12(sp)
    80005470:	85be                	mv	a1,a5
    80005472:	0c000537          	lui	a0,0xc000
    80005476:	f4bff0ef          	jal	ra,800053c0 <flash_cmd_to_read>
    8000547a:	87aa                	mv	a5,a0
    8000547c:	ce3e                	sw	a5,28(sp)
	return read_value;
    8000547e:	47f2                	lw	a5,28(sp)
}
    80005480:	853e                	mv	a0,a5
    80005482:	70a2                	ld	ra,40(sp)
    80005484:	6145                	addi	sp,sp,48
    80005486:	8082                	ret

0000000080005488 <flash_cmd_read>:
 * @details use for sending 8bit command and receive the 32bit of data
 * @param int command (opcode)
 * @return int  value (flash response to opcode)
 */
int flash_cmd_read(int command)
{
    80005488:	7179                	addi	sp,sp,-48
    8000548a:	f406                	sd	ra,40(sp)
    8000548c:	87aa                	mv	a5,a0
    8000548e:	c63e                	sw	a5,12(sp)
	int dr5;
	set_spi(spi_dr1, command);
    80005490:	85818793          	addi	a5,gp,-1960 # 8000ab60 <spi_dr1>
    80005494:	639c                	ld	a5,0(a5)
    80005496:	4732                	lw	a4,12(sp)
    80005498:	85ba                	mv	a1,a4
    8000549a:	853e                	mv	a0,a5
    8000549c:	bffff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr5, command);
    800054a0:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    800054a4:	639c                	ld	a5,0(a5)
    800054a6:	4732                	lw	a4,12(sp)
    800054a8:	85ba                	mv	a1,a4
    800054aa:	853e                	mv	a0,a5
    800054ac:	befff0ef          	jal	ra,8000509a <set_spi>
	spi_tx_rx_start();
    800054b0:	c29ff0ef          	jal	ra,800050d8 <spi_tx_rx_start>
	set_spi(spi_cr1, (SPI_BR(7)|SPI_TOTAL_BITS_TX(8)|SPI_TOTAL_BITS_RX(32)|SPI_SPE|SPI_CPHA|SPI_CPOL));
    800054b4:	84018793          	addi	a5,gp,-1984 # 8000ab48 <spi_cr1>
    800054b8:	6398                	ld	a4,0(a5)
    800054ba:	200807b7          	lui	a5,0x20080
    800054be:	07b78593          	addi	a1,a5,123 # 2008007b <_STACK_SIZE+0x2006c07b>
    800054c2:	853a                	mv	a0,a4
    800054c4:	bd7ff0ef          	jal	ra,8000509a <set_spi>
	if(spi_rxne_enable()) {
    800054c8:	c7fff0ef          	jal	ra,80005146 <spi_rxne_enable>
    800054cc:	87aa                	mv	a5,a0
    800054ce:	c791                	beqz	a5,800054da <flash_cmd_read+0x52>
		dr5 = *spi_dr5;
    800054d0:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    800054d4:	639c                	ld	a5,0(a5)
    800054d6:	439c                	lw	a5,0(a5)
    800054d8:	ce3e                	sw	a5,28(sp)
	}
	return dr5;
    800054da:	47f2                	lw	a5,28(sp)
}
    800054dc:	853e                	mv	a0,a5
    800054de:	70a2                	ld	ra,40(sp)
    800054e0:	6145                	addi	sp,sp,48
    800054e2:	8082                	ret

00000000800054e4 <flash_erase>:
 * @details Erase the 64kb sector from given address 
 * @warning before erasing the flash one should enable the WEL bit spi_sr by using write_enable()
 * @param int (address (address from which data should erase))
 */
void flash_erase(int address)
{
    800054e4:	1101                	addi	sp,sp,-32
    800054e6:	ec06                	sd	ra,24(sp)
    800054e8:	87aa                	mv	a5,a0
    800054ea:	c63e                	sw	a5,12(sp)
	flash_cmd_addr(0xdc000000, address);
    800054ec:	47b2                	lw	a5,12(sp)
    800054ee:	85be                	mv	a1,a5
    800054f0:	dc000537          	lui	a0,0xdc000
    800054f4:	d45ff0ef          	jal	ra,80005238 <flash_cmd_addr>
}
    800054f8:	0001                	nop
    800054fa:	60e2                	ld	ra,24(sp)
    800054fc:	6105                	addi	sp,sp,32
    800054fe:	8082                	ret

0000000080005500 <flash_status_register_read>:
 * @details  Using flash_cmd_read function with opcode 05h to check status of WIP(Write in progress)
 *           and WEL(Write Enable Latch) bit.
 * @return int
 */
int flash_status_register_read(void)
{
    80005500:	1101                	addi	sp,sp,-32
    80005502:	ec06                	sd	ra,24(sp)
	int stat = 0x3;
    80005504:	478d                	li	a5,3
    80005506:	c63e                	sw	a5,12(sp)

	while (stat & 0x03)
    80005508:	a839                	j	80005526 <flash_status_register_read+0x26>
	{
		stat = flash_cmd_read(0x05000000);
    8000550a:	05000537          	lui	a0,0x5000
    8000550e:	f7bff0ef          	jal	ra,80005488 <flash_cmd_read>
    80005512:	87aa                	mv	a5,a0
    80005514:	c63e                	sw	a5,12(sp)
		log_debug("flash status register val %x\n", stat);
    80005516:	47b2                	lw	a5,12(sp)
    80005518:	85be                	mv	a1,a5
    8000551a:	00004517          	auipc	a0,0x4
    8000551e:	fa650513          	addi	a0,a0,-90 # 800094c0 <__rodata_start+0x168>
    80005522:	671010ef          	jal	ra,80007392 <log_debug>
	while (stat & 0x03)
    80005526:	47b2                	lw	a5,12(sp)
    80005528:	8b8d                	andi	a5,a5,3
    8000552a:	2781                	sext.w	a5,a5
    8000552c:	fff9                	bnez	a5,8000550a <flash_status_register_read+0xa>
	}

	return 0;
    8000552e:	4781                	li	a5,0
}
    80005530:	853e                	mv	a0,a5
    80005532:	60e2                	ld	ra,24(sp)
    80005534:	6105                	addi	sp,sp,32
    80005536:	8082                	ret

0000000080005538 <flash_device_id>:
 *          24 bits of data from flash
 * @warning to move data from data register to fifo there must be some data into spi_dr5
 * @return int
 */
int flash_device_id(void)
{
    80005538:	1101                	addi	sp,sp,-32
    8000553a:	ec06                	sd	ra,24(sp)
	int dr3;
	int val1, val2;

	flash_write_enable();
    8000553c:	c73ff0ef          	jal	ra,800051ae <flash_write_enable>
	set_spi(spi_dr1, 0x9f000000);
    80005540:	85818793          	addi	a5,gp,-1960 # 8000ab60 <spi_dr1>
    80005544:	639c                	ld	a5,0(a5)
    80005546:	9f0005b7          	lui	a1,0x9f000
    8000554a:	853e                	mv	a0,a5
    8000554c:	b4fff0ef          	jal	ra,8000509a <set_spi>
	set_spi(spi_dr5, 0x9f000000);
    80005550:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    80005554:	639c                	ld	a5,0(a5)
    80005556:	9f0005b7          	lui	a1,0x9f000
    8000555a:	853e                	mv	a0,a5
    8000555c:	b3fff0ef          	jal	ra,8000509a <set_spi>
	spi_tx_rx_start();
    80005560:	b79ff0ef          	jal	ra,800050d8 <spi_tx_rx_start>
	set_spi(spi_cr1, (SPI_BR(7)|SPI_TOTAL_BITS_TX(8)|SPI_TOTAL_BITS_RX(24)|SPI_SPE|SPI_CPHA|SPI_CPOL));
    80005564:	84018793          	addi	a5,gp,-1984 # 8000ab48 <spi_cr1>
    80005568:	6398                	ld	a4,0(a5)
    8000556a:	180807b7          	lui	a5,0x18080
    8000556e:	07b78593          	addi	a1,a5,123 # 1808007b <_STACK_SIZE+0x1806c07b>
    80005572:	853a                	mv	a0,a4
    80005574:	b27ff0ef          	jal	ra,8000509a <set_spi>

	if(spi_rxne_enable())
    80005578:	bcfff0ef          	jal	ra,80005146 <spi_rxne_enable>
    8000557c:	87aa                	mv	a5,a0
    8000557e:	c791                	beqz	a5,8000558a <flash_device_id+0x52>
	{
		dr3 = *spi_dr5;
    80005580:	87818793          	addi	a5,gp,-1928 # 8000ab80 <spi_dr5>
    80005584:	639c                	ld	a5,0(a5)
    80005586:	439c                	lw	a5,0(a5)
    80005588:	c63e                	sw	a5,12(sp)
	}

	val1 = bitExtracted(dr3, 8, 17);
    8000558a:	47b2                	lw	a5,12(sp)
    8000558c:	4645                	li	a2,17
    8000558e:	45a1                	li	a1,8
    80005590:	853e                	mv	a0,a5
    80005592:	b7bff0ef          	jal	ra,8000510c <bitExtracted>
    80005596:	87aa                	mv	a5,a0
    80005598:	c43e                	sw	a5,8(sp)
	val2 = bitExtracted(dr3, 16, 1);
    8000559a:	47b2                	lw	a5,12(sp)
    8000559c:	4605                	li	a2,1
    8000559e:	45c1                	li	a1,16
    800055a0:	853e                	mv	a0,a5
    800055a2:	b6bff0ef          	jal	ra,8000510c <bitExtracted>
    800055a6:	87aa                	mv	a5,a0
    800055a8:	c23e                	sw	a5,4(sp)

	log_debug("Device ID %x \n", val1);
    800055aa:	47a2                	lw	a5,8(sp)
    800055ac:	85be                	mv	a1,a5
    800055ae:	00004517          	auipc	a0,0x4
    800055b2:	f3250513          	addi	a0,a0,-206 # 800094e0 <__rodata_start+0x188>
    800055b6:	5dd010ef          	jal	ra,80007392 <log_debug>
	log_debug("extracted device id %x \n",val2);
    800055ba:	4792                	lw	a5,4(sp)
    800055bc:	85be                	mv	a1,a5
    800055be:	00004517          	auipc	a0,0x4
    800055c2:	f3250513          	addi	a0,a0,-206 # 800094f0 <__rodata_start+0x198>
    800055c6:	5cd010ef          	jal	ra,80007392 <log_debug>

	return 1;
    800055ca:	4785                	li	a5,1
}
    800055cc:	853e                	mv	a0,a5
    800055ce:	60e2                	ld	ra,24(sp)
    800055d0:	6105                	addi	sp,sp,32
    800055d2:	8082                	ret

00000000800055d4 <i2c_init>:
 * @fn void i2c_init()
 * @brief Initialises the i2c modules.
 * @details Initialises the i2c array modules to the max. no of i2c modules present
 */
void i2c_init()
{
    800055d4:	1141                	addi	sp,sp,-16
	for(int i=0; i< MAX_I2C_COUNT; i++)
    800055d6:	c602                	sw	zero,12(sp)
    800055d8:	a815                	j	8000560c <i2c_init+0x38>
	{
		i2c_instance[i] = (i2c_struct*) (I2C0_BASE + (i * I2C_OFFSET));
    800055da:	4732                	lw	a4,12(sp)
    800055dc:	87ba                	mv	a5,a4
    800055de:	0027979b          	slliw	a5,a5,0x2
    800055e2:	9fb9                	addw	a5,a5,a4
    800055e4:	00a7979b          	slliw	a5,a5,0xa
    800055e8:	0007871b          	sext.w	a4,a5
    800055ec:	000407b7          	lui	a5,0x40
    800055f0:	9fb9                	addw	a5,a5,a4
    800055f2:	2781                	sext.w	a5,a5
    800055f4:	86be                	mv	a3,a5
    800055f6:	00102717          	auipc	a4,0x102
    800055fa:	88a70713          	addi	a4,a4,-1910 # 80106e80 <i2c_instance>
    800055fe:	47b2                	lw	a5,12(sp)
    80005600:	078e                	slli	a5,a5,0x3
    80005602:	97ba                	add	a5,a5,a4
    80005604:	e394                	sd	a3,0(a5)
	for(int i=0; i< MAX_I2C_COUNT; i++)
    80005606:	47b2                	lw	a5,12(sp)
    80005608:	2785                	addiw	a5,a5,1
    8000560a:	c63e                	sw	a5,12(sp)
    8000560c:	47b2                	lw	a5,12(sp)
    8000560e:	0007871b          	sext.w	a4,a5
    80005612:	4785                	li	a5,1
    80005614:	fce7d3e3          	bge	a5,a4,800055da <i2c_init+0x6>
	}
}
    80005618:	0001                	nop
    8000561a:	0001                	nop
    8000561c:	0141                	addi	sp,sp,16
    8000561e:	8082                	ret

0000000080005620 <config_i2c>:
 * @param unsigned char prescale_div
 * @param unsigned char scl_div
 * @return REturns 0 if success; else returns -ENXIO.
 */
int config_i2c(i2c_struct * instance, unsigned char prescale_div, unsigned char scl_div)
{
    80005620:	7179                	addi	sp,sp,-48
    80005622:	f406                	sd	ra,40(sp)
    80005624:	e42a                	sd	a0,8(sp)
    80005626:	87ae                	mv	a5,a1
    80005628:	8732                	mv	a4,a2
    8000562a:	00f103a3          	sb	a5,7(sp)
    8000562e:	87ba                	mv	a5,a4
    80005630:	00f10323          	sb	a5,6(sp)
	unsigned char temp = 0;
    80005634:	00010fa3          	sb	zero,31(sp)
	log_debug("\tI2C: Initializing the Controller\n");
    80005638:	00004517          	auipc	a0,0x4
    8000563c:	ed850513          	addi	a0,a0,-296 # 80009510 <__rodata_start+0x1b8>
    80005640:	553010ef          	jal	ra,80007392 <log_debug>

	if(prescale_div  != instance->prescale )
    80005644:	00714783          	lbu	a5,7(sp)
    80005648:	0007871b          	sext.w	a4,a5
    8000564c:	67a2                	ld	a5,8(sp)
    8000564e:	439c                	lw	a5,0(a5)
    80005650:	04f70d63          	beq	a4,a5,800056aa <config_i2c+0x8a>
	{
		instance->prescale = prescale_div;
    80005654:	00714783          	lbu	a5,7(sp)
    80005658:	0007871b          	sext.w	a4,a5
    8000565c:	67a2                	ld	a5,8(sp)
    8000565e:	c398                	sw	a4,0(a5)
#ifdef DEBUG 
		temp = instance->prescale;
    80005660:	67a2                	ld	a5,8(sp)
    80005662:	439c                	lw	a5,0(a5)
    80005664:	00f10fa3          	sb	a5,31(sp)

		if((temp | 0x00) != prescale_div)
    80005668:	01f14703          	lbu	a4,31(sp)
    8000566c:	00714783          	lbu	a5,7(sp)
    80005670:	0ff77713          	andi	a4,a4,255
    80005674:	0ff7f793          	andi	a5,a5,255
    80005678:	02f70363          	beq	a4,a5,8000569e <config_i2c+0x7e>
		{
			log_error("\t Failed to write Prescale division Written Value: 0x%x; read Value: 0x%x\n", prescale_div, instance->prescale);
    8000567c:	00714783          	lbu	a5,7(sp)
    80005680:	0007871b          	sext.w	a4,a5
    80005684:	67a2                	ld	a5,8(sp)
    80005686:	439c                	lw	a5,0(a5)
    80005688:	863e                	mv	a2,a5
    8000568a:	85ba                	mv	a1,a4
    8000568c:	00004517          	auipc	a0,0x4
    80005690:	eac50513          	addi	a0,a0,-340 # 80009538 <__rodata_start+0x1e0>
    80005694:	549010ef          	jal	ra,800073dc <log_error>
			return -ENXIO;
    80005698:	05200793          	li	a5,82
    8000569c:	a291                	j	800057e0 <config_i2c+0x1c0>
		}
		else
		{
			log_debug("\tPrescaler successfully initalized\n");
    8000569e:	00004517          	auipc	a0,0x4
    800056a2:	eea50513          	addi	a0,a0,-278 # 80009588 <__rodata_start+0x230>
    800056a6:	4ed010ef          	jal	ra,80007392 <log_debug>
		}
#endif
	}

	if(scl_div != instance->scl )
    800056aa:	00614783          	lbu	a5,6(sp)
    800056ae:	0007871b          	sext.w	a4,a5
    800056b2:	67a2                	ld	a5,8(sp)
    800056b4:	5f9c                	lw	a5,56(a5)
    800056b6:	04f70d63          	beq	a4,a5,80005710 <config_i2c+0xf0>
	{
		instance->scl = scl_div;  //Setting the I2C clock value to be 1, which will set the clock for module and prescaler clock
    800056ba:	00614783          	lbu	a5,6(sp)
    800056be:	0007871b          	sext.w	a4,a5
    800056c2:	67a2                	ld	a5,8(sp)
    800056c4:	df98                	sw	a4,56(a5)


#ifdef DEBUG 
		temp = instance->scl;
    800056c6:	67a2                	ld	a5,8(sp)
    800056c8:	5f9c                	lw	a5,56(a5)
    800056ca:	00f10fa3          	sb	a5,31(sp)

		/* Just reading the written value to see if all is well -- Compiler should not optimize this load!!! Compiler can just optimize the store to pointer address followed by load pointer to a register to just an immediate load to the register since clock register is not used anywhere -- but the purpose is lost. Don't give compiler optimizations */
		if((temp | 0x00) != scl_div)
    800056ce:	01f14703          	lbu	a4,31(sp)
    800056d2:	00614783          	lbu	a5,6(sp)
    800056d6:	0ff77713          	andi	a4,a4,255
    800056da:	0ff7f793          	andi	a5,a5,255
    800056de:	02f70363          	beq	a4,a5,80005704 <config_i2c+0xe4>
		{
			log_error("\tClock initialization failed Write Value: 0x%x; read Value: 0x%x\n", scl_div, temp);
    800056e2:	00614783          	lbu	a5,6(sp)
    800056e6:	2781                	sext.w	a5,a5
    800056e8:	01f14703          	lbu	a4,31(sp)
    800056ec:	2701                	sext.w	a4,a4
    800056ee:	863a                	mv	a2,a4
    800056f0:	85be                	mv	a1,a5
    800056f2:	00004517          	auipc	a0,0x4
    800056f6:	ebe50513          	addi	a0,a0,-322 # 800095b0 <__rodata_start+0x258>
    800056fa:	4e3010ef          	jal	ra,800073dc <log_error>
			return -ENXIO;
    800056fe:	05200793          	li	a5,82
    80005702:	a8f9                	j	800057e0 <config_i2c+0x1c0>
		}
		else
		{
			log_debug("\tClock successfully initalized\n");
    80005704:	00004517          	auipc	a0,0x4
    80005708:	ef450513          	addi	a0,a0,-268 # 800095f8 <__rodata_start+0x2a0>
    8000570c:	487010ef          	jal	ra,80007392 <log_debug>
		}
#endif
	}

	/* S1=0x80 S0 selected, serial interface off */
	log_debug("\tClearing the status register. \n");
    80005710:	00004517          	auipc	a0,0x4
    80005714:	f0850513          	addi	a0,a0,-248 # 80009618 <__rodata_start+0x2c0>
    80005718:	47b010ef          	jal	ra,80007392 <log_debug>
	instance->control = I2C_PIN;
    8000571c:	67a2                	ld	a5,8(sp)
    8000571e:	08000713          	li	a4,128
    80005722:	c798                	sw	a4,8(a5)

	// Reading set control Register Value to ensure sanctity
	log_debug("\tReading Status Register \n");
    80005724:	00004517          	auipc	a0,0x4
    80005728:	f1c50513          	addi	a0,a0,-228 # 80009640 <__rodata_start+0x2e8>
    8000572c:	467010ef          	jal	ra,80007392 <log_debug>
	temp = instance->control;
    80005730:	67a2                	ld	a5,8(sp)
    80005732:	479c                	lw	a5,8(a5)
    80005734:	00f10fa3          	sb	a5,31(sp)

	//Check whether the status register is cleared or not.
	if((temp & 0x7f) != 0){
    80005738:	01f14783          	lbu	a5,31(sp)
    8000573c:	2781                	sext.w	a5,a5
    8000573e:	07f7f793          	andi	a5,a5,127
    80005742:	2781                	sext.w	a5,a5
    80005744:	cb91                	beqz	a5,80005758 <config_i2c+0x138>
		log_error("\tDevice Not Recognized\n");
    80005746:	00004517          	auipc	a0,0x4
    8000574a:	f1a50513          	addi	a0,a0,-230 # 80009660 <__rodata_start+0x308>
    8000574e:	48f010ef          	jal	ra,800073dc <log_error>
		return -ENXIO;
    80005752:	05200793          	li	a5,82
    80005756:	a069                	j	800057e0 <config_i2c+0x1c0>
	}

	log_debug("\tWaiting for a specified time\n ");
    80005758:	00004517          	auipc	a0,0x4
    8000575c:	f2050513          	addi	a0,a0,-224 # 80009678 <__rodata_start+0x320>
    80005760:	433010ef          	jal	ra,80007392 <log_debug>
	waitfor(900); //1 Second software wait -- Should be 900000 but setting to 900 now since simulation is already slow
    80005764:	38400513          	li	a0,900
    80005768:	4aa010ef          	jal	ra,80006c12 <waitfor>
	log_debug("\tDone Waiting \n ");
    8000576c:	00004517          	auipc	a0,0x4
    80005770:	f2c50513          	addi	a0,a0,-212 # 80009698 <__rodata_start+0x340>
    80005774:	41f010ef          	jal	ra,80007392 <log_debug>
	log_info("\nControl: %x; Status: %x", instance->control, instance->status);
    80005778:	67a2                	ld	a5,8(sp)
    8000577a:	4798                	lw	a4,8(a5)
    8000577c:	67a2                	ld	a5,8(sp)
    8000577e:	4f9c                	lw	a5,24(a5)
    80005780:	863e                	mv	a2,a5
    80005782:	85ba                	mv	a1,a4
    80005784:	00004517          	auipc	a0,0x4
    80005788:	f2c50513          	addi	a0,a0,-212 # 800096b0 <__rodata_start+0x358>
    8000578c:	3d5010ef          	jal	ra,80007360 <log_info>
	/* Enable Serial Interface */
	instance->control = I2C_IDLE;
    80005790:	67a2                	ld	a5,8(sp)
    80005792:	0c100713          	li	a4,193
    80005796:	c798                	sw	a4,8(a5)
	waitfor(900); //1 Second software wait -- Should be 900000 but setting to 900 now since simulation is already slow
    80005798:	38400513          	li	a0,900
    8000579c:	476010ef          	jal	ra,80006c12 <waitfor>

	temp = instance->status;
    800057a0:	67a2                	ld	a5,8(sp)
    800057a2:	4f9c                	lw	a5,24(a5)
    800057a4:	00f10fa3          	sb	a5,31(sp)

	/* Check to see if I2C is really in Idle and see if we can access the status register -- If not something wrong in initialization. This also verifies if Control is properly written since zero bit will be initialized to zero*/
	if(temp != (I2C_PIN | I2C_BB)){
    800057a8:	01f14783          	lbu	a5,31(sp)
    800057ac:	0ff7f713          	andi	a4,a5,255
    800057b0:	08100793          	li	a5,129
    800057b4:	00f70f63          	beq	a4,a5,800057d2 <config_i2c+0x1b2>
		log_error("\n\tInitialization failed; Status Reg: %x\n", temp);
    800057b8:	01f14783          	lbu	a5,31(sp)
    800057bc:	2781                	sext.w	a5,a5
    800057be:	85be                	mv	a1,a5
    800057c0:	00004517          	auipc	a0,0x4
    800057c4:	f1050513          	addi	a0,a0,-240 # 800096d0 <__rodata_start+0x378>
    800057c8:	415010ef          	jal	ra,800073dc <log_error>
		return -ENXIO;
    800057cc:	05200793          	li	a5,82
    800057d0:	a801                	j	800057e0 <config_i2c+0x1c0>
	}

	log_info("\tI2C Initialization success\n");
    800057d2:	00004517          	auipc	a0,0x4
    800057d6:	f2e50513          	addi	a0,a0,-210 # 80009700 <__rodata_start+0x3a8>
    800057da:	387010ef          	jal	ra,80007360 <log_info>
	return 0;
    800057de:	4781                	li	a5,0
}
    800057e0:	853e                	mv	a0,a5
    800057e2:	70a2                	ld	ra,40(sp)
    800057e4:	6145                	addi	sp,sp,48
    800057e6:	8082                	ret

00000000800057e8 <wait_till_I2c_bus_free>:
 *    for a particular time. If it becomes free, returns 0, else negative value.
 * @param i2c_struct*
 * @return Returns 0 if the bus becomes free; else returns ETIMEDOUT.
 */
int wait_till_I2c_bus_free(i2c_struct * instance)
{
    800057e8:	7179                	addi	sp,sp,-48
    800057ea:	f406                	sd	ra,40(sp)
    800057ec:	e42a                	sd	a0,8(sp)
	log_debug("\tCheck for I2C Bus Busy to be free.\n");
    800057ee:	00004517          	auipc	a0,0x4
    800057f2:	f3250513          	addi	a0,a0,-206 # 80009720 <__rodata_start+0x3c8>
    800057f6:	39d010ef          	jal	ra,80007392 <log_debug>
	int timeout = DEF_TIMEOUT;
    800057fa:	03c00793          	li	a5,60
    800057fe:	ce3e                	sw	a5,28(sp)
	int status;

	status = instance->status;
    80005800:	67a2                	ld	a5,8(sp)
    80005802:	4f9c                	lw	a5,24(a5)
    80005804:	cc3e                	sw	a5,24(sp)

	while (!(status & I2C_BB) && --timeout) {
    80005806:	a809                	j	80005818 <wait_till_I2c_bus_free+0x30>
		waitfor(20000); /* wait for 100 us */
    80005808:	6795                	lui	a5,0x5
    8000580a:	e2078513          	addi	a0,a5,-480 # 4e20 <_tbss_end+0x4e20>
    8000580e:	404010ef          	jal	ra,80006c12 <waitfor>
		status = instance->status;
    80005812:	67a2                	ld	a5,8(sp)
    80005814:	4f9c                	lw	a5,24(a5)
    80005816:	cc3e                	sw	a5,24(sp)
	while (!(status & I2C_BB) && --timeout) {
    80005818:	47e2                	lw	a5,24(sp)
    8000581a:	8b85                	andi	a5,a5,1
    8000581c:	2781                	sext.w	a5,a5
    8000581e:	e799                	bnez	a5,8000582c <wait_till_I2c_bus_free+0x44>
    80005820:	47f2                	lw	a5,28(sp)
    80005822:	37fd                	addiw	a5,a5,-1
    80005824:	ce3e                	sw	a5,28(sp)
    80005826:	47f2                	lw	a5,28(sp)
    80005828:	2781                	sext.w	a5,a5
    8000582a:	fff9                	bnez	a5,80005808 <wait_till_I2c_bus_free+0x20>
	}

	if (timeout == 0) {
    8000582c:	47f2                	lw	a5,28(sp)
    8000582e:	2781                	sext.w	a5,a5
    80005830:	eb91                	bnez	a5,80005844 <wait_till_I2c_bus_free+0x5c>
		log_error("\t Bus busy wait - timed out. Resetting\n");
    80005832:	00004517          	auipc	a0,0x4
    80005836:	f1650513          	addi	a0,a0,-234 # 80009748 <__rodata_start+0x3f0>
    8000583a:	3a3010ef          	jal	ra,800073dc <log_error>
		return ETIMEDOUT;
    8000583e:	fb000793          	li	a5,-80
    80005842:	a011                	j	80005846 <wait_till_I2c_bus_free+0x5e>
	}

	return 0;
    80005844:	4781                	li	a5,0
}
    80005846:	853e                	mv	a0,a5
    80005848:	70a2                	ld	ra,40(sp)
    8000584a:	6145                	addi	sp,sp,48
    8000584c:	8082                	ret

000000008000584e <wait_till_txrx_operation_Completes>:
 * @param i2c_struct* 
 * @param int *status  --> contents of the status register
 * @return zero if success; else -ETIMEOUT
 */
int wait_till_txrx_operation_Completes(i2c_struct * instance, int *status)
{
    8000584e:	7179                	addi	sp,sp,-48
    80005850:	f406                	sd	ra,40(sp)
    80005852:	e42a                	sd	a0,8(sp)
    80005854:	e02e                	sd	a1,0(sp)

	int timeout = DEF_TIMEOUT;
    80005856:	03c00793          	li	a5,60
    8000585a:	ce3e                	sw	a5,28(sp)

	*status = instance->status;
    8000585c:	67a2                	ld	a5,8(sp)
    8000585e:	4f9c                	lw	a5,24(a5)
    80005860:	0007871b          	sext.w	a4,a5
    80005864:	6782                	ld	a5,0(sp)
    80005866:	c398                	sw	a4,0(a5)

	while ((*status & I2C_PIN) && --timeout) {
    80005868:	a821                	j	80005880 <wait_till_txrx_operation_Completes+0x32>
		waitfor(10000); /* wait for 100 us */
    8000586a:	6789                	lui	a5,0x2
    8000586c:	71078513          	addi	a0,a5,1808 # 2710 <_tbss_end+0x2710>
    80005870:	3a2010ef          	jal	ra,80006c12 <waitfor>
		*status = instance->status;
    80005874:	67a2                	ld	a5,8(sp)
    80005876:	4f9c                	lw	a5,24(a5)
    80005878:	0007871b          	sext.w	a4,a5
    8000587c:	6782                	ld	a5,0(sp)
    8000587e:	c398                	sw	a4,0(a5)
	while ((*status & I2C_PIN) && --timeout) {
    80005880:	6782                	ld	a5,0(sp)
    80005882:	439c                	lw	a5,0(a5)
    80005884:	0807f793          	andi	a5,a5,128
    80005888:	2781                	sext.w	a5,a5
    8000588a:	c799                	beqz	a5,80005898 <wait_till_txrx_operation_Completes+0x4a>
    8000588c:	47f2                	lw	a5,28(sp)
    8000588e:	37fd                	addiw	a5,a5,-1
    80005890:	ce3e                	sw	a5,28(sp)
    80005892:	47f2                	lw	a5,28(sp)
    80005894:	2781                	sext.w	a5,a5
    80005896:	fbf1                	bnez	a5,8000586a <wait_till_txrx_operation_Completes+0x1c>
	}

	if (timeout == 0){
    80005898:	47f2                	lw	a5,28(sp)
    8000589a:	2781                	sext.w	a5,a5
    8000589c:	eb91                	bnez	a5,800058b0 <wait_till_txrx_operation_Completes+0x62>
		log_info("\tWait for pin timed out\n");
    8000589e:	00004517          	auipc	a0,0x4
    800058a2:	ed250513          	addi	a0,a0,-302 # 80009770 <__rodata_start+0x418>
    800058a6:	2bb010ef          	jal	ra,80007360 <log_info>
		return ETIMEDOUT;
    800058aa:	fb000793          	li	a5,-80
    800058ae:	a829                	j	800058c8 <wait_till_txrx_operation_Completes+0x7a>
	}

	waitfor(10000); /* wait for 100 us */
    800058b0:	6789                	lui	a5,0x2
    800058b2:	71078513          	addi	a0,a5,1808 # 2710 <_tbss_end+0x2710>
    800058b6:	35c010ef          	jal	ra,80006c12 <waitfor>
	log_debug("\n I2C tx_rx operation is completed");
    800058ba:	00004517          	auipc	a0,0x4
    800058be:	ed650513          	addi	a0,a0,-298 # 80009790 <__rodata_start+0x438>
    800058c2:	2d1010ef          	jal	ra,80007392 <log_debug>
	return 0;
    800058c6:	4781                	li	a5,0
}
    800058c8:	853e                	mv	a0,a5
    800058ca:	70a2                	ld	ra,40(sp)
    800058cc:	6145                	addi	sp,sp,48
    800058ce:	8082                	ret

00000000800058d0 <sendbytes>:
 * @param int last
 * @param int eni
 * @return Returns number of bytes written else EREMOTEIO.
 */
int sendbytes(i2c_struct * instance, const char *buf, int count, int last, int eni)
{
    800058d0:	7139                	addi	sp,sp,-64
    800058d2:	fc06                	sd	ra,56(sp)
    800058d4:	ec2a                	sd	a0,24(sp)
    800058d6:	e82e                	sd	a1,16(sp)
    800058d8:	87b2                	mv	a5,a2
    800058da:	c63e                	sw	a5,12(sp)
    800058dc:	87b6                	mv	a5,a3
    800058de:	c43e                	sw	a5,8(sp)
    800058e0:	87ba                	mv	a5,a4
    800058e2:	c23e                	sw	a5,4(sp)
	int wrcount, status, timeout;
	printf("\tStarting Write Transaction -- Did you create tri1 nets for SDA and SCL in verilog?\n");
    800058e4:	00004517          	auipc	a0,0x4
    800058e8:	ed450513          	addi	a0,a0,-300 # 800097b8 <__rodata_start+0x460>
    800058ec:	229010ef          	jal	ra,80007314 <printf>
	for (wrcount=0; wrcount<count; ++wrcount) {
    800058f0:	d602                	sw	zero,44(sp)
    800058f2:	a0ad                	j	8000595c <sendbytes+0x8c>
		instance->data = buf[wrcount];
    800058f4:	57b2                	lw	a5,44(sp)
    800058f6:	6742                	ld	a4,16(sp)
    800058f8:	97ba                	add	a5,a5,a4
    800058fa:	0007c783          	lbu	a5,0(a5)
    800058fe:	0007871b          	sext.w	a4,a5
    80005902:	67e2                	ld	a5,24(sp)
    80005904:	cb98                	sw	a4,16(a5)
		timeout = wait_till_txrx_operation_Completes(instance, &status);
    80005906:	105c                	addi	a5,sp,36
    80005908:	85be                	mv	a1,a5
    8000590a:	6562                	ld	a0,24(sp)
    8000590c:	f43ff0ef          	jal	ra,8000584e <wait_till_txrx_operation_Completes>
    80005910:	87aa                	mv	a5,a0
    80005912:	d43e                	sw	a5,40(sp)
		if (timeout) {
    80005914:	57a2                	lw	a5,40(sp)
    80005916:	2781                	sext.w	a5,a5
    80005918:	cf91                	beqz	a5,80005934 <sendbytes+0x64>
			printf("\tTimeout happened - Write did not go through the BFM -- Diagnose\n");
    8000591a:	00004517          	auipc	a0,0x4
    8000591e:	ef650513          	addi	a0,a0,-266 # 80009810 <__rodata_start+0x4b8>
    80005922:	1f3010ef          	jal	ra,80007314 <printf>
			instance->control = I2C_STOP;
    80005926:	67e2                	ld	a5,24(sp)
    80005928:	0c300713          	li	a4,195
    8000592c:	c798                	sw	a4,8(a5)
			return EREMOTEIO;
    8000592e:	faf00793          	li	a5,-81
    80005932:	a8a5                	j	800059aa <sendbytes+0xda>
		}
		if (status & I2C_LRB) { // What error is this?
    80005934:	5792                	lw	a5,36(sp)
    80005936:	8ba1                	andi	a5,a5,8
    80005938:	2781                	sext.w	a5,a5
    8000593a:	cf91                	beqz	a5,80005956 <sendbytes+0x86>
			instance->control = I2C_STOP;//~
    8000593c:	67e2                	ld	a5,24(sp)
    8000593e:	0c300713          	li	a4,195
    80005942:	c798                	sw	a4,8(a5)
			printf("\tSome status check failing\n");
    80005944:	00004517          	auipc	a0,0x4
    80005948:	f1450513          	addi	a0,a0,-236 # 80009858 <__rodata_start+0x500>
    8000594c:	1c9010ef          	jal	ra,80007314 <printf>
			return EREMOTEIO;
    80005950:	faf00793          	li	a5,-81
    80005954:	a899                	j	800059aa <sendbytes+0xda>
	for (wrcount=0; wrcount<count; ++wrcount) {
    80005956:	57b2                	lw	a5,44(sp)
    80005958:	2785                	addiw	a5,a5,1
    8000595a:	d63e                	sw	a5,44(sp)
    8000595c:	5732                	lw	a4,44(sp)
    8000595e:	47b2                	lw	a5,12(sp)
    80005960:	2701                	sext.w	a4,a4
    80005962:	2781                	sext.w	a5,a5
    80005964:	f8f748e3          	blt	a4,a5,800058f4 <sendbytes+0x24>
		}
	}
	if (last){
    80005968:	47a2                	lw	a5,8(sp)
    8000596a:	2781                	sext.w	a5,a5
    8000596c:	cf81                	beqz	a5,80005984 <sendbytes+0xb4>
		printf("\tLast byte sent : Issue a stop\n");
    8000596e:	00004517          	auipc	a0,0x4
    80005972:	f0a50513          	addi	a0,a0,-246 # 80009878 <__rodata_start+0x520>
    80005976:	19f010ef          	jal	ra,80007314 <printf>
		instance->control = I2C_STOP;
    8000597a:	67e2                	ld	a5,24(sp)
    8000597c:	0c300713          	li	a4,195
    80005980:	c798                	sw	a4,8(a5)
    80005982:	a01d                	j	800059a8 <sendbytes+0xd8>
	}
	else{
		printf("\tSending Rep Start and doing some other R/W transaction\n");
    80005984:	00004517          	auipc	a0,0x4
    80005988:	f1450513          	addi	a0,a0,-236 # 80009898 <__rodata_start+0x540>
    8000598c:	189010ef          	jal	ra,80007314 <printf>

		if(!eni)
    80005990:	4792                	lw	a5,4(sp)
    80005992:	2781                	sext.w	a5,a5
    80005994:	e791                	bnez	a5,800059a0 <sendbytes+0xd0>
			instance->control = I2C_REPSTART;
    80005996:	67e2                	ld	a5,24(sp)
    80005998:	04500713          	li	a4,69
    8000599c:	c798                	sw	a4,8(a5)
    8000599e:	a029                	j	800059a8 <sendbytes+0xd8>
		else
			instance->control = I2C_REPSTART_ENI;
    800059a0:	67e2                	ld	a5,24(sp)
    800059a2:	04d00713          	li	a4,77
    800059a6:	c798                	sw	a4,8(a5)
	}

	return wrcount;
    800059a8:	57b2                	lw	a5,44(sp)
}
    800059aa:	853e                	mv	a0,a5
    800059ac:	70e2                	ld	ra,56(sp)
    800059ae:	6121                	addi	sp,sp,64
    800059b0:	8082                	ret

00000000800059b2 <readbytes>:
 * @param int count
 * @param int last
 * @return Returns number of bytest read over i2c bus. else -1.
 */
int readbytes(i2c_struct * instance, char *buf, int count, int last)
{
    800059b2:	7139                	addi	sp,sp,-64
    800059b4:	fc06                	sd	ra,56(sp)
    800059b6:	ec2a                	sd	a0,24(sp)
    800059b8:	e82e                	sd	a1,16(sp)
    800059ba:	87b2                	mv	a5,a2
    800059bc:	8736                	mv	a4,a3
    800059be:	c63e                	sw	a5,12(sp)
    800059c0:	87ba                	mv	a5,a4
    800059c2:	c43e                	sw	a5,8(sp)
	int i, status;
	int wfp;

	/* increment number of bytes to read by one -- read dummy byte */
	for (i = 0; i <= count; i++) {
    800059c4:	d602                	sw	zero,44(sp)
    800059c6:	a0c5                	j	80005aa6 <readbytes+0xf4>
		wfp = wait_till_txrx_operation_Completes(instance, &status);
    800059c8:	105c                	addi	a5,sp,36
    800059ca:	85be                	mv	a1,a5
    800059cc:	6562                	ld	a0,24(sp)
    800059ce:	e81ff0ef          	jal	ra,8000584e <wait_till_txrx_operation_Completes>
    800059d2:	87aa                	mv	a5,a0
    800059d4:	d43e                	sw	a5,40(sp)
		if (wfp) {
    800059d6:	57a2                	lw	a5,40(sp)
    800059d8:	2781                	sext.w	a5,a5
    800059da:	c799                	beqz	a5,800059e8 <readbytes+0x36>
			instance->control = I2C_STOP;
    800059dc:	67e2                	ld	a5,24(sp)
    800059de:	0c300713          	li	a4,195
    800059e2:	c798                	sw	a4,8(a5)
			return -1;
    800059e4:	57fd                	li	a5,-1
    800059e6:	a8c9                	j	80005ab8 <readbytes+0x106>
		}

		if ((status & I2C_LRB) && (i != count)) {
    800059e8:	5792                	lw	a5,36(sp)
    800059ea:	8ba1                	andi	a5,a5,8
    800059ec:	2781                	sext.w	a5,a5
    800059ee:	c39d                	beqz	a5,80005a14 <readbytes+0x62>
    800059f0:	5732                	lw	a4,44(sp)
    800059f2:	47b2                	lw	a5,12(sp)
    800059f4:	2701                	sext.w	a4,a4
    800059f6:	2781                	sext.w	a5,a5
    800059f8:	00f70e63          	beq	a4,a5,80005a14 <readbytes+0x62>
			instance->control = I2C_STOP;
    800059fc:	67e2                	ld	a5,24(sp)
    800059fe:	0c300713          	li	a4,195
    80005a02:	c798                	sw	a4,8(a5)
			printf("\tNo ack\n");
    80005a04:	00004517          	auipc	a0,0x4
    80005a08:	ed450513          	addi	a0,a0,-300 # 800098d8 <__rodata_start+0x580>
    80005a0c:	109010ef          	jal	ra,80007314 <printf>
			return -1;
    80005a10:	57fd                	li	a5,-1
    80005a12:	a05d                	j	80005ab8 <readbytes+0x106>
		}

		if (i)
    80005a14:	57b2                	lw	a5,44(sp)
    80005a16:	2781                	sext.w	a5,a5
    80005a18:	cb9d                	beqz	a5,80005a4e <readbytes+0x9c>
		{
			buf[i - 1] = instance->data;
    80005a1a:	67e2                	ld	a5,24(sp)
    80005a1c:	4b94                	lw	a3,16(a5)
    80005a1e:	57b2                	lw	a5,44(sp)
    80005a20:	17fd                	addi	a5,a5,-1
    80005a22:	6742                	ld	a4,16(sp)
    80005a24:	97ba                	add	a5,a5,a4
    80005a26:	8736                	mv	a4,a3
    80005a28:	0ff77713          	andi	a4,a4,255
    80005a2c:	00e78023          	sb	a4,0(a5)
			printf("\n Read Value: %x", buf[i - 1]);
    80005a30:	57b2                	lw	a5,44(sp)
    80005a32:	17fd                	addi	a5,a5,-1
    80005a34:	6742                	ld	a4,16(sp)
    80005a36:	97ba                	add	a5,a5,a4
    80005a38:	0007c783          	lbu	a5,0(a5)
    80005a3c:	2781                	sext.w	a5,a5
    80005a3e:	85be                	mv	a1,a5
    80005a40:	00004517          	auipc	a0,0x4
    80005a44:	ea850513          	addi	a0,a0,-344 # 800098e8 <__rodata_start+0x590>
    80005a48:	0cd010ef          	jal	ra,80007314 <printf>
    80005a4c:	a819                	j	80005a62 <readbytes+0xb0>
		}
		else
			instance->data = !instance->data; /* dummy read */
    80005a4e:	67e2                	ld	a5,24(sp)
    80005a50:	4b9c                	lw	a5,16(a5)
    80005a52:	0017b793          	seqz	a5,a5
    80005a56:	0ff7f793          	andi	a5,a5,255
    80005a5a:	0007871b          	sext.w	a4,a5
    80005a5e:	67e2                	ld	a5,24(sp)
    80005a60:	cb98                	sw	a4,16(a5)

		if (i == count - 1) {
    80005a62:	47b2                	lw	a5,12(sp)
    80005a64:	37fd                	addiw	a5,a5,-1
    80005a66:	0007871b          	sext.w	a4,a5
    80005a6a:	57b2                	lw	a5,44(sp)
    80005a6c:	2781                	sext.w	a5,a5
    80005a6e:	00e79763          	bne	a5,a4,80005a7c <readbytes+0xca>
			instance->control = I2C_ESO;
    80005a72:	67e2                	ld	a5,24(sp)
    80005a74:	04000713          	li	a4,64
    80005a78:	c798                	sw	a4,8(a5)
    80005a7a:	a01d                	j	80005aa0 <readbytes+0xee>
		} else if (i == count) {
    80005a7c:	5732                	lw	a4,44(sp)
    80005a7e:	47b2                	lw	a5,12(sp)
    80005a80:	2701                	sext.w	a4,a4
    80005a82:	2781                	sext.w	a5,a5
    80005a84:	00f71e63          	bne	a4,a5,80005aa0 <readbytes+0xee>
			if (last)
    80005a88:	47a2                	lw	a5,8(sp)
    80005a8a:	2781                	sext.w	a5,a5
    80005a8c:	c791                	beqz	a5,80005a98 <readbytes+0xe6>
				instance->control = I2C_STOP;
    80005a8e:	67e2                	ld	a5,24(sp)
    80005a90:	0c300713          	li	a4,195
    80005a94:	c798                	sw	a4,8(a5)
    80005a96:	a029                	j	80005aa0 <readbytes+0xee>
			else
				instance->control = I2C_REPSTART_ENI;
    80005a98:	67e2                	ld	a5,24(sp)
    80005a9a:	04d00713          	li	a4,77
    80005a9e:	c798                	sw	a4,8(a5)
	for (i = 0; i <= count; i++) {
    80005aa0:	57b2                	lw	a5,44(sp)
    80005aa2:	2785                	addiw	a5,a5,1
    80005aa4:	d63e                	sw	a5,44(sp)
    80005aa6:	5732                	lw	a4,44(sp)
    80005aa8:	47b2                	lw	a5,12(sp)
    80005aaa:	2701                	sext.w	a4,a4
    80005aac:	2781                	sext.w	a5,a5
    80005aae:	f0e7dde3          	bge	a5,a4,800059c8 <readbytes+0x16>
		}

	}

	return i-1; //excluding the dummy read
    80005ab2:	57b2                	lw	a5,44(sp)
    80005ab4:	37fd                	addiw	a5,a5,-1
    80005ab6:	2781                	sext.w	a5,a5
}
    80005ab8:	853e                	mv	a0,a5
    80005aba:	70e2                	ld	ra,56(sp)
    80005abc:	6121                	addi	sp,sp,64
    80005abe:	8082                	ret

0000000080005ac0 <i2c_send_slave_address>:
 * @param unsigned char rdWrCntrl
 * @param unsigned long delay
 * @return Zero if success; else non zero
 */
int i2c_send_slave_address(i2c_struct * instance, unsigned char slaveAddress, unsigned char rdWrCntrl, unsigned long delay)
{
    80005ac0:	7139                	addi	sp,sp,-64
    80005ac2:	fc06                	sd	ra,56(sp)
    80005ac4:	ec2a                	sd	a0,24(sp)
    80005ac6:	87ae                	mv	a5,a1
    80005ac8:	8732                	mv	a4,a2
    80005aca:	e436                	sd	a3,8(sp)
    80005acc:	00f10ba3          	sb	a5,23(sp)
    80005ad0:	87ba                	mv	a5,a4
    80005ad2:	00f10b23          	sb	a5,22(sp)
	int timeout;
	unsigned char temp = 0;
    80005ad6:	020107a3          	sb	zero,47(sp)
	int status = 0;
    80005ada:	d202                	sw	zero,36(sp)

	delay = delay;

	if(rdWrCntrl == 0)
    80005adc:	01614783          	lbu	a5,22(sp)
    80005ae0:	0ff7f793          	andi	a5,a5,255
    80005ae4:	c799                	beqz	a5,80005af2 <i2c_send_slave_address+0x32>
		slaveAddress |= I2C_WRITE;
	else
		slaveAddress |= I2C_READ;
    80005ae6:	01714783          	lbu	a5,23(sp)
    80005aea:	0017e793          	ori	a5,a5,1
    80005aee:	00f10ba3          	sb	a5,23(sp)

	//Writing the slave address that needs to be written into data register.
	instance->data = slaveAddress;
    80005af2:	01714783          	lbu	a5,23(sp)
    80005af6:	0007871b          	sext.w	a4,a5
    80005afa:	67e2                	ld	a5,24(sp)
    80005afc:	cb98                	sw	a4,16(a5)
	log_debug("\tSlave Address 0x%x written into data register\n", slaveAddress);
    80005afe:	01714783          	lbu	a5,23(sp)
    80005b02:	2781                	sext.w	a5,a5
    80005b04:	85be                	mv	a1,a5
    80005b06:	00004517          	auipc	a0,0x4
    80005b0a:	dfa50513          	addi	a0,a0,-518 # 80009900 <__rodata_start+0x5a8>
    80005b0e:	085010ef          	jal	ra,80007392 <log_debug>

	//Reads back the data register to confirm
	temp = instance->data; //Reads the slave address from I2C controller
    80005b12:	67e2                	ld	a5,24(sp)
    80005b14:	4b9c                	lw	a5,16(a5)
    80005b16:	02f107a3          	sb	a5,47(sp)

	if(slaveAddress != (int)temp)
    80005b1a:	01714703          	lbu	a4,23(sp)
    80005b1e:	02f14783          	lbu	a5,47(sp)
    80005b22:	0ff77713          	andi	a4,a4,255
    80005b26:	0ff7f793          	andi	a5,a5,255
    80005b2a:	04f70063          	beq	a4,a5,80005b6a <i2c_send_slave_address+0xaa>
	{
		log_error("\tSlave address is not matching; Written Add. Value: 0x%x; Read Add. Value: 0x%x\n", slaveAddress, temp);
    80005b2e:	01714783          	lbu	a5,23(sp)
    80005b32:	2781                	sext.w	a5,a5
    80005b34:	02f14703          	lbu	a4,47(sp)
    80005b38:	2701                	sext.w	a4,a4
    80005b3a:	863a                	mv	a2,a4
    80005b3c:	85be                	mv	a1,a5
    80005b3e:	00004517          	auipc	a0,0x4
    80005b42:	df250513          	addi	a0,a0,-526 # 80009930 <__rodata_start+0x5d8>
    80005b46:	097010ef          	jal	ra,800073dc <log_error>
		log_error("\n There is some issue in AXI interface. Please check.");
    80005b4a:	00004517          	auipc	a0,0x4
    80005b4e:	e3e50513          	addi	a0,a0,-450 # 80009988 <__rodata_start+0x630>
    80005b52:	08b010ef          	jal	ra,800073dc <log_error>
		return EAXI_ERROR;
    80005b56:	57fd                	li	a5,-1
    80005b58:	a8bd                	j	80005bd6 <i2c_send_slave_address+0x116>
	}

	//Waits till the bus becomes free.
	while(wait_till_I2c_bus_free(instance))
	{
		log_error("\tError in Waiting for BB\n");
    80005b5a:	00004517          	auipc	a0,0x4
    80005b5e:	e6650513          	addi	a0,a0,-410 # 800099c0 <__rodata_start+0x668>
    80005b62:	07b010ef          	jal	ra,800073dc <log_error>
		return EI2C_BUS_ERROR;
    80005b66:	57f9                	li	a5,-2
    80005b68:	a0bd                	j	80005bd6 <i2c_send_slave_address+0x116>
	while(wait_till_I2c_bus_free(instance))
    80005b6a:	0001                	nop
    80005b6c:	6562                	ld	a0,24(sp)
    80005b6e:	c7bff0ef          	jal	ra,800057e8 <wait_till_I2c_bus_free>
    80005b72:	87aa                	mv	a5,a0
    80005b74:	f3fd                	bnez	a5,80005b5a <i2c_send_slave_address+0x9a>
	}


	//Send the start condition and slave address to slave
#ifndef USE_SA_WRITE_I2C_INTERRUPT
	instance->control = I2C_START; //Sending the slave address to the I2C slave
    80005b76:	67e2                	ld	a5,24(sp)
    80005b78:	0c500713          	li	a4,197
    80005b7c:	c798                	sw	a4,8(a5)
	waitfor(90000);
    80005b7e:	67d9                	lui	a5,0x16
    80005b80:	f9078513          	addi	a0,a5,-112 # 15f90 <_STACK_SIZE+0x1f90>
    80005b84:	08e010ef          	jal	ra,80006c12 <waitfor>
	//Wait for PIN to become low.
	timeout = wait_till_txrx_operation_Completes(instance, &status);
    80005b88:	105c                	addi	a5,sp,36
    80005b8a:	85be                	mv	a1,a5
    80005b8c:	6562                	ld	a0,24(sp)
    80005b8e:	cc1ff0ef          	jal	ra,8000584e <wait_till_txrx_operation_Completes>
    80005b92:	87aa                	mv	a5,a0
    80005b94:	d43e                	sw	a5,40(sp)
	if (timeout) {//Asking the controller to send a start signal to initiate the transaction
    80005b96:	57a2                	lw	a5,40(sp)
    80005b98:	2781                	sext.w	a5,a5
    80005b9a:	cf89                	beqz	a5,80005bb4 <i2c_send_slave_address+0xf4>
		printf("\tTimeout happened - Write did not go through the BFM -- Diagnose\n");
    80005b9c:	00004517          	auipc	a0,0x4
    80005ba0:	c7450513          	addi	a0,a0,-908 # 80009810 <__rodata_start+0x4b8>
    80005ba4:	770010ef          	jal	ra,80007314 <printf>
		instance->control = I2C_STOP; //~
    80005ba8:	67e2                	ld	a5,24(sp)
    80005baa:	0c300713          	li	a4,195
    80005bae:	c798                	sw	a4,8(a5)
		return EI2C_PIN_ERROR;
    80005bb0:	57f5                	li	a5,-3
    80005bb2:	a015                	j	80005bd6 <i2c_send_slave_address+0x116>
	}

	if (status & I2C_LRB) {
    80005bb4:	5792                	lw	a5,36(sp)
    80005bb6:	8ba1                	andi	a5,a5,8
    80005bb8:	2781                	sext.w	a5,a5
    80005bba:	cf89                	beqz	a5,80005bd4 <i2c_send_slave_address+0x114>
		instance->control = I2C_STOP; //~
    80005bbc:	67e2                	ld	a5,24(sp)
    80005bbe:	0c300713          	li	a4,195
    80005bc2:	c798                	sw	a4,8(a5)
		printf("\tSome status check failing\n");
    80005bc4:	00004517          	auipc	a0,0x4
    80005bc8:	c9450513          	addi	a0,a0,-876 # 80009858 <__rodata_start+0x500>
    80005bcc:	748010ef          	jal	ra,80007314 <printf>
		return EI2C_LRB_ERROR;
    80005bd0:	57f1                	li	a5,-4
    80005bd2:	a011                	j	80005bd6 <i2c_send_slave_address+0x116>
	while(!i2c_complete_flag);
	log_info("\n Slave Address Write Operation is complete.");
	i2c_complete_flag = 0;
#endif

	return I2C_SUCCESS;
    80005bd4:	4781                	li	a5,0
}
    80005bd6:	853e                	mv	a0,a5
    80005bd8:	70e2                	ld	ra,56(sp)
    80005bda:	6121                	addi	sp,sp,64
    80005bdc:	8082                	ret

0000000080005bde <i2c_write_data>:
 * @param unsigned char writedata
 * @param unsigned char delay
 * @return Returns Zeron on success; else -EREMOTEIO
 */
int i2c_write_data(i2c_struct * instance, unsigned char writeData, unsigned char delay)
{
    80005bde:	7179                	addi	sp,sp,-48
    80005be0:	f406                	sd	ra,40(sp)
    80005be2:	e42a                	sd	a0,8(sp)
    80005be4:	87ae                	mv	a5,a1
    80005be6:	8732                	mv	a4,a2
    80005be8:	00f103a3          	sb	a5,7(sp)
    80005bec:	87ba                	mv	a5,a4
    80005bee:	00f10323          	sb	a5,6(sp)
	int timeout;
	int status = 0;
    80005bf2:	cc02                	sw	zero,24(sp)
	delay = delay;

	instance->data= writeData;
    80005bf4:	00714783          	lbu	a5,7(sp)
    80005bf8:	0007871b          	sext.w	a4,a5
    80005bfc:	67a2                	ld	a5,8(sp)
    80005bfe:	cb98                	sw	a4,16(a5)

#ifndef USE_WRITE_I2C_INTERRUPT
	timeout = wait_till_txrx_operation_Completes(instance, &status);
    80005c00:	083c                	addi	a5,sp,24
    80005c02:	85be                	mv	a1,a5
    80005c04:	6522                	ld	a0,8(sp)
    80005c06:	c49ff0ef          	jal	ra,8000584e <wait_till_txrx_operation_Completes>
    80005c0a:	87aa                	mv	a5,a0
    80005c0c:	ce3e                	sw	a5,28(sp)
	if (timeout) {
    80005c0e:	47f2                	lw	a5,28(sp)
    80005c10:	2781                	sext.w	a5,a5
    80005c12:	cf91                	beqz	a5,80005c2e <i2c_write_data+0x50>
		printf("\tTimeout happened - Write did not go through the BFM -- Diagnose\n");
    80005c14:	00004517          	auipc	a0,0x4
    80005c18:	bfc50513          	addi	a0,a0,-1028 # 80009810 <__rodata_start+0x4b8>
    80005c1c:	6f8010ef          	jal	ra,80007314 <printf>
		instance->control = I2C_STOP; //~
    80005c20:	67a2                	ld	a5,8(sp)
    80005c22:	0c300713          	li	a4,195
    80005c26:	c798                	sw	a4,8(a5)
		return EREMOTEIO;
    80005c28:	faf00793          	li	a5,-81
    80005c2c:	a015                	j	80005c50 <i2c_write_data+0x72>
	}

	if (status & I2C_LRB)
    80005c2e:	47e2                	lw	a5,24(sp)
    80005c30:	8ba1                	andi	a5,a5,8
    80005c32:	2781                	sext.w	a5,a5
    80005c34:	cf89                	beqz	a5,80005c4e <i2c_write_data+0x70>
	{ // What error is this?
		instance->control = I2C_STOP; //~
    80005c36:	67a2                	ld	a5,8(sp)
    80005c38:	0c300713          	li	a4,195
    80005c3c:	c798                	sw	a4,8(a5)
		printf("\tSome status check failing\n");
    80005c3e:	00004517          	auipc	a0,0x4
    80005c42:	c1a50513          	addi	a0,a0,-998 # 80009858 <__rodata_start+0x500>
    80005c46:	6ce010ef          	jal	ra,80007314 <printf>
		return EI2C_LRB_ERROR;
    80005c4a:	57f1                	li	a5,-4
    80005c4c:	a011                	j	80005c50 <i2c_write_data+0x72>
	while(!i2c_complete_flag);
	log_info("\n Write Operation is complete.");
	i2c_complete_flag = 0;
#endif

	return I2C_SUCCESS;
    80005c4e:	4781                	li	a5,0
}
    80005c50:	853e                	mv	a0,a5
    80005c52:	70a2                	ld	ra,40(sp)
    80005c54:	6145                	addi	sp,sp,48
    80005c56:	8082                	ret

0000000080005c58 <i2c_read_data>:
 * @param unsigned char delay
 * @return Zero on success; else -ETIMEOUT
 */
//#define READ_INTERRUPT 1
int i2c_read_data(i2c_struct * instance, unsigned char *read_data, unsigned char delay)
{
    80005c58:	7139                	addi	sp,sp,-64
    80005c5a:	fc06                	sd	ra,56(sp)
    80005c5c:	ec2a                	sd	a0,24(sp)
    80005c5e:	e82e                	sd	a1,16(sp)
    80005c60:	87b2                	mv	a5,a2
    80005c62:	00f107a3          	sb	a5,15(sp)
	int status = 0;
    80005c66:	d602                	sw	zero,44(sp)

	/* Make a dummy read as per spec of the I2C controller */

	*read_data = instance->data; //~
    80005c68:	67e2                	ld	a5,24(sp)
    80005c6a:	4b9c                	lw	a5,16(a5)
    80005c6c:	0ff7f713          	andi	a4,a5,255
    80005c70:	67c2                	ld	a5,16(sp)
    80005c72:	00e78023          	sb	a4,0(a5)
	while(!i2c_complete_flag);
	*read_data = instance->data;

	printf("\n I2C Read Data = %x", i2c_read_data);
#else
	while(wait_till_txrx_operation_Completes(instance, &status))
    80005c76:	a829                	j	80005c90 <i2c_read_data+0x38>
	{
		printf("\twaiting for pin\n");
    80005c78:	00004517          	auipc	a0,0x4
    80005c7c:	d6850513          	addi	a0,a0,-664 # 800099e0 <__rodata_start+0x688>
    80005c80:	694010ef          	jal	ra,80007314 <printf>
		waitfor(delay);
    80005c84:	00f14783          	lbu	a5,15(sp)
    80005c88:	2781                	sext.w	a5,a5
    80005c8a:	853e                	mv	a0,a5
    80005c8c:	787000ef          	jal	ra,80006c12 <waitfor>
	while(wait_till_txrx_operation_Completes(instance, &status))
    80005c90:	107c                	addi	a5,sp,44
    80005c92:	85be                	mv	a1,a5
    80005c94:	6562                	ld	a0,24(sp)
    80005c96:	bb9ff0ef          	jal	ra,8000584e <wait_till_txrx_operation_Completes>
    80005c9a:	87aa                	mv	a5,a0
    80005c9c:	fff1                	bnez	a5,80005c78 <i2c_read_data+0x20>
	}
#endif
	return I2C_SUCCESS;
    80005c9e:	4781                	li	a5,0
}
    80005ca0:	853e                	mv	a0,a5
    80005ca2:	70e2                	ld	ra,56(sp)
    80005ca4:	6121                	addi	sp,sp,64
    80005ca6:	8082                	ret

0000000080005ca8 <i2c_send_interrupt_slave_address>:
 * @param unsigned char rdWrCntrl
 * @param unsigned long delay
 * @return Zero on success. Else corresponding error value.
 */
int i2c_send_interrupt_slave_address(i2c_struct * instance, unsigned char slaveAddress, unsigned char rdWrCntrl, unsigned long delay)
{
    80005ca8:	7139                	addi	sp,sp,-64
    80005caa:	fc06                	sd	ra,56(sp)
    80005cac:	ec2a                	sd	a0,24(sp)
    80005cae:	87ae                	mv	a5,a1
    80005cb0:	8732                	mv	a4,a2
    80005cb2:	e436                	sd	a3,8(sp)
    80005cb4:	00f10ba3          	sb	a5,23(sp)
    80005cb8:	87ba                	mv	a5,a4
    80005cba:	00f10b23          	sb	a5,22(sp)
	int timeout;
	unsigned char temp = 0;
    80005cbe:	020107a3          	sb	zero,47(sp)
	int status = 0;
    80005cc2:	d202                	sw	zero,36(sp)
	delay = delay;

	if(rdWrCntrl == 0)
    80005cc4:	01614783          	lbu	a5,22(sp)
    80005cc8:	0ff7f793          	andi	a5,a5,255
    80005ccc:	c799                	beqz	a5,80005cda <i2c_send_interrupt_slave_address+0x32>
		slaveAddress |= I2C_WRITE;
	else
		slaveAddress |= I2C_READ;
    80005cce:	01714783          	lbu	a5,23(sp)
    80005cd2:	0017e793          	ori	a5,a5,1
    80005cd6:	00f10ba3          	sb	a5,23(sp)

	log_debug("\n\tSetting Slave Address : 0x%x\n", slaveAddress);/* Writes the slave address to I2C controller */
    80005cda:	01714783          	lbu	a5,23(sp)
    80005cde:	2781                	sext.w	a5,a5
    80005ce0:	85be                	mv	a1,a5
    80005ce2:	00004517          	auipc	a0,0x4
    80005ce6:	d1650513          	addi	a0,a0,-746 # 800099f8 <__rodata_start+0x6a0>
    80005cea:	6a8010ef          	jal	ra,80007392 <log_debug>
	//Writing the slave address that needs to be written into data register.
	instance->data = slaveAddress;
    80005cee:	01714783          	lbu	a5,23(sp)
    80005cf2:	0007871b          	sext.w	a4,a5
    80005cf6:	67e2                	ld	a5,24(sp)
    80005cf8:	cb98                	sw	a4,16(a5)
	log_debug("\tSlave Address is written into data register\n");
    80005cfa:	00004517          	auipc	a0,0x4
    80005cfe:	d1e50513          	addi	a0,a0,-738 # 80009a18 <__rodata_start+0x6c0>
    80005d02:	690010ef          	jal	ra,80007392 <log_debug>

	//Reads back the data register to confirm
	temp = instance->data; //Reads the slave address from I2C controller
    80005d06:	67e2                	ld	a5,24(sp)
    80005d08:	4b9c                	lw	a5,16(a5)
    80005d0a:	02f107a3          	sb	a5,47(sp)
	log_debug("\tSet slave address read again, which is 0x%x\n",temp);
    80005d0e:	02f14783          	lbu	a5,47(sp)
    80005d12:	2781                	sext.w	a5,a5
    80005d14:	85be                	mv	a1,a5
    80005d16:	00004517          	auipc	a0,0x4
    80005d1a:	d3250513          	addi	a0,a0,-718 # 80009a48 <__rodata_start+0x6f0>
    80005d1e:	674010ef          	jal	ra,80007392 <log_debug>

	if(slaveAddress != (int)temp)
    80005d22:	01714703          	lbu	a4,23(sp)
    80005d26:	02f14783          	lbu	a5,47(sp)
    80005d2a:	0ff77713          	andi	a4,a4,255
    80005d2e:	0ff7f793          	andi	a5,a5,255
    80005d32:	04f70063          	beq	a4,a5,80005d72 <i2c_send_interrupt_slave_address+0xca>
	{
		log_error("\tSlave address is not matching; Written Add. Value: 0x%x; Read Add. Value: 0x%x\n", slaveAddress, temp);
    80005d36:	01714783          	lbu	a5,23(sp)
    80005d3a:	2781                	sext.w	a5,a5
    80005d3c:	02f14703          	lbu	a4,47(sp)
    80005d40:	2701                	sext.w	a4,a4
    80005d42:	863a                	mv	a2,a4
    80005d44:	85be                	mv	a1,a5
    80005d46:	00004517          	auipc	a0,0x4
    80005d4a:	bea50513          	addi	a0,a0,-1046 # 80009930 <__rodata_start+0x5d8>
    80005d4e:	68e010ef          	jal	ra,800073dc <log_error>
		log_error("\n There is some issue in AXI interface. Please check.");
    80005d52:	00004517          	auipc	a0,0x4
    80005d56:	c3650513          	addi	a0,a0,-970 # 80009988 <__rodata_start+0x630>
    80005d5a:	682010ef          	jal	ra,800073dc <log_error>
		return EAXI_ERROR;
    80005d5e:	57fd                	li	a5,-1
    80005d60:	a041                	j	80005de0 <i2c_send_interrupt_slave_address+0x138>
	}

	//Waits till the bus becomes free.
	while(wait_till_I2c_bus_free(instance))
	{
		log_error("\tError in Waiting for BB\n");
    80005d62:	00004517          	auipc	a0,0x4
    80005d66:	c5e50513          	addi	a0,a0,-930 # 800099c0 <__rodata_start+0x668>
    80005d6a:	672010ef          	jal	ra,800073dc <log_error>
		return EI2C_BUS_ERROR;
    80005d6e:	57f9                	li	a5,-2
    80005d70:	a885                	j	80005de0 <i2c_send_interrupt_slave_address+0x138>
	while(wait_till_I2c_bus_free(instance))
    80005d72:	0001                	nop
    80005d74:	6562                	ld	a0,24(sp)
    80005d76:	a73ff0ef          	jal	ra,800057e8 <wait_till_I2c_bus_free>
    80005d7a:	87aa                	mv	a5,a0
    80005d7c:	f3fd                	bnez	a5,80005d62 <i2c_send_interrupt_slave_address+0xba>
	}

	//Send the start condition and slave address to slave
#ifndef USE_SA_WRITE_I2C_INTERRUPT
	instance->control = I2C_START;; //Sending the slave address to the I2C slave
    80005d7e:	67e2                	ld	a5,24(sp)
    80005d80:	0c500713          	li	a4,197
    80005d84:	c798                	sw	a4,8(a5)
	//Wait for PIN to become low.
	timeout = wait_till_txrx_operation_Completes(instance, &status);
    80005d86:	105c                	addi	a5,sp,36
    80005d88:	85be                	mv	a1,a5
    80005d8a:	6562                	ld	a0,24(sp)
    80005d8c:	ac3ff0ef          	jal	ra,8000584e <wait_till_txrx_operation_Completes>
    80005d90:	87aa                	mv	a5,a0
    80005d92:	d43e                	sw	a5,40(sp)
	if (timeout) {//Asking the controller to send a start signal to initiate the transaction
    80005d94:	57a2                	lw	a5,40(sp)
    80005d96:	2781                	sext.w	a5,a5
    80005d98:	cf89                	beqz	a5,80005db2 <i2c_send_interrupt_slave_address+0x10a>
		printf("\tTimeout happened - Write did not go through the BFM -- Diagnose\n");
    80005d9a:	00004517          	auipc	a0,0x4
    80005d9e:	a7650513          	addi	a0,a0,-1418 # 80009810 <__rodata_start+0x4b8>
    80005da2:	572010ef          	jal	ra,80007314 <printf>
		instance->control = I2C_STOP; //~
    80005da6:	67e2                	ld	a5,24(sp)
    80005da8:	0c300713          	li	a4,195
    80005dac:	c798                	sw	a4,8(a5)
		return EI2C_PIN_ERROR;
    80005dae:	57f5                	li	a5,-3
    80005db0:	a805                	j	80005de0 <i2c_send_interrupt_slave_address+0x138>
	}

	if (status & I2C_LRB) {
    80005db2:	5792                	lw	a5,36(sp)
    80005db4:	8ba1                	andi	a5,a5,8
    80005db6:	2781                	sext.w	a5,a5
    80005db8:	cf89                	beqz	a5,80005dd2 <i2c_send_interrupt_slave_address+0x12a>
		instance->control = I2C_STOP; //~
    80005dba:	67e2                	ld	a5,24(sp)
    80005dbc:	0c300713          	li	a4,195
    80005dc0:	c798                	sw	a4,8(a5)
		printf("\tSome status check failing\n");
    80005dc2:	00004517          	auipc	a0,0x4
    80005dc6:	a9650513          	addi	a0,a0,-1386 # 80009858 <__rodata_start+0x500>
    80005dca:	54a010ef          	jal	ra,80007314 <printf>
		return EI2C_LRB_ERROR;
    80005dce:	57f1                	li	a5,-4
    80005dd0:	a801                	j	80005de0 <i2c_send_interrupt_slave_address+0x138>
	instance->control = I2C_REPSTART_ENI; //Sending the slave address to the I2C slave
	while(!i2c_complete_flag);
	log_info("\n Slave Address Write Operation is complete.");
	i2c_complete_flag = 0;
#endif
	log_info("\n Slave address is written successfully");
    80005dd2:	00004517          	auipc	a0,0x4
    80005dd6:	ca650513          	addi	a0,a0,-858 # 80009a78 <__rodata_start+0x720>
    80005dda:	586010ef          	jal	ra,80007360 <log_info>
	return I2C_SUCCESS;
    80005dde:	4781                	li	a5,0
}
    80005de0:	853e                	mv	a0,a5
    80005de2:	70e2                	ld	ra,56(sp)
    80005de4:	6121                	addi	sp,sp,64
    80005de6:	8082                	ret

0000000080005de8 <i2c_read_interrupt_data>:
 * @param unsigned char delay 
 * @param unsigned char last
 * @return Zero on success.
 */
int i2c_read_interrupt_data(i2c_struct * instance, unsigned char *read_data, unsigned char delay, unsigned char last)
{
    80005de8:	7139                	addi	sp,sp,-64
    80005dea:	fc06                	sd	ra,56(sp)
    80005dec:	ec2a                	sd	a0,24(sp)
    80005dee:	e82e                	sd	a1,16(sp)
    80005df0:	87b2                	mv	a5,a2
    80005df2:	8736                	mv	a4,a3
    80005df4:	00f107a3          	sb	a5,15(sp)
    80005df8:	87ba                	mv	a5,a4
    80005dfa:	00f10723          	sb	a5,14(sp)
	int status = 0;
    80005dfe:	d602                	sw	zero,44(sp)

	/* Make a dummy read as per spec of the I2C controller */
	*read_data = instance->data;
    80005e00:	67e2                	ld	a5,24(sp)
    80005e02:	4b9c                	lw	a5,16(a5)
    80005e04:	0ff7f713          	andi	a4,a5,255
    80005e08:	67c2                	ld	a5,16(sp)
    80005e0a:	00e78023          	sb	a4,0(a5)
		//			printf("\n Call I2C rep. start eni");
		//			while(!i2c_complete_flag);
	}
	printf("\n I2C Read Data = %x", *read_data);
#else
	while(wait_till_txrx_operation_Completes(instance, &status))
    80005e0e:	a829                	j	80005e28 <i2c_read_interrupt_data+0x40>
	{
		printf("\twaiting for pin\n");
    80005e10:	00004517          	auipc	a0,0x4
    80005e14:	bd050513          	addi	a0,a0,-1072 # 800099e0 <__rodata_start+0x688>
    80005e18:	4fc010ef          	jal	ra,80007314 <printf>
		waitfor(delay);
    80005e1c:	00f14783          	lbu	a5,15(sp)
    80005e20:	2781                	sext.w	a5,a5
    80005e22:	853e                	mv	a0,a5
    80005e24:	5ef000ef          	jal	ra,80006c12 <waitfor>
	while(wait_till_txrx_operation_Completes(instance, &status))
    80005e28:	107c                	addi	a5,sp,44
    80005e2a:	85be                	mv	a1,a5
    80005e2c:	6562                	ld	a0,24(sp)
    80005e2e:	a21ff0ef          	jal	ra,8000584e <wait_till_txrx_operation_Completes>
    80005e32:	87aa                	mv	a5,a0
    80005e34:	fff1                	bnez	a5,80005e10 <i2c_read_interrupt_data+0x28>
	}
	if(!last)
    80005e36:	00e14783          	lbu	a5,14(sp)
    80005e3a:	0ff7f793          	andi	a5,a5,255
    80005e3e:	eb81                	bnez	a5,80005e4e <i2c_read_interrupt_data+0x66>
	{
		printf("\n Rep Start");				
    80005e40:	00004517          	auipc	a0,0x4
    80005e44:	c6050513          	addi	a0,a0,-928 # 80009aa0 <__rodata_start+0x748>
    80005e48:	4cc010ef          	jal	ra,80007314 <printf>
    80005e4c:	a819                	j	80005e62 <i2c_read_interrupt_data+0x7a>
		//				instance->control = I2C_REPSTART;
	}
	else
	{
		printf("\nCall I2C Stop");
    80005e4e:	00004517          	auipc	a0,0x4
    80005e52:	c6250513          	addi	a0,a0,-926 # 80009ab0 <__rodata_start+0x758>
    80005e56:	4be010ef          	jal	ra,80007314 <printf>
		instance->control = I2C_STOP;
    80005e5a:	67e2                	ld	a5,24(sp)
    80005e5c:	0c300713          	li	a4,195
    80005e60:	c798                	sw	a4,8(a5)
	}
#endif
	return I2C_SUCCESS;
    80005e62:	4781                	li	a5,0
}
    80005e64:	853e                	mv	a0,a5
    80005e66:	70e2                	ld	ra,56(sp)
    80005e68:	6121                	addi	sp,sp,64
    80005e6a:	8082                	ret

0000000080005e6c <i2c_write_interrupt_data>:
 * @param unsigned char delay
 * @param unsigned char last
 * @return Zero on success. Else based on the error.
 */
int i2c_write_interrupt_data(i2c_struct * instance, unsigned char writeData, unsigned char delay, unsigned char last)
{
    80005e6c:	7179                	addi	sp,sp,-48
    80005e6e:	f406                	sd	ra,40(sp)
    80005e70:	e42a                	sd	a0,8(sp)
    80005e72:	87ae                	mv	a5,a1
    80005e74:	8736                	mv	a4,a3
    80005e76:	00f103a3          	sb	a5,7(sp)
    80005e7a:	87b2                	mv	a5,a2
    80005e7c:	00f10323          	sb	a5,6(sp)
    80005e80:	87ba                	mv	a5,a4
    80005e82:	00f102a3          	sb	a5,5(sp)
	int timeout;
	int status = 0;
    80005e86:	cc02                	sw	zero,24(sp)
	delay = delay;

	instance->data = writeData;
    80005e88:	00714783          	lbu	a5,7(sp)
    80005e8c:	0007871b          	sext.w	a4,a5
    80005e90:	67a2                	ld	a5,8(sp)
    80005e92:	cb98                	sw	a4,16(a5)

#ifndef USE_WRITE_I2C_INTERRUPT
	timeout = wait_till_txrx_operation_Completes(instance, &status);
    80005e94:	083c                	addi	a5,sp,24
    80005e96:	85be                	mv	a1,a5
    80005e98:	6522                	ld	a0,8(sp)
    80005e9a:	9b5ff0ef          	jal	ra,8000584e <wait_till_txrx_operation_Completes>
    80005e9e:	87aa                	mv	a5,a0
    80005ea0:	ce3e                	sw	a5,28(sp)
	if (timeout) {
    80005ea2:	47f2                	lw	a5,28(sp)
    80005ea4:	2781                	sext.w	a5,a5
    80005ea6:	cf91                	beqz	a5,80005ec2 <i2c_write_interrupt_data+0x56>
		printf("\tTimeout happened - Write did not go through the BFM -- Diagnose\n");
    80005ea8:	00004517          	auipc	a0,0x4
    80005eac:	96850513          	addi	a0,a0,-1688 # 80009810 <__rodata_start+0x4b8>
    80005eb0:	464010ef          	jal	ra,80007314 <printf>
		instance->control = I2C_STOP; //~
    80005eb4:	67a2                	ld	a5,8(sp)
    80005eb6:	0c300713          	li	a4,195
    80005eba:	c798                	sw	a4,8(a5)
		return EREMOTEIO;
    80005ebc:	faf00793          	li	a5,-81
    80005ec0:	a099                	j	80005f06 <i2c_write_interrupt_data+0x9a>
	}

	if (status & I2C_LRB)
    80005ec2:	47e2                	lw	a5,24(sp)
    80005ec4:	8ba1                	andi	a5,a5,8
    80005ec6:	2781                	sext.w	a5,a5
    80005ec8:	cf89                	beqz	a5,80005ee2 <i2c_write_interrupt_data+0x76>
	{ // What error is this?
		instance->control = I2C_STOP;//~
    80005eca:	67a2                	ld	a5,8(sp)
    80005ecc:	0c300713          	li	a4,195
    80005ed0:	c798                	sw	a4,8(a5)
		printf("\tSome status check failing\n");
    80005ed2:	00004517          	auipc	a0,0x4
    80005ed6:	98650513          	addi	a0,a0,-1658 # 80009858 <__rodata_start+0x500>
    80005eda:	43a010ef          	jal	ra,80007314 <printf>
		return EI2C_LRB_ERROR;
    80005ede:	57f1                	li	a5,-4
    80005ee0:	a01d                	j	80005f06 <i2c_write_interrupt_data+0x9a>
	}

	if(1 == last)
    80005ee2:	00514783          	lbu	a5,5(sp)
    80005ee6:	0ff7f713          	andi	a4,a5,255
    80005eea:	4785                	li	a5,1
    80005eec:	00f71c63          	bne	a4,a5,80005f04 <i2c_write_interrupt_data+0x98>
	{
		instance->control = I2C_STOP;;
    80005ef0:	67a2                	ld	a5,8(sp)
    80005ef2:	0c300713          	li	a4,195
    80005ef6:	c798                	sw	a4,8(a5)
		printf("\tI2C Write Success and completes\n");
    80005ef8:	00004517          	auipc	a0,0x4
    80005efc:	bc850513          	addi	a0,a0,-1080 # 80009ac0 <__rodata_start+0x768>
    80005f00:	414010ef          	jal	ra,80007314 <printf>
		//		while(!i2c_complete_flag);
	}
	log_info("\n Write Operation is complete.");
	i2c_complete_flag = 0;
#endif
	return I2C_SUCCESS;
    80005f04:	4781                	li	a5,0
}
    80005f06:	853e                	mv	a0,a5
    80005f08:	70a2                	ld	ra,40(sp)
    80005f0a:	6145                	addi	sp,sp,48
    80005f0c:	8082                	ret

0000000080005f0e <interrupt_complete>:
 * @brief write the int_id to complete register
 * @details Signals completion of interrupt. From s/w side the interrupt claim/complete register is written with the interrupt id.
 * @param uint32_t interrupt_id
 */
void interrupt_complete(uint32_t interrupt_id)
{
    80005f0e:	7179                	addi	sp,sp,-48
    80005f10:	f406                	sd	ra,40(sp)
    80005f12:	87aa                	mv	a5,a0
    80005f14:	c63e                	sw	a5,12(sp)
	log_trace("\ninterrupt_complete entered\n");
    80005f16:	00004517          	auipc	a0,0x4
    80005f1a:	bd250513          	addi	a0,a0,-1070 # 80009ae8 <__rodata_start+0x790>
    80005f1e:	42a010ef          	jal	ra,80007348 <log_trace>

	uint32_t *claim_addr =  (uint32_t *) (PLIC_BASE_ADDRESS +
    80005f22:	0c0107b7          	lui	a5,0xc010
    80005f26:	07c1                	addi	a5,a5,16
    80005f28:	ec3e                	sd	a5,24(sp)
						      PLIC_CLAIM_OFFSET);

	*claim_addr = interrupt_id;
    80005f2a:	67e2                	ld	a5,24(sp)
    80005f2c:	4732                	lw	a4,12(sp)
    80005f2e:	c398                	sw	a4,0(a5)
	hart0_interrupt_matrix[interrupt_id].state = SERVICED;
    80005f30:	00101717          	auipc	a4,0x101
    80005f34:	f6870713          	addi	a4,a4,-152 # 80106e98 <hart0_interrupt_matrix>
    80005f38:	00c16783          	lwu	a5,12(sp)
    80005f3c:	0792                	slli	a5,a5,0x4
    80005f3e:	97ba                	add	a5,a5,a4
    80005f40:	4709                	li	a4,2
    80005f42:	c798                	sw	a4,8(a5)
	hart0_interrupt_matrix[interrupt_id].count++;
    80005f44:	00101717          	auipc	a4,0x101
    80005f48:	f5470713          	addi	a4,a4,-172 # 80106e98 <hart0_interrupt_matrix>
    80005f4c:	00c16783          	lwu	a5,12(sp)
    80005f50:	0792                	slli	a5,a5,0x4
    80005f52:	97ba                	add	a5,a5,a4
    80005f54:	47dc                	lw	a5,12(a5)
    80005f56:	2785                	addiw	a5,a5,1
    80005f58:	0007871b          	sext.w	a4,a5
    80005f5c:	00101697          	auipc	a3,0x101
    80005f60:	f3c68693          	addi	a3,a3,-196 # 80106e98 <hart0_interrupt_matrix>
    80005f64:	00c16783          	lwu	a5,12(sp)
    80005f68:	0792                	slli	a5,a5,0x4
    80005f6a:	97b6                	add	a5,a5,a3
    80005f6c:	c7d8                	sw	a4,12(a5)

	log_debug("interrupt id %d, state changed to %d\n", interrupt_id,
		 hart0_interrupt_matrix[interrupt_id].state);
    80005f6e:	00101717          	auipc	a4,0x101
    80005f72:	f2a70713          	addi	a4,a4,-214 # 80106e98 <hart0_interrupt_matrix>
    80005f76:	00c16783          	lwu	a5,12(sp)
    80005f7a:	0792                	slli	a5,a5,0x4
    80005f7c:	97ba                	add	a5,a5,a4
    80005f7e:	4798                	lw	a4,8(a5)
	log_debug("interrupt id %d, state changed to %d\n", interrupt_id,
    80005f80:	47b2                	lw	a5,12(sp)
    80005f82:	863a                	mv	a2,a4
    80005f84:	85be                	mv	a1,a5
    80005f86:	00004517          	auipc	a0,0x4
    80005f8a:	b8250513          	addi	a0,a0,-1150 # 80009b08 <__rodata_start+0x7b0>
    80005f8e:	404010ef          	jal	ra,80007392 <log_debug>

	log_debug("interrupt id = %x \n reset to default values state = %x \
    80005f92:	00101717          	auipc	a4,0x101
    80005f96:	f0670713          	addi	a4,a4,-250 # 80106e98 <hart0_interrupt_matrix>
    80005f9a:	00c16783          	lwu	a5,12(sp)
    80005f9e:	0792                	slli	a5,a5,0x4
    80005fa0:	97ba                	add	a5,a5,a4
    80005fa2:	438c                	lw	a1,0(a5)
		  \n priority = %x\n count = %x\n", \
		  hart0_interrupt_matrix[interrupt_id].id, \
		  hart0_interrupt_matrix[interrupt_id].state, \
    80005fa4:	00101717          	auipc	a4,0x101
    80005fa8:	ef470713          	addi	a4,a4,-268 # 80106e98 <hart0_interrupt_matrix>
    80005fac:	00c16783          	lwu	a5,12(sp)
    80005fb0:	0792                	slli	a5,a5,0x4
    80005fb2:	97ba                	add	a5,a5,a4
    80005fb4:	4790                	lw	a2,8(a5)
	log_debug("interrupt id = %x \n reset to default values state = %x \
    80005fb6:	00101717          	auipc	a4,0x101
    80005fba:	ee270713          	addi	a4,a4,-286 # 80106e98 <hart0_interrupt_matrix>
    80005fbe:	00c16783          	lwu	a5,12(sp)
    80005fc2:	0792                	slli	a5,a5,0x4
    80005fc4:	97ba                	add	a5,a5,a4
    80005fc6:	43d4                	lw	a3,4(a5)
    80005fc8:	00101717          	auipc	a4,0x101
    80005fcc:	ed070713          	addi	a4,a4,-304 # 80106e98 <hart0_interrupt_matrix>
    80005fd0:	00c16783          	lwu	a5,12(sp)
    80005fd4:	0792                	slli	a5,a5,0x4
    80005fd6:	97ba                	add	a5,a5,a4
    80005fd8:	47dc                	lw	a5,12(a5)
    80005fda:	873e                	mv	a4,a5
    80005fdc:	00004517          	auipc	a0,0x4
    80005fe0:	b5450513          	addi	a0,a0,-1196 # 80009b30 <__rodata_start+0x7d8>
    80005fe4:	3ae010ef          	jal	ra,80007392 <log_debug>
		  hart0_interrupt_matrix[interrupt_id].priority, \
		  hart0_interrupt_matrix[interrupt_id].count);

	log_trace("interrupt_complete exited\n");
    80005fe8:	00004517          	auipc	a0,0x4
    80005fec:	ba050513          	addi	a0,a0,-1120 # 80009b88 <__rodata_start+0x830>
    80005ff0:	358010ef          	jal	ra,80007348 <log_trace>
}
    80005ff4:	0001                	nop
    80005ff6:	70a2                	ld	ra,40(sp)
    80005ff8:	6145                	addi	sp,sp,48
    80005ffa:	8082                	ret

0000000080005ffc <interrupt_claim_request>:
 * @details read the interrupt claim register to know the interrupt id
 *           of the highest priority pending interrupt 
 * @return uint32_t
 */
uint32_t interrupt_claim_request()
{
    80005ffc:	1101                	addi	sp,sp,-32
    80005ffe:	ec06                	sd	ra,24(sp)
	uint32_t *interrupt_claim_address = NULL;
    80006000:	e402                	sd	zero,8(sp)
	uint32_t interrupt_id;

	log_trace("\ninterrupt_claim_request entered\n");
    80006002:	00004517          	auipc	a0,0x4
    80006006:	ba650513          	addi	a0,a0,-1114 # 80009ba8 <__rodata_start+0x850>
    8000600a:	33e010ef          	jal	ra,80007348 <log_trace>
	   From the isr table, the exact isr will be called

	   refer https://gitlab.com/shaktiproject/uncore/devices/blob/master/plic/plic.bsv as on 26/8/2019
	 */

	interrupt_claim_address = (uint32_t *)(PLIC_BASE_ADDRESS + PLIC_CLAIM_OFFSET);
    8000600e:	0c0107b7          	lui	a5,0xc010
    80006012:	07c1                	addi	a5,a5,16
    80006014:	e43e                	sd	a5,8(sp)

	interrupt_id = *interrupt_claim_address;
    80006016:	67a2                	ld	a5,8(sp)
    80006018:	439c                	lw	a5,0(a5)
    8000601a:	c23e                	sw	a5,4(sp)

	log_debug("interrupt id [%x] claimed  at address %x\n", interrupt_id,
    8000601c:	4792                	lw	a5,4(sp)
    8000601e:	6622                	ld	a2,8(sp)
    80006020:	85be                	mv	a1,a5
    80006022:	00004517          	auipc	a0,0x4
    80006026:	bae50513          	addi	a0,a0,-1106 # 80009bd0 <__rodata_start+0x878>
    8000602a:	368010ef          	jal	ra,80007392 <log_debug>
		 interrupt_claim_address );

	log_trace("interrupt_claim_request exited\n");
    8000602e:	00004517          	auipc	a0,0x4
    80006032:	bd250513          	addi	a0,a0,-1070 # 80009c00 <__rodata_start+0x8a8>
    80006036:	312010ef          	jal	ra,80007348 <log_trace>

	return interrupt_id;
    8000603a:	4792                	lw	a5,4(sp)
}
    8000603c:	853e                	mv	a0,a5
    8000603e:	60e2                	ld	ra,24(sp)
    80006040:	6105                	addi	sp,sp,32
    80006042:	8082                	ret

0000000080006044 <mach_plic_handler>:
 *	    process it and complete the interrupt.
 * @param uintptr_t int_id
 * @param uintptr_t epc
 */
void mach_plic_handler( __attribute__((unused)) uintptr_t int_id, __attribute__((unused)) uintptr_t epc)
{
    80006044:	7179                	addi	sp,sp,-48
    80006046:	f406                	sd	ra,40(sp)
    80006048:	e42a                	sd	a0,8(sp)
    8000604a:	e02e                	sd	a1,0(sp)
	uint32_t  interrupt_id;

	log_trace("\nmach_plic_handler entered\n");
    8000604c:	00004517          	auipc	a0,0x4
    80006050:	bd450513          	addi	a0,a0,-1068 # 80009c20 <__rodata_start+0x8c8>
    80006054:	2f4010ef          	jal	ra,80007348 <log_trace>

	interrupt_id = interrupt_claim_request();
    80006058:	fa5ff0ef          	jal	ra,80005ffc <interrupt_claim_request>
    8000605c:	87aa                	mv	a5,a0
    8000605e:	ce3e                	sw	a5,28(sp)

	log_debug("interrupt id claimed = %x\n", interrupt_id);
    80006060:	47f2                	lw	a5,28(sp)
    80006062:	85be                	mv	a1,a5
    80006064:	00004517          	auipc	a0,0x4
    80006068:	bdc50513          	addi	a0,a0,-1060 # 80009c40 <__rodata_start+0x8e8>
    8000606c:	326010ef          	jal	ra,80007392 <log_debug>

	if (interrupt_id <= 0 || interrupt_id > PLIC_MAX_INTERRUPT_SRC)
    80006070:	47f2                	lw	a5,28(sp)
    80006072:	2781                	sext.w	a5,a5
    80006074:	c799                	beqz	a5,80006082 <mach_plic_handler+0x3e>
    80006076:	47f2                	lw	a5,28(sp)
    80006078:	0007871b          	sext.w	a4,a5
    8000607c:	47f1                	li	a5,28
    8000607e:	00e7fa63          	bgeu	a5,a4,80006092 <mach_plic_handler+0x4e>
	{
		log_fatal("Fatal error, interrupt id [%x] claimed is wrong\n", interrupt_id);
    80006082:	47f2                	lw	a5,28(sp)
    80006084:	85be                	mv	a1,a5
    80006086:	00004517          	auipc	a0,0x4
    8000608a:	bda50513          	addi	a0,a0,-1062 # 80009c60 <__rodata_start+0x908>
    8000608e:	380010ef          	jal	ra,8000740e <log_fatal>

	   reference - risc v priv spec v1.10 section 7.10 Interrupt Claims
	 */

	/*change state to active*/
	hart0_interrupt_matrix[interrupt_id].state = ACTIVE;
    80006092:	00101717          	auipc	a4,0x101
    80006096:	e0670713          	addi	a4,a4,-506 # 80106e98 <hart0_interrupt_matrix>
    8000609a:	01c16783          	lwu	a5,28(sp)
    8000609e:	0792                	slli	a5,a5,0x4
    800060a0:	97ba                	add	a5,a5,a4
    800060a2:	4705                	li	a4,1
    800060a4:	c798                	sw	a4,8(a5)

	log_debug("interrupt id %d, state changed to %d\n",
		 interrupt_id,hart0_interrupt_matrix[interrupt_id].state);
    800060a6:	00101717          	auipc	a4,0x101
    800060aa:	df270713          	addi	a4,a4,-526 # 80106e98 <hart0_interrupt_matrix>
    800060ae:	01c16783          	lwu	a5,28(sp)
    800060b2:	0792                	slli	a5,a5,0x4
    800060b4:	97ba                	add	a5,a5,a4
    800060b6:	4798                	lw	a4,8(a5)
	log_debug("interrupt id %d, state changed to %d\n",
    800060b8:	47f2                	lw	a5,28(sp)
    800060ba:	863a                	mv	a2,a4
    800060bc:	85be                	mv	a1,a5
    800060be:	00004517          	auipc	a0,0x4
    800060c2:	a4a50513          	addi	a0,a0,-1462 # 80009b08 <__rodata_start+0x7b0>
    800060c6:	2cc010ef          	jal	ra,80007392 <log_debug>

	/*call relevant interrupt service routine*/
	isr_table[interrupt_id](interrupt_id);
    800060ca:	00101717          	auipc	a4,0x101
    800060ce:	f8e70713          	addi	a4,a4,-114 # 80107058 <isr_table>
    800060d2:	01c16783          	lwu	a5,28(sp)
    800060d6:	078e                	slli	a5,a5,0x3
    800060d8:	97ba                	add	a5,a5,a4
    800060da:	6398                	ld	a4,0(a5)
    800060dc:	47f2                	lw	a5,28(sp)
    800060de:	853e                	mv	a0,a5
    800060e0:	9702                	jalr	a4

	interrupt_complete(interrupt_id);
    800060e2:	47f2                	lw	a5,28(sp)
    800060e4:	853e                	mv	a0,a5
    800060e6:	e29ff0ef          	jal	ra,80005f0e <interrupt_complete>

	log_debug("interrupt id %d complete \n", interrupt_id);
    800060ea:	47f2                	lw	a5,28(sp)
    800060ec:	85be                	mv	a1,a5
    800060ee:	00004517          	auipc	a0,0x4
    800060f2:	baa50513          	addi	a0,a0,-1110 # 80009c98 <__rodata_start+0x940>
    800060f6:	29c010ef          	jal	ra,80007392 <log_debug>

	log_trace("\nmach_plic_handler exited\n");
    800060fa:	00004517          	auipc	a0,0x4
    800060fe:	bbe50513          	addi	a0,a0,-1090 # 80009cb8 <__rodata_start+0x960>
    80006102:	246010ef          	jal	ra,80007348 <log_trace>
}
    80006106:	0001                	nop
    80006108:	70a2                	ld	ra,40(sp)
    8000610a:	6145                	addi	sp,sp,48
    8000610c:	8082                	ret

000000008000610e <isr_default>:
 * @details Default isr. Use it when you dont know what to do with interrupts
 * @param uint32_t interrupt_id
 * @return uint32_t
 */
void isr_default(uint32_t interrupt_id)
{
    8000610e:	1101                	addi	sp,sp,-32
    80006110:	ec06                	sd	ra,24(sp)
    80006112:	87aa                	mv	a5,a0
    80006114:	c63e                	sw	a5,12(sp)
	log_trace("\nisr_default entered\n");
    80006116:	00004517          	auipc	a0,0x4
    8000611a:	bc250513          	addi	a0,a0,-1086 # 80009cd8 <__rodata_start+0x980>
    8000611e:	22a010ef          	jal	ra,80007348 <log_trace>

	if( interrupt_id > 0 && interrupt_id < 7 )  //PWM Interrupts
    80006122:	47b2                	lw	a5,12(sp)
    80006124:	2781                	sext.w	a5,a5
    80006126:	cf8d                	beqz	a5,80006160 <isr_default+0x52>
    80006128:	47b2                	lw	a5,12(sp)
    8000612a:	0007871b          	sext.w	a4,a5
    8000612e:	4799                	li	a5,6
    80006130:	02e7e863          	bltu	a5,a4,80006160 <isr_default+0x52>
	{
		/*
		   Assuming 6 pwm's are there
		 */

		if(pwm_check_continuous_mode((6-interrupt_id)) == 0)
    80006134:	4719                	li	a4,6
    80006136:	47b2                	lw	a5,12(sp)
    80006138:	40f707bb          	subw	a5,a4,a5
    8000613c:	2781                	sext.w	a5,a5
    8000613e:	2781                	sext.w	a5,a5
    80006140:	853e                	mv	a0,a5
    80006142:	688000ef          	jal	ra,800067ca <pwm_check_continuous_mode>
    80006146:	87aa                	mv	a5,a0
    80006148:	ef81                	bnez	a5,80006160 <isr_default+0x52>
		{
			set_pwm_control_register((6-interrupt_id),0x80);
    8000614a:	4719                	li	a4,6
    8000614c:	47b2                	lw	a5,12(sp)
    8000614e:	40f707bb          	subw	a5,a4,a5
    80006152:	2781                	sext.w	a5,a5
    80006154:	2781                	sext.w	a5,a5
    80006156:	08000593          	li	a1,128
    8000615a:	853e                	mv	a0,a5
    8000615c:	600000ef          	jal	ra,8000675c <set_pwm_control_register>
		}
	}

	log_info("interrupt [%d] serviced\n",interrupt_id);
    80006160:	47b2                	lw	a5,12(sp)
    80006162:	85be                	mv	a1,a5
    80006164:	00004517          	auipc	a0,0x4
    80006168:	b8c50513          	addi	a0,a0,-1140 # 80009cf0 <__rodata_start+0x998>
    8000616c:	1f4010ef          	jal	ra,80007360 <log_info>

	log_trace("\nisr_default exited\n");
    80006170:	00004517          	auipc	a0,0x4
    80006174:	ba050513          	addi	a0,a0,-1120 # 80009d10 <__rodata_start+0x9b8>
    80006178:	1d0010ef          	jal	ra,80007348 <log_trace>
}
    8000617c:	0001                	nop
    8000617e:	60e2                	ld	ra,24(sp)
    80006180:	6105                	addi	sp,sp,32
    80006182:	8082                	ret

0000000080006184 <interrupt_enable>:
 * @brief enable the interrupt
 * @details A single bit that enables an interrupt. The bit position corresponds to the interrupt id
 * @param uint32_t interrupt_id
 */
void interrupt_enable(uint32_t interrupt_id)
{
    80006184:	7139                	addi	sp,sp,-64
    80006186:	fc06                	sd	ra,56(sp)
    80006188:	87aa                	mv	a5,a0
    8000618a:	c63e                	sw	a5,12(sp)
	uint8_t *interrupt_enable_addr;
	uint8_t current_value = 0x00, new_value;
    8000618c:	020107a3          	sb	zero,47(sp)

	log_trace("\ninterrupt_enable entered \n");
    80006190:	00004517          	auipc	a0,0x4
    80006194:	b9850513          	addi	a0,a0,-1128 # 80009d28 <__rodata_start+0x9d0>
    80006198:	1b0010ef          	jal	ra,80007348 <log_trace>

	log_debug("interrupt_id = %x\n", interrupt_id);
    8000619c:	47b2                	lw	a5,12(sp)
    8000619e:	85be                	mv	a1,a5
    800061a0:	00004517          	auipc	a0,0x4
    800061a4:	ba850513          	addi	a0,a0,-1112 # 80009d48 <__rodata_start+0x9f0>
    800061a8:	1ea010ef          	jal	ra,80007392 <log_debug>

	log_debug("PLIC BASE ADDRESS = %x, PLIC ENABLE OFFSET = %x\n" \
    800061ac:	6609                	lui	a2,0x2
    800061ae:	0c0005b7          	lui	a1,0xc000
    800061b2:	00004517          	auipc	a0,0x4
    800061b6:	bae50513          	addi	a0,a0,-1106 # 80009d60 <__rodata_start+0xa08>
    800061ba:	1d8010ef          	jal	ra,80007392 <log_debug>
		  ,PLIC_BASE_ADDRESS, PLIC_ENABLE_OFFSET);

	interrupt_enable_addr = (uint8_t *) (PLIC_BASE_ADDRESS +
					     PLIC_ENABLE_OFFSET +
					     (interrupt_id >> 3));
    800061be:	47b2                	lw	a5,12(sp)
    800061c0:	0037d79b          	srliw	a5,a5,0x3
    800061c4:	2781                	sext.w	a5,a5
    800061c6:	02079713          	slli	a4,a5,0x20
    800061ca:	9301                	srli	a4,a4,0x20
					     PLIC_ENABLE_OFFSET +
    800061cc:	0c0027b7          	lui	a5,0xc002
    800061d0:	97ba                	add	a5,a5,a4
	interrupt_enable_addr = (uint8_t *) (PLIC_BASE_ADDRESS +
    800061d2:	f03e                	sd	a5,32(sp)

	current_value = *interrupt_enable_addr;
    800061d4:	7782                	ld	a5,32(sp)
    800061d6:	0007c783          	lbu	a5,0(a5) # c002000 <_STACK_SIZE+0xbfee000>
    800061da:	02f107a3          	sb	a5,47(sp)

	log_debug("interrupt_enable_addr = %x current_value = %x \n", \
    800061de:	02f14783          	lbu	a5,47(sp)
    800061e2:	2781                	sext.w	a5,a5
    800061e4:	863e                	mv	a2,a5
    800061e6:	7582                	ld	a1,32(sp)
    800061e8:	00004517          	auipc	a0,0x4
    800061ec:	bb050513          	addi	a0,a0,-1104 # 80009d98 <__rodata_start+0xa40>
    800061f0:	1a2010ef          	jal	ra,80007392 <log_debug>
		  interrupt_enable_addr, current_value);

	/*set the bit corresponding to the interrupt src*/
	new_value = current_value | (0x1 << (interrupt_id & 0x07));
    800061f4:	47b2                	lw	a5,12(sp)
    800061f6:	8b9d                	andi	a5,a5,7
    800061f8:	2781                	sext.w	a5,a5
    800061fa:	4705                	li	a4,1
    800061fc:	00f717bb          	sllw	a5,a4,a5
    80006200:	2781                	sext.w	a5,a5
    80006202:	0187971b          	slliw	a4,a5,0x18
    80006206:	4187571b          	sraiw	a4,a4,0x18
    8000620a:	02f10783          	lb	a5,47(sp)
    8000620e:	8fd9                	or	a5,a5,a4
    80006210:	0187979b          	slliw	a5,a5,0x18
    80006214:	4187d79b          	sraiw	a5,a5,0x18
    80006218:	00f10fa3          	sb	a5,31(sp)

	*interrupt_enable_addr = new_value;
    8000621c:	7782                	ld	a5,32(sp)
    8000621e:	01f14703          	lbu	a4,31(sp)
    80006222:	00e78023          	sb	a4,0(a5)

	log_debug("interrupt_enable_addr = %x new_value = %x\n", \
		 interrupt_enable_addr, *interrupt_enable_addr);
    80006226:	7782                	ld	a5,32(sp)
    80006228:	0007c783          	lbu	a5,0(a5)
	log_debug("interrupt_enable_addr = %x new_value = %x\n", \
    8000622c:	2781                	sext.w	a5,a5
    8000622e:	863e                	mv	a2,a5
    80006230:	7582                	ld	a1,32(sp)
    80006232:	00004517          	auipc	a0,0x4
    80006236:	b9650513          	addi	a0,a0,-1130 # 80009dc8 <__rodata_start+0xa70>
    8000623a:	158010ef          	jal	ra,80007392 <log_debug>

	log_debug("value read: new_value = %x\n", *interrupt_enable_addr);
    8000623e:	7782                	ld	a5,32(sp)
    80006240:	0007c783          	lbu	a5,0(a5)
    80006244:	2781                	sext.w	a5,a5
    80006246:	85be                	mv	a1,a5
    80006248:	00004517          	auipc	a0,0x4
    8000624c:	bb050513          	addi	a0,a0,-1104 # 80009df8 <__rodata_start+0xaa0>
    80006250:	142010ef          	jal	ra,80007392 <log_debug>

	log_trace("\ninterrupt_enable exited \n");
    80006254:	00004517          	auipc	a0,0x4
    80006258:	bc450513          	addi	a0,a0,-1084 # 80009e18 <__rodata_start+0xac0>
    8000625c:	0ec010ef          	jal	ra,80007348 <log_trace>
}
    80006260:	0001                	nop
    80006262:	70e2                	ld	ra,56(sp)
    80006264:	6121                	addi	sp,sp,64
    80006266:	8082                	ret

0000000080006268 <interrupt_disable>:
 * @details A single bit that enables an interrupt.
 *          The bit position corresponds to the interrupt id
 * @param uint32_t interrupt_id
 */
void interrupt_disable(uint32_t interrupt_id)
{
    80006268:	7179                	addi	sp,sp,-48
    8000626a:	f406                	sd	ra,40(sp)
    8000626c:	87aa                	mv	a5,a0
    8000626e:	c63e                	sw	a5,12(sp)
	uint8_t *interrupt_disable_addr = 0;
    80006270:	ec02                	sd	zero,24(sp)
	uint8_t current_value = 0x00, new_value;
    80006272:	00010ba3          	sb	zero,23(sp)

	log_trace("\ninterrupt_disable entered \n");
    80006276:	00004517          	auipc	a0,0x4
    8000627a:	bc250513          	addi	a0,a0,-1086 # 80009e38 <__rodata_start+0xae0>
    8000627e:	0ca010ef          	jal	ra,80007348 <log_trace>

	log_debug("interrupt_id = %x\n", interrupt_id);
    80006282:	47b2                	lw	a5,12(sp)
    80006284:	85be                	mv	a1,a5
    80006286:	00004517          	auipc	a0,0x4
    8000628a:	ac250513          	addi	a0,a0,-1342 # 80009d48 <__rodata_start+0x9f0>
    8000628e:	104010ef          	jal	ra,80007392 <log_debug>

	log_debug("PLIC BASE ADDRESS = %x, PLIC ENABLE OFFSET = %x interrupt_id = %x\n",
    80006292:	47b2                	lw	a5,12(sp)
    80006294:	86be                	mv	a3,a5
    80006296:	6609                	lui	a2,0x2
    80006298:	0c0005b7          	lui	a1,0xc000
    8000629c:	00004517          	auipc	a0,0x4
    800062a0:	bbc50513          	addi	a0,a0,-1092 # 80009e58 <__rodata_start+0xb00>
    800062a4:	0ee010ef          	jal	ra,80007392 <log_debug>
		  PLIC_BASE_ADDRESS, PLIC_ENABLE_OFFSET, interrupt_id);

	interrupt_disable_addr = (uint8_t *) (PLIC_BASE_ADDRESS +
					      PLIC_ENABLE_OFFSET +
					      (interrupt_id >> 3));
    800062a8:	47b2                	lw	a5,12(sp)
    800062aa:	0037d79b          	srliw	a5,a5,0x3
    800062ae:	2781                	sext.w	a5,a5
    800062b0:	02079713          	slli	a4,a5,0x20
    800062b4:	9301                	srli	a4,a4,0x20
					      PLIC_ENABLE_OFFSET +
    800062b6:	0c0027b7          	lui	a5,0xc002
    800062ba:	97ba                	add	a5,a5,a4
	interrupt_disable_addr = (uint8_t *) (PLIC_BASE_ADDRESS +
    800062bc:	ec3e                	sd	a5,24(sp)

	current_value = *interrupt_disable_addr;
    800062be:	67e2                	ld	a5,24(sp)
    800062c0:	0007c783          	lbu	a5,0(a5) # c002000 <_STACK_SIZE+0xbfee000>
    800062c4:	00f10ba3          	sb	a5,23(sp)

	log_debug("interrupt_disable_addr = %x current_value = %x \n",
    800062c8:	01714783          	lbu	a5,23(sp)
    800062cc:	2781                	sext.w	a5,a5
    800062ce:	863e                	mv	a2,a5
    800062d0:	65e2                	ld	a1,24(sp)
    800062d2:	00004517          	auipc	a0,0x4
    800062d6:	bce50513          	addi	a0,a0,-1074 # 80009ea0 <__rodata_start+0xb48>
    800062da:	0b8010ef          	jal	ra,80007392 <log_debug>
		  interrupt_disable_addr, current_value);

	/*unset the bit corresponding to the interrupt src*/
	new_value = current_value & (~(0x1 << (interrupt_id & 0x07)));
    800062de:	47b2                	lw	a5,12(sp)
    800062e0:	8b9d                	andi	a5,a5,7
    800062e2:	2781                	sext.w	a5,a5
    800062e4:	4705                	li	a4,1
    800062e6:	00f717bb          	sllw	a5,a4,a5
    800062ea:	2781                	sext.w	a5,a5
    800062ec:	0187979b          	slliw	a5,a5,0x18
    800062f0:	4187d79b          	sraiw	a5,a5,0x18
    800062f4:	fff7c793          	not	a5,a5
    800062f8:	0187971b          	slliw	a4,a5,0x18
    800062fc:	4187571b          	sraiw	a4,a4,0x18
    80006300:	01710783          	lb	a5,23(sp)
    80006304:	8ff9                	and	a5,a5,a4
    80006306:	0187979b          	slliw	a5,a5,0x18
    8000630a:	4187d79b          	sraiw	a5,a5,0x18
    8000630e:	00f10b23          	sb	a5,22(sp)

	*interrupt_disable_addr = new_value;
    80006312:	67e2                	ld	a5,24(sp)
    80006314:	01614703          	lbu	a4,22(sp)
    80006318:	00e78023          	sb	a4,0(a5)

	hart0_interrupt_matrix[interrupt_id].state = INACTIVE;
    8000631c:	00101717          	auipc	a4,0x101
    80006320:	b7c70713          	addi	a4,a4,-1156 # 80106e98 <hart0_interrupt_matrix>
    80006324:	00c16783          	lwu	a5,12(sp)
    80006328:	0792                	slli	a5,a5,0x4
    8000632a:	97ba                	add	a5,a5,a4
    8000632c:	0007a423          	sw	zero,8(a5)

	log_debug("interrupt id %d, state changed to %d\n",
		 interrupt_id,hart0_interrupt_matrix[interrupt_id].state);
    80006330:	00101717          	auipc	a4,0x101
    80006334:	b6870713          	addi	a4,a4,-1176 # 80106e98 <hart0_interrupt_matrix>
    80006338:	00c16783          	lwu	a5,12(sp)
    8000633c:	0792                	slli	a5,a5,0x4
    8000633e:	97ba                	add	a5,a5,a4
    80006340:	4798                	lw	a4,8(a5)
	log_debug("interrupt id %d, state changed to %d\n",
    80006342:	47b2                	lw	a5,12(sp)
    80006344:	863a                	mv	a2,a4
    80006346:	85be                	mv	a1,a5
    80006348:	00003517          	auipc	a0,0x3
    8000634c:	7c050513          	addi	a0,a0,1984 # 80009b08 <__rodata_start+0x7b0>
    80006350:	042010ef          	jal	ra,80007392 <log_debug>

	log_debug("interrupt_disable_addr = %x new_value = %x\n",
		 interrupt_disable_addr, *interrupt_disable_addr);
    80006354:	67e2                	ld	a5,24(sp)
    80006356:	0007c783          	lbu	a5,0(a5)
	log_debug("interrupt_disable_addr = %x new_value = %x\n",
    8000635a:	2781                	sext.w	a5,a5
    8000635c:	863e                	mv	a2,a5
    8000635e:	65e2                	ld	a1,24(sp)
    80006360:	00004517          	auipc	a0,0x4
    80006364:	b7850513          	addi	a0,a0,-1160 # 80009ed8 <__rodata_start+0xb80>
    80006368:	02a010ef          	jal	ra,80007392 <log_debug>

	log_trace("interrupt_disable exited\n");
    8000636c:	00004517          	auipc	a0,0x4
    80006370:	b9c50513          	addi	a0,a0,-1124 # 80009f08 <__rodata_start+0xbb0>
    80006374:	7d5000ef          	jal	ra,80007348 <log_trace>
}
    80006378:	0001                	nop
    8000637a:	70a2                	ld	ra,40(sp)
    8000637c:	6145                	addi	sp,sp,48
    8000637e:	8082                	ret

0000000080006380 <set_interrupt_threshold>:
 * @brief set priority threshold for all interrupts
 * @details set a threshold on interrrupt priority. Any interruptthat has lesser priority than the threshold is ignored.
 * @param uint32_t priority_value
 */
void set_interrupt_threshold(uint32_t priority_value)
{
    80006380:	7179                	addi	sp,sp,-48
    80006382:	f406                	sd	ra,40(sp)
    80006384:	87aa                	mv	a5,a0
    80006386:	c63e                	sw	a5,12(sp)
	log_trace("\nset interrupt_threshold entered\n");
    80006388:	00004517          	auipc	a0,0x4
    8000638c:	ba050513          	addi	a0,a0,-1120 # 80009f28 <__rodata_start+0xbd0>
    80006390:	7b9000ef          	jal	ra,80007348 <log_trace>

	uint32_t *interrupt_threshold_priority = NULL;
    80006394:	ec02                	sd	zero,24(sp)

	interrupt_threshold_priority = (uint32_t *) (PLIC_BASE_ADDRESS +
    80006396:	0c0107b7          	lui	a5,0xc010
    8000639a:	ec3e                	sd	a5,24(sp)
							 PLIC_THRESHOLD_OFFSET);

	*interrupt_threshold_priority = priority_value;
    8000639c:	67e2                	ld	a5,24(sp)
    8000639e:	4732                	lw	a4,12(sp)
    800063a0:	c398                	sw	a4,0(a5)

	log_debug("plic threshold set to %d\n", *interrupt_threshold_priority);
    800063a2:	67e2                	ld	a5,24(sp)
    800063a4:	439c                	lw	a5,0(a5)
    800063a6:	85be                	mv	a1,a5
    800063a8:	00004517          	auipc	a0,0x4
    800063ac:	ba850513          	addi	a0,a0,-1112 # 80009f50 <__rodata_start+0xbf8>
    800063b0:	7e3000ef          	jal	ra,80007392 <log_debug>

	log_trace("set interrupt_threshold exited\n");
    800063b4:	00004517          	auipc	a0,0x4
    800063b8:	bbc50513          	addi	a0,a0,-1092 # 80009f70 <__rodata_start+0xc18>
    800063bc:	78d000ef          	jal	ra,80007348 <log_trace>
}
    800063c0:	0001                	nop
    800063c2:	70a2                	ld	ra,40(sp)
    800063c4:	6145                	addi	sp,sp,48
    800063c6:	8082                	ret

00000000800063c8 <set_interrupt_priority>:
 * @details set priority for each interrupt. This is a 4 byte field.
 * @param uint32_t priority_value
 * @param uint32_t int_id
 */
void set_interrupt_priority(uint32_t priority_value, uint32_t int_id)
{
    800063c8:	7179                	addi	sp,sp,-48
    800063ca:	f406                	sd	ra,40(sp)
    800063cc:	87aa                	mv	a5,a0
    800063ce:	872e                	mv	a4,a1
    800063d0:	c63e                	sw	a5,12(sp)
    800063d2:	87ba                	mv	a5,a4
    800063d4:	c43e                	sw	a5,8(sp)
	log_trace("\n set interrupt priority entered %x\n", priority_value);
    800063d6:	47b2                	lw	a5,12(sp)
    800063d8:	85be                	mv	a1,a5
    800063da:	00004517          	auipc	a0,0x4
    800063de:	bb650513          	addi	a0,a0,-1098 # 80009f90 <__rodata_start+0xc38>
    800063e2:	767000ef          	jal	ra,80007348 <log_trace>
	   based address + priority offset + 4*interruptId
	 */

	interrupt_priority_address = (uint32_t *) (PLIC_BASE_ADDRESS +
						   PLIC_PRIORITY_OFFSET +
						   (int_id <<
    800063e6:	47a2                	lw	a5,8(sp)
    800063e8:	0027979b          	slliw	a5,a5,0x2
    800063ec:	2781                	sext.w	a5,a5
    800063ee:	02079713          	slli	a4,a5,0x20
    800063f2:	9301                	srli	a4,a4,0x20
						   PLIC_PRIORITY_OFFSET +
    800063f4:	0c0007b7          	lui	a5,0xc000
    800063f8:	97ba                	add	a5,a5,a4
	interrupt_priority_address = (uint32_t *) (PLIC_BASE_ADDRESS +
    800063fa:	ec3e                	sd	a5,24(sp)
						    PLIC_PRIORITY_SHIFT_PER_INT));

	log_debug("interrupt_priority_address = %x\n", interrupt_priority_address);
    800063fc:	65e2                	ld	a1,24(sp)
    800063fe:	00004517          	auipc	a0,0x4
    80006402:	bba50513          	addi	a0,a0,-1094 # 80009fb8 <__rodata_start+0xc60>
    80006406:	78d000ef          	jal	ra,80007392 <log_debug>

	log_debug("current data at interrupt_priority_address = %x\n", *interrupt_priority_address);
    8000640a:	67e2                	ld	a5,24(sp)
    8000640c:	439c                	lw	a5,0(a5)
    8000640e:	85be                	mv	a1,a5
    80006410:	00004517          	auipc	a0,0x4
    80006414:	bd050513          	addi	a0,a0,-1072 # 80009fe0 <__rodata_start+0xc88>
    80006418:	77b000ef          	jal	ra,80007392 <log_debug>

	*interrupt_priority_address = priority_value;
    8000641c:	67e2                	ld	a5,24(sp)
    8000641e:	4732                	lw	a4,12(sp)
    80006420:	c398                	sw	a4,0(a5)

	log_debug(" new data at interrupt_priority_address = %x\n", *interrupt_priority_address);
    80006422:	67e2                	ld	a5,24(sp)
    80006424:	439c                	lw	a5,0(a5)
    80006426:	85be                	mv	a1,a5
    80006428:	00004517          	auipc	a0,0x4
    8000642c:	bf050513          	addi	a0,a0,-1040 # 8000a018 <__rodata_start+0xcc0>
    80006430:	763000ef          	jal	ra,80007392 <log_debug>

	log_trace("set interrupt priority exited\n");
    80006434:	00004517          	auipc	a0,0x4
    80006438:	c1450513          	addi	a0,a0,-1004 # 8000a048 <__rodata_start+0xcf0>
    8000643c:	70d000ef          	jal	ra,80007348 <log_trace>
}
    80006440:	0001                	nop
    80006442:	70a2                	ld	ra,40(sp)
    80006444:	6145                	addi	sp,sp,48
    80006446:	8082                	ret

0000000080006448 <configure_interrupt_pin>:
 * @brief configure a gpio pin for each interrupt
 * @details enable the corresponding gpio pin for a interrupt as read.
 * @param uint32_t id
 */
void configure_interrupt_pin( __attribute__((unused)) uint32_t id)
{
    80006448:	7179                	addi	sp,sp,-48
    8000644a:	f406                	sd	ra,40(sp)
    8000644c:	87aa                	mv	a5,a0
    8000644e:	c63e                	sw	a5,12(sp)
	log_trace("\nconfigure interrupt pin entered\n");
    80006450:	00004517          	auipc	a0,0x4
    80006454:	c1850513          	addi	a0,a0,-1000 # 8000a068 <__rodata_start+0xd10>
    80006458:	6f1000ef          	jal	ra,80007348 <log_trace>
//todo ->map gpio pins and interrupt id

//	pin = id - PLIC_GPIO_OFFSET;
//	log_info("pin = %x\n", pin);

	read_data = read_word(GPIO_DIRECTION_CNTRL_REG);
    8000645c:	000407b7          	lui	a5,0x40
    80006460:	10078513          	addi	a0,a5,256 # 40100 <_STACK_SIZE+0x2c100>
    80006464:	2bb000ef          	jal	ra,80006f1e <read_word>
    80006468:	87aa                	mv	a5,a0
    8000646a:	ce3e                	sw	a5,28(sp)

	log_debug("GPIO DIRECTION REGISTER VALUE = %x\n", read_data);
    8000646c:	47f2                	lw	a5,28(sp)
    8000646e:	85be                	mv	a1,a5
    80006470:	00004517          	auipc	a0,0x4
    80006474:	c2050513          	addi	a0,a0,-992 # 8000a090 <__rodata_start+0xd38>
    80006478:	71b000ef          	jal	ra,80007392 <log_debug>
//	pin = (0x1 << (pin));
//	log_info("pin = %x\n", pin);

	/*interrrupt id 10 mapped to GPIO 5*/

	write_word(GPIO_DIRECTION_CNTRL_REG, 0x00000000);
    8000647c:	4581                	li	a1,0
    8000647e:	000407b7          	lui	a5,0x40
    80006482:	10078513          	addi	a0,a5,256 # 40100 <_STACK_SIZE+0x2c100>
    80006486:	2c3000ef          	jal	ra,80006f48 <write_word>
//	write_word(GPIO_DIRECTION_CNTRL_REG, ((~(pin)) & read_data));

	log_debug("Data written to GPIO DIRECTION CTRL REG = %x\n", read_word(GPIO_DIRECTION_CNTRL_REG));
    8000648a:	000407b7          	lui	a5,0x40
    8000648e:	10078513          	addi	a0,a5,256 # 40100 <_STACK_SIZE+0x2c100>
    80006492:	28d000ef          	jal	ra,80006f1e <read_word>
    80006496:	87aa                	mv	a5,a0
    80006498:	85be                	mv	a1,a5
    8000649a:	00004517          	auipc	a0,0x4
    8000649e:	c1e50513          	addi	a0,a0,-994 # 8000a0b8 <__rodata_start+0xd60>
    800064a2:	6f1000ef          	jal	ra,80007392 <log_debug>

	log_trace("configure interrupt pin exited\n");
    800064a6:	00004517          	auipc	a0,0x4
    800064aa:	c4250513          	addi	a0,a0,-958 # 8000a0e8 <__rodata_start+0xd90>
    800064ae:	69b000ef          	jal	ra,80007348 <log_trace>
}
    800064b2:	0001                	nop
    800064b4:	70a2                	ld	ra,40(sp)
    800064b6:	6145                	addi	sp,sp,48
    800064b8:	8082                	ret

00000000800064ba <plic_init>:
 * @details Intitializes the plic registers to default values.
 *          Sets up the plic meta data table. Assigns the plic 
 *          handler to mcause_interrupt_table.,By default interrupts are disabled. 
 */
void plic_init()
{
    800064ba:	1101                	addi	sp,sp,-32
    800064bc:	ec06                	sd	ra,24(sp)
	uint32_t int_id = 0;
    800064be:	c602                	sw	zero,12(sp)

	log_trace("\nplic_init entered\n");
    800064c0:	00004517          	auipc	a0,0x4
    800064c4:	c4850513          	addi	a0,a0,-952 # 8000a108 <__rodata_start+0xdb0>
    800064c8:	681000ef          	jal	ra,80007348 <log_trace>

	/*Assign service routine for external interrupt in machine mode*/
	mcause_interrupt_table[MACH_EXTERNAL_INTERRUPT] = mach_plic_handler;
    800064cc:	00101797          	auipc	a5,0x101
    800064d0:	c6c78793          	addi	a5,a5,-916 # 80107138 <mcause_interrupt_table>
    800064d4:	00000717          	auipc	a4,0x0
    800064d8:	b7070713          	addi	a4,a4,-1168 # 80006044 <mach_plic_handler>
    800064dc:	efb8                	sd	a4,88(a5)

	log_debug("Assigned mach_plic_handler to trap id : %d\n", MACH_EXTERNAL_INTERRUPT);
    800064de:	45ad                	li	a1,11
    800064e0:	00004517          	auipc	a0,0x4
    800064e4:	c4050513          	addi	a0,a0,-960 # 8000a120 <__rodata_start+0xdc8>
    800064e8:	6ab000ef          	jal	ra,80007392 <log_debug>

	   The priority value 0 is reserved to mean “never interrupt”,
	   and interrupt priority increases with increasing integer values.
	 */

	hart0_interrupt_matrix[0].state = INACTIVE;
    800064ec:	00101797          	auipc	a5,0x101
    800064f0:	9ac78793          	addi	a5,a5,-1620 # 80106e98 <hart0_interrupt_matrix>
    800064f4:	0007a423          	sw	zero,8(a5)
	hart0_interrupt_matrix[0].id = 0;
    800064f8:	00101797          	auipc	a5,0x101
    800064fc:	9a078793          	addi	a5,a5,-1632 # 80106e98 <hart0_interrupt_matrix>
    80006500:	0007a023          	sw	zero,0(a5)
	hart0_interrupt_matrix[0].priority = 0;
    80006504:	00101797          	auipc	a5,0x101
    80006508:	99478793          	addi	a5,a5,-1644 # 80106e98 <hart0_interrupt_matrix>
    8000650c:	0007a223          	sw	zero,4(a5)
	hart0_interrupt_matrix[0].count = 0;
    80006510:	00101797          	auipc	a5,0x101
    80006514:	98878793          	addi	a5,a5,-1656 # 80106e98 <hart0_interrupt_matrix>
    80006518:	0007a623          	sw	zero,12(a5)

	interrupt_disable(int_id);
    8000651c:	47b2                	lw	a5,12(sp)
    8000651e:	853e                	mv	a0,a5
    80006520:	d49ff0ef          	jal	ra,80006268 <interrupt_disable>

	for(int_id = 1; int_id < PLIC_MAX_INTERRUPT_SRC; int_id++)
    80006524:	4785                	li	a5,1
    80006526:	c63e                	sw	a5,12(sp)
    80006528:	a0dd                	j	8000660e <plic_init+0x154>
	{
		hart0_interrupt_matrix[int_id].state = INACTIVE;
    8000652a:	00101717          	auipc	a4,0x101
    8000652e:	96e70713          	addi	a4,a4,-1682 # 80106e98 <hart0_interrupt_matrix>
    80006532:	00c16783          	lwu	a5,12(sp)
    80006536:	0792                	slli	a5,a5,0x4
    80006538:	97ba                	add	a5,a5,a4
    8000653a:	0007a423          	sw	zero,8(a5)
		hart0_interrupt_matrix[int_id].id = int_id;
    8000653e:	00101717          	auipc	a4,0x101
    80006542:	95a70713          	addi	a4,a4,-1702 # 80106e98 <hart0_interrupt_matrix>
    80006546:	00c16783          	lwu	a5,12(sp)
    8000654a:	0792                	slli	a5,a5,0x4
    8000654c:	97ba                	add	a5,a5,a4
    8000654e:	4732                	lw	a4,12(sp)
    80006550:	c398                	sw	a4,0(a5)
		hart0_interrupt_matrix[int_id].priority = PLIC_PRIORITY_3;
    80006552:	00101717          	auipc	a4,0x101
    80006556:	94670713          	addi	a4,a4,-1722 # 80106e98 <hart0_interrupt_matrix>
    8000655a:	00c16783          	lwu	a5,12(sp)
    8000655e:	0792                	slli	a5,a5,0x4
    80006560:	97ba                	add	a5,a5,a4
    80006562:	4709                	li	a4,2
    80006564:	c3d8                	sw	a4,4(a5)
		hart0_interrupt_matrix[int_id].count = 0;
    80006566:	00101717          	auipc	a4,0x101
    8000656a:	93270713          	addi	a4,a4,-1742 # 80106e98 <hart0_interrupt_matrix>
    8000656e:	00c16783          	lwu	a5,12(sp)
    80006572:	0792                	slli	a5,a5,0x4
    80006574:	97ba                	add	a5,a5,a4
    80006576:	0007a623          	sw	zero,12(a5)

		log_debug("\n*************************************************");
    8000657a:	00004517          	auipc	a0,0x4
    8000657e:	bd650513          	addi	a0,a0,-1066 # 8000a150 <__rodata_start+0xdf8>
    80006582:	611000ef          	jal	ra,80007392 <log_debug>

		/*Disable all interrupts at the beginning*/
		interrupt_disable(int_id);
    80006586:	47b2                	lw	a5,12(sp)
    80006588:	853e                	mv	a0,a5
    8000658a:	cdfff0ef          	jal	ra,80006268 <interrupt_disable>

		/*assign a default isr for all interrupts*/
		isr_table[int_id] = isr_default;
    8000658e:	00101717          	auipc	a4,0x101
    80006592:	aca70713          	addi	a4,a4,-1334 # 80107058 <isr_table>
    80006596:	00c16783          	lwu	a5,12(sp)
    8000659a:	078e                	slli	a5,a5,0x3
    8000659c:	97ba                	add	a5,a5,a4
    8000659e:	00000717          	auipc	a4,0x0
    800065a2:	b7070713          	addi	a4,a4,-1168 # 8000610e <isr_default>
    800065a6:	e398                	sd	a4,0(a5)

		/*set priority for all interrupts*/

		set_interrupt_priority(PLIC_PRIORITY_3, int_id);
    800065a8:	47b2                	lw	a5,12(sp)
    800065aa:	85be                	mv	a1,a5
    800065ac:	4509                	li	a0,2
    800065ae:	e1bff0ef          	jal	ra,800063c8 <set_interrupt_priority>

		log_debug("\ninterrupt id = %x \nreset to default values state = %x \
    800065b2:	00101717          	auipc	a4,0x101
    800065b6:	8e670713          	addi	a4,a4,-1818 # 80106e98 <hart0_interrupt_matrix>
    800065ba:	00c16783          	lwu	a5,12(sp)
    800065be:	0792                	slli	a5,a5,0x4
    800065c0:	97ba                	add	a5,a5,a4
    800065c2:	438c                	lw	a1,0(a5)
			  \npriority = %x\ncount = %x\n \
			  \n*************************************************",
			  hart0_interrupt_matrix[int_id].id, \
			  hart0_interrupt_matrix[int_id].state, \
    800065c4:	00101717          	auipc	a4,0x101
    800065c8:	8d470713          	addi	a4,a4,-1836 # 80106e98 <hart0_interrupt_matrix>
    800065cc:	00c16783          	lwu	a5,12(sp)
    800065d0:	0792                	slli	a5,a5,0x4
    800065d2:	97ba                	add	a5,a5,a4
    800065d4:	4790                	lw	a2,8(a5)
		log_debug("\ninterrupt id = %x \nreset to default values state = %x \
    800065d6:	00101717          	auipc	a4,0x101
    800065da:	8c270713          	addi	a4,a4,-1854 # 80106e98 <hart0_interrupt_matrix>
    800065de:	00c16783          	lwu	a5,12(sp)
    800065e2:	0792                	slli	a5,a5,0x4
    800065e4:	97ba                	add	a5,a5,a4
    800065e6:	43d4                	lw	a3,4(a5)
    800065e8:	00101717          	auipc	a4,0x101
    800065ec:	8b070713          	addi	a4,a4,-1872 # 80106e98 <hart0_interrupt_matrix>
    800065f0:	00c16783          	lwu	a5,12(sp)
    800065f4:	0792                	slli	a5,a5,0x4
    800065f6:	97ba                	add	a5,a5,a4
    800065f8:	47dc                	lw	a5,12(a5)
    800065fa:	873e                	mv	a4,a5
    800065fc:	00004517          	auipc	a0,0x4
    80006600:	b8c50513          	addi	a0,a0,-1140 # 8000a188 <__rodata_start+0xe30>
    80006604:	58f000ef          	jal	ra,80007392 <log_debug>
	for(int_id = 1; int_id < PLIC_MAX_INTERRUPT_SRC; int_id++)
    80006608:	47b2                	lw	a5,12(sp)
    8000660a:	2785                	addiw	a5,a5,1
    8000660c:	c63e                	sw	a5,12(sp)
    8000660e:	47b2                	lw	a5,12(sp)
    80006610:	0007871b          	sext.w	a4,a5
    80006614:	47ed                	li	a5,27
    80006616:	f0e7fae3          	bgeu	a5,a4,8000652a <plic_init+0x70>

	/*Enable required interrupts
	  interrupt_enable(int_id);
	 */
	/*set threshold value for interrupts*/
	set_interrupt_threshold(PLIC_PRIORITY_2);
    8000661a:	4505                	li	a0,1
    8000661c:	d65ff0ef          	jal	ra,80006380 <set_interrupt_threshold>

	log_trace("plic_init exited \n");
    80006620:	00004517          	auipc	a0,0x4
    80006624:	bf850513          	addi	a0,a0,-1032 # 8000a218 <__rodata_start+0xec0>
    80006628:	521000ef          	jal	ra,80007348 <log_trace>
}
    8000662c:	0001                	nop
    8000662e:	60e2                	ld	ra,24(sp)
    80006630:	6105                	addi	sp,sp,32
    80006632:	8082                	ret

0000000080006634 <configure_interrupt>:
 * @warning Here it is assumed, to have a one to one mapping
 *          between interrupt enable bit and interrupt pin
 * @param uint32_t int_id
 */
void configure_interrupt(uint32_t int_id)
{
    80006634:	1101                	addi	sp,sp,-32
    80006636:	ec06                	sd	ra,24(sp)
    80006638:	87aa                	mv	a5,a0
    8000663a:	c63e                	sw	a5,12(sp)
	log_trace("\nconfigure_interrupt entered \n");
    8000663c:	00004517          	auipc	a0,0x4
    80006640:	bf450513          	addi	a0,a0,-1036 # 8000a230 <__rodata_start+0xed8>
    80006644:	505000ef          	jal	ra,80007348 <log_trace>

	log_debug("interrupt id = %x \n", int_id);
    80006648:	47b2                	lw	a5,12(sp)
    8000664a:	85be                	mv	a1,a5
    8000664c:	00004517          	auipc	a0,0x4
    80006650:	c0450513          	addi	a0,a0,-1020 # 8000a250 <__rodata_start+0xef8>
    80006654:	53f000ef          	jal	ra,80007392 <log_debug>

	configure_interrupt_pin(int_id);
    80006658:	47b2                	lw	a5,12(sp)
    8000665a:	853e                	mv	a0,a5
    8000665c:	dedff0ef          	jal	ra,80006448 <configure_interrupt_pin>

	interrupt_enable(int_id);
    80006660:	47b2                	lw	a5,12(sp)
    80006662:	853e                	mv	a0,a5
    80006664:	b21ff0ef          	jal	ra,80006184 <interrupt_enable>

	log_trace("configure_interrupt exited \n");
    80006668:	00004517          	auipc	a0,0x4
    8000666c:	c0050513          	addi	a0,a0,-1024 # 8000a268 <__rodata_start+0xf10>
    80006670:	4d9000ef          	jal	ra,80007348 <log_trace>
}
    80006674:	0001                	nop
    80006676:	60e2                	ld	ra,24(sp)
    80006678:	6105                	addi	sp,sp,32
    8000667a:	8082                	ret

000000008000667c <set_pwm_period_register>:
 * @param int module_number- specifies the pwm module to be selected
 * @param int value - value to be set between 0x0000 to 0xffff.
 * @return int returns 1 on success, 0 on failure.
 */
int set_pwm_period_register(int module_number, int value)
{
    8000667c:	7179                	addi	sp,sp,-48
    8000667e:	f406                	sd	ra,40(sp)
    80006680:	87aa                	mv	a5,a0
    80006682:	872e                	mv	a4,a1
    80006684:	c63e                	sw	a5,12(sp)
    80006686:	87ba                	mv	a5,a4
    80006688:	c43e                	sw	a5,8(sp)
	if (value > PERIOD_REGISTER_MAX) {
    8000668a:	47a2                	lw	a5,8(sp)
    8000668c:	0007871b          	sext.w	a4,a5
    80006690:	67c1                	lui	a5,0x10
    80006692:	00f74d63          	blt	a4,a5,800066ac <set_pwm_period_register+0x30>
		log_error("\nPeriod Register Value higher than max value (%x)", PERIOD_REGISTER_MAX);	
    80006696:	67c1                	lui	a5,0x10
    80006698:	fff78593          	addi	a1,a5,-1 # ffff <_tbss_end+0xffff>
    8000669c:	00004517          	auipc	a0,0x4
    800066a0:	bec50513          	addi	a0,a0,-1044 # 8000a288 <__rodata_start+0xf30>
    800066a4:	539000ef          	jal	ra,800073dc <log_error>
		return 0;
    800066a8:	4781                	li	a5,0
    800066aa:	a825                	j	800066e2 <set_pwm_period_register+0x66>
	}

	volatile short* period_value;
	period_value = (int*) (PWM_BASE_ADDRESS + module_number*PWM_MODULE_OFFSET + PERIOD_REGISTER);
    800066ac:	47b2                	lw	a5,12(sp)
    800066ae:	3007879b          	addiw	a5,a5,768
    800066b2:	2781                	sext.w	a5,a5
    800066b4:	0087979b          	slliw	a5,a5,0x8
    800066b8:	2781                	sext.w	a5,a5
    800066ba:	ec3e                	sd	a5,24(sp)
	*period_value = value;
    800066bc:	47a2                	lw	a5,8(sp)
    800066be:	0107971b          	slliw	a4,a5,0x10
    800066c2:	4107571b          	sraiw	a4,a4,0x10
    800066c6:	67e2                	ld	a5,24(sp)
    800066c8:	00e79023          	sh	a4,0(a5)

	log_info("\n Period Register of module number %d set to %x", module_number, value);
    800066cc:	4722                	lw	a4,8(sp)
    800066ce:	47b2                	lw	a5,12(sp)
    800066d0:	863a                	mv	a2,a4
    800066d2:	85be                	mv	a1,a5
    800066d4:	00004517          	auipc	a0,0x4
    800066d8:	bec50513          	addi	a0,a0,-1044 # 8000a2c0 <__rodata_start+0xf68>
    800066dc:	485000ef          	jal	ra,80007360 <log_info>

	return 1;
    800066e0:	4785                	li	a5,1
}
    800066e2:	853e                	mv	a0,a5
    800066e4:	70a2                	ld	ra,40(sp)
    800066e6:	6145                	addi	sp,sp,48
    800066e8:	8082                	ret

00000000800066ea <set_pwm_duty_register>:
 * @param int module_number- specifies the pwm module to be selected
 * @param int value - value to be set between 0x0000 to 0xffff.
 * @return int returns 1 on success, 0 on failure.
 */
int set_pwm_duty_register(int module_number, int value)
{
    800066ea:	7179                	addi	sp,sp,-48
    800066ec:	f406                	sd	ra,40(sp)
    800066ee:	87aa                	mv	a5,a0
    800066f0:	872e                	mv	a4,a1
    800066f2:	c63e                	sw	a5,12(sp)
    800066f4:	87ba                	mv	a5,a4
    800066f6:	c43e                	sw	a5,8(sp)
	volatile short* duty_value;

	if (value > DUTY_REGISTER_MAX) {
    800066f8:	47a2                	lw	a5,8(sp)
    800066fa:	0007871b          	sext.w	a4,a5
    800066fe:	67c1                	lui	a5,0x10
    80006700:	00f74d63          	blt	a4,a5,8000671a <set_pwm_duty_register+0x30>
		log_error("\nDuty Register Value higher than max value (%x)", DUTY_REGISTER_MAX);
    80006704:	67c1                	lui	a5,0x10
    80006706:	fff78593          	addi	a1,a5,-1 # ffff <_tbss_end+0xffff>
    8000670a:	00004517          	auipc	a0,0x4
    8000670e:	be650513          	addi	a0,a0,-1050 # 8000a2f0 <__rodata_start+0xf98>
    80006712:	4cb000ef          	jal	ra,800073dc <log_error>
		return 0;
    80006716:	4781                	li	a5,0
    80006718:	a835                	j	80006754 <set_pwm_duty_register+0x6a>
	}

	duty_value = PWM_BASE_ADDRESS + module_number*PWM_MODULE_OFFSET + DUTY_REGISTER;
    8000671a:	47b2                	lw	a5,12(sp)
    8000671c:	3007879b          	addiw	a5,a5,768
    80006720:	2781                	sext.w	a5,a5
    80006722:	0087979b          	slliw	a5,a5,0x8
    80006726:	2781                	sext.w	a5,a5
    80006728:	2791                	addiw	a5,a5,4
    8000672a:	2781                	sext.w	a5,a5
    8000672c:	ec3e                	sd	a5,24(sp)
	*duty_value = value;
    8000672e:	47a2                	lw	a5,8(sp)
    80006730:	0107971b          	slliw	a4,a5,0x10
    80006734:	4107571b          	sraiw	a4,a4,0x10
    80006738:	67e2                	ld	a5,24(sp)
    8000673a:	00e79023          	sh	a4,0(a5)

	log_info("\n Duty Register of module number %d set to %x", module_number, value);
    8000673e:	4722                	lw	a4,8(sp)
    80006740:	47b2                	lw	a5,12(sp)
    80006742:	863a                	mv	a2,a4
    80006744:	85be                	mv	a1,a5
    80006746:	00004517          	auipc	a0,0x4
    8000674a:	bda50513          	addi	a0,a0,-1062 # 8000a320 <__rodata_start+0xfc8>
    8000674e:	413000ef          	jal	ra,80007360 <log_info>

	return 1;
    80006752:	4785                	li	a5,1
}
    80006754:	853e                	mv	a0,a5
    80006756:	70a2                	ld	ra,40(sp)
    80006758:	6145                	addi	sp,sp,48
    8000675a:	8082                	ret

000000008000675c <set_pwm_control_register>:
 * @param int module_number- specifies the pwm module to be selected
 * @param int value - value to be set between 0x0000 to 0xff.
 * @return int returns 1 on success, 0 on failure.
 */
int set_pwm_control_register(int module_number, int value)
{
    8000675c:	7179                	addi	sp,sp,-48
    8000675e:	f406                	sd	ra,40(sp)
    80006760:	87aa                	mv	a5,a0
    80006762:	872e                	mv	a4,a1
    80006764:	c63e                	sw	a5,12(sp)
    80006766:	87ba                	mv	a5,a4
    80006768:	c43e                	sw	a5,8(sp)
	volatile char* control_value;

	if (value > CONTROL_REGISTER_MAX) {
    8000676a:	47a2                	lw	a5,8(sp)
    8000676c:	0007871b          	sext.w	a4,a5
    80006770:	0ff00793          	li	a5,255
    80006774:	00e7dc63          	bge	a5,a4,8000678c <set_pwm_control_register+0x30>
		log_error("\nControl Register Value higher than max value (%x)", CONTROL_REGISTER_MAX);	
    80006778:	0ff00593          	li	a1,255
    8000677c:	00004517          	auipc	a0,0x4
    80006780:	bd450513          	addi	a0,a0,-1068 # 8000a350 <__rodata_start+0xff8>
    80006784:	459000ef          	jal	ra,800073dc <log_error>
		return 0;
    80006788:	4781                	li	a5,0
    8000678a:	a825                	j	800067c2 <set_pwm_control_register+0x66>
	}

	control_value = PWM_BASE_ADDRESS + module_number*PWM_MODULE_OFFSET + CONTROL_REGISTER;
    8000678c:	47b2                	lw	a5,12(sp)
    8000678e:	3007879b          	addiw	a5,a5,768
    80006792:	2781                	sext.w	a5,a5
    80006794:	0087979b          	slliw	a5,a5,0x8
    80006798:	2781                	sext.w	a5,a5
    8000679a:	27a1                	addiw	a5,a5,8
    8000679c:	2781                	sext.w	a5,a5
    8000679e:	ec3e                	sd	a5,24(sp)
	*control_value = value;
    800067a0:	47a2                	lw	a5,8(sp)
    800067a2:	0ff7f713          	andi	a4,a5,255
    800067a6:	67e2                	ld	a5,24(sp)
    800067a8:	00e78023          	sb	a4,0(a5)

	log_info("\n Control Register of module number %d set to %x", module_number, value);
    800067ac:	4722                	lw	a4,8(sp)
    800067ae:	47b2                	lw	a5,12(sp)
    800067b0:	863a                	mv	a2,a4
    800067b2:	85be                	mv	a1,a5
    800067b4:	00004517          	auipc	a0,0x4
    800067b8:	bd450513          	addi	a0,a0,-1068 # 8000a388 <__rodata_start+0x1030>
    800067bc:	3a5000ef          	jal	ra,80007360 <log_info>

	return 1;
    800067c0:	4785                	li	a5,1
}
    800067c2:	853e                	mv	a0,a5
    800067c4:	70a2                	ld	ra,40(sp)
    800067c6:	6145                	addi	sp,sp,48
    800067c8:	8082                	ret

00000000800067ca <pwm_check_continuous_mode>:
 * @details This function will be called to check if continuous mode is set for current pwm module
 * @param int module_number- specifies the pwm module to be selected 
 * @return int returns 1 if running in continuous mode, 0 if not.
 */
int pwm_check_continuous_mode(int module_number)
{
    800067ca:	7179                	addi	sp,sp,-48
    800067cc:	f406                	sd	ra,40(sp)
    800067ce:	87aa                	mv	a5,a0
    800067d0:	c63e                	sw	a5,12(sp)
	volatile char* control_value;
	control_value = PWM_BASE_ADDRESS + module_number*PWM_MODULE_OFFSET + CONTROL_REGISTER;
    800067d2:	47b2                	lw	a5,12(sp)
    800067d4:	3007879b          	addiw	a5,a5,768
    800067d8:	2781                	sext.w	a5,a5
    800067da:	0087979b          	slliw	a5,a5,0x8
    800067de:	2781                	sext.w	a5,a5
    800067e0:	27a1                	addiw	a5,a5,8
    800067e2:	2781                	sext.w	a5,a5
    800067e4:	ec3e                	sd	a5,24(sp)
	int value = *control_value & CONTINUOUS_ONCE;
    800067e6:	67e2                	ld	a5,24(sp)
    800067e8:	0007c783          	lbu	a5,0(a5)
    800067ec:	0ff7f793          	andi	a5,a5,255
    800067f0:	2781                	sext.w	a5,a5
    800067f2:	8ba1                	andi	a5,a5,8
    800067f4:	ca3e                	sw	a5,20(sp)
	log_info("\n Running in continuous mode(1/0): %d", (value>>3));
    800067f6:	47d2                	lw	a5,20(sp)
    800067f8:	4037d79b          	sraiw	a5,a5,0x3
    800067fc:	2781                	sext.w	a5,a5
    800067fe:	85be                	mv	a1,a5
    80006800:	00004517          	auipc	a0,0x4
    80006804:	bc050513          	addi	a0,a0,-1088 # 8000a3c0 <__rodata_start+0x1068>
    80006808:	359000ef          	jal	ra,80007360 <log_info>
	if( (value>>3) == 1)
    8000680c:	47d2                	lw	a5,20(sp)
    8000680e:	4037d79b          	sraiw	a5,a5,0x3
    80006812:	2781                	sext.w	a5,a5
    80006814:	873e                	mv	a4,a5
    80006816:	4785                	li	a5,1
    80006818:	00f71463          	bne	a4,a5,80006820 <pwm_check_continuous_mode+0x56>
		return 1;
    8000681c:	4785                	li	a5,1
    8000681e:	a011                	j	80006822 <pwm_check_continuous_mode+0x58>
	else
		return 0;
    80006820:	4781                	li	a5,0
}
    80006822:	853e                	mv	a0,a5
    80006824:	70a2                	ld	ra,40(sp)
    80006826:	6145                	addi	sp,sp,48
    80006828:	8082                	ret

000000008000682a <set_pwm_clock_register>:
 * @param int module_number- specifies the pwm module to be selected
 * @param int value - value to be set between 0x0000 to 0xffff.
 * @return int returns 1 on success, 0 on failure.
 */
int set_pwm_clock_register(int module_number, int value)
{
    8000682a:	7179                	addi	sp,sp,-48
    8000682c:	f406                	sd	ra,40(sp)
    8000682e:	87aa                	mv	a5,a0
    80006830:	872e                	mv	a4,a1
    80006832:	c63e                	sw	a5,12(sp)
    80006834:	87ba                	mv	a5,a4
    80006836:	c43e                	sw	a5,8(sp)
	volatile short* clock_value;

	if (value > CLOCK_REGISTER_MAX) {
    80006838:	47a2                	lw	a5,8(sp)
    8000683a:	0007871b          	sext.w	a4,a5
    8000683e:	67c1                	lui	a5,0x10
    80006840:	00f74d63          	blt	a4,a5,8000685a <set_pwm_clock_register+0x30>
		log_error("\nClock Register Value higher than max value (%x)", CLOCK_REGISTER_MAX);
    80006844:	67c1                	lui	a5,0x10
    80006846:	fff78593          	addi	a1,a5,-1 # ffff <_tbss_end+0xffff>
    8000684a:	00004517          	auipc	a0,0x4
    8000684e:	b9e50513          	addi	a0,a0,-1122 # 8000a3e8 <__rodata_start+0x1090>
    80006852:	38b000ef          	jal	ra,800073dc <log_error>
		return 0;
    80006856:	4781                	li	a5,0
    80006858:	a025                	j	80006880 <set_pwm_clock_register+0x56>
	}

	clock_value = PWM_BASE_ADDRESS + module_number*PWM_MODULE_OFFSET + CLOCK_REGISTER;
    8000685a:	47b2                	lw	a5,12(sp)
    8000685c:	3007879b          	addiw	a5,a5,768
    80006860:	2781                	sext.w	a5,a5
    80006862:	0087979b          	slliw	a5,a5,0x8
    80006866:	2781                	sext.w	a5,a5
    80006868:	27b1                	addiw	a5,a5,12
    8000686a:	2781                	sext.w	a5,a5
    8000686c:	ec3e                	sd	a5,24(sp)
	*clock_value = value;
    8000686e:	47a2                	lw	a5,8(sp)
    80006870:	0107971b          	slliw	a4,a5,0x10
    80006874:	4107571b          	sraiw	a4,a4,0x10
    80006878:	67e2                	ld	a5,24(sp)
    8000687a:	00e79023          	sh	a4,0(a5)

	return 1;
    8000687e:	4785                	li	a5,1
}
    80006880:	853e                	mv	a0,a5
    80006882:	70a2                	ld	ra,40(sp)
    80006884:	6145                	addi	sp,sp,48
    80006886:	8082                	ret

0000000080006888 <pwm_clear_registers>:
 * @brief Function to clear all registers in a specific pwm module
 * @details This function will be called to clear all registers in a specific pwm module
 * @param int module_number- specifies the pwm module to be selected
 */
void pwm_clear_registers(int module_number)
{
    80006888:	1101                	addi	sp,sp,-32
    8000688a:	ec06                	sd	ra,24(sp)
    8000688c:	87aa                	mv	a5,a0
    8000688e:	c63e                	sw	a5,12(sp)
	set_pwm_period_register(module_number, 0);
    80006890:	47b2                	lw	a5,12(sp)
    80006892:	4581                	li	a1,0
    80006894:	853e                	mv	a0,a5
    80006896:	de7ff0ef          	jal	ra,8000667c <set_pwm_period_register>
	set_pwm_duty_register(module_number, 0);
    8000689a:	47b2                	lw	a5,12(sp)
    8000689c:	4581                	li	a1,0
    8000689e:	853e                	mv	a0,a5
    800068a0:	e4bff0ef          	jal	ra,800066ea <set_pwm_duty_register>
	set_pwm_control_register(module_number, 0);
    800068a4:	47b2                	lw	a5,12(sp)
    800068a6:	4581                	li	a1,0
    800068a8:	853e                	mv	a0,a5
    800068aa:	eb3ff0ef          	jal	ra,8000675c <set_pwm_control_register>
	set_pwm_clock_register(module_number, 0);
    800068ae:	47b2                	lw	a5,12(sp)
    800068b0:	4581                	li	a1,0
    800068b2:	853e                	mv	a0,a5
    800068b4:	f77ff0ef          	jal	ra,8000682a <set_pwm_clock_register>

	log_info("\n All registers of module number %d cleared", module_number);
    800068b8:	47b2                	lw	a5,12(sp)
    800068ba:	85be                	mv	a1,a5
    800068bc:	00004517          	auipc	a0,0x4
    800068c0:	b6450513          	addi	a0,a0,-1180 # 8000a420 <__rodata_start+0x10c8>
    800068c4:	29d000ef          	jal	ra,80007360 <log_info>
}
    800068c8:	0001                	nop
    800068ca:	60e2                	ld	ra,24(sp)
    800068cc:	6105                	addi	sp,sp,32
    800068ce:	8082                	ret

00000000800068d0 <pwm_init>:
/** @fn void pwm_init
 * @brief Function to initialize all pwm modules
 * @details This function will be called to initialize all pwm modules
 */
void pwm_init(void)
{
    800068d0:	1101                	addi	sp,sp,-32
    800068d2:	ec06                	sd	ra,24(sp)
	int i;

	for (i = 0; i < 5; i++) {
    800068d4:	c602                	sw	zero,12(sp)
    800068d6:	a801                	j	800068e6 <pwm_init+0x16>
		pwm_clear_registers(i);
    800068d8:	47b2                	lw	a5,12(sp)
    800068da:	853e                	mv	a0,a5
    800068dc:	fadff0ef          	jal	ra,80006888 <pwm_clear_registers>
	for (i = 0; i < 5; i++) {
    800068e0:	47b2                	lw	a5,12(sp)
    800068e2:	2785                	addiw	a5,a5,1
    800068e4:	c63e                	sw	a5,12(sp)
    800068e6:	47b2                	lw	a5,12(sp)
    800068e8:	0007871b          	sext.w	a4,a5
    800068ec:	4791                	li	a5,4
    800068ee:	fee7d5e3          	bge	a5,a4,800068d8 <pwm_init+0x8>
	}

	log_info("\n All Register values of all modules cleared");
    800068f2:	00004517          	auipc	a0,0x4
    800068f6:	b5e50513          	addi	a0,a0,-1186 # 8000a450 <__rodata_start+0x10f8>
    800068fa:	267000ef          	jal	ra,80007360 <log_info>
}
    800068fe:	0001                	nop
    80006900:	60e2                	ld	ra,24(sp)
    80006902:	6105                	addi	sp,sp,32
    80006904:	8082                	ret

0000000080006906 <configure_control_register_mode>:
 *                1-Timer Mode run once.
 *                2-Timer Mode run continuously.)
 * @return int (returns value to be set in the control register.)
 */
int configure_control_register_mode(int mode)
{
    80006906:	7179                	addi	sp,sp,-48
    80006908:	f406                	sd	ra,40(sp)
    8000690a:	87aa                	mv	a5,a0
    8000690c:	c63e                	sw	a5,12(sp)
	int value = 0x0;
    8000690e:	ce02                	sw	zero,28(sp)

	if (mode == 0) {
    80006910:	47b2                	lw	a5,12(sp)
    80006912:	2781                	sext.w	a5,a5
    80006914:	e38d                	bnez	a5,80006936 <configure_control_register_mode+0x30>
		log_info("\n Current Module is set to PWM mode");
    80006916:	00004517          	auipc	a0,0x4
    8000691a:	b6a50513          	addi	a0,a0,-1174 # 8000a480 <__rodata_start+0x1128>
    8000691e:	243000ef          	jal	ra,80007360 <log_info>

		value += PWM_ENABLE;
    80006922:	47f2                	lw	a5,28(sp)
    80006924:	2789                	addiw	a5,a5,2
    80006926:	ce3e                	sw	a5,28(sp)
		value += PWM_START;
    80006928:	47f2                	lw	a5,28(sp)
    8000692a:	2791                	addiw	a5,a5,4
    8000692c:	ce3e                	sw	a5,28(sp)
		value += PWM_OUTPUT_ENABLE;
    8000692e:	47f2                	lw	a5,28(sp)
    80006930:	27c1                	addiw	a5,a5,16
    80006932:	ce3e                	sw	a5,28(sp)
    80006934:	a099                	j	8000697a <configure_control_register_mode+0x74>
	}
	else if (mode == 1) {
    80006936:	47b2                	lw	a5,12(sp)
    80006938:	0007871b          	sext.w	a4,a5
    8000693c:	4785                	li	a5,1
    8000693e:	00f71c63          	bne	a4,a5,80006956 <configure_control_register_mode+0x50>
		log_info("\n Current Module is set to timer once only mode");
    80006942:	00004517          	auipc	a0,0x4
    80006946:	b6650513          	addi	a0,a0,-1178 # 8000a4a8 <__rodata_start+0x1150>
    8000694a:	217000ef          	jal	ra,80007360 <log_info>

		value += PWM_START;
    8000694e:	47f2                	lw	a5,28(sp)
    80006950:	2791                	addiw	a5,a5,4
    80006952:	ce3e                	sw	a5,28(sp)
    80006954:	a01d                	j	8000697a <configure_control_register_mode+0x74>
	}
	else if(mode == 2) {
    80006956:	47b2                	lw	a5,12(sp)
    80006958:	0007871b          	sext.w	a4,a5
    8000695c:	4789                	li	a5,2
    8000695e:	00f71e63          	bne	a4,a5,8000697a <configure_control_register_mode+0x74>
		log_info("\n Current Module is set to timer continuous mode");
    80006962:	00004517          	auipc	a0,0x4
    80006966:	b7650513          	addi	a0,a0,-1162 # 8000a4d8 <__rodata_start+0x1180>
    8000696a:	1f7000ef          	jal	ra,80007360 <log_info>

		value += PWM_START;
    8000696e:	47f2                	lw	a5,28(sp)
    80006970:	2791                	addiw	a5,a5,4
    80006972:	ce3e                	sw	a5,28(sp)
		value += CONTINUOUS_ONCE;
    80006974:	47f2                	lw	a5,28(sp)
    80006976:	27a1                	addiw	a5,a5,8
    80006978:	ce3e                	sw	a5,28(sp)
	}

	return value;
    8000697a:	47f2                	lw	a5,28(sp)
}
    8000697c:	853e                	mv	a0,a5
    8000697e:	70a2                	ld	ra,40(sp)
    80006980:	6145                	addi	sp,sp,48
    80006982:	8082                	ret

0000000080006984 <pwm_start>:
 *                  0-PWM Mode
 *                  1-Timer Mode run once
 *                  2-Timer Mode run contin )
 */
void pwm_start(int module_number, int mode)
{
    80006984:	7179                	addi	sp,sp,-48
    80006986:	f406                	sd	ra,40(sp)
    80006988:	87aa                	mv	a5,a0
    8000698a:	872e                	mv	a4,a1
    8000698c:	c63e                	sw	a5,12(sp)
    8000698e:	87ba                	mv	a5,a4
    80006990:	c43e                	sw	a5,8(sp)
	int control = configure_control_register_mode(mode);
    80006992:	47a2                	lw	a5,8(sp)
    80006994:	853e                	mv	a0,a5
    80006996:	f71ff0ef          	jal	ra,80006906 <configure_control_register_mode>
    8000699a:	87aa                	mv	a5,a0
    8000699c:	ce3e                	sw	a5,28(sp)

	if(set_pwm_control_register(module_number, control))
    8000699e:	4772                	lw	a4,28(sp)
    800069a0:	47b2                	lw	a5,12(sp)
    800069a2:	85ba                	mv	a1,a4
    800069a4:	853e                	mv	a0,a5
    800069a6:	db7ff0ef          	jal	ra,8000675c <set_pwm_control_register>
    800069aa:	87aa                	mv	a5,a0
    800069ac:	cb89                	beqz	a5,800069be <pwm_start+0x3a>
	{
		log_info("\n PWM module number %d has been entered", module_number);
    800069ae:	47b2                	lw	a5,12(sp)
    800069b0:	85be                	mv	a1,a5
    800069b2:	00004517          	auipc	a0,0x4
    800069b6:	b5e50513          	addi	a0,a0,-1186 # 8000a510 <__rodata_start+0x11b8>
    800069ba:	1a7000ef          	jal	ra,80007360 <log_info>
	}

	if(!set_pwm_control_register(module_number, control))
    800069be:	4772                	lw	a4,28(sp)
    800069c0:	47b2                	lw	a5,12(sp)
    800069c2:	85ba                	mv	a1,a4
    800069c4:	853e                	mv	a0,a5
    800069c6:	d97ff0ef          	jal	ra,8000675c <set_pwm_control_register>
    800069ca:	87aa                	mv	a5,a0
    800069cc:	eb89                	bnez	a5,800069de <pwm_start+0x5a>
	{
		log_error("\n PWM module number %d not entered",module_number);
    800069ce:	47b2                	lw	a5,12(sp)
    800069d0:	85be                	mv	a1,a5
    800069d2:	00004517          	auipc	a0,0x4
    800069d6:	b6650513          	addi	a0,a0,-1178 # 8000a538 <__rodata_start+0x11e0>
    800069da:	203000ef          	jal	ra,800073dc <log_error>
	}
}
    800069de:	0001                	nop
    800069e0:	70a2                	ld	ra,40(sp)
    800069e2:	6145                	addi	sp,sp,48
    800069e4:	8082                	ret

00000000800069e6 <pwm_use_external_clock>:
 * @param int (module_number-  the pwm module to be selected )
 * @param int (value -true or 1  - External Clock 
 *                    false or 0 - Internal Clock )
 */
void pwm_use_external_clock(int module_number, bool value)
{
    800069e6:	1101                	addi	sp,sp,-32
    800069e8:	87aa                	mv	a5,a0
    800069ea:	872e                	mv	a4,a1
    800069ec:	c63e                	sw	a5,12(sp)
    800069ee:	87ba                	mv	a5,a4
    800069f0:	00f105a3          	sb	a5,11(sp)
	unsigned char* control_value;
	control_value = PWM_BASE_ADDRESS + module_number * PWM_MODULE_OFFSET + CONTROL_REGISTER;
    800069f4:	47b2                	lw	a5,12(sp)
    800069f6:	3007879b          	addiw	a5,a5,768
    800069fa:	2781                	sext.w	a5,a5
    800069fc:	0087979b          	slliw	a5,a5,0x8
    80006a00:	2781                	sext.w	a5,a5
    80006a02:	27a1                	addiw	a5,a5,8
    80006a04:	2781                	sext.w	a5,a5
    80006a06:	ec3e                	sd	a5,24(sp)
	if(value == 1)
    80006a08:	00b14783          	lbu	a5,11(sp)
    80006a0c:	0ff7f793          	andi	a5,a5,255
    80006a10:	c789                	beqz	a5,80006a1a <pwm_use_external_clock+0x34>
	control_value += CLOCK_SELECTOR;
    80006a12:	67e2                	ld	a5,24(sp)
    80006a14:	0785                	addi	a5,a5,1
    80006a16:	ec3e                	sd	a5,24(sp)
	else if(control_value && CLOCK_SELECTOR)
	control_value -= CLOCK_SELECTOR;	
}
    80006a18:	a031                	j	80006a24 <pwm_use_external_clock+0x3e>
	else if(control_value && CLOCK_SELECTOR)
    80006a1a:	67e2                	ld	a5,24(sp)
    80006a1c:	c781                	beqz	a5,80006a24 <pwm_use_external_clock+0x3e>
	control_value -= CLOCK_SELECTOR;	
    80006a1e:	67e2                	ld	a5,24(sp)
    80006a20:	17fd                	addi	a5,a5,-1
    80006a22:	ec3e                	sd	a5,24(sp)
}
    80006a24:	0001                	nop
    80006a26:	6105                	addi	sp,sp,32
    80006a28:	8082                	ret

0000000080006a2a <pwm_set_clock>:
 * @details This function will set the clock divisor value of a specific pwm module
 * @param int module_number-  the pwm module to be selected
              int clock_divisor- value of clock divisor to be used to divide base clock speed of 50MHz.
 */
void pwm_set_clock(int module_number, int clock_divisor)
{
    80006a2a:	1101                	addi	sp,sp,-32
    80006a2c:	ec06                	sd	ra,24(sp)
    80006a2e:	87aa                	mv	a5,a0
    80006a30:	872e                	mv	a4,a1
    80006a32:	c63e                	sw	a5,12(sp)
    80006a34:	87ba                	mv	a5,a4
    80006a36:	c43e                	sw	a5,8(sp)
	if (set_pwm_clock_register(module_number, clock_divisor) == 0)
    80006a38:	4722                	lw	a4,8(sp)
    80006a3a:	47b2                	lw	a5,12(sp)
    80006a3c:	85ba                	mv	a1,a4
    80006a3e:	853e                	mv	a0,a5
    80006a40:	debff0ef          	jal	ra,8000682a <set_pwm_clock_register>
    80006a44:	87aa                	mv	a5,a0
    80006a46:	e799                	bnez	a5,80006a54 <pwm_set_clock+0x2a>
	{
		log_error("\n Error in setting clock register");
    80006a48:	00004517          	auipc	a0,0x4
    80006a4c:	b1850513          	addi	a0,a0,-1256 # 8000a560 <__rodata_start+0x1208>
    80006a50:	18d000ef          	jal	ra,800073dc <log_error>
	}
}
    80006a54:	0001                	nop
    80006a56:	60e2                	ld	ra,24(sp)
    80006a58:	6105                	addi	sp,sp,32
    80006a5a:	8082                	ret

0000000080006a5c <pwm_set_duty_cycle>:
 * @details This function will set the duty cycles value of a specific pwm module
 * @param int module_number-  the pwm module to be selected 
 * @param int duty - value of duty cycles to be used to decide how many period cycles the pwm signal is set to 1.
 */
void pwm_set_duty_cycle(int module_number, int duty)
{
    80006a5c:	1101                	addi	sp,sp,-32
    80006a5e:	ec06                	sd	ra,24(sp)
    80006a60:	87aa                	mv	a5,a0
    80006a62:	872e                	mv	a4,a1
    80006a64:	c63e                	sw	a5,12(sp)
    80006a66:	87ba                	mv	a5,a4
    80006a68:	c43e                	sw	a5,8(sp)
	if (set_pwm_duty_register(module_number, duty) == 0) {
    80006a6a:	4722                	lw	a4,8(sp)
    80006a6c:	47b2                	lw	a5,12(sp)
    80006a6e:	85ba                	mv	a1,a4
    80006a70:	853e                	mv	a0,a5
    80006a72:	c79ff0ef          	jal	ra,800066ea <set_pwm_duty_register>
    80006a76:	87aa                	mv	a5,a0
    80006a78:	e799                	bnez	a5,80006a86 <pwm_set_duty_cycle+0x2a>
		log_error("\n Error in setting duty register");
    80006a7a:	00004517          	auipc	a0,0x4
    80006a7e:	b0e50513          	addi	a0,a0,-1266 # 8000a588 <__rodata_start+0x1230>
    80006a82:	15b000ef          	jal	ra,800073dc <log_error>
	}
}
    80006a86:	0001                	nop
    80006a88:	60e2                	ld	ra,24(sp)
    80006a8a:	6105                	addi	sp,sp,32
    80006a8c:	8082                	ret

0000000080006a8e <pwm_set_periodic_cycle>:
 * @param int module_number-  the pwm module to be selected
 * @param int clock_divisor-  value of period cycles which is used to further divide the                                                      
 *         frequency into fixed period cycles.
 */
void pwm_set_periodic_cycle(int module_number, int period)
{
    80006a8e:	1101                	addi	sp,sp,-32
    80006a90:	ec06                	sd	ra,24(sp)
    80006a92:	87aa                	mv	a5,a0
    80006a94:	872e                	mv	a4,a1
    80006a96:	c63e                	sw	a5,12(sp)
    80006a98:	87ba                	mv	a5,a4
    80006a9a:	c43e                	sw	a5,8(sp)
	if(set_pwm_period_register(module_number, period) == 0) {
    80006a9c:	4722                	lw	a4,8(sp)
    80006a9e:	47b2                	lw	a5,12(sp)
    80006aa0:	85ba                	mv	a1,a4
    80006aa2:	853e                	mv	a0,a5
    80006aa4:	bd9ff0ef          	jal	ra,8000667c <set_pwm_period_register>
    80006aa8:	87aa                	mv	a5,a0
    80006aaa:	e799                	bnez	a5,80006ab8 <pwm_set_periodic_cycle+0x2a>
		log_error("\n Error in setting period register");
    80006aac:	00004517          	auipc	a0,0x4
    80006ab0:	b0450513          	addi	a0,a0,-1276 # 8000a5b0 <__rodata_start+0x1258>
    80006ab4:	129000ef          	jal	ra,800073dc <log_error>
	}
}
    80006ab8:	0001                	nop
    80006aba:	60e2                	ld	ra,24(sp)
    80006abc:	6105                	addi	sp,sp,32
    80006abe:	8082                	ret

0000000080006ac0 <pwm_configure>:
 * @param int period - value of periodic cycle to be used. the signal resets after every count of the periodic cycle
 * @param int duty_cycle - value of duty cycle. It specifies how many cycles the signal is active out of the periodic cycle
 * @param bool external_clock - value of external clock selector. It specifies if external clock is to be used.
  */
void pwm_configure(int module_number,int clock_divisor, int period, int duty, bool external_clock)
{
    80006ac0:	7179                	addi	sp,sp,-48
    80006ac2:	f406                	sd	ra,40(sp)
    80006ac4:	87aa                	mv	a5,a0
    80006ac6:	ce3e                	sw	a5,28(sp)
    80006ac8:	87ae                	mv	a5,a1
    80006aca:	cc3e                	sw	a5,24(sp)
    80006acc:	87b2                	mv	a5,a2
    80006ace:	ca3e                	sw	a5,20(sp)
    80006ad0:	87b6                	mv	a5,a3
    80006ad2:	c83e                	sw	a5,16(sp)
    80006ad4:	87ba                	mv	a5,a4
    80006ad6:	00f107a3          	sb	a5,15(sp)
	pwm_set_periodic_cycle(module_number, period);
    80006ada:	4752                	lw	a4,20(sp)
    80006adc:	47f2                	lw	a5,28(sp)
    80006ade:	85ba                	mv	a1,a4
    80006ae0:	853e                	mv	a0,a5
    80006ae2:	fadff0ef          	jal	ra,80006a8e <pwm_set_periodic_cycle>
	pwm_set_duty_cycle(module_number, duty);
    80006ae6:	4742                	lw	a4,16(sp)
    80006ae8:	47f2                	lw	a5,28(sp)
    80006aea:	85ba                	mv	a1,a4
    80006aec:	853e                	mv	a0,a5
    80006aee:	f6fff0ef          	jal	ra,80006a5c <pwm_set_duty_cycle>
	pwm_set_clock(module_number, clock_divisor);
    80006af2:	4762                	lw	a4,24(sp)
    80006af4:	47f2                	lw	a5,28(sp)
    80006af6:	85ba                	mv	a1,a4
    80006af8:	853e                	mv	a0,a5
    80006afa:	f31ff0ef          	jal	ra,80006a2a <pwm_set_clock>
	pwm_use_external_clock(module_number, external_clock);
    80006afe:	00f14703          	lbu	a4,15(sp)
    80006b02:	47f2                	lw	a5,28(sp)
    80006b04:	85ba                	mv	a1,a4
    80006b06:	853e                	mv	a0,a5
    80006b08:	edfff0ef          	jal	ra,800069e6 <pwm_use_external_clock>
	log_info("PWM %d succesfully configured",module_number);
    80006b0c:	47f2                	lw	a5,28(sp)
    80006b0e:	85be                	mv	a1,a5
    80006b10:	00004517          	auipc	a0,0x4
    80006b14:	ac850513          	addi	a0,a0,-1336 # 8000a5d8 <__rodata_start+0x1280>
    80006b18:	049000ef          	jal	ra,80007360 <log_info>
}
    80006b1c:	0001                	nop
    80006b1e:	70a2                	ld	ra,40(sp)
    80006b20:	6145                	addi	sp,sp,48
    80006b22:	8082                	ret

0000000080006b24 <pwm_stop>:
 * @brief Function to stop a specific pwm module
 * @details This function will stop a specific pwm module
 * @param int module_number-  the pwm module to be selected
 */
void pwm_stop(int module_number)
{
    80006b24:	1101                	addi	sp,sp,-32
    80006b26:	ec06                	sd	ra,24(sp)
    80006b28:	87aa                	mv	a5,a0
    80006b2a:	c63e                	sw	a5,12(sp)
	set_pwm_control_register(module_number, 0x0);
    80006b2c:	47b2                	lw	a5,12(sp)
    80006b2e:	4581                	li	a1,0
    80006b30:	853e                	mv	a0,a5
    80006b32:	c2bff0ef          	jal	ra,8000675c <set_pwm_control_register>
	log_info("\n PWM module number %d has been stopped", module_number);
    80006b36:	47b2                	lw	a5,12(sp)
    80006b38:	85be                	mv	a1,a5
    80006b3a:	00004517          	auipc	a0,0x4
    80006b3e:	abe50513          	addi	a0,a0,-1346 # 8000a5f8 <__rodata_start+0x12a0>
    80006b42:	01f000ef          	jal	ra,80007360 <log_info>
}
    80006b46:	0001                	nop
    80006b48:	60e2                	ld	ra,24(sp)
    80006b4a:	6105                	addi	sp,sp,32
    80006b4c:	8082                	ret

0000000080006b4e <show_register_values>:
 * @brief Function to print the values of all the registers of a specific pwm module
 * @details This function will print the values of all the registers of a specific pwm module
 * @param int module_number-  the pwm module to be selected
 */
void show_register_values(int module_number)
{
    80006b4e:	7139                	addi	sp,sp,-64
    80006b50:	fc06                	sd	ra,56(sp)
    80006b52:	87aa                	mv	a5,a0
    80006b54:	c63e                	sw	a5,12(sp)
	volatile unsigned short* period_value;
	volatile unsigned short* duty_value;
	volatile unsigned char*  control_value;
	volatile unsigned short* clock_value;

	period_value = PWM_BASE_ADDRESS + module_number * PWM_MODULE_OFFSET + PERIOD_REGISTER;
    80006b56:	47b2                	lw	a5,12(sp)
    80006b58:	3007879b          	addiw	a5,a5,768
    80006b5c:	2781                	sext.w	a5,a5
    80006b5e:	0087979b          	slliw	a5,a5,0x8
    80006b62:	2781                	sext.w	a5,a5
    80006b64:	f43e                	sd	a5,40(sp)
	duty_value = PWM_BASE_ADDRESS + module_number * PWM_MODULE_OFFSET + DUTY_REGISTER;
    80006b66:	47b2                	lw	a5,12(sp)
    80006b68:	3007879b          	addiw	a5,a5,768
    80006b6c:	2781                	sext.w	a5,a5
    80006b6e:	0087979b          	slliw	a5,a5,0x8
    80006b72:	2781                	sext.w	a5,a5
    80006b74:	2791                	addiw	a5,a5,4
    80006b76:	2781                	sext.w	a5,a5
    80006b78:	f03e                	sd	a5,32(sp)
	control_value = PWM_BASE_ADDRESS + module_number * PWM_MODULE_OFFSET + CONTROL_REGISTER;
    80006b7a:	47b2                	lw	a5,12(sp)
    80006b7c:	3007879b          	addiw	a5,a5,768
    80006b80:	2781                	sext.w	a5,a5
    80006b82:	0087979b          	slliw	a5,a5,0x8
    80006b86:	2781                	sext.w	a5,a5
    80006b88:	27a1                	addiw	a5,a5,8
    80006b8a:	2781                	sext.w	a5,a5
    80006b8c:	ec3e                	sd	a5,24(sp)
	clock_value = PWM_BASE_ADDRESS + module_number * PWM_MODULE_OFFSET + CLOCK_REGISTER;
    80006b8e:	47b2                	lw	a5,12(sp)
    80006b90:	3007879b          	addiw	a5,a5,768
    80006b94:	2781                	sext.w	a5,a5
    80006b96:	0087979b          	slliw	a5,a5,0x8
    80006b9a:	2781                	sext.w	a5,a5
    80006b9c:	27b1                	addiw	a5,a5,12
    80006b9e:	2781                	sext.w	a5,a5
    80006ba0:	e83e                	sd	a5,16(sp)

	log_info("\nThe value of period register is %x",  *period_value);
    80006ba2:	77a2                	ld	a5,40(sp)
    80006ba4:	0007d783          	lhu	a5,0(a5)
    80006ba8:	17c2                	slli	a5,a5,0x30
    80006baa:	93c1                	srli	a5,a5,0x30
    80006bac:	2781                	sext.w	a5,a5
    80006bae:	85be                	mv	a1,a5
    80006bb0:	00004517          	auipc	a0,0x4
    80006bb4:	a7050513          	addi	a0,a0,-1424 # 8000a620 <__rodata_start+0x12c8>
    80006bb8:	7a8000ef          	jal	ra,80007360 <log_info>
	log_info("\nThe value of duty register is %x",    *duty_value);
    80006bbc:	7782                	ld	a5,32(sp)
    80006bbe:	0007d783          	lhu	a5,0(a5)
    80006bc2:	17c2                	slli	a5,a5,0x30
    80006bc4:	93c1                	srli	a5,a5,0x30
    80006bc6:	2781                	sext.w	a5,a5
    80006bc8:	85be                	mv	a1,a5
    80006bca:	00004517          	auipc	a0,0x4
    80006bce:	a7e50513          	addi	a0,a0,-1410 # 8000a648 <__rodata_start+0x12f0>
    80006bd2:	78e000ef          	jal	ra,80007360 <log_info>
	log_info("\nThe value of control register is %x", *control_value);
    80006bd6:	67e2                	ld	a5,24(sp)
    80006bd8:	0007c783          	lbu	a5,0(a5)
    80006bdc:	0ff7f793          	andi	a5,a5,255
    80006be0:	2781                	sext.w	a5,a5
    80006be2:	85be                	mv	a1,a5
    80006be4:	00004517          	auipc	a0,0x4
    80006be8:	a8c50513          	addi	a0,a0,-1396 # 8000a670 <__rodata_start+0x1318>
    80006bec:	774000ef          	jal	ra,80007360 <log_info>
	log_info("\nThe value of clock register is %x",   *clock_value);
    80006bf0:	67c2                	ld	a5,16(sp)
    80006bf2:	0007d783          	lhu	a5,0(a5)
    80006bf6:	17c2                	slli	a5,a5,0x30
    80006bf8:	93c1                	srli	a5,a5,0x30
    80006bfa:	2781                	sext.w	a5,a5
    80006bfc:	85be                	mv	a1,a5
    80006bfe:	00004517          	auipc	a0,0x4
    80006c02:	a9a50513          	addi	a0,a0,-1382 # 8000a698 <__rodata_start+0x1340>
    80006c06:	75a000ef          	jal	ra,80007360 <log_info>
}
    80006c0a:	0001                	nop
    80006c0c:	70e2                	ld	ra,56(sp)
    80006c0e:	6121                	addi	sp,sp,64
    80006c10:	8082                	ret

0000000080006c12 <waitfor>:
/** @fn  void waitfor(unsigned int secs)
 * @brief stall the process for given time
 * @param unsigned int secs
 */
void waitfor(unsigned int secs)
{
    80006c12:	1101                	addi	sp,sp,-32
    80006c14:	87aa                	mv	a5,a0
    80006c16:	c63e                	sw	a5,12(sp)
	unsigned int time = 0;
    80006c18:	ce02                	sw	zero,28(sp)
	while (time++ < secs);
    80006c1a:	0001                	nop
    80006c1c:	47f2                	lw	a5,28(sp)
    80006c1e:	0017871b          	addiw	a4,a5,1
    80006c22:	ce3a                	sw	a4,28(sp)
    80006c24:	4732                	lw	a4,12(sp)
    80006c26:	2701                	sext.w	a4,a4
    80006c28:	fee7eae3          	bltu	a5,a4,80006c1c <waitfor+0xa>
}
    80006c2c:	0001                	nop
    80006c2e:	0001                	nop
    80006c30:	6105                	addi	sp,sp,32
    80006c32:	8082                	ret

0000000080006c34 <delay>:
/** @fn void delay(unsigned long seconds)
 * @brief  sleeps for number seconds  
 * @param unsigned long (number of seconds) 
 */
void delay(unsigned long seconds)
{
    80006c34:	1101                	addi	sp,sp,-32
    80006c36:	e42a                	sd	a0,8(sp)
	unsigned long cntr1 = seconds *1000;
    80006c38:	6722                	ld	a4,8(sp)
    80006c3a:	3e800793          	li	a5,1000
    80006c3e:	02f707b3          	mul	a5,a4,a5
    80006c42:	ec3e                	sd	a5,24(sp)
	unsigned long tmpCntr;

	while (cntr1--) {
    80006c44:	a811                	j	80006c58 <delay+0x24>
		tmpCntr = 1000;
    80006c46:	3e800793          	li	a5,1000
    80006c4a:	e83e                	sd	a5,16(sp)
		while (tmpCntr--);
    80006c4c:	0001                	nop
    80006c4e:	67c2                	ld	a5,16(sp)
    80006c50:	fff78713          	addi	a4,a5,-1
    80006c54:	e83a                	sd	a4,16(sp)
    80006c56:	ffe5                	bnez	a5,80006c4e <delay+0x1a>
	while (cntr1--) {
    80006c58:	67e2                	ld	a5,24(sp)
    80006c5a:	fff78713          	addi	a4,a5,-1
    80006c5e:	ec3a                	sd	a4,24(sp)
    80006c60:	f3fd                	bnez	a5,80006c46 <delay+0x12>
	}
}
    80006c62:	0001                	nop
    80006c64:	0001                	nop
    80006c66:	6105                	addi	sp,sp,32
    80006c68:	8082                	ret

0000000080006c6a <pow_10>:
 * @brief generate different powers of 10 
 * @param unsigned int y
 * @return return result in float 
 */
float pow_10(unsigned int y)
{
    80006c6a:	7179                	addi	sp,sp,-48
    80006c6c:	f406                	sd	ra,40(sp)
    80006c6e:	87aa                	mv	a5,a0
    80006c70:	c63e                	sw	a5,12(sp)
	unsigned int x=1;
    80006c72:	4785                	li	a5,1
    80006c74:	ce3e                	sw	a5,28(sp)

	for (unsigned int i=0; i <y; i++)
    80006c76:	cc02                	sw	zero,24(sp)
    80006c78:	a821                	j	80006c90 <pow_10+0x26>
	{
		x *= 10;
    80006c7a:	4772                	lw	a4,28(sp)
    80006c7c:	87ba                	mv	a5,a4
    80006c7e:	0027979b          	slliw	a5,a5,0x2
    80006c82:	9fb9                	addw	a5,a5,a4
    80006c84:	0017979b          	slliw	a5,a5,0x1
    80006c88:	ce3e                	sw	a5,28(sp)
	for (unsigned int i=0; i <y; i++)
    80006c8a:	47e2                	lw	a5,24(sp)
    80006c8c:	2785                	addiw	a5,a5,1
    80006c8e:	cc3e                	sw	a5,24(sp)
    80006c90:	4762                	lw	a4,24(sp)
    80006c92:	47b2                	lw	a5,12(sp)
    80006c94:	2701                	sext.w	a4,a4
    80006c96:	2781                	sext.w	a5,a5
    80006c98:	fef761e3          	bltu	a4,a5,80006c7a <pow_10+0x10>
	}

	return ((float) x);
    80006c9c:	47f2                	lw	a5,28(sp)
    80006c9e:	853e                	mv	a0,a5
    80006ca0:	4ba020ef          	jal	ra,8000915a <__floatunsisf>
    80006ca4:	87aa                	mv	a5,a0
}
    80006ca6:	853e                	mv	a0,a5
    80006ca8:	70a2                	ld	ra,40(sp)
    80006caa:	6145                	addi	sp,sp,48
    80006cac:	8082                	ret

0000000080006cae <reverse>:
 * @brief reverse a string and store in the same string
 * @param char *str
 * @param int length
 */
void reverse(char *str, int length) 
{ 
    80006cae:	1101                	addi	sp,sp,-32
    80006cb0:	e42a                	sd	a0,8(sp)
    80006cb2:	87ae                	mv	a5,a1
    80006cb4:	c23e                	sw	a5,4(sp)
	int i = 0;
    80006cb6:	ce02                	sw	zero,28(sp)
	int j = length - 1;
    80006cb8:	4792                	lw	a5,4(sp)
    80006cba:	37fd                	addiw	a5,a5,-1
    80006cbc:	cc3e                	sw	a5,24(sp)
	char tmp;

	while (i<j) 
    80006cbe:	a83d                	j	80006cfc <reverse+0x4e>
	{ 
		tmp = str[i]; 
    80006cc0:	47f2                	lw	a5,28(sp)
    80006cc2:	6722                	ld	a4,8(sp)
    80006cc4:	97ba                	add	a5,a5,a4
    80006cc6:	0007c783          	lbu	a5,0(a5)
    80006cca:	00f10ba3          	sb	a5,23(sp)
		str[i] = str[j]; 
    80006cce:	47e2                	lw	a5,24(sp)
    80006cd0:	6722                	ld	a4,8(sp)
    80006cd2:	973e                	add	a4,a4,a5
    80006cd4:	47f2                	lw	a5,28(sp)
    80006cd6:	66a2                	ld	a3,8(sp)
    80006cd8:	97b6                	add	a5,a5,a3
    80006cda:	00074703          	lbu	a4,0(a4)
    80006cde:	00e78023          	sb	a4,0(a5)
		str[j] = tmp; 
    80006ce2:	47e2                	lw	a5,24(sp)
    80006ce4:	6722                	ld	a4,8(sp)
    80006ce6:	97ba                	add	a5,a5,a4
    80006ce8:	01714703          	lbu	a4,23(sp)
    80006cec:	00e78023          	sb	a4,0(a5)

		i++;
    80006cf0:	47f2                	lw	a5,28(sp)
    80006cf2:	2785                	addiw	a5,a5,1
    80006cf4:	ce3e                	sw	a5,28(sp)
		j--; 
    80006cf6:	47e2                	lw	a5,24(sp)
    80006cf8:	37fd                	addiw	a5,a5,-1
    80006cfa:	cc3e                	sw	a5,24(sp)
	while (i<j) 
    80006cfc:	4772                	lw	a4,28(sp)
    80006cfe:	47e2                	lw	a5,24(sp)
    80006d00:	2701                	sext.w	a4,a4
    80006d02:	2781                	sext.w	a5,a5
    80006d04:	faf74ee3          	blt	a4,a5,80006cc0 <reverse+0x12>
	} 
} 
    80006d08:	0001                	nop
    80006d0a:	0001                	nop
    80006d0c:	6105                	addi	sp,sp,32
    80006d0e:	8082                	ret

0000000080006d10 <int_to_string>:
 * @param char str[]
 * @param int afterpoint
 * @return int
 */
int int_to_string(int number, char str[], unsigned int afterpoint) 
{
    80006d10:	7179                	addi	sp,sp,-48
    80006d12:	f406                	sd	ra,40(sp)
    80006d14:	87aa                	mv	a5,a0
    80006d16:	e02e                	sd	a1,0(sp)
    80006d18:	8732                	mv	a4,a2
    80006d1a:	c63e                	sw	a5,12(sp)
    80006d1c:	87ba                	mv	a5,a4
    80006d1e:	c43e                	sw	a5,8(sp)
	uint32_t i = 0; 
    80006d20:	ce02                	sw	zero,28(sp)

	/*extract each digit and put into str[i]*/

	while (number != 0) 
    80006d22:	a815                	j	80006d56 <int_to_string+0x46>
	{
		str[i] = ((number%10) + '0');
    80006d24:	4732                	lw	a4,12(sp)
    80006d26:	47a9                	li	a5,10
    80006d28:	02f767bb          	remw	a5,a4,a5
    80006d2c:	2781                	sext.w	a5,a5
    80006d2e:	0ff7f713          	andi	a4,a5,255
    80006d32:	01c16783          	lwu	a5,28(sp)
    80006d36:	6682                	ld	a3,0(sp)
    80006d38:	97b6                	add	a5,a5,a3
    80006d3a:	0307071b          	addiw	a4,a4,48
    80006d3e:	0ff77713          	andi	a4,a4,255
    80006d42:	00e78023          	sb	a4,0(a5)
		i++;
    80006d46:	47f2                	lw	a5,28(sp)
    80006d48:	2785                	addiw	a5,a5,1
    80006d4a:	ce3e                	sw	a5,28(sp)
		number = number/10;
    80006d4c:	4732                	lw	a4,12(sp)
    80006d4e:	47a9                	li	a5,10
    80006d50:	02f747bb          	divw	a5,a4,a5
    80006d54:	c63e                	sw	a5,12(sp)
	while (number != 0) 
    80006d56:	47b2                	lw	a5,12(sp)
    80006d58:	2781                	sext.w	a5,a5
    80006d5a:	f7e9                	bnez	a5,80006d24 <int_to_string+0x14>
	}

	/*insert 0 after the numbers, if count of digits less than afterpoint*/

	while (i < afterpoint) 
    80006d5c:	a821                	j	80006d74 <int_to_string+0x64>
	{
		str[i] = '0'; 
    80006d5e:	01c16783          	lwu	a5,28(sp)
    80006d62:	6702                	ld	a4,0(sp)
    80006d64:	97ba                	add	a5,a5,a4
    80006d66:	03000713          	li	a4,48
    80006d6a:	00e78023          	sb	a4,0(a5)
		i++;
    80006d6e:	47f2                	lw	a5,28(sp)
    80006d70:	2785                	addiw	a5,a5,1
    80006d72:	ce3e                	sw	a5,28(sp)
	while (i < afterpoint) 
    80006d74:	4772                	lw	a4,28(sp)
    80006d76:	47a2                	lw	a5,8(sp)
    80006d78:	2701                	sext.w	a4,a4
    80006d7a:	2781                	sext.w	a5,a5
    80006d7c:	fef761e3          	bltu	a4,a5,80006d5e <int_to_string+0x4e>

	/*
	   zeroth digit is in oth position in array,
	   To read digits properly, reverse array
	 */
	reverse(str, i); 
    80006d80:	47f2                	lw	a5,28(sp)
    80006d82:	85be                	mv	a1,a5
    80006d84:	6502                	ld	a0,0(sp)
    80006d86:	f29ff0ef          	jal	ra,80006cae <reverse>
	str[i] = '\0'; 
    80006d8a:	01c16783          	lwu	a5,28(sp)
    80006d8e:	6702                	ld	a4,0(sp)
    80006d90:	97ba                	add	a5,a5,a4
    80006d92:	00078023          	sb	zero,0(a5)

	return i; 
    80006d96:	47f2                	lw	a5,28(sp)
}
    80006d98:	853e                	mv	a0,a5
    80006d9a:	70a2                	ld	ra,40(sp)
    80006d9c:	6145                	addi	sp,sp,48
    80006d9e:	8082                	ret

0000000080006da0 <ftoa>:
 * @param float (floating point number - n)
 * @param char* (float in string - res)
 * @param int (precision - afterpoint)
 */
void ftoa(float n, char *res, unsigned int afterpoint) 
{
    80006da0:	715d                	addi	sp,sp,-80
    80006da2:	e486                	sd	ra,72(sp)
    80006da4:	c62a                	sw	a0,12(sp)
    80006da6:	e02e                	sd	a1,0(sp)
    80006da8:	87b2                	mv	a5,a2
    80006daa:	c43e                	sw	a5,8(sp)
	int i=0;
    80006dac:	de02                	sw	zero,60(sp)
	char temp[30]={'\0'};
    80006dae:	e802                	sd	zero,16(sp)
    80006db0:	ec02                	sd	zero,24(sp)
    80006db2:	f002                	sd	zero,32(sp)
    80006db4:	d402                	sw	zero,40(sp)
    80006db6:	02011623          	sh	zero,44(sp)
	n += 0.0000001;
    80006dba:	4532                	lw	a0,12(sp)
    80006dbc:	452020ef          	jal	ra,8000920e <__extendsfdf2>
    80006dc0:	872a                	mv	a4,a0
    80006dc2:	00004797          	auipc	a5,0x4
    80006dc6:	91678793          	addi	a5,a5,-1770 # 8000a6d8 <__rodata_start+0x1380>
    80006dca:	638c                	ld	a1,0(a5)
    80006dcc:	853a                	mv	a0,a4
    80006dce:	0e3010ef          	jal	ra,800086b0 <__adddf3>
    80006dd2:	87aa                	mv	a5,a0
    80006dd4:	853e                	mv	a0,a5
    80006dd6:	4a6020ef          	jal	ra,8000927c <__truncdfsf2>
    80006dda:	87aa                	mv	a5,a0
    80006ddc:	c63e                	sw	a5,12(sp)

	// Extract integer part 
	int ipart = (int)n; 
    80006dde:	4532                	lw	a0,12(sp)
    80006de0:	240020ef          	jal	ra,80009020 <__fixsfsi>
    80006de4:	87aa                	mv	a5,a0
    80006de6:	dc3e                	sw	a5,56(sp)

	// Extract floating part 
	float fpart = (float) (n - (float)ipart); 
    80006de8:	57e2                	lw	a5,56(sp)
    80006dea:	853e                	mv	a0,a5
    80006dec:	2a0020ef          	jal	ra,8000908c <__floatsisf>
    80006df0:	87aa                	mv	a5,a0
    80006df2:	85be                	mv	a1,a5
    80006df4:	4532                	lw	a0,12(sp)
    80006df6:	6cd010ef          	jal	ra,80008cc2 <__subsf3>
    80006dfa:	87aa                	mv	a5,a0
    80006dfc:	da3e                	sw	a5,52(sp)
	int j=0;
    80006dfe:	d802                	sw	zero,48(sp)

	if(n < (0/1))
    80006e00:	00000593          	li	a1,0
    80006e04:	4532                	lw	a0,12(sp)
    80006e06:	44b010ef          	jal	ra,80008a50 <__lesf2>
    80006e0a:	87aa                	mv	a5,a0
    80006e0c:	0007db63          	bgez	a5,80006e22 <ftoa+0x82>
	{
		res[j]='-';
    80006e10:	57c2                	lw	a5,48(sp)
    80006e12:	6702                	ld	a4,0(sp)
    80006e14:	97ba                	add	a5,a5,a4
    80006e16:	02d00713          	li	a4,45
    80006e1a:	00e78023          	sb	a4,0(a5)
		j=1;
    80006e1e:	4785                	li	a5,1
    80006e20:	d83e                	sw	a5,48(sp)
	}

	if (ipart == 0)
    80006e22:	57e2                	lw	a5,56(sp)
    80006e24:	2781                	sext.w	a5,a5
    80006e26:	ef81                	bnez	a5,80006e3e <ftoa+0x9e>
	{
		res[j]='0';
    80006e28:	57c2                	lw	a5,48(sp)
    80006e2a:	6702                	ld	a4,0(sp)
    80006e2c:	97ba                	add	a5,a5,a4
    80006e2e:	03000713          	li	a4,48
    80006e32:	00e78023          	sb	a4,0(a5)
		j=j+1;
    80006e36:	57c2                	lw	a5,48(sp)
    80006e38:	2785                	addiw	a5,a5,1
    80006e3a:	d83e                	sw	a5,48(sp)
    80006e3c:	a815                	j	80006e70 <ftoa+0xd0>
	}
	else{
		if (ipart <0)
    80006e3e:	57e2                	lw	a5,56(sp)
    80006e40:	2781                	sext.w	a5,a5
    80006e42:	0007d663          	bgez	a5,80006e4e <ftoa+0xae>
		{
			ipart =(-1)*ipart;
    80006e46:	57e2                	lw	a5,56(sp)
    80006e48:	40f007bb          	negw	a5,a5
    80006e4c:	dc3e                	sw	a5,56(sp)
		}

		i = int_to_string(ipart, temp, 0); 
    80006e4e:	0818                	addi	a4,sp,16
    80006e50:	57e2                	lw	a5,56(sp)
    80006e52:	4601                	li	a2,0
    80006e54:	85ba                	mv	a1,a4
    80006e56:	853e                	mv	a0,a5
    80006e58:	eb9ff0ef          	jal	ra,80006d10 <int_to_string>
    80006e5c:	87aa                	mv	a5,a0
    80006e5e:	de3e                	sw	a5,60(sp)

		strcpy(res+j,temp);
    80006e60:	57c2                	lw	a5,48(sp)
    80006e62:	6702                	ld	a4,0(sp)
    80006e64:	97ba                	add	a5,a5,a4
    80006e66:	0818                	addi	a4,sp,16
    80006e68:	85ba                	mv	a1,a4
    80006e6a:	853e                	mv	a0,a5
    80006e6c:	774010ef          	jal	ra,800085e0 <strcpy>
	}

	i = i+j;
    80006e70:	5772                	lw	a4,60(sp)
    80006e72:	57c2                	lw	a5,48(sp)
    80006e74:	9fb9                	addw	a5,a5,a4
    80006e76:	de3e                	sw	a5,60(sp)

	// check for display option after point 
	if (afterpoint != 0) 
    80006e78:	47a2                	lw	a5,8(sp)
    80006e7a:	2781                	sext.w	a5,a5
    80006e7c:	c7b5                	beqz	a5,80006ee8 <ftoa+0x148>
	{ 
		res[i] = '.'; // add dot 
    80006e7e:	57f2                	lw	a5,60(sp)
    80006e80:	6702                	ld	a4,0(sp)
    80006e82:	97ba                	add	a5,a5,a4
    80006e84:	02e00713          	li	a4,46
    80006e88:	00e78023          	sb	a4,0(a5)

		if (fpart < 0/1)
    80006e8c:	00000593          	li	a1,0
    80006e90:	5552                	lw	a0,52(sp)
    80006e92:	3bf010ef          	jal	ra,80008a50 <__lesf2>
    80006e96:	87aa                	mv	a5,a0
    80006e98:	0007d863          	bgez	a5,80006ea8 <ftoa+0x108>
		{

			fpart = (-1)*fpart;
    80006e9c:	5752                	lw	a4,52(sp)
    80006e9e:	800007b7          	lui	a5,0x80000
    80006ea2:	8fb9                	xor	a5,a5,a4
    80006ea4:	da3e                	sw	a5,52(sp)
    80006ea6:	a031                	j	80006eb2 <ftoa+0x112>

		}
		else if (fpart == 0/1)
    80006ea8:	00000593          	li	a1,0
    80006eac:	5552                	lw	a0,52(sp)
    80006eae:	345010ef          	jal	ra,800089f2 <__eqsf2>
		{
			fpart = fpart;
		}

		fpart = fpart * pow_10( afterpoint); 
    80006eb2:	47a2                	lw	a5,8(sp)
    80006eb4:	853e                	mv	a0,a5
    80006eb6:	db5ff0ef          	jal	ra,80006c6a <pow_10>
    80006eba:	87aa                	mv	a5,a0
    80006ebc:	85be                	mv	a1,a5
    80006ebe:	5552                	lw	a0,52(sp)
    80006ec0:	415010ef          	jal	ra,80008ad4 <__mulsf3>
    80006ec4:	87aa                	mv	a5,a0
    80006ec6:	da3e                	sw	a5,52(sp)

		int_to_string((int)fpart, res + i + 1, afterpoint); 
    80006ec8:	5552                	lw	a0,52(sp)
    80006eca:	156020ef          	jal	ra,80009020 <__fixsfsi>
    80006ece:	87aa                	mv	a5,a0
    80006ed0:	0007869b          	sext.w	a3,a5
    80006ed4:	57f2                	lw	a5,60(sp)
    80006ed6:	0785                	addi	a5,a5,1
    80006ed8:	6702                	ld	a4,0(sp)
    80006eda:	97ba                	add	a5,a5,a4
    80006edc:	4722                	lw	a4,8(sp)
    80006ede:	863a                	mv	a2,a4
    80006ee0:	85be                	mv	a1,a5
    80006ee2:	8536                	mv	a0,a3
    80006ee4:	e2dff0ef          	jal	ra,80006d10 <int_to_string>
	} 
} 
    80006ee8:	0001                	nop
    80006eea:	60a6                	ld	ra,72(sp)
    80006eec:	6161                	addi	sp,sp,80
    80006eee:	8082                	ret

0000000080006ef0 <delay_loop>:
 * @brief Delay calculated interms of iterative operation 
 * @param unsigned long 
 * @param unsigned long
 */
void delay_loop(unsigned long cntr1, unsigned long cntr2)
{
    80006ef0:	1101                	addi	sp,sp,-32
    80006ef2:	e42a                	sd	a0,8(sp)
    80006ef4:	e02e                	sd	a1,0(sp)
	unsigned long tmpCntr = cntr2;
    80006ef6:	6782                	ld	a5,0(sp)
    80006ef8:	ec3e                	sd	a5,24(sp)

	while (cntr1--)
    80006efa:	a809                	j	80006f0c <delay_loop+0x1c>
	{
		tmpCntr = cntr2;
    80006efc:	6782                	ld	a5,0(sp)
    80006efe:	ec3e                	sd	a5,24(sp)

		while (tmpCntr--);
    80006f00:	0001                	nop
    80006f02:	67e2                	ld	a5,24(sp)
    80006f04:	fff78713          	addi	a4,a5,-1 # ffffffff7fffffff <__stack+0xfffffffeffee4daf>
    80006f08:	ec3a                	sd	a4,24(sp)
    80006f0a:	ffe5                	bnez	a5,80006f02 <delay_loop+0x12>
	while (cntr1--)
    80006f0c:	67a2                	ld	a5,8(sp)
    80006f0e:	fff78713          	addi	a4,a5,-1
    80006f12:	e43a                	sd	a4,8(sp)
    80006f14:	f7e5                	bnez	a5,80006efc <delay_loop+0xc>
	}
}
    80006f16:	0001                	nop
    80006f18:	0001                	nop
    80006f1a:	6105                	addi	sp,sp,32
    80006f1c:	8082                	ret

0000000080006f1e <read_word>:
 * Here we assume the word size to be 32 bits for gpio
 * @param int* addr
 * @return long int
 */
unsigned long read_word(uint32_t *addr)
{
    80006f1e:	1101                	addi	sp,sp,-32
    80006f20:	ec06                	sd	ra,24(sp)
    80006f22:	e42a                	sd	a0,8(sp)
	log_debug("addr = %x data = %x\n", addr, *addr);
    80006f24:	67a2                	ld	a5,8(sp)
    80006f26:	439c                	lw	a5,0(a5)
    80006f28:	863e                	mv	a2,a5
    80006f2a:	65a2                	ld	a1,8(sp)
    80006f2c:	00003517          	auipc	a0,0x3
    80006f30:	79450513          	addi	a0,a0,1940 # 8000a6c0 <__rodata_start+0x1368>
    80006f34:	45e000ef          	jal	ra,80007392 <log_debug>
	return *addr;
    80006f38:	67a2                	ld	a5,8(sp)
    80006f3a:	439c                	lw	a5,0(a5)
    80006f3c:	1782                	slli	a5,a5,0x20
    80006f3e:	9381                	srli	a5,a5,0x20
}
    80006f40:	853e                	mv	a0,a5
    80006f42:	60e2                	ld	ra,24(sp)
    80006f44:	6105                	addi	sp,sp,32
    80006f46:	8082                	ret

0000000080006f48 <write_word>:
 * @brief  writes a value to an address
 * @param int* 
 * @param unsigned long
 */
void write_word(uint32_t *addr, unsigned long val)
{
    80006f48:	1101                	addi	sp,sp,-32
    80006f4a:	ec06                	sd	ra,24(sp)
    80006f4c:	e42a                	sd	a0,8(sp)
    80006f4e:	e02e                	sd	a1,0(sp)
	*addr = val;
    80006f50:	6782                	ld	a5,0(sp)
    80006f52:	0007871b          	sext.w	a4,a5
    80006f56:	67a2                	ld	a5,8(sp)
    80006f58:	c398                	sw	a4,0(a5)
	log_debug("addr = %x data = %x\n", addr, *addr);
    80006f5a:	67a2                	ld	a5,8(sp)
    80006f5c:	439c                	lw	a5,0(a5)
    80006f5e:	863e                	mv	a2,a5
    80006f60:	65a2                	ld	a1,8(sp)
    80006f62:	00003517          	auipc	a0,0x3
    80006f66:	75e50513          	addi	a0,a0,1886 # 8000a6c0 <__rodata_start+0x1368>
    80006f6a:	428000ef          	jal	ra,80007392 <log_debug>
}
    80006f6e:	0001                	nop
    80006f70:	60e2                	ld	ra,24(sp)
    80006f72:	6105                	addi	sp,sp,32
    80006f74:	8082                	ret

0000000080006f76 <itoa>:
 * @param unsigned long long int
 * @param unsigned 
 */

static inline void itoa (unsigned long long int number, unsigned base)
{
    80006f76:	7169                	addi	sp,sp,-304
    80006f78:	f606                	sd	ra,296(sp)
    80006f7a:	e42a                	sd	a0,8(sp)
    80006f7c:	87ae                	mv	a5,a1
    80006f7e:	c23e                	sw	a5,4(sp)
	int i = 0;
    80006f80:	10012e23          	sw	zero,284(sp)
	unsigned int intermediate = 0;
    80006f84:	10012c23          	sw	zero,280(sp)
	unsigned int digits[sizeof(number)*8];

	while (1) {
		digits[i] = number % base;
    80006f88:	00416783          	lwu	a5,4(sp)
    80006f8c:	6722                	ld	a4,8(sp)
    80006f8e:	02f777b3          	remu	a5,a4,a5
    80006f92:	0007871b          	sext.w	a4,a5
    80006f96:	11c12783          	lw	a5,284(sp)
    80006f9a:	078a                	slli	a5,a5,0x2
    80006f9c:	1214                	addi	a3,sp,288
    80006f9e:	97b6                	add	a5,a5,a3
    80006fa0:	eee7ac23          	sw	a4,-264(a5)

		if (number < base)
    80006fa4:	00416783          	lwu	a5,4(sp)
    80006fa8:	6722                	ld	a4,8(sp)
    80006faa:	00f76e63          	bltu	a4,a5,80006fc6 <itoa+0x50>
			break;

		number /= base;
    80006fae:	00416783          	lwu	a5,4(sp)
    80006fb2:	6722                	ld	a4,8(sp)
    80006fb4:	02f757b3          	divu	a5,a4,a5
    80006fb8:	e43e                	sd	a5,8(sp)
		i++;
    80006fba:	11c12783          	lw	a5,284(sp)
    80006fbe:	2785                	addiw	a5,a5,1
    80006fc0:	10f12e23          	sw	a5,284(sp)
		digits[i] = number % base;
    80006fc4:	b7d1                	j	80006f88 <itoa+0x12>
			break;
    80006fc6:	0001                	nop
	}
	i++;
    80006fc8:	11c12783          	lw	a5,284(sp)
    80006fcc:	2785                	addiw	a5,a5,1
    80006fce:	10f12e23          	sw	a5,284(sp)
	while (i-- > 0)
    80006fd2:	a0a1                	j	8000701a <itoa+0xa4>
	{
		if (digits[i] >= 10)
    80006fd4:	11c12783          	lw	a5,284(sp)
    80006fd8:	078a                	slli	a5,a5,0x2
    80006fda:	1218                	addi	a4,sp,288
    80006fdc:	97ba                	add	a5,a5,a4
    80006fde:	ef87a783          	lw	a5,-264(a5)
    80006fe2:	873e                	mv	a4,a5
    80006fe4:	47a5                	li	a5,9
    80006fe6:	00e7f763          	bgeu	a5,a4,80006ff4 <itoa+0x7e>
			intermediate = 'a' - 10;
    80006fea:	05700793          	li	a5,87
    80006fee:	10f12c23          	sw	a5,280(sp)
    80006ff2:	a029                	j	80006ffc <itoa+0x86>
		else
			intermediate = '0';
    80006ff4:	03000793          	li	a5,48
    80006ff8:	10f12c23          	sw	a5,280(sp)

		putchar(digits[i] + intermediate);
    80006ffc:	11c12783          	lw	a5,284(sp)
    80007000:	078a                	slli	a5,a5,0x2
    80007002:	1218                	addi	a4,sp,288
    80007004:	97ba                	add	a5,a5,a4
    80007006:	ef87a783          	lw	a5,-264(a5)
    8000700a:	11812703          	lw	a4,280(sp)
    8000700e:	9fb9                	addw	a5,a5,a4
    80007010:	2781                	sext.w	a5,a5
    80007012:	2781                	sext.w	a5,a5
    80007014:	853e                	mv	a0,a5
    80007016:	cc9fd0ef          	jal	ra,80004cde <putchar>
	while (i-- > 0)
    8000701a:	11c12783          	lw	a5,284(sp)
    8000701e:	fff7871b          	addiw	a4,a5,-1
    80007022:	10e12e23          	sw	a4,284(sp)
    80007026:	faf047e3          	bgtz	a5,80006fd4 <itoa+0x5e>
	}
}
    8000702a:	0001                	nop
    8000702c:	0001                	nop
    8000702e:	70b2                	ld	ra,296(sp)
    80007030:	6155                	addi	sp,sp,304
    80007032:	8082                	ret

0000000080007034 <_printf_>:
 * @brief Handles the input stream of characters to print on screen
 * @details Identifies the type of format string, number of arguments and prints the right characer on screen
 * @param const char
 */
void _printf_(const char *fmt, va_list ap)
{
    80007034:	7119                	addi	sp,sp,-128
    80007036:	fc86                	sd	ra,120(sp)
    80007038:	f8a2                	sd	s0,112(sp)
    8000703a:	f4a6                	sd	s1,104(sp)
    8000703c:	e42a                	sd	a0,8(sp)
    8000703e:	e02e                	sd	a1,0(sp)
	register const char* p;
	const char* last_fmt;
	register int ch;
	unsigned long long num;
	int base, lflag, i;
	float float_num = 0;
    80007040:	00000793          	li	a5,0
    80007044:	c4be                	sw	a5,72(sp)
	char float_arr[30] = {'\0'};
    80007046:	ec02                	sd	zero,24(sp)
    80007048:	f002                	sd	zero,32(sp)
    8000704a:	f402                	sd	zero,40(sp)
    8000704c:	d802                	sw	zero,48(sp)
    8000704e:	02011a23          	sh	zero,52(sp)
	int backtothebeginning;

	for (;;) {
		for (;(ch = *(unsigned char *) fmt) != '%'; fmt++) {
    80007052:	a809                	j	80007064 <_printf_+0x30>
			if (ch == '\0')
    80007054:	2a040a63          	beqz	s0,80007308 <_printf_+0x2d4>
				return;
			putchar(ch);
    80007058:	8522                	mv	a0,s0
    8000705a:	c85fd0ef          	jal	ra,80004cde <putchar>
		for (;(ch = *(unsigned char *) fmt) != '%'; fmt++) {
    8000705e:	67a2                	ld	a5,8(sp)
    80007060:	0785                	addi	a5,a5,1
    80007062:	e43e                	sd	a5,8(sp)
    80007064:	67a2                	ld	a5,8(sp)
    80007066:	0007c783          	lbu	a5,0(a5)
    8000706a:	0007841b          	sext.w	s0,a5
    8000706e:	8722                	mv	a4,s0
    80007070:	02500793          	li	a5,37
    80007074:	fef710e3          	bne	a4,a5,80007054 <_printf_+0x20>
		}
		fmt++;
    80007078:	67a2                	ld	a5,8(sp)
    8000707a:	0785                	addi	a5,a5,1
    8000707c:	e43e                	sd	a5,8(sp)

		// Process a %-escape sequence
		last_fmt = fmt;
    8000707e:	67a2                	ld	a5,8(sp)
    80007080:	e0be                	sd	a5,64(sp)
		lflag = 0; 
    80007082:	ca82                	sw	zero,84(sp)

		backtothebeginning = 0;
    80007084:	c682                	sw	zero,76(sp)
		for (;;) {

			switch (ch = *(unsigned char *) fmt++) {
    80007086:	67a2                	ld	a5,8(sp)
    80007088:	00178713          	addi	a4,a5,1
    8000708c:	e43a                	sd	a4,8(sp)
    8000708e:	0007c783          	lbu	a5,0(a5)
    80007092:	0007841b          	sext.w	s0,a5
    80007096:	8722                	mv	a4,s0
    80007098:	02500793          	li	a5,37
    8000709c:	24f70463          	beq	a4,a5,800072e4 <_printf_+0x2b0>
    800070a0:	8722                	mv	a4,s0
    800070a2:	02500793          	li	a5,37
    800070a6:	24f74363          	blt	a4,a5,800072ec <_printf_+0x2b8>
    800070aa:	8722                	mv	a4,s0
    800070ac:	07800793          	li	a5,120
    800070b0:	22e7ce63          	blt	a5,a4,800072ec <_printf_+0x2b8>
    800070b4:	8722                	mv	a4,s0
    800070b6:	06300793          	li	a5,99
    800070ba:	22f74963          	blt	a4,a5,800072ec <_printf_+0x2b8>
    800070be:	f9d4069b          	addiw	a3,s0,-99
    800070c2:	0006871b          	sext.w	a4,a3
    800070c6:	47d5                	li	a5,21
    800070c8:	22e7e263          	bltu	a5,a4,800072ec <_printf_+0x2b8>
    800070cc:	02069793          	slli	a5,a3,0x20
    800070d0:	9381                	srli	a5,a5,0x20
    800070d2:	00279713          	slli	a4,a5,0x2
    800070d6:	00003797          	auipc	a5,0x3
    800070da:	61278793          	addi	a5,a5,1554 # 8000a6e8 <__rodata_start+0x1390>
    800070de:	97ba                	add	a5,a5,a4
    800070e0:	439c                	lw	a5,0(a5)
    800070e2:	0007871b          	sext.w	a4,a5
    800070e6:	00003797          	auipc	a5,0x3
    800070ea:	60278793          	addi	a5,a5,1538 # 8000a6e8 <__rodata_start+0x1390>
    800070ee:	97ba                	add	a5,a5,a4
    800070f0:	8782                	jr	a5

				// long flag (doubled for long long)
				case 'l':
					lflag++;
    800070f2:	47d6                	lw	a5,84(sp)
    800070f4:	2785                	addiw	a5,a5,1
    800070f6:	cabe                	sw	a5,84(sp)
					backtothebeginning = 1;
    800070f8:	4785                	li	a5,1
    800070fa:	c6be                	sw	a5,76(sp)
					break;
    800070fc:	aafd                	j	800072fa <_printf_+0x2c6>

					// character
				case 'c':
					putchar(va_arg(ap, int));
    800070fe:	6782                	ld	a5,0(sp)
    80007100:	00878713          	addi	a4,a5,8
    80007104:	e03a                	sd	a4,0(sp)
    80007106:	439c                	lw	a5,0(a5)
    80007108:	853e                	mv	a0,a5
    8000710a:	bd5fd0ef          	jal	ra,80004cde <putchar>
					break;
    8000710e:	a2f5                	j	800072fa <_printf_+0x2c6>

					// string
				case 's':
					if ((p = va_arg(ap, char *)) == NULL)
    80007110:	6782                	ld	a5,0(sp)
    80007112:	00878713          	addi	a4,a5,8
    80007116:	e03a                	sd	a4,0(sp)
    80007118:	6384                	ld	s1,0(a5)
    8000711a:	e891                	bnez	s1,8000712e <_printf_+0xfa>
						p = "(null)";
    8000711c:	00003497          	auipc	s1,0x3
    80007120:	5c448493          	addi	s1,s1,1476 # 8000a6e0 <__rodata_start+0x1388>
					for (; (ch = *p) != '\0' ;) {
    80007124:	a029                	j	8000712e <_printf_+0xfa>
						putchar(ch);
    80007126:	8522                	mv	a0,s0
    80007128:	bb7fd0ef          	jal	ra,80004cde <putchar>
						p++;
    8000712c:	0485                	addi	s1,s1,1
					for (; (ch = *p) != '\0' ;) {
    8000712e:	0004c783          	lbu	a5,0(s1)
    80007132:	0007841b          	sext.w	s0,a5
    80007136:	f865                	bnez	s0,80007126 <_printf_+0xf2>
					}
					break;
    80007138:	a2c9                	j	800072fa <_printf_+0x2c6>

					// (signed) decimal
				case 'd':
					base = 10;
    8000713a:	47a9                	li	a5,10
    8000713c:	de3e                	sw	a5,60(sp)

					if (lflag >= 2)
    8000713e:	47d6                	lw	a5,84(sp)
    80007140:	0007871b          	sext.w	a4,a5
    80007144:	4785                	li	a5,1
    80007146:	00e7d963          	bge	a5,a4,80007158 <_printf_+0x124>
						num = va_arg(ap, long long);
    8000714a:	6782                	ld	a5,0(sp)
    8000714c:	00878713          	addi	a4,a5,8
    80007150:	e03a                	sd	a4,0(sp)
    80007152:	639c                	ld	a5,0(a5)
    80007154:	ecbe                	sd	a5,88(sp)
    80007156:	a025                	j	8000717e <_printf_+0x14a>
					else if (lflag ==1)
    80007158:	47d6                	lw	a5,84(sp)
    8000715a:	0007871b          	sext.w	a4,a5
    8000715e:	4785                	li	a5,1
    80007160:	00f71963          	bne	a4,a5,80007172 <_printf_+0x13e>
						num = va_arg(ap, long);
    80007164:	6782                	ld	a5,0(sp)
    80007166:	00878713          	addi	a4,a5,8
    8000716a:	e03a                	sd	a4,0(sp)
    8000716c:	639c                	ld	a5,0(a5)
    8000716e:	ecbe                	sd	a5,88(sp)
    80007170:	a039                	j	8000717e <_printf_+0x14a>
					else
						num = va_arg(ap, int);
    80007172:	6782                	ld	a5,0(sp)
    80007174:	00878713          	addi	a4,a5,8
    80007178:	e03a                	sd	a4,0(sp)
    8000717a:	439c                	lw	a5,0(a5)
    8000717c:	ecbe                	sd	a5,88(sp)

					if ((long long) num < 0) {
    8000717e:	67e6                	ld	a5,88(sp)
    80007180:	0007da63          	bgez	a5,80007194 <_printf_+0x160>
						putchar('-');
    80007184:	02d00513          	li	a0,45
    80007188:	b57fd0ef          	jal	ra,80004cde <putchar>
						num = -(long long) num;
    8000718c:	67e6                	ld	a5,88(sp)
    8000718e:	40f007b3          	neg	a5,a5
    80007192:	ecbe                	sd	a5,88(sp)
					}

					itoa( num, base);
    80007194:	57f2                	lw	a5,60(sp)
    80007196:	85be                	mv	a1,a5
    80007198:	6566                	ld	a0,88(sp)
    8000719a:	dddff0ef          	jal	ra,80006f76 <itoa>

					break;
    8000719e:	aab1                	j	800072fa <_printf_+0x2c6>

				case 'f':
					float_num =  va_arg(ap, double);
    800071a0:	6782                	ld	a5,0(sp)
    800071a2:	00878713          	addi	a4,a5,8
    800071a6:	e03a                	sd	a4,0(sp)
    800071a8:	639c                	ld	a5,0(a5)
    800071aa:	853e                	mv	a0,a5
    800071ac:	0d0020ef          	jal	ra,8000927c <__truncdfsf2>
    800071b0:	87aa                	mv	a5,a0
    800071b2:	c4be                	sw	a5,72(sp)

					ftoa(float_num, float_arr, 6);
    800071b4:	083c                	addi	a5,sp,24
    800071b6:	4619                	li	a2,6
    800071b8:	85be                	mv	a1,a5
    800071ba:	4526                	lw	a0,72(sp)
    800071bc:	be5ff0ef          	jal	ra,80006da0 <ftoa>

					for( i = 0; float_arr[i] != '\0'; i++)
    800071c0:	c882                	sw	zero,80(sp)
    800071c2:	a01d                	j	800071e8 <_printf_+0x1b4>
					{
						putchar(float_arr[i]);
    800071c4:	47c6                	lw	a5,80(sp)
    800071c6:	1098                	addi	a4,sp,96
    800071c8:	97ba                	add	a5,a5,a4
    800071ca:	fb87c783          	lbu	a5,-72(a5)
    800071ce:	2781                	sext.w	a5,a5
    800071d0:	853e                	mv	a0,a5
    800071d2:	b0dfd0ef          	jal	ra,80004cde <putchar>
						if(i > 29) break;
    800071d6:	47c6                	lw	a5,80(sp)
    800071d8:	0007871b          	sext.w	a4,a5
    800071dc:	47f5                	li	a5,29
    800071de:	00e7cc63          	blt	a5,a4,800071f6 <_printf_+0x1c2>
					for( i = 0; float_arr[i] != '\0'; i++)
    800071e2:	47c6                	lw	a5,80(sp)
    800071e4:	2785                	addiw	a5,a5,1
    800071e6:	c8be                	sw	a5,80(sp)
    800071e8:	47c6                	lw	a5,80(sp)
    800071ea:	1098                	addi	a4,sp,96
    800071ec:	97ba                	add	a5,a5,a4
    800071ee:	fb87c783          	lbu	a5,-72(a5)
    800071f2:	fbe9                	bnez	a5,800071c4 <_printf_+0x190>
					}
					break;
    800071f4:	a219                	j	800072fa <_printf_+0x2c6>
						if(i > 29) break;
    800071f6:	0001                	nop
					break;
    800071f8:	a209                	j	800072fa <_printf_+0x2c6>

					// unsigned decimal
				case 'u':
					base = 10;
    800071fa:	47a9                	li	a5,10
    800071fc:	de3e                	sw	a5,60(sp)

					if (lflag >= 2)
    800071fe:	47d6                	lw	a5,84(sp)
    80007200:	0007871b          	sext.w	a4,a5
    80007204:	4785                	li	a5,1
    80007206:	00e7d963          	bge	a5,a4,80007218 <_printf_+0x1e4>
						num = va_arg(ap, unsigned long long);
    8000720a:	6782                	ld	a5,0(sp)
    8000720c:	00878713          	addi	a4,a5,8
    80007210:	e03a                	sd	a4,0(sp)
    80007212:	639c                	ld	a5,0(a5)
    80007214:	ecbe                	sd	a5,88(sp)
    80007216:	a01d                	j	8000723c <_printf_+0x208>
					else if (lflag)
    80007218:	47d6                	lw	a5,84(sp)
    8000721a:	2781                	sext.w	a5,a5
    8000721c:	cb81                	beqz	a5,8000722c <_printf_+0x1f8>
						num = va_arg(ap, unsigned long);
    8000721e:	6782                	ld	a5,0(sp)
    80007220:	00878713          	addi	a4,a5,8
    80007224:	e03a                	sd	a4,0(sp)
    80007226:	639c                	ld	a5,0(a5)
    80007228:	ecbe                	sd	a5,88(sp)
    8000722a:	a809                	j	8000723c <_printf_+0x208>
					else
						num = va_arg(ap, unsigned int);
    8000722c:	6782                	ld	a5,0(sp)
    8000722e:	00878713          	addi	a4,a5,8
    80007232:	e03a                	sd	a4,0(sp)
    80007234:	439c                	lw	a5,0(a5)
    80007236:	1782                	slli	a5,a5,0x20
    80007238:	9381                	srli	a5,a5,0x20
    8000723a:	ecbe                	sd	a5,88(sp)

					itoa( num, base);
    8000723c:	57f2                	lw	a5,60(sp)
    8000723e:	85be                	mv	a1,a5
    80007240:	6566                	ld	a0,88(sp)
    80007242:	d35ff0ef          	jal	ra,80006f76 <itoa>

					break;
    80007246:	a855                	j	800072fa <_printf_+0x2c6>

					// (unsigned) octal
				case 'o':
					// should do something with padding so it's always 3 octits
					base = 8;
    80007248:	47a1                	li	a5,8
    8000724a:	de3e                	sw	a5,60(sp)

					if (lflag >= 2)
    8000724c:	47d6                	lw	a5,84(sp)
    8000724e:	0007871b          	sext.w	a4,a5
    80007252:	4785                	li	a5,1
    80007254:	00e7d963          	bge	a5,a4,80007266 <_printf_+0x232>
						num = va_arg(ap, unsigned long long);
    80007258:	6782                	ld	a5,0(sp)
    8000725a:	00878713          	addi	a4,a5,8
    8000725e:	e03a                	sd	a4,0(sp)
    80007260:	639c                	ld	a5,0(a5)
    80007262:	ecbe                	sd	a5,88(sp)
    80007264:	a01d                	j	8000728a <_printf_+0x256>
					else if (lflag)
    80007266:	47d6                	lw	a5,84(sp)
    80007268:	2781                	sext.w	a5,a5
    8000726a:	cb81                	beqz	a5,8000727a <_printf_+0x246>
						num = va_arg(ap, unsigned long);
    8000726c:	6782                	ld	a5,0(sp)
    8000726e:	00878713          	addi	a4,a5,8
    80007272:	e03a                	sd	a4,0(sp)
    80007274:	639c                	ld	a5,0(a5)
    80007276:	ecbe                	sd	a5,88(sp)
    80007278:	a809                	j	8000728a <_printf_+0x256>
					else
						num = va_arg(ap, unsigned int);
    8000727a:	6782                	ld	a5,0(sp)
    8000727c:	00878713          	addi	a4,a5,8
    80007280:	e03a                	sd	a4,0(sp)
    80007282:	439c                	lw	a5,0(a5)
    80007284:	1782                	slli	a5,a5,0x20
    80007286:	9381                	srli	a5,a5,0x20
    80007288:	ecbe                	sd	a5,88(sp)

					itoa( num, base);
    8000728a:	57f2                	lw	a5,60(sp)
    8000728c:	85be                	mv	a1,a5
    8000728e:	6566                	ld	a0,88(sp)
    80007290:	ce7ff0ef          	jal	ra,80006f76 <itoa>

					break;
    80007294:	a09d                	j	800072fa <_printf_+0x2c6>

				case 'x':
					base = 16;
    80007296:	47c1                	li	a5,16
    80007298:	de3e                	sw	a5,60(sp)

					if (lflag >= 2)
    8000729a:	47d6                	lw	a5,84(sp)
    8000729c:	0007871b          	sext.w	a4,a5
    800072a0:	4785                	li	a5,1
    800072a2:	00e7d963          	bge	a5,a4,800072b4 <_printf_+0x280>
						num = va_arg(ap, unsigned long long);
    800072a6:	6782                	ld	a5,0(sp)
    800072a8:	00878713          	addi	a4,a5,8
    800072ac:	e03a                	sd	a4,0(sp)
    800072ae:	639c                	ld	a5,0(a5)
    800072b0:	ecbe                	sd	a5,88(sp)
    800072b2:	a01d                	j	800072d8 <_printf_+0x2a4>
					else if (lflag)
    800072b4:	47d6                	lw	a5,84(sp)
    800072b6:	2781                	sext.w	a5,a5
    800072b8:	cb81                	beqz	a5,800072c8 <_printf_+0x294>
						num = va_arg(ap, unsigned long);
    800072ba:	6782                	ld	a5,0(sp)
    800072bc:	00878713          	addi	a4,a5,8
    800072c0:	e03a                	sd	a4,0(sp)
    800072c2:	639c                	ld	a5,0(a5)
    800072c4:	ecbe                	sd	a5,88(sp)
    800072c6:	a809                	j	800072d8 <_printf_+0x2a4>
					else
						num = va_arg(ap, unsigned int);
    800072c8:	6782                	ld	a5,0(sp)
    800072ca:	00878713          	addi	a4,a5,8
    800072ce:	e03a                	sd	a4,0(sp)
    800072d0:	439c                	lw	a5,0(a5)
    800072d2:	1782                	slli	a5,a5,0x20
    800072d4:	9381                	srli	a5,a5,0x20
    800072d6:	ecbe                	sd	a5,88(sp)

					itoa( num, base);
    800072d8:	57f2                	lw	a5,60(sp)
    800072da:	85be                	mv	a1,a5
    800072dc:	6566                	ld	a0,88(sp)
    800072de:	c99ff0ef          	jal	ra,80006f76 <itoa>

					break;
    800072e2:	a821                	j	800072fa <_printf_+0x2c6>

					// escaped '%' character
				case '%':
					putchar(ch);
    800072e4:	8522                	mv	a0,s0
    800072e6:	9f9fd0ef          	jal	ra,80004cde <putchar>
					break;
    800072ea:	a801                	j	800072fa <_printf_+0x2c6>

					// unrecognized escape sequence - just print it literally
				default:
					putchar('%');
    800072ec:	02500513          	li	a0,37
    800072f0:	9effd0ef          	jal	ra,80004cde <putchar>
					fmt = last_fmt;
    800072f4:	6786                	ld	a5,64(sp)
    800072f6:	e43e                	sd	a5,8(sp)
					break;
    800072f8:	0001                	nop
			}

			if (backtothebeginning)
    800072fa:	47b6                	lw	a5,76(sp)
    800072fc:	2781                	sext.w	a5,a5
    800072fe:	c399                	beqz	a5,80007304 <_printf_+0x2d0>
			{
				backtothebeginning = 0;
    80007300:	c682                	sw	zero,76(sp)
			switch (ch = *(unsigned char *) fmt++) {
    80007302:	b351                	j	80007086 <_printf_+0x52>
				continue;
			}
			else
				break;
    80007304:	0001                	nop
		for (;(ch = *(unsigned char *) fmt) != '%'; fmt++) {
    80007306:	bbb9                	j	80007064 <_printf_+0x30>
				return;
    80007308:	0001                	nop
		}
	}
}
    8000730a:	70e6                	ld	ra,120(sp)
    8000730c:	7446                	ld	s0,112(sp)
    8000730e:	74a6                	ld	s1,104(sp)
    80007310:	6109                	addi	sp,sp,128
    80007312:	8082                	ret

0000000080007314 <printf>:
 * @details prints the characters on terminal
 * @param const char*
 * @return int
 */
int printf(const char* fmt, ...)
{
    80007314:	7159                	addi	sp,sp,-112
    80007316:	f406                	sd	ra,40(sp)
    80007318:	e42a                	sd	a0,8(sp)
    8000731a:	fc2e                	sd	a1,56(sp)
    8000731c:	e0b2                	sd	a2,64(sp)
    8000731e:	e4b6                	sd	a3,72(sp)
    80007320:	e8ba                	sd	a4,80(sp)
    80007322:	ecbe                	sd	a5,88(sp)
    80007324:	f0c2                	sd	a6,96(sp)
    80007326:	f4c6                	sd	a7,104(sp)
	va_list ap;
	va_start(ap, fmt);
    80007328:	189c                	addi	a5,sp,112
    8000732a:	e03e                	sd	a5,0(sp)
    8000732c:	6782                	ld	a5,0(sp)
    8000732e:	fc878793          	addi	a5,a5,-56
    80007332:	ec3e                	sd	a5,24(sp)

	_printf_(fmt, ap);
    80007334:	67e2                	ld	a5,24(sp)
    80007336:	85be                	mv	a1,a5
    80007338:	6522                	ld	a0,8(sp)
    8000733a:	cfbff0ef          	jal	ra,80007034 <_printf_>

	va_end(ap);
	return 0; // incorrect return value, but who cares, anyway?
    8000733e:	4781                	li	a5,0
}
    80007340:	853e                	mv	a0,a5
    80007342:	70a2                	ld	ra,40(sp)
    80007344:	6165                	addi	sp,sp,112
    80007346:	8082                	ret

0000000080007348 <log_trace>:
 * @brief Function to print trace logs
 * @details This function print trace logs if the LOG_LEVEL allows trace logs
 * @param const char* (printf formatted arguments with format specifiers)
 */
void log_trace(const char* fmt, ...)
{
    80007348:	711d                	addi	sp,sp,-96
    8000734a:	e42a                	sd	a0,8(sp)
    8000734c:	f42e                	sd	a1,40(sp)
    8000734e:	f832                	sd	a2,48(sp)
    80007350:	fc36                	sd	a3,56(sp)
    80007352:	e0ba                	sd	a4,64(sp)
    80007354:	e4be                	sd	a5,72(sp)
    80007356:	e8c2                	sd	a6,80(sp)
    80007358:	ecc6                	sd	a7,88(sp)

		_printf_(fmt, ap);

		va_end(ap);
	}
}
    8000735a:	0001                	nop
    8000735c:	6125                	addi	sp,sp,96
    8000735e:	8082                	ret

0000000080007360 <log_info>:
 * @brief Function to print info logs
 * @details This function print info logs if the LOG_LEVEL allows info logs
 * @param const char* (printf formatted arguments with format specifiers)
 */
void log_info(const char* fmt, ...)
{
    80007360:	7159                	addi	sp,sp,-112
    80007362:	f406                	sd	ra,40(sp)
    80007364:	e42a                	sd	a0,8(sp)
    80007366:	fc2e                	sd	a1,56(sp)
    80007368:	e0b2                	sd	a2,64(sp)
    8000736a:	e4b6                	sd	a3,72(sp)
    8000736c:	e8ba                	sd	a4,80(sp)
    8000736e:	ecbe                	sd	a5,88(sp)
    80007370:	f0c2                	sd	a6,96(sp)
    80007372:	f4c6                	sd	a7,104(sp)
	if (INFO <= LOG_LEVEL) {
		va_list ap;
		va_start(ap, fmt);
    80007374:	189c                	addi	a5,sp,112
    80007376:	e03e                	sd	a5,0(sp)
    80007378:	6782                	ld	a5,0(sp)
    8000737a:	fc878793          	addi	a5,a5,-56
    8000737e:	ec3e                	sd	a5,24(sp)

		_printf_( fmt, ap);
    80007380:	67e2                	ld	a5,24(sp)
    80007382:	85be                	mv	a1,a5
    80007384:	6522                	ld	a0,8(sp)
    80007386:	cafff0ef          	jal	ra,80007034 <_printf_>

		va_end(ap);
	}
}
    8000738a:	0001                	nop
    8000738c:	70a2                	ld	ra,40(sp)
    8000738e:	6165                	addi	sp,sp,112
    80007390:	8082                	ret

0000000080007392 <log_debug>:
 * @brief Function to print debug logs
 * @details This function print debug logs if the LOG_LEVEL allows debug logs
 * @param const char* (printf formatted arguments with format specifiers)
 */
void log_debug(const char* fmt, ...)
{
    80007392:	711d                	addi	sp,sp,-96
    80007394:	e42a                	sd	a0,8(sp)
    80007396:	f42e                	sd	a1,40(sp)
    80007398:	f832                	sd	a2,48(sp)
    8000739a:	fc36                	sd	a3,56(sp)
    8000739c:	e0ba                	sd	a4,64(sp)
    8000739e:	e4be                	sd	a5,72(sp)
    800073a0:	e8c2                	sd	a6,80(sp)
    800073a2:	ecc6                	sd	a7,88(sp)

		_printf_(fmt, ap);

		va_end(ap);
	}
}
    800073a4:	0001                	nop
    800073a6:	6125                	addi	sp,sp,96
    800073a8:	8082                	ret

00000000800073aa <log_warn>:
 * @brief Function to print warn logs
 * @details This function print trace warn if the LOG_LEVEL allows warn logs
 * @param const char* (printf formatted arguments with format specifiers)
 */
void log_warn(const char* fmt, ...)
{
    800073aa:	7159                	addi	sp,sp,-112
    800073ac:	f406                	sd	ra,40(sp)
    800073ae:	e42a                	sd	a0,8(sp)
    800073b0:	fc2e                	sd	a1,56(sp)
    800073b2:	e0b2                	sd	a2,64(sp)
    800073b4:	e4b6                	sd	a3,72(sp)
    800073b6:	e8ba                	sd	a4,80(sp)
    800073b8:	ecbe                	sd	a5,88(sp)
    800073ba:	f0c2                	sd	a6,96(sp)
    800073bc:	f4c6                	sd	a7,104(sp)
	if (WARN <= LOG_LEVEL) {
		va_list ap;
		va_start(ap, fmt);
    800073be:	189c                	addi	a5,sp,112
    800073c0:	e03e                	sd	a5,0(sp)
    800073c2:	6782                	ld	a5,0(sp)
    800073c4:	fc878793          	addi	a5,a5,-56
    800073c8:	ec3e                	sd	a5,24(sp)

		_printf_( fmt, ap);
    800073ca:	67e2                	ld	a5,24(sp)
    800073cc:	85be                	mv	a1,a5
    800073ce:	6522                	ld	a0,8(sp)
    800073d0:	c65ff0ef          	jal	ra,80007034 <_printf_>

		va_end(ap);
	}
}
    800073d4:	0001                	nop
    800073d6:	70a2                	ld	ra,40(sp)
    800073d8:	6165                	addi	sp,sp,112
    800073da:	8082                	ret

00000000800073dc <log_error>:
 * @brief Function to print error logs
 * @details This function print error logs if the LOG_LEVEL allows error logs
 * @param const char* (printf formatted arguments with format specifiers)
 */
void log_error(const char* fmt, ...)
{
    800073dc:	7159                	addi	sp,sp,-112
    800073de:	f406                	sd	ra,40(sp)
    800073e0:	e42a                	sd	a0,8(sp)
    800073e2:	fc2e                	sd	a1,56(sp)
    800073e4:	e0b2                	sd	a2,64(sp)
    800073e6:	e4b6                	sd	a3,72(sp)
    800073e8:	e8ba                	sd	a4,80(sp)
    800073ea:	ecbe                	sd	a5,88(sp)
    800073ec:	f0c2                	sd	a6,96(sp)
    800073ee:	f4c6                	sd	a7,104(sp)
	if (ERROR <= LOG_LEVEL) {
		va_list ap;
		va_start(ap, fmt);
    800073f0:	189c                	addi	a5,sp,112
    800073f2:	e03e                	sd	a5,0(sp)
    800073f4:	6782                	ld	a5,0(sp)
    800073f6:	fc878793          	addi	a5,a5,-56
    800073fa:	ec3e                	sd	a5,24(sp)

		_printf_( fmt, ap);
    800073fc:	67e2                	ld	a5,24(sp)
    800073fe:	85be                	mv	a1,a5
    80007400:	6522                	ld	a0,8(sp)
    80007402:	c33ff0ef          	jal	ra,80007034 <_printf_>

		va_end(ap);
	}
}
    80007406:	0001                	nop
    80007408:	70a2                	ld	ra,40(sp)
    8000740a:	6165                	addi	sp,sp,112
    8000740c:	8082                	ret

000000008000740e <log_fatal>:
 * @brief Function to print fatal logs
 * @details This function print fatal logs if the LOG_LEVEL allows fatal logs
 * @param const char* (printf formatted arguments with format specifiers)
 */
void log_fatal(const char* fmt, ...)
{
    8000740e:	7159                	addi	sp,sp,-112
    80007410:	f406                	sd	ra,40(sp)
    80007412:	e42a                	sd	a0,8(sp)
    80007414:	fc2e                	sd	a1,56(sp)
    80007416:	e0b2                	sd	a2,64(sp)
    80007418:	e4b6                	sd	a3,72(sp)
    8000741a:	e8ba                	sd	a4,80(sp)
    8000741c:	ecbe                	sd	a5,88(sp)
    8000741e:	f0c2                	sd	a6,96(sp)
    80007420:	f4c6                	sd	a7,104(sp)
	if (FATAL <= LOG_LEVEL) {
		va_list ap;
		va_start(ap, fmt);
    80007422:	189c                	addi	a5,sp,112
    80007424:	e03e                	sd	a5,0(sp)
    80007426:	6782                	ld	a5,0(sp)
    80007428:	fc878793          	addi	a5,a5,-56
    8000742c:	ec3e                	sd	a5,24(sp)

		_printf_( fmt, ap);
    8000742e:	67e2                	ld	a5,24(sp)
    80007430:	85be                	mv	a1,a5
    80007432:	6522                	ld	a0,8(sp)
    80007434:	c01ff0ef          	jal	ra,80007034 <_printf_>

		va_end(ap);
	}

	log_info("\n panic \n");
    80007438:	00003517          	auipc	a0,0x3
    8000743c:	30850513          	addi	a0,a0,776 # 8000a740 <__rodata_start+0x13e8>
    80007440:	f21ff0ef          	jal	ra,80007360 <log_info>
	while (1);
    80007444:	a001                	j	80007444 <log_fatal+0x36>

0000000080007446 <extract_ie_code>:
 *	    by masking the most significant bit. 
 * @param unsigned int num
 * @return unsigned int
 */
unsigned int extract_ie_code(unsigned int num)
{
    80007446:	7179                	addi	sp,sp,-48
    80007448:	f406                	sd	ra,40(sp)
    8000744a:	87aa                	mv	a5,a0
    8000744c:	c63e                	sw	a5,12(sp)
	unsigned int exception_code;

	log_trace("\nextract_ie_code entered\n");
    8000744e:	00003517          	auipc	a0,0x3
    80007452:	30250513          	addi	a0,a0,770 # 8000a750 <__rodata_start+0x13f8>
    80007456:	ef3ff0ef          	jal	ra,80007348 <log_trace>

	exception_code = (num & 0X7FFFFFFF);
    8000745a:	4732                	lw	a4,12(sp)
    8000745c:	800007b7          	lui	a5,0x80000
    80007460:	fff7c793          	not	a5,a5
    80007464:	8ff9                	and	a5,a5,a4
    80007466:	ce3e                	sw	a5,28(sp)

	log_debug("exception code = %x\n",exception_code);
    80007468:	47f2                	lw	a5,28(sp)
    8000746a:	85be                	mv	a1,a5
    8000746c:	00003517          	auipc	a0,0x3
    80007470:	30450513          	addi	a0,a0,772 # 8000a770 <__rodata_start+0x1418>
    80007474:	f1fff0ef          	jal	ra,80007392 <log_debug>

	log_trace("extract_ie_code exited\n");
    80007478:	00003517          	auipc	a0,0x3
    8000747c:	31050513          	addi	a0,a0,784 # 8000a788 <__rodata_start+0x1430>
    80007480:	ec9ff0ef          	jal	ra,80007348 <log_trace>

	return exception_code;
    80007484:	47f2                	lw	a5,28(sp)
}
    80007486:	853e                	mv	a0,a5
    80007488:	70a2                	ld	ra,40(sp)
    8000748a:	6145                	addi	sp,sp,48
    8000748c:	8082                	ret

000000008000748e <default_handler>:
 * @brief default handler that loops infinitely 
 * @param unsigned int ptr mcause
 * @param unsigned int ptr epc
 */
void default_handler(__attribute__((unused)) uintptr_t mcause, __attribute__((unused)) uintptr_t epc)
{
    8000748e:	1101                	addi	sp,sp,-32
    80007490:	ec06                	sd	ra,24(sp)
    80007492:	e42a                	sd	a0,8(sp)
    80007494:	e02e                	sd	a1,0(sp)
	log_trace("\ndefault_handler entered\n");
    80007496:	00003517          	auipc	a0,0x3
    8000749a:	30a50513          	addi	a0,a0,778 # 8000a7a0 <__rodata_start+0x1448>
    8000749e:	eabff0ef          	jal	ra,80007348 <log_trace>

	while(1);
    800074a2:	a001                	j	800074a2 <default_handler+0x14>

00000000800074a4 <handle_trap>:
 * @param unsigned int ptr mcause
 * @param unsigned int ptr epc
 * @return unsigned int ptr
 */
uintptr_t handle_trap(uintptr_t mcause, uintptr_t epc)
{
    800074a4:	7179                	addi	sp,sp,-48
    800074a6:	f406                	sd	ra,40(sp)
    800074a8:	e42a                	sd	a0,8(sp)
    800074aa:	e02e                	sd	a1,0(sp)
	unsigned int ie_entry = 0;;
    800074ac:	ce02                	sw	zero,28(sp)
	uint32_t shift_length = 0;
    800074ae:	cc02                	sw	zero,24(sp)

	log_trace("\nhandle_trap entered\n");
    800074b0:	00003517          	auipc	a0,0x3
    800074b4:	31050513          	addi	a0,a0,784 # 8000a7c0 <__rodata_start+0x1468>
    800074b8:	e91ff0ef          	jal	ra,80007348 <log_trace>
	   The mcause register is an XLEN-bit read-write register formatted as shown in Figure 3.2
	   1. When a trap is taken into M-mode, mcause is written with a code indicating the event that caused the trap.
	   Otherwise, mcause is never written by the implementation, though it may be explicitly written by software.
	 */

	log_info("mcause = %x, epc = %x\n", mcause, epc);
    800074bc:	6602                	ld	a2,0(sp)
    800074be:	65a2                	ld	a1,8(sp)
    800074c0:	00003517          	auipc	a0,0x3
    800074c4:	31850513          	addi	a0,a0,792 # 8000a7d8 <__rodata_start+0x1480>
    800074c8:	e99ff0ef          	jal	ra,80007360 <log_info>
	/*
	   The Interrupt bit in the mcause register is set if the trap was caused by an interrupt.
	   The Exception Code field contains a code identifying the last exception
	 */

	log_debug("sizeof(uintptr)  = %d \n",sizeof(uintptr_t));
    800074cc:	45a1                	li	a1,8
    800074ce:	00003517          	auipc	a0,0x3
    800074d2:	32250513          	addi	a0,a0,802 # 8000a7f0 <__rodata_start+0x1498>
    800074d6:	ebdff0ef          	jal	ra,80007392 <log_debug>
	shift_length = __riscv_xlen - 1;
    800074da:	03f00793          	li	a5,63
    800074de:	cc3e                	sw	a5,24(sp)

	if (mcause & (1 << (shift_length))){
    800074e0:	47e2                	lw	a5,24(sp)
    800074e2:	4705                	li	a4,1
    800074e4:	00f717bb          	sllw	a5,a4,a5
    800074e8:	2781                	sext.w	a5,a5
    800074ea:	873e                	mv	a4,a5
    800074ec:	67a2                	ld	a5,8(sp)
    800074ee:	8ff9                	and	a5,a5,a4
    800074f0:	cb9d                	beqz	a5,80007526 <handle_trap+0x82>

		ie_entry = extract_ie_code(mcause);
    800074f2:	67a2                	ld	a5,8(sp)
    800074f4:	2781                	sext.w	a5,a5
    800074f6:	853e                	mv	a0,a5
    800074f8:	f4fff0ef          	jal	ra,80007446 <extract_ie_code>
    800074fc:	87aa                	mv	a5,a0
    800074fe:	ce3e                	sw	a5,28(sp)

		log_debug("Source of Trap: Interrupt\n");
    80007500:	00003517          	auipc	a0,0x3
    80007504:	30850513          	addi	a0,a0,776 # 8000a808 <__rodata_start+0x14b0>
    80007508:	e8bff0ef          	jal	ra,80007392 <log_debug>

		mcause_interrupt_table[ie_entry](mcause, epc);
    8000750c:	00100717          	auipc	a4,0x100
    80007510:	c2c70713          	addi	a4,a4,-980 # 80107138 <mcause_interrupt_table>
    80007514:	01c16783          	lwu	a5,28(sp)
    80007518:	078e                	slli	a5,a5,0x3
    8000751a:	97ba                	add	a5,a5,a4
    8000751c:	639c                	ld	a5,0(a5)
    8000751e:	6582                	ld	a1,0(sp)
    80007520:	6522                	ld	a0,8(sp)
    80007522:	9782                	jalr	a5
    80007524:	a015                	j	80007548 <handle_trap+0xa4>
	}
	else{
		log_debug("Source of Trap: Software\n");
    80007526:	00003517          	auipc	a0,0x3
    8000752a:	30250513          	addi	a0,a0,770 # 8000a828 <__rodata_start+0x14d0>
    8000752e:	e65ff0ef          	jal	ra,80007392 <log_debug>

		mcause_trap_table[mcause](mcause, epc);
    80007532:	00100717          	auipc	a4,0x100
    80007536:	c8670713          	addi	a4,a4,-890 # 801071b8 <mcause_trap_table>
    8000753a:	67a2                	ld	a5,8(sp)
    8000753c:	078e                	slli	a5,a5,0x3
    8000753e:	97ba                	add	a5,a5,a4
    80007540:	639c                	ld	a5,0(a5)
    80007542:	6582                	ld	a1,0(sp)
    80007544:	6522                	ld	a0,8(sp)
    80007546:	9782                	jalr	a5
	}

	log_trace("handle_trap exited\n");
    80007548:	00003517          	auipc	a0,0x3
    8000754c:	30050513          	addi	a0,a0,768 # 8000a848 <__rodata_start+0x14f0>
    80007550:	df9ff0ef          	jal	ra,80007348 <log_trace>

return epc;
    80007554:	6782                	ld	a5,0(sp)
}
    80007556:	853e                	mv	a0,a5
    80007558:	70a2                	ld	ra,40(sp)
    8000755a:	6145                	addi	sp,sp,48
    8000755c:	8082                	ret

000000008000755e <section_init>:
		*stack_end=0x0;
		stack_end--;
	}
#endif

}
    8000755e:	0001                	nop
    80007560:	8082                	ret

0000000080007562 <trap_init>:
 * @brief Initialize the trap/interrupt callback routines with user defined handler.
 * @details Assign default handler for trap / interrupt that does not have user defined
 *          callback routines"
 */
static void trap_init(void)
{
    80007562:	1141                	addi	sp,sp,-16
    80007564:	e406                	sd	ra,8(sp)
	log_trace("trap_init entered \n ");
    80007566:	00003517          	auipc	a0,0x3
    8000756a:	2fa50513          	addi	a0,a0,762 # 8000a860 <__rodata_start+0x1508>
    8000756e:	ddbff0ef          	jal	ra,80007348 <log_trace>

	mcause_interrupt_table[USER_SW_INTERRUPT]        = default_handler;
    80007572:	00100797          	auipc	a5,0x100
    80007576:	bc678793          	addi	a5,a5,-1082 # 80107138 <mcause_interrupt_table>
    8000757a:	00000717          	auipc	a4,0x0
    8000757e:	f1470713          	addi	a4,a4,-236 # 8000748e <default_handler>
    80007582:	e398                	sd	a4,0(a5)
	mcause_interrupt_table[SUPER_SW_INTERRUPT]       = default_handler;
    80007584:	00100797          	auipc	a5,0x100
    80007588:	bb478793          	addi	a5,a5,-1100 # 80107138 <mcause_interrupt_table>
    8000758c:	00000717          	auipc	a4,0x0
    80007590:	f0270713          	addi	a4,a4,-254 # 8000748e <default_handler>
    80007594:	e798                	sd	a4,8(a5)
	mcause_interrupt_table[RESERVED_INTERRUPT0]      = default_handler;
    80007596:	00100797          	auipc	a5,0x100
    8000759a:	ba278793          	addi	a5,a5,-1118 # 80107138 <mcause_interrupt_table>
    8000759e:	00000717          	auipc	a4,0x0
    800075a2:	ef070713          	addi	a4,a4,-272 # 8000748e <default_handler>
    800075a6:	eb98                	sd	a4,16(a5)
	mcause_interrupt_table[MACH_SW_INTERRUPT]        = default_handler;
    800075a8:	00100797          	auipc	a5,0x100
    800075ac:	b9078793          	addi	a5,a5,-1136 # 80107138 <mcause_interrupt_table>
    800075b0:	00000717          	auipc	a4,0x0
    800075b4:	ede70713          	addi	a4,a4,-290 # 8000748e <default_handler>
    800075b8:	ef98                	sd	a4,24(a5)
	mcause_interrupt_table[USER_TIMER_INTERRUPT]     = default_handler;
    800075ba:	00100797          	auipc	a5,0x100
    800075be:	b7e78793          	addi	a5,a5,-1154 # 80107138 <mcause_interrupt_table>
    800075c2:	00000717          	auipc	a4,0x0
    800075c6:	ecc70713          	addi	a4,a4,-308 # 8000748e <default_handler>
    800075ca:	f398                	sd	a4,32(a5)
	mcause_interrupt_table[SUPER_TIMER_INTERRUPT]    = default_handler;
    800075cc:	00100797          	auipc	a5,0x100
    800075d0:	b6c78793          	addi	a5,a5,-1172 # 80107138 <mcause_interrupt_table>
    800075d4:	00000717          	auipc	a4,0x0
    800075d8:	eba70713          	addi	a4,a4,-326 # 8000748e <default_handler>
    800075dc:	f798                	sd	a4,40(a5)
	mcause_interrupt_table[RESERVED_INTERRUPT1]      = default_handler;
    800075de:	00100797          	auipc	a5,0x100
    800075e2:	b5a78793          	addi	a5,a5,-1190 # 80107138 <mcause_interrupt_table>
    800075e6:	00000717          	auipc	a4,0x0
    800075ea:	ea870713          	addi	a4,a4,-344 # 8000748e <default_handler>
    800075ee:	fb98                	sd	a4,48(a5)
	mcause_interrupt_table[MACH_TIMER_INTERRUPT]     = mach_clint_handler;
    800075f0:	00100797          	auipc	a5,0x100
    800075f4:	b4878793          	addi	a5,a5,-1208 # 80107138 <mcause_interrupt_table>
    800075f8:	ffffe717          	auipc	a4,0xffffe
    800075fc:	95870713          	addi	a4,a4,-1704 # 80004f50 <mach_clint_handler>
    80007600:	ff98                	sd	a4,56(a5)
	mcause_interrupt_table[USER_EXT_INTERRUPT]       = default_handler;
    80007602:	00100797          	auipc	a5,0x100
    80007606:	b3678793          	addi	a5,a5,-1226 # 80107138 <mcause_interrupt_table>
    8000760a:	00000717          	auipc	a4,0x0
    8000760e:	e8470713          	addi	a4,a4,-380 # 8000748e <default_handler>
    80007612:	e3b8                	sd	a4,64(a5)
	mcause_interrupt_table[SUPERVISOR_EXT_INTERRUPT] = default_handler;
    80007614:	00100797          	auipc	a5,0x100
    80007618:	b2478793          	addi	a5,a5,-1244 # 80107138 <mcause_interrupt_table>
    8000761c:	00000717          	auipc	a4,0x0
    80007620:	e7270713          	addi	a4,a4,-398 # 8000748e <default_handler>
    80007624:	e7b8                	sd	a4,72(a5)
	mcause_interrupt_table[RESERVED_INTERRUPT2]      = default_handler;
    80007626:	00100797          	auipc	a5,0x100
    8000762a:	b1278793          	addi	a5,a5,-1262 # 80107138 <mcause_interrupt_table>
    8000762e:	00000717          	auipc	a4,0x0
    80007632:	e6070713          	addi	a4,a4,-416 # 8000748e <default_handler>
    80007636:	ebb8                	sd	a4,80(a5)
	mcause_interrupt_table[MACH_EXTERNAL_INTERRUPT]  = mach_plic_handler;
    80007638:	00100797          	auipc	a5,0x100
    8000763c:	b0078793          	addi	a5,a5,-1280 # 80107138 <mcause_interrupt_table>
    80007640:	fffff717          	auipc	a4,0xfffff
    80007644:	a0470713          	addi	a4,a4,-1532 # 80006044 <mach_plic_handler>
    80007648:	efb8                	sd	a4,88(a5)
	mcause_interrupt_table[RESERVED_INTERRUPT3]      = default_handler;
    8000764a:	00100797          	auipc	a5,0x100
    8000764e:	aee78793          	addi	a5,a5,-1298 # 80107138 <mcause_interrupt_table>
    80007652:	00000717          	auipc	a4,0x0
    80007656:	e3c70713          	addi	a4,a4,-452 # 8000748e <default_handler>
    8000765a:	f3b8                	sd	a4,96(a5)
	mcause_interrupt_table[RESERVED_INTERRUPT4]      = default_handler;
    8000765c:	00100797          	auipc	a5,0x100
    80007660:	adc78793          	addi	a5,a5,-1316 # 80107138 <mcause_interrupt_table>
    80007664:	00000717          	auipc	a4,0x0
    80007668:	e2a70713          	addi	a4,a4,-470 # 8000748e <default_handler>
    8000766c:	f7b8                	sd	a4,104(a5)
	mcause_interrupt_table[RESERVED_INTERRUPT5]      = default_handler;
    8000766e:	00100797          	auipc	a5,0x100
    80007672:	aca78793          	addi	a5,a5,-1334 # 80107138 <mcause_interrupt_table>
    80007676:	00000717          	auipc	a4,0x0
    8000767a:	e1870713          	addi	a4,a4,-488 # 8000748e <default_handler>
    8000767e:	fbb8                	sd	a4,112(a5)
	mcause_interrupt_table[RESERVED_INTERRUPT6]      = default_handler;
    80007680:	00100797          	auipc	a5,0x100
    80007684:	ab878793          	addi	a5,a5,-1352 # 80107138 <mcause_interrupt_table>
    80007688:	00000717          	auipc	a4,0x0
    8000768c:	e0670713          	addi	a4,a4,-506 # 8000748e <default_handler>
    80007690:	ffb8                	sd	a4,120(a5)

	mcause_trap_table[INSTRUCTION_ADDRESS_MISALIGNED] =
    80007692:	00100797          	auipc	a5,0x100
    80007696:	b2678793          	addi	a5,a5,-1242 # 801071b8 <mcause_trap_table>
    8000769a:	00000717          	auipc	a4,0x0
    8000769e:	df470713          	addi	a4,a4,-524 # 8000748e <default_handler>
    800076a2:	e398                	sd	a4,0(a5)
		default_handler;
	mcause_trap_table[INSTRUCTION_ACCESS_FAULT] =
    800076a4:	00100797          	auipc	a5,0x100
    800076a8:	b1478793          	addi	a5,a5,-1260 # 801071b8 <mcause_trap_table>
    800076ac:	00000717          	auipc	a4,0x0
    800076b0:	de270713          	addi	a4,a4,-542 # 8000748e <default_handler>
    800076b4:	e798                	sd	a4,8(a5)
		default_handler;
	mcause_trap_table[ILLEGAL_INSTRUCTION] =
    800076b6:	00100797          	auipc	a5,0x100
    800076ba:	b0278793          	addi	a5,a5,-1278 # 801071b8 <mcause_trap_table>
    800076be:	00000717          	auipc	a4,0x0
    800076c2:	dd070713          	addi	a4,a4,-560 # 8000748e <default_handler>
    800076c6:	eb98                	sd	a4,16(a5)
		default_handler;
	mcause_trap_table[BREAKPOINT] =
    800076c8:	00100797          	auipc	a5,0x100
    800076cc:	af078793          	addi	a5,a5,-1296 # 801071b8 <mcause_trap_table>
    800076d0:	00000717          	auipc	a4,0x0
    800076d4:	dbe70713          	addi	a4,a4,-578 # 8000748e <default_handler>
    800076d8:	ef98                	sd	a4,24(a5)
		default_handler;
	mcause_trap_table[LOAD_ADDRESS_MISALIGNED] =
    800076da:	00100797          	auipc	a5,0x100
    800076de:	ade78793          	addi	a5,a5,-1314 # 801071b8 <mcause_trap_table>
    800076e2:	00000717          	auipc	a4,0x0
    800076e6:	dac70713          	addi	a4,a4,-596 # 8000748e <default_handler>
    800076ea:	f398                	sd	a4,32(a5)
		default_handler;
	mcause_trap_table[LOAD_ACCESS_FAULT] =
    800076ec:	00100797          	auipc	a5,0x100
    800076f0:	acc78793          	addi	a5,a5,-1332 # 801071b8 <mcause_trap_table>
    800076f4:	00000717          	auipc	a4,0x0
    800076f8:	d9a70713          	addi	a4,a4,-614 # 8000748e <default_handler>
    800076fc:	f798                	sd	a4,40(a5)
		default_handler;
	mcause_trap_table[STORE_AMO_ADDRESS_MISALIGNED] =
    800076fe:	00100797          	auipc	a5,0x100
    80007702:	aba78793          	addi	a5,a5,-1350 # 801071b8 <mcause_trap_table>
    80007706:	00000717          	auipc	a4,0x0
    8000770a:	d8870713          	addi	a4,a4,-632 # 8000748e <default_handler>
    8000770e:	fb98                	sd	a4,48(a5)
		default_handler;
	mcause_trap_table[STORE_AMO_ACCESS_FAULT] =
    80007710:	00100797          	auipc	a5,0x100
    80007714:	aa878793          	addi	a5,a5,-1368 # 801071b8 <mcause_trap_table>
    80007718:	00000717          	auipc	a4,0x0
    8000771c:	d7670713          	addi	a4,a4,-650 # 8000748e <default_handler>
    80007720:	ff98                	sd	a4,56(a5)
		default_handler;
	mcause_trap_table[ENVIRONMENT_CALL_FROM_U_MODE] =
    80007722:	00100797          	auipc	a5,0x100
    80007726:	a9678793          	addi	a5,a5,-1386 # 801071b8 <mcause_trap_table>
    8000772a:	00000717          	auipc	a4,0x0
    8000772e:	d6470713          	addi	a4,a4,-668 # 8000748e <default_handler>
    80007732:	e3b8                	sd	a4,64(a5)
		default_handler;
	mcause_trap_table[ENVIRONMENT_CALL_FROM_S_MODE] =
    80007734:	00100797          	auipc	a5,0x100
    80007738:	a8478793          	addi	a5,a5,-1404 # 801071b8 <mcause_trap_table>
    8000773c:	00000717          	auipc	a4,0x0
    80007740:	d5270713          	addi	a4,a4,-686 # 8000748e <default_handler>
    80007744:	e7b8                	sd	a4,72(a5)
		default_handler;
	mcause_trap_table[RESERVED_TRAP1] =
    80007746:	00100797          	auipc	a5,0x100
    8000774a:	a7278793          	addi	a5,a5,-1422 # 801071b8 <mcause_trap_table>
    8000774e:	00000717          	auipc	a4,0x0
    80007752:	d4070713          	addi	a4,a4,-704 # 8000748e <default_handler>
    80007756:	ebb8                	sd	a4,80(a5)
		default_handler;
	mcause_trap_table[ENVIRONMENT_CALL_FROM_M_MODE] =
    80007758:	00100797          	auipc	a5,0x100
    8000775c:	a6078793          	addi	a5,a5,-1440 # 801071b8 <mcause_trap_table>
    80007760:	00000717          	auipc	a4,0x0
    80007764:	d2e70713          	addi	a4,a4,-722 # 8000748e <default_handler>
    80007768:	efb8                	sd	a4,88(a5)
		default_handler;
	mcause_trap_table[INSTRUCTION_PAGE_FAULT] =
    8000776a:	00100797          	auipc	a5,0x100
    8000776e:	a4e78793          	addi	a5,a5,-1458 # 801071b8 <mcause_trap_table>
    80007772:	00000717          	auipc	a4,0x0
    80007776:	d1c70713          	addi	a4,a4,-740 # 8000748e <default_handler>
    8000777a:	f3b8                	sd	a4,96(a5)
		default_handler;
	mcause_trap_table[LOAD_PAGE_FAULT] =
    8000777c:	00100797          	auipc	a5,0x100
    80007780:	a3c78793          	addi	a5,a5,-1476 # 801071b8 <mcause_trap_table>
    80007784:	00000717          	auipc	a4,0x0
    80007788:	d0a70713          	addi	a4,a4,-758 # 8000748e <default_handler>
    8000778c:	f7b8                	sd	a4,104(a5)
		default_handler;
	mcause_trap_table[RESERVED_TRAP2] =
    8000778e:	00100797          	auipc	a5,0x100
    80007792:	a2a78793          	addi	a5,a5,-1494 # 801071b8 <mcause_trap_table>
    80007796:	00000717          	auipc	a4,0x0
    8000779a:	cf870713          	addi	a4,a4,-776 # 8000748e <default_handler>
    8000779e:	fbb8                	sd	a4,112(a5)
		default_handler;
	mcause_trap_table[STORE_AMO_PAGE_FAULT] =
    800077a0:	00100797          	auipc	a5,0x100
    800077a4:	a1878793          	addi	a5,a5,-1512 # 801071b8 <mcause_trap_table>
    800077a8:	00000717          	auipc	a4,0x0
    800077ac:	ce670713          	addi	a4,a4,-794 # 8000748e <default_handler>
    800077b0:	ffb8                	sd	a4,120(a5)
		default_handler;

	log_trace("trap_init exited \n ");
    800077b2:	00003517          	auipc	a0,0x3
    800077b6:	0c650513          	addi	a0,a0,198 # 8000a878 <__rodata_start+0x1520>
    800077ba:	b8fff0ef          	jal	ra,80007348 <log_trace>
}
    800077be:	0001                	nop
    800077c0:	60a2                	ld	ra,8(sp)
    800077c2:	0141                	addi	sp,sp,16
    800077c4:	8082                	ret

00000000800077c6 <init>:

/** @fn void init(void)
 * @brief initialize the necessary variables for system start
 */
void init(void)
{
    800077c6:	1141                	addi	sp,sp,-16
    800077c8:	e406                	sd	ra,8(sp)
//	section_init(); // uncomment on need basis
	uart_init();
    800077ca:	caafd0ef          	jal	ra,80004c74 <uart_init>

	log_trace("init entered \n ");
    800077ce:	00003517          	auipc	a0,0x3
    800077d2:	0c250513          	addi	a0,a0,194 # 8000a890 <__rodata_start+0x1538>
    800077d6:	b73ff0ef          	jal	ra,80007348 <log_trace>
#ifdef AARDONYX
	micron_disable_xip_volatile(0,0);
	flashMemInit();
#endif

	trap_init();
    800077da:	d89ff0ef          	jal	ra,80007562 <trap_init>

	main();
    800077de:	75c000ef          	jal	ra,80007f3a <main>

	log_trace("init exited\n");
    800077e2:	00003517          	auipc	a0,0x3
    800077e6:	0be50513          	addi	a0,a0,190 # 8000a8a0 <__rodata_start+0x1548>
    800077ea:	b5fff0ef          	jal	ra,80007348 <log_trace>
}
    800077ee:	0001                	nop
    800077f0:	60a2                	ld	ra,8(sp)
    800077f2:	0141                	addi	sp,sp,16
    800077f4:	8082                	ret

00000000800077f6 <read_bmp280_register>:
 * @param uint32_t *readTemp  Reading the temperature value.
 * @param uint32_t delay  Used delay for I2C functionality.
 * @return It returns the value to the main.
 */
int read_bmp280_register(i2c_struct *instance, uint32_t reg_offset, uint32_t *readTemp, uint32_t delay)
{
    800077f6:	7139                	addi	sp,sp,-64
    800077f8:	fc06                	sd	ra,56(sp)
    800077fa:	ec2a                	sd	a0,24(sp)
    800077fc:	87ae                	mv	a5,a1
    800077fe:	e432                	sd	a2,8(sp)
    80007800:	8736                	mv	a4,a3
    80007802:	ca3e                	sw	a5,20(sp)
    80007804:	87ba                	mv	a5,a4
    80007806:	c83e                	sw	a5,16(sp)
	unsigned char read_buf[4] = {'\0'};
    80007808:	d402                	sw	zero,40(sp)
	unsigned char temp = 0;
    8000780a:	020103a3          	sb	zero,39(sp)

	//Writes the slave address for write
	i2c_send_slave_address(instance, BMP280_SLAVE_ADDRESS, I2C_WRITE, 800);
    8000780e:	32000693          	li	a3,800
    80007812:	4601                	li	a2,0
    80007814:	0ec00593          	li	a1,236
    80007818:	6562                	ld	a0,24(sp)
    8000781a:	aa6fe0ef          	jal	ra,80005ac0 <i2c_send_slave_address>

	//Writes the pointer to address that needs to be read
	i2c_write_data(instance, reg_offset , delay);
    8000781e:	47d2                	lw	a5,20(sp)
    80007820:	0ff7f793          	andi	a5,a5,255
    80007824:	4742                	lw	a4,16(sp)
    80007826:	0ff77713          	andi	a4,a4,255
    8000782a:	863a                	mv	a2,a4
    8000782c:	85be                	mv	a1,a5
    8000782e:	6562                	ld	a0,24(sp)
    80007830:	baefe0ef          	jal	ra,80005bde <i2c_write_data>

	//Stops the I2C transaction to start reading the temperature value.
	instance->control = I2C_STOP;
    80007834:	67e2                	ld	a5,24(sp)
    80007836:	0c300713          	li	a4,195
    8000783a:	c798                	sw	a4,8(a5)

	//Writes the slave address for read
	i2c_send_slave_address(instance, BMP280_SLAVE_ADDRESS, I2C_READ, 800);
    8000783c:	32000693          	li	a3,800
    80007840:	4605                	li	a2,1
    80007842:	0ec00593          	li	a1,236
    80007846:	6562                	ld	a0,24(sp)
    80007848:	a78fe0ef          	jal	ra,80005ac0 <i2c_send_slave_address>

	/* Make a dummy read as per spec of the I2C controller */
	i2c_read_data(instance, &temp, delay);
    8000784c:	47c2                	lw	a5,16(sp)
    8000784e:	0ff7f713          	andi	a4,a5,255
    80007852:	02710793          	addi	a5,sp,39
    80007856:	863a                	mv	a2,a4
    80007858:	85be                	mv	a1,a5
    8000785a:	6562                	ld	a0,24(sp)
    8000785c:	bfcfe0ef          	jal	ra,80005c58 <i2c_read_data>
	instance->control = I2C_NACK;
    80007860:	67e2                	ld	a5,24(sp)
    80007862:	04000713          	li	a4,64
    80007866:	c798                	sw	a4,8(a5)

	//Reads the MSB Byte of temperature [D9 - D1]
	i2c_read_data(instance, &read_buf[0], delay);
    80007868:	47c2                	lw	a5,16(sp)
    8000786a:	0ff7f713          	andi	a4,a5,255
    8000786e:	103c                	addi	a5,sp,40
    80007870:	863a                	mv	a2,a4
    80007872:	85be                	mv	a1,a5
    80007874:	6562                	ld	a0,24(sp)
    80007876:	be2fe0ef          	jal	ra,80005c58 <i2c_read_data>

	instance->control = I2C_STOP;
    8000787a:	67e2                	ld	a5,24(sp)
    8000787c:	0c300713          	li	a4,195
    80007880:	c798                	sw	a4,8(a5)
	*readTemp = read_buf[0] ;
    80007882:	02814783          	lbu	a5,40(sp)
    80007886:	0007871b          	sext.w	a4,a5
    8000788a:	67a2                	ld	a5,8(sp)
    8000788c:	c398                	sw	a4,0(a5)
	return 0;
    8000788e:	4781                	li	a5,0
}
    80007890:	853e                	mv	a0,a5
    80007892:	70e2                	ld	ra,56(sp)
    80007894:	6121                	addi	sp,sp,64
    80007896:	8082                	ret

0000000080007898 <read_bmp280_values>:
 * @param uint32_t *temperature  Reading the temperature value.
 * @param uint32_t delay  Used delay for I2C functionality.
 */
int read_bmp280_values(i2c_struct * instance, uint32_t reg_offset,
		       uint32_t *pressure, uint32_t *temperature, uint32_t delay)
{
    80007898:	711d                	addi	sp,sp,-96
    8000789a:	ec86                	sd	ra,88(sp)
    8000789c:	ec2a                	sd	a0,24(sp)
    8000789e:	87ae                	mv	a5,a1
    800078a0:	e432                	sd	a2,8(sp)
    800078a2:	e036                	sd	a3,0(sp)
    800078a4:	ca3e                	sw	a5,20(sp)
    800078a6:	87ba                	mv	a5,a4
    800078a8:	c83e                	sw	a5,16(sp)
	unsigned char read_buf[6] = {'\0'};
    800078aa:	d402                	sw	zero,40(sp)
    800078ac:	02011623          	sh	zero,44(sp)
	int32_t adc_P, adc_T, var1, var2, t_fine; 
	int32_t temp;
	int32_t p;

	//Writes the slave address for write
	i2c_send_slave_address(instance, BMP280_SLAVE_ADDRESS, I2C_WRITE, 800);
    800078b0:	32000693          	li	a3,800
    800078b4:	4601                	li	a2,0
    800078b6:	0ec00593          	li	a1,236
    800078ba:	6562                	ld	a0,24(sp)
    800078bc:	a04fe0ef          	jal	ra,80005ac0 <i2c_send_slave_address>

	//Writes the pointer to address that needs to be read
	i2c_write_data(instance, reg_offset , delay);
    800078c0:	47d2                	lw	a5,20(sp)
    800078c2:	0ff7f793          	andi	a5,a5,255
    800078c6:	4742                	lw	a4,16(sp)
    800078c8:	0ff77713          	andi	a4,a4,255
    800078cc:	863a                	mv	a2,a4
    800078ce:	85be                	mv	a1,a5
    800078d0:	6562                	ld	a0,24(sp)
    800078d2:	b0cfe0ef          	jal	ra,80005bde <i2c_write_data>

	//Stops the I2C transaction to start reading the temperature value.
	instance->control = I2C_STOP;
    800078d6:	67e2                	ld	a5,24(sp)
    800078d8:	0c300713          	li	a4,195
    800078dc:	c798                	sw	a4,8(a5)

	//Writes the slave address for read
	i2c_send_slave_address(instance, BMP280_SLAVE_ADDRESS, I2C_READ, 800);
    800078de:	32000693          	li	a3,800
    800078e2:	4605                	li	a2,1
    800078e4:	0ec00593          	li	a1,236
    800078e8:	6562                	ld	a0,24(sp)
    800078ea:	9d6fe0ef          	jal	ra,80005ac0 <i2c_send_slave_address>

	/* Make a dummy read as per spec of the I2C controller */
	i2c_read_data(instance, read_buf, delay);
    800078ee:	47c2                	lw	a5,16(sp)
    800078f0:	0ff7f713          	andi	a4,a5,255
    800078f4:	103c                	addi	a5,sp,40
    800078f6:	863a                	mv	a2,a4
    800078f8:	85be                	mv	a1,a5
    800078fa:	6562                	ld	a0,24(sp)
    800078fc:	b5cfe0ef          	jal	ra,80005c58 <i2c_read_data>

	//Read Pressure
	i2c_read_data(instance, &read_buf[0], delay);
    80007900:	47c2                	lw	a5,16(sp)
    80007902:	0ff7f713          	andi	a4,a5,255
    80007906:	103c                	addi	a5,sp,40
    80007908:	863a                	mv	a2,a4
    8000790a:	85be                	mv	a1,a5
    8000790c:	6562                	ld	a0,24(sp)
    8000790e:	b4afe0ef          	jal	ra,80005c58 <i2c_read_data>
	i2c_read_data(instance, &read_buf[1], delay);
    80007912:	47c2                	lw	a5,16(sp)
    80007914:	0ff7f713          	andi	a4,a5,255
    80007918:	103c                	addi	a5,sp,40
    8000791a:	0785                	addi	a5,a5,1
    8000791c:	863a                	mv	a2,a4
    8000791e:	85be                	mv	a1,a5
    80007920:	6562                	ld	a0,24(sp)
    80007922:	b36fe0ef          	jal	ra,80005c58 <i2c_read_data>
	i2c_read_data(instance, &read_buf[2], delay);
    80007926:	47c2                	lw	a5,16(sp)
    80007928:	0ff7f713          	andi	a4,a5,255
    8000792c:	103c                	addi	a5,sp,40
    8000792e:	0789                	addi	a5,a5,2
    80007930:	863a                	mv	a2,a4
    80007932:	85be                	mv	a1,a5
    80007934:	6562                	ld	a0,24(sp)
    80007936:	b22fe0ef          	jal	ra,80005c58 <i2c_read_data>

	//Read Temperature	
	i2c_read_data(instance, &read_buf[3], delay);
    8000793a:	47c2                	lw	a5,16(sp)
    8000793c:	0ff7f713          	andi	a4,a5,255
    80007940:	103c                	addi	a5,sp,40
    80007942:	078d                	addi	a5,a5,3
    80007944:	863a                	mv	a2,a4
    80007946:	85be                	mv	a1,a5
    80007948:	6562                	ld	a0,24(sp)
    8000794a:	b0efe0ef          	jal	ra,80005c58 <i2c_read_data>
	i2c_read_data(instance, &read_buf[4], delay);
    8000794e:	47c2                	lw	a5,16(sp)
    80007950:	0ff7f713          	andi	a4,a5,255
    80007954:	103c                	addi	a5,sp,40
    80007956:	0791                	addi	a5,a5,4
    80007958:	863a                	mv	a2,a4
    8000795a:	85be                	mv	a1,a5
    8000795c:	6562                	ld	a0,24(sp)
    8000795e:	afafe0ef          	jal	ra,80005c58 <i2c_read_data>
	instance->control = I2C_NACK;
    80007962:	67e2                	ld	a5,24(sp)
    80007964:	04000713          	li	a4,64
    80007968:	c798                	sw	a4,8(a5)
	i2c_read_data(instance, &read_buf[5], delay);
    8000796a:	47c2                	lw	a5,16(sp)
    8000796c:	0ff7f713          	andi	a4,a5,255
    80007970:	103c                	addi	a5,sp,40
    80007972:	0795                	addi	a5,a5,5
    80007974:	863a                	mv	a2,a4
    80007976:	85be                	mv	a1,a5
    80007978:	6562                	ld	a0,24(sp)
    8000797a:	adefe0ef          	jal	ra,80005c58 <i2c_read_data>

	instance->control = I2C_STOP;
    8000797e:	67e2                	ld	a5,24(sp)
    80007980:	0c300713          	li	a4,195
    80007984:	c798                	sw	a4,8(a5)
	adc_P = ((read_buf[0] << 12) | (read_buf[1] << 4) | (read_buf[2] >> 4));
    80007986:	02814783          	lbu	a5,40(sp)
    8000798a:	2781                	sext.w	a5,a5
    8000798c:	00c7979b          	slliw	a5,a5,0xc
    80007990:	0007871b          	sext.w	a4,a5
    80007994:	02914783          	lbu	a5,41(sp)
    80007998:	2781                	sext.w	a5,a5
    8000799a:	0047979b          	slliw	a5,a5,0x4
    8000799e:	2781                	sext.w	a5,a5
    800079a0:	8fd9                	or	a5,a5,a4
    800079a2:	0007871b          	sext.w	a4,a5
    800079a6:	02a14783          	lbu	a5,42(sp)
    800079aa:	0047d79b          	srliw	a5,a5,0x4
    800079ae:	0ff7f793          	andi	a5,a5,255
    800079b2:	2781                	sext.w	a5,a5
    800079b4:	8fd9                	or	a5,a5,a4
    800079b6:	c6be                	sw	a5,76(sp)
	adc_T = ((read_buf[3] << 12) | (read_buf[4] << 4) | (read_buf[5] >> 4));
    800079b8:	02b14783          	lbu	a5,43(sp)
    800079bc:	2781                	sext.w	a5,a5
    800079be:	00c7979b          	slliw	a5,a5,0xc
    800079c2:	0007871b          	sext.w	a4,a5
    800079c6:	02c14783          	lbu	a5,44(sp)
    800079ca:	2781                	sext.w	a5,a5
    800079cc:	0047979b          	slliw	a5,a5,0x4
    800079d0:	2781                	sext.w	a5,a5
    800079d2:	8fd9                	or	a5,a5,a4
    800079d4:	0007871b          	sext.w	a4,a5
    800079d8:	02d14783          	lbu	a5,45(sp)
    800079dc:	0047d79b          	srliw	a5,a5,0x4
    800079e0:	0ff7f793          	andi	a5,a5,255
    800079e4:	2781                	sext.w	a5,a5
    800079e6:	8fd9                	or	a5,a5,a4
    800079e8:	c4be                	sw	a5,72(sp)

	// Calculate TEMPERATURE
	var1 = ((((adc_T / 8) - ((int32_t)bmp280_calib_dig_T1 * 2))) * ((int32_t)bmp280_calib_dig_T2)) / 2048;
    800079ea:	47a6                	lw	a5,72(sp)
    800079ec:	41f7d71b          	sraiw	a4,a5,0x1f
    800079f0:	01d7571b          	srliw	a4,a4,0x1d
    800079f4:	9fb9                	addw	a5,a5,a4
    800079f6:	4037d79b          	sraiw	a5,a5,0x3
    800079fa:	0007871b          	sext.w	a4,a5
    800079fe:	00100797          	auipc	a5,0x100
    80007a02:	83e78793          	addi	a5,a5,-1986 # 8010723c <bmp280_calib_dig_T1>
    80007a06:	0007d783          	lhu	a5,0(a5)
    80007a0a:	2781                	sext.w	a5,a5
    80007a0c:	0017979b          	slliw	a5,a5,0x1
    80007a10:	2781                	sext.w	a5,a5
    80007a12:	40f707bb          	subw	a5,a4,a5
    80007a16:	0007871b          	sext.w	a4,a5
    80007a1a:	00100797          	auipc	a5,0x100
    80007a1e:	83478793          	addi	a5,a5,-1996 # 8010724e <bmp280_calib_dig_T2>
    80007a22:	00079783          	lh	a5,0(a5)
    80007a26:	2781                	sext.w	a5,a5
    80007a28:	02f707bb          	mulw	a5,a4,a5
    80007a2c:	2781                	sext.w	a5,a5
    80007a2e:	41f7d71b          	sraiw	a4,a5,0x1f
    80007a32:	0157571b          	srliw	a4,a4,0x15
    80007a36:	9fb9                	addw	a5,a5,a4
    80007a38:	40b7d79b          	sraiw	a5,a5,0xb
    80007a3c:	c2be                	sw	a5,68(sp)
	var2 = (((((adc_T / 16) - ((int32_t)bmp280_calib_dig_T1)) * ((adc_T / 16) - ((int32_t)bmp280_calib_dig_T1))) / 4096) * ((int32_t)bmp280_calib_dig_T3)) / 16384;
    80007a3e:	47a6                	lw	a5,72(sp)
    80007a40:	41f7d71b          	sraiw	a4,a5,0x1f
    80007a44:	01c7571b          	srliw	a4,a4,0x1c
    80007a48:	9fb9                	addw	a5,a5,a4
    80007a4a:	4047d79b          	sraiw	a5,a5,0x4
    80007a4e:	0007871b          	sext.w	a4,a5
    80007a52:	000ff797          	auipc	a5,0xff
    80007a56:	7ea78793          	addi	a5,a5,2026 # 8010723c <bmp280_calib_dig_T1>
    80007a5a:	0007d783          	lhu	a5,0(a5)
    80007a5e:	2781                	sext.w	a5,a5
    80007a60:	40f707bb          	subw	a5,a4,a5
    80007a64:	0007871b          	sext.w	a4,a5
    80007a68:	47a6                	lw	a5,72(sp)
    80007a6a:	41f7d69b          	sraiw	a3,a5,0x1f
    80007a6e:	01c6d69b          	srliw	a3,a3,0x1c
    80007a72:	9fb5                	addw	a5,a5,a3
    80007a74:	4047d79b          	sraiw	a5,a5,0x4
    80007a78:	0007869b          	sext.w	a3,a5
    80007a7c:	000ff797          	auipc	a5,0xff
    80007a80:	7c078793          	addi	a5,a5,1984 # 8010723c <bmp280_calib_dig_T1>
    80007a84:	0007d783          	lhu	a5,0(a5)
    80007a88:	2781                	sext.w	a5,a5
    80007a8a:	40f687bb          	subw	a5,a3,a5
    80007a8e:	2781                	sext.w	a5,a5
    80007a90:	02f707bb          	mulw	a5,a4,a5
    80007a94:	2781                	sext.w	a5,a5
    80007a96:	41f7d71b          	sraiw	a4,a5,0x1f
    80007a9a:	0147571b          	srliw	a4,a4,0x14
    80007a9e:	9fb9                	addw	a5,a5,a4
    80007aa0:	40c7d79b          	sraiw	a5,a5,0xc
    80007aa4:	0007871b          	sext.w	a4,a5
    80007aa8:	000ff797          	auipc	a5,0xff
    80007aac:	79678793          	addi	a5,a5,1942 # 8010723e <bmp280_calib_dig_T3>
    80007ab0:	00079783          	lh	a5,0(a5)
    80007ab4:	2781                	sext.w	a5,a5
    80007ab6:	02f707bb          	mulw	a5,a4,a5
    80007aba:	2781                	sext.w	a5,a5
    80007abc:	41f7d71b          	sraiw	a4,a5,0x1f
    80007ac0:	0127571b          	srliw	a4,a4,0x12
    80007ac4:	9fb9                	addw	a5,a5,a4
    80007ac6:	40e7d79b          	sraiw	a5,a5,0xe
    80007aca:	c0be                	sw	a5,64(sp)
	t_fine = var1 + var2;
    80007acc:	4716                	lw	a4,68(sp)
    80007ace:	4786                	lw	a5,64(sp)
    80007ad0:	9fb9                	addw	a5,a5,a4
    80007ad2:	de3e                	sw	a5,60(sp)

	temp = (t_fine * 5 + 128) / 256;
    80007ad4:	5772                	lw	a4,60(sp)
    80007ad6:	87ba                	mv	a5,a4
    80007ad8:	0027979b          	slliw	a5,a5,0x2
    80007adc:	9fb9                	addw	a5,a5,a4
    80007ade:	2781                	sext.w	a5,a5
    80007ae0:	0807879b          	addiw	a5,a5,128
    80007ae4:	2781                	sext.w	a5,a5
    80007ae6:	41f7d71b          	sraiw	a4,a5,0x1f
    80007aea:	0187571b          	srliw	a4,a4,0x18
    80007aee:	9fb9                	addw	a5,a5,a4
    80007af0:	4087d79b          	sraiw	a5,a5,0x8
    80007af4:	dc3e                	sw	a5,56(sp)
	*temperature = temp;
    80007af6:	5762                	lw	a4,56(sp)
    80007af8:	6782                	ld	a5,0(sp)
    80007afa:	c398                	sw	a4,0(a5)

	printf("\nTemperature Value:%u.%u °C", (temp/100),(temp%100));
    80007afc:	5762                	lw	a4,56(sp)
    80007afe:	06400793          	li	a5,100
    80007b02:	02f747bb          	divw	a5,a4,a5
    80007b06:	0007869b          	sext.w	a3,a5
    80007b0a:	5762                	lw	a4,56(sp)
    80007b0c:	06400793          	li	a5,100
    80007b10:	02f767bb          	remw	a5,a4,a5
    80007b14:	2781                	sext.w	a5,a5
    80007b16:	863e                	mv	a2,a5
    80007b18:	85b6                	mv	a1,a3
    80007b1a:	00003517          	auipc	a0,0x3
    80007b1e:	d9650513          	addi	a0,a0,-618 # 8000a8b0 <__rodata_start+0x1558>
    80007b22:	ff2ff0ef          	jal	ra,80007314 <printf>

	//Calculate Pressure
	var1 = 0; 
    80007b26:	c282                	sw	zero,68(sp)
	var2 = 0;
    80007b28:	c082                	sw	zero,64(sp)

	var1 = (((int32_t)t_fine) / 2) - (int32_t)64000;
    80007b2a:	57f2                	lw	a5,60(sp)
    80007b2c:	01f7d71b          	srliw	a4,a5,0x1f
    80007b30:	9fb9                	addw	a5,a5,a4
    80007b32:	4017d79b          	sraiw	a5,a5,0x1
    80007b36:	0007871b          	sext.w	a4,a5
    80007b3a:	77c1                	lui	a5,0xffff0
    80007b3c:	6007879b          	addiw	a5,a5,1536
    80007b40:	9fb9                	addw	a5,a5,a4
    80007b42:	c2be                	sw	a5,68(sp)
	var2 = (((var1/4) * (var1/4)) / 2048 ) * ((int32_t)bmp280_calib_dig_P6);
    80007b44:	4796                	lw	a5,68(sp)
    80007b46:	41f7d71b          	sraiw	a4,a5,0x1f
    80007b4a:	01e7571b          	srliw	a4,a4,0x1e
    80007b4e:	9fb9                	addw	a5,a5,a4
    80007b50:	4027d79b          	sraiw	a5,a5,0x2
    80007b54:	0007871b          	sext.w	a4,a5
    80007b58:	4796                	lw	a5,68(sp)
    80007b5a:	41f7d69b          	sraiw	a3,a5,0x1f
    80007b5e:	01e6d69b          	srliw	a3,a3,0x1e
    80007b62:	9fb5                	addw	a5,a5,a3
    80007b64:	4027d79b          	sraiw	a5,a5,0x2
    80007b68:	2781                	sext.w	a5,a5
    80007b6a:	02f707bb          	mulw	a5,a4,a5
    80007b6e:	2781                	sext.w	a5,a5
    80007b70:	41f7d71b          	sraiw	a4,a5,0x1f
    80007b74:	0157571b          	srliw	a4,a4,0x15
    80007b78:	9fb9                	addw	a5,a5,a4
    80007b7a:	40b7d79b          	sraiw	a5,a5,0xb
    80007b7e:	0007871b          	sext.w	a4,a5
    80007b82:	000ff797          	auipc	a5,0xff
    80007b86:	6c478793          	addi	a5,a5,1732 # 80107246 <bmp280_calib_dig_P6>
    80007b8a:	00079783          	lh	a5,0(a5)
    80007b8e:	2781                	sext.w	a5,a5
    80007b90:	02f707bb          	mulw	a5,a4,a5
    80007b94:	c0be                	sw	a5,64(sp)
	var2 = var2 + ((var1 * ((int32_t)bmp280_calib_dig_P5)) * 2);
    80007b96:	000ff797          	auipc	a5,0xff
    80007b9a:	6ae78793          	addi	a5,a5,1710 # 80107244 <bmp280_calib_dig_P5>
    80007b9e:	00079783          	lh	a5,0(a5)
    80007ba2:	2781                	sext.w	a5,a5
    80007ba4:	4716                	lw	a4,68(sp)
    80007ba6:	02f707bb          	mulw	a5,a4,a5
    80007baa:	2781                	sext.w	a5,a5
    80007bac:	0017979b          	slliw	a5,a5,0x1
    80007bb0:	2781                	sext.w	a5,a5
    80007bb2:	4706                	lw	a4,64(sp)
    80007bb4:	9fb9                	addw	a5,a5,a4
    80007bb6:	c0be                	sw	a5,64(sp)
	var2 = (var2/4) + (((int32_t)bmp280_calib_dig_P4) * 65536);
    80007bb8:	4786                	lw	a5,64(sp)
    80007bba:	41f7d71b          	sraiw	a4,a5,0x1f
    80007bbe:	01e7571b          	srliw	a4,a4,0x1e
    80007bc2:	9fb9                	addw	a5,a5,a4
    80007bc4:	4027d79b          	sraiw	a5,a5,0x2
    80007bc8:	0007871b          	sext.w	a4,a5
    80007bcc:	000ff797          	auipc	a5,0xff
    80007bd0:	67478793          	addi	a5,a5,1652 # 80107240 <bmp280_calib_dig_P4>
    80007bd4:	00079783          	lh	a5,0(a5)
    80007bd8:	2781                	sext.w	a5,a5
    80007bda:	0107979b          	slliw	a5,a5,0x10
    80007bde:	2781                	sext.w	a5,a5
    80007be0:	9fb9                	addw	a5,a5,a4
    80007be2:	c0be                	sw	a5,64(sp)
	var1 = ((((int32_t)bmp280_calib_dig_P3 * (((var1/4) * (var1/4)) / 8192 )) / 8) + ((((int32_t)bmp280_calib_dig_P2) * var1)/2)) / 262144;
    80007be4:	000ff797          	auipc	a5,0xff
    80007be8:	66478793          	addi	a5,a5,1636 # 80107248 <bmp280_calib_dig_P3>
    80007bec:	00079783          	lh	a5,0(a5)
    80007bf0:	0007871b          	sext.w	a4,a5
    80007bf4:	4796                	lw	a5,68(sp)
    80007bf6:	41f7d69b          	sraiw	a3,a5,0x1f
    80007bfa:	01e6d69b          	srliw	a3,a3,0x1e
    80007bfe:	9fb5                	addw	a5,a5,a3
    80007c00:	4027d79b          	sraiw	a5,a5,0x2
    80007c04:	0007869b          	sext.w	a3,a5
    80007c08:	4796                	lw	a5,68(sp)
    80007c0a:	41f7d61b          	sraiw	a2,a5,0x1f
    80007c0e:	01e6561b          	srliw	a2,a2,0x1e
    80007c12:	9fb1                	addw	a5,a5,a2
    80007c14:	4027d79b          	sraiw	a5,a5,0x2
    80007c18:	2781                	sext.w	a5,a5
    80007c1a:	02f687bb          	mulw	a5,a3,a5
    80007c1e:	2781                	sext.w	a5,a5
    80007c20:	41f7d69b          	sraiw	a3,a5,0x1f
    80007c24:	0136d69b          	srliw	a3,a3,0x13
    80007c28:	9fb5                	addw	a5,a5,a3
    80007c2a:	40d7d79b          	sraiw	a5,a5,0xd
    80007c2e:	2781                	sext.w	a5,a5
    80007c30:	02f707bb          	mulw	a5,a4,a5
    80007c34:	2781                	sext.w	a5,a5
    80007c36:	41f7d71b          	sraiw	a4,a5,0x1f
    80007c3a:	01d7571b          	srliw	a4,a4,0x1d
    80007c3e:	9fb9                	addw	a5,a5,a4
    80007c40:	4037d79b          	sraiw	a5,a5,0x3
    80007c44:	0007871b          	sext.w	a4,a5
    80007c48:	000ff797          	auipc	a5,0xff
    80007c4c:	60478793          	addi	a5,a5,1540 # 8010724c <bmp280_calib_dig_P2>
    80007c50:	00079783          	lh	a5,0(a5)
    80007c54:	2781                	sext.w	a5,a5
    80007c56:	4696                	lw	a3,68(sp)
    80007c58:	02f687bb          	mulw	a5,a3,a5
    80007c5c:	2781                	sext.w	a5,a5
    80007c5e:	01f7d69b          	srliw	a3,a5,0x1f
    80007c62:	9fb5                	addw	a5,a5,a3
    80007c64:	4017d79b          	sraiw	a5,a5,0x1
    80007c68:	2781                	sext.w	a5,a5
    80007c6a:	9fb9                	addw	a5,a5,a4
    80007c6c:	2781                	sext.w	a5,a5
    80007c6e:	41f7d71b          	sraiw	a4,a5,0x1f
    80007c72:	00e7571b          	srliw	a4,a4,0xe
    80007c76:	9fb9                	addw	a5,a5,a4
    80007c78:	4127d79b          	sraiw	a5,a5,0x12
    80007c7c:	c2be                	sw	a5,68(sp)
	var1 =((((32768 + var1)) * ((int32_t)bmp280_calib_dig_P1)) / 32768);
    80007c7e:	4716                	lw	a4,68(sp)
    80007c80:	67a1                	lui	a5,0x8
    80007c82:	9fb9                	addw	a5,a5,a4
    80007c84:	0007871b          	sext.w	a4,a5
    80007c88:	000ff797          	auipc	a5,0xff
    80007c8c:	5ba78793          	addi	a5,a5,1466 # 80107242 <bmp280_calib_dig_P1>
    80007c90:	0007d783          	lhu	a5,0(a5)
    80007c94:	2781                	sext.w	a5,a5
    80007c96:	02f707bb          	mulw	a5,a4,a5
    80007c9a:	2781                	sext.w	a5,a5
    80007c9c:	41f7d71b          	sraiw	a4,a5,0x1f
    80007ca0:	0117571b          	srliw	a4,a4,0x11
    80007ca4:	9fb9                	addw	a5,a5,a4
    80007ca6:	40f7d79b          	sraiw	a5,a5,0xf
    80007caa:	c2be                	sw	a5,68(sp)

	if (var1 == 0)
    80007cac:	4796                	lw	a5,68(sp)
    80007cae:	2781                	sext.w	a5,a5
    80007cb0:	e399                	bnez	a5,80007cb6 <read_bmp280_values+0x41e>
		return 0; // avoid exception caused by division by zero
    80007cb2:	4781                	li	a5,0
    80007cb4:	a2a1                	j	80007dfc <read_bmp280_values+0x564>

	p = (((uint32_t)(((int32_t)1048576) - adc_P) - (var2 / 4096))) * 3125;
    80007cb6:	4786                	lw	a5,64(sp)
    80007cb8:	41f7d71b          	sraiw	a4,a5,0x1f
    80007cbc:	0147571b          	srliw	a4,a4,0x14
    80007cc0:	9fb9                	addw	a5,a5,a4
    80007cc2:	40c7d79b          	sraiw	a5,a5,0xc
    80007cc6:	2781                	sext.w	a5,a5
    80007cc8:	0007871b          	sext.w	a4,a5
    80007ccc:	47b6                	lw	a5,76(sp)
    80007cce:	9fb9                	addw	a5,a5,a4
    80007cd0:	0007871b          	sext.w	a4,a5
    80007cd4:	77fd                	lui	a5,0xfffff
    80007cd6:	3cb7879b          	addiw	a5,a5,971
    80007cda:	02f707bb          	mulw	a5,a4,a5
    80007cde:	0007871b          	sext.w	a4,a5
    80007ce2:	c35007b7          	lui	a5,0xc3500
    80007ce6:	9fb9                	addw	a5,a5,a4
    80007ce8:	2781                	sext.w	a5,a5
    80007cea:	da3e                	sw	a5,52(sp)

	if (p < (int32_t) 0x80000000)
		p = (p * 2) / ((uint32_t)var1);

	else
		p = (p / (uint32_t)var1) * 2;
    80007cec:	5752                	lw	a4,52(sp)
    80007cee:	4796                	lw	a5,68(sp)
    80007cf0:	02f757bb          	divuw	a5,a4,a5
    80007cf4:	2781                	sext.w	a5,a5
    80007cf6:	0017979b          	slliw	a5,a5,0x1
    80007cfa:	2781                	sext.w	a5,a5
    80007cfc:	da3e                	sw	a5,52(sp)

	var1 = (((int32_t)bmp280_calib_dig_P9) * ((int32_t)(((p/8) * (p/8)) / 8192))) / 4096;
    80007cfe:	000ff797          	auipc	a5,0xff
    80007d02:	53a78793          	addi	a5,a5,1338 # 80107238 <bmp280_calib_dig_P9>
    80007d06:	00079783          	lh	a5,0(a5)
    80007d0a:	0007871b          	sext.w	a4,a5
    80007d0e:	57d2                	lw	a5,52(sp)
    80007d10:	41f7d69b          	sraiw	a3,a5,0x1f
    80007d14:	01d6d69b          	srliw	a3,a3,0x1d
    80007d18:	9fb5                	addw	a5,a5,a3
    80007d1a:	4037d79b          	sraiw	a5,a5,0x3
    80007d1e:	0007869b          	sext.w	a3,a5
    80007d22:	57d2                	lw	a5,52(sp)
    80007d24:	41f7d61b          	sraiw	a2,a5,0x1f
    80007d28:	01d6561b          	srliw	a2,a2,0x1d
    80007d2c:	9fb1                	addw	a5,a5,a2
    80007d2e:	4037d79b          	sraiw	a5,a5,0x3
    80007d32:	2781                	sext.w	a5,a5
    80007d34:	02f687bb          	mulw	a5,a3,a5
    80007d38:	2781                	sext.w	a5,a5
    80007d3a:	41f7d69b          	sraiw	a3,a5,0x1f
    80007d3e:	0136d69b          	srliw	a3,a3,0x13
    80007d42:	9fb5                	addw	a5,a5,a3
    80007d44:	40d7d79b          	sraiw	a5,a5,0xd
    80007d48:	2781                	sext.w	a5,a5
    80007d4a:	02f707bb          	mulw	a5,a4,a5
    80007d4e:	2781                	sext.w	a5,a5
    80007d50:	41f7d71b          	sraiw	a4,a5,0x1f
    80007d54:	0147571b          	srliw	a4,a4,0x14
    80007d58:	9fb9                	addw	a5,a5,a4
    80007d5a:	40c7d79b          	sraiw	a5,a5,0xc
    80007d5e:	c2be                	sw	a5,68(sp)
	var2 = (((int32_t)(p/4)) * ((int32_t)bmp280_calib_dig_P8)) / 8192;
    80007d60:	57d2                	lw	a5,52(sp)
    80007d62:	41f7d71b          	sraiw	a4,a5,0x1f
    80007d66:	01e7571b          	srliw	a4,a4,0x1e
    80007d6a:	9fb9                	addw	a5,a5,a4
    80007d6c:	4027d79b          	sraiw	a5,a5,0x2
    80007d70:	0007871b          	sext.w	a4,a5
    80007d74:	000ff797          	auipc	a5,0xff
    80007d78:	4d678793          	addi	a5,a5,1238 # 8010724a <bmp280_calib_dig_P8>
    80007d7c:	00079783          	lh	a5,0(a5)
    80007d80:	2781                	sext.w	a5,a5
    80007d82:	02f707bb          	mulw	a5,a4,a5
    80007d86:	2781                	sext.w	a5,a5
    80007d88:	41f7d71b          	sraiw	a4,a5,0x1f
    80007d8c:	0137571b          	srliw	a4,a4,0x13
    80007d90:	9fb9                	addw	a5,a5,a4
    80007d92:	40d7d79b          	sraiw	a5,a5,0xd
    80007d96:	c0be                	sw	a5,64(sp)

	p = (uint32_t)((int32_t)p + ((var1 + var2 + (int32_t)bmp280_calib_dig_P7)/16));
    80007d98:	4716                	lw	a4,68(sp)
    80007d9a:	4786                	lw	a5,64(sp)
    80007d9c:	9fb9                	addw	a5,a5,a4
    80007d9e:	0007871b          	sext.w	a4,a5
    80007da2:	000ff797          	auipc	a5,0xff
    80007da6:	49878793          	addi	a5,a5,1176 # 8010723a <bmp280_calib_dig_P7>
    80007daa:	00079783          	lh	a5,0(a5)
    80007dae:	2781                	sext.w	a5,a5
    80007db0:	9fb9                	addw	a5,a5,a4
    80007db2:	2781                	sext.w	a5,a5
    80007db4:	41f7d71b          	sraiw	a4,a5,0x1f
    80007db8:	01c7571b          	srliw	a4,a4,0x1c
    80007dbc:	9fb9                	addw	a5,a5,a4
    80007dbe:	4047d79b          	sraiw	a5,a5,0x4
    80007dc2:	2781                	sext.w	a5,a5
    80007dc4:	5752                	lw	a4,52(sp)
    80007dc6:	9fb9                	addw	a5,a5,a4
    80007dc8:	da3e                	sw	a5,52(sp)
	*pressure = p;
    80007dca:	5752                	lw	a4,52(sp)
    80007dcc:	67a2                	ld	a5,8(sp)
    80007dce:	c398                	sw	a4,0(a5)

	printf("\nThe Pressure Value:%u.%u Kpa",(p/1000),(p%1000));
    80007dd0:	5752                	lw	a4,52(sp)
    80007dd2:	3e800793          	li	a5,1000
    80007dd6:	02f747bb          	divw	a5,a4,a5
    80007dda:	0007869b          	sext.w	a3,a5
    80007dde:	5752                	lw	a4,52(sp)
    80007de0:	3e800793          	li	a5,1000
    80007de4:	02f767bb          	remw	a5,a4,a5
    80007de8:	2781                	sext.w	a5,a5
    80007dea:	863e                	mv	a2,a5
    80007dec:	85b6                	mv	a1,a3
    80007dee:	00003517          	auipc	a0,0x3
    80007df2:	ae250513          	addi	a0,a0,-1310 # 8000a8d0 <__rodata_start+0x1578>
    80007df6:	d1eff0ef          	jal	ra,80007314 <printf>
	return 0;
    80007dfa:	4781                	li	a5,0
}
    80007dfc:	853e                	mv	a0,a5
    80007dfe:	60e6                	ld	ra,88(sp)
    80007e00:	6125                	addi	sp,sp,96
    80007e02:	8082                	ret

0000000080007e04 <read_bmp280_values16>:
 * @param uint32_t reg_offset  Used to store the register offset value.
 * @param uint32_t delay  Used delay for I2C functionality.
 * @return It returns 16bits value to the main.
 */
short read_bmp280_values16(i2c_struct * instance, uint32_t reg_offset, uint32_t delay)
{
    80007e04:	7179                	addi	sp,sp,-48
    80007e06:	f406                	sd	ra,40(sp)
    80007e08:	e42a                	sd	a0,8(sp)
    80007e0a:	87ae                	mv	a5,a1
    80007e0c:	8732                	mv	a4,a2
    80007e0e:	c23e                	sw	a5,4(sp)
    80007e10:	87ba                	mv	a5,a4
    80007e12:	c03e                	sw	a5,0(sp)
	unsigned char read_buf[2] = {'\0'};
    80007e14:	00011c23          	sh	zero,24(sp)
	unsigned char temp = 0;
    80007e18:	00010ba3          	sb	zero,23(sp)

	//Writes the slave address for write
	i2c_send_slave_address(instance, BMP280_SLAVE_ADDRESS, I2C_WRITE, 800);
    80007e1c:	32000693          	li	a3,800
    80007e20:	4601                	li	a2,0
    80007e22:	0ec00593          	li	a1,236
    80007e26:	6522                	ld	a0,8(sp)
    80007e28:	c99fd0ef          	jal	ra,80005ac0 <i2c_send_slave_address>

	//Writes the pointer to address that needs to be read
	i2c_write_data(instance, reg_offset , delay);
    80007e2c:	4792                	lw	a5,4(sp)
    80007e2e:	0ff7f793          	andi	a5,a5,255
    80007e32:	4702                	lw	a4,0(sp)
    80007e34:	0ff77713          	andi	a4,a4,255
    80007e38:	863a                	mv	a2,a4
    80007e3a:	85be                	mv	a1,a5
    80007e3c:	6522                	ld	a0,8(sp)
    80007e3e:	da1fd0ef          	jal	ra,80005bde <i2c_write_data>

	//Stops the I2C transaction to start reading the temperature value.
	instance->control = I2C_STOP;
    80007e42:	67a2                	ld	a5,8(sp)
    80007e44:	0c300713          	li	a4,195
    80007e48:	c798                	sw	a4,8(a5)

	//Writes the slave address for read
	i2c_send_slave_address(instance, BMP280_SLAVE_ADDRESS, I2C_READ, 800);
    80007e4a:	32000693          	li	a3,800
    80007e4e:	4605                	li	a2,1
    80007e50:	0ec00593          	li	a1,236
    80007e54:	6522                	ld	a0,8(sp)
    80007e56:	c6bfd0ef          	jal	ra,80005ac0 <i2c_send_slave_address>

	/* Make a dummy read as per spec of the I2C controller */
	i2c_read_data(instance, &temp, delay);
    80007e5a:	4782                	lw	a5,0(sp)
    80007e5c:	0ff7f713          	andi	a4,a5,255
    80007e60:	01710793          	addi	a5,sp,23
    80007e64:	863a                	mv	a2,a4
    80007e66:	85be                	mv	a1,a5
    80007e68:	6522                	ld	a0,8(sp)
    80007e6a:	deffd0ef          	jal	ra,80005c58 <i2c_read_data>

	i2c_read_data(instance, &read_buf[0], delay);
    80007e6e:	4782                	lw	a5,0(sp)
    80007e70:	0ff7f713          	andi	a4,a5,255
    80007e74:	083c                	addi	a5,sp,24
    80007e76:	863a                	mv	a2,a4
    80007e78:	85be                	mv	a1,a5
    80007e7a:	6522                	ld	a0,8(sp)
    80007e7c:	dddfd0ef          	jal	ra,80005c58 <i2c_read_data>
	instance->control = I2C_NACK;
    80007e80:	67a2                	ld	a5,8(sp)
    80007e82:	04000713          	li	a4,64
    80007e86:	c798                	sw	a4,8(a5)
	i2c_read_data(instance, &read_buf[1], delay);
    80007e88:	4782                	lw	a5,0(sp)
    80007e8a:	0ff7f713          	andi	a4,a5,255
    80007e8e:	083c                	addi	a5,sp,24
    80007e90:	0785                	addi	a5,a5,1
    80007e92:	863a                	mv	a2,a4
    80007e94:	85be                	mv	a1,a5
    80007e96:	6522                	ld	a0,8(sp)
    80007e98:	dc1fd0ef          	jal	ra,80005c58 <i2c_read_data>
	instance->control = I2C_STOP;
    80007e9c:	67a2                	ld	a5,8(sp)
    80007e9e:	0c300713          	li	a4,195
    80007ea2:	c798                	sw	a4,8(a5)

	return ( ( read_buf[1] << 8 ) | read_buf[0] );	
    80007ea4:	01914783          	lbu	a5,25(sp)
    80007ea8:	2781                	sext.w	a5,a5
    80007eaa:	0087979b          	slliw	a5,a5,0x8
    80007eae:	2781                	sext.w	a5,a5
    80007eb0:	0107971b          	slliw	a4,a5,0x10
    80007eb4:	4107571b          	sraiw	a4,a4,0x10
    80007eb8:	01814783          	lbu	a5,24(sp)
    80007ebc:	0107979b          	slliw	a5,a5,0x10
    80007ec0:	4107d79b          	sraiw	a5,a5,0x10
    80007ec4:	8fd9                	or	a5,a5,a4
    80007ec6:	0107979b          	slliw	a5,a5,0x10
    80007eca:	4107d79b          	sraiw	a5,a5,0x10
}
    80007ece:	853e                	mv	a0,a5
    80007ed0:	70a2                	ld	ra,40(sp)
    80007ed2:	6145                	addi	sp,sp,48
    80007ed4:	8082                	ret

0000000080007ed6 <write_bmp280_register>:
 * @param unsigned char write_value  Passing the value want write to register.
 * @param uint32_t delay  Used delay for I2C functionality.
 * @return Returns 0 to the main after stopping I2C.
 */
int write_bmp280_register(i2c_struct * instance, uint32_t reg_offset, unsigned char write_value, uint32_t delay)
{
    80007ed6:	7179                	addi	sp,sp,-48
    80007ed8:	f406                	sd	ra,40(sp)
    80007eda:	ec2a                	sd	a0,24(sp)
    80007edc:	87ae                	mv	a5,a1
    80007ede:	8736                	mv	a4,a3
    80007ee0:	ca3e                	sw	a5,20(sp)
    80007ee2:	87b2                	mv	a5,a2
    80007ee4:	00f109a3          	sb	a5,19(sp)
    80007ee8:	87ba                	mv	a5,a4
    80007eea:	c63e                	sw	a5,12(sp)
	i2c_send_slave_address(instance, BMP280_SLAVE_ADDRESS, I2C_WRITE, delay);
    80007eec:	00c16783          	lwu	a5,12(sp)
    80007ef0:	86be                	mv	a3,a5
    80007ef2:	4601                	li	a2,0
    80007ef4:	0ec00593          	li	a1,236
    80007ef8:	6562                	ld	a0,24(sp)
    80007efa:	bc7fd0ef          	jal	ra,80005ac0 <i2c_send_slave_address>

	i2c_write_data(instance, reg_offset , delay);
    80007efe:	47d2                	lw	a5,20(sp)
    80007f00:	0ff7f793          	andi	a5,a5,255
    80007f04:	4732                	lw	a4,12(sp)
    80007f06:	0ff77713          	andi	a4,a4,255
    80007f0a:	863a                	mv	a2,a4
    80007f0c:	85be                	mv	a1,a5
    80007f0e:	6562                	ld	a0,24(sp)
    80007f10:	ccffd0ef          	jal	ra,80005bde <i2c_write_data>
	i2c_write_data(instance, write_value , delay);
    80007f14:	47b2                	lw	a5,12(sp)
    80007f16:	0ff7f713          	andi	a4,a5,255
    80007f1a:	01314783          	lbu	a5,19(sp)
    80007f1e:	863a                	mv	a2,a4
    80007f20:	85be                	mv	a1,a5
    80007f22:	6562                	ld	a0,24(sp)
    80007f24:	cbbfd0ef          	jal	ra,80005bde <i2c_write_data>

	//Stops the I2C transaction to start reading the temperature value.
	instance->control = I2C_STOP;
    80007f28:	67e2                	ld	a5,24(sp)
    80007f2a:	0c300713          	li	a4,195
    80007f2e:	c798                	sw	a4,8(a5)
	return 0;
    80007f30:	4781                	li	a5,0
}
    80007f32:	853e                	mv	a0,a5
    80007f34:	70a2                	ld	ra,40(sp)
    80007f36:	6145                	addi	sp,sp,48
    80007f38:	8082                	ret

0000000080007f3a <main>:
void vTaskspiwrite(__attribute__((unused)) void *pvParameters);
void vTaskbmp280(__attribute__((unused)) void *pvParameters);
/*-----------------------------------------------------------*/

int main(void)
{
    80007f3a:	1141                	addi	sp,sp,-16
    80007f3c:	e406                	sd	ra,8(sp)
	printf("FREERTOS starting\n");
    80007f3e:	00003517          	auipc	a0,0x3
    80007f42:	9b250513          	addi	a0,a0,-1614 # 8000a8f0 <__rodata_start+0x1598>
    80007f46:	bceff0ef          	jal	ra,80007314 <printf>

	xTaskCreate(vTaskbmp280,"Task 3",500,NULL,1,NULL);
    80007f4a:	4781                	li	a5,0
    80007f4c:	4705                	li	a4,1
    80007f4e:	4681                	li	a3,0
    80007f50:	1f400613          	li	a2,500
    80007f54:	00003597          	auipc	a1,0x3
    80007f58:	9b458593          	addi	a1,a1,-1612 # 8000a908 <__rodata_start+0x15b0>
    80007f5c:	00000517          	auipc	a0,0x0
    80007f60:	06250513          	addi	a0,a0,98 # 80007fbe <vTaskbmp280>
    80007f64:	8d1f90ef          	jal	ra,80001834 <xTaskCreate>
	xTaskCreate(vTaskgpio,"Task 1",500,NULL,1,NULL);
    80007f68:	4781                	li	a5,0
    80007f6a:	4705                	li	a4,1
    80007f6c:	4681                	li	a3,0
    80007f6e:	1f400613          	li	a2,500
    80007f72:	00003597          	auipc	a1,0x3
    80007f76:	99e58593          	addi	a1,a1,-1634 # 8000a910 <__rodata_start+0x15b8>
    80007f7a:	00000517          	auipc	a0,0x0
    80007f7e:	43050513          	addi	a0,a0,1072 # 800083aa <vTaskgpio>
    80007f82:	8b3f90ef          	jal	ra,80001834 <xTaskCreate>
	xTaskCreate(vTaskspiwrite,"Task 2",500,NULL,1,NULL);
    80007f86:	4781                	li	a5,0
    80007f88:	4705                	li	a4,1
    80007f8a:	4681                	li	a3,0
    80007f8c:	1f400613          	li	a2,500
    80007f90:	00003597          	auipc	a1,0x3
    80007f94:	98858593          	addi	a1,a1,-1656 # 8000a918 <__rodata_start+0x15c0>
    80007f98:	00000517          	auipc	a0,0x0
    80007f9c:	3f050513          	addi	a0,a0,1008 # 80008388 <vTaskspiwrite>
    80007fa0:	895f90ef          	jal	ra,80001834 <xTaskCreate>

	printf("Task scheduler started\n");	/* Task scheduledd with help of
    80007fa4:	00003517          	auipc	a0,0x3
    80007fa8:	97c50513          	addi	a0,a0,-1668 # 8000a920 <__rodata_start+0x15c8>
    80007fac:	b68ff0ef          	jal	ra,80007314 <printf>
						   clint */
	vTaskStartScheduler();
    80007fb0:	af2fa0ef          	jal	ra,800022a2 <vTaskStartScheduler>

	/* Exit FreeRTOS */
	return 0;
    80007fb4:	4781                	li	a5,0
}
    80007fb6:	853e                	mv	a0,a5
    80007fb8:	60a2                	ld	ra,8(sp)
    80007fba:	0141                	addi	sp,sp,16
    80007fbc:	8082                	ret

0000000080007fbe <vTaskbmp280>:
/*-----------------------------------------------------------*/
void vTaskbmp280(__attribute__((unused)) void *pvParameters )
{
    80007fbe:	7179                	addi	sp,sp,-48
    80007fc0:	f406                	sd	ra,40(sp)
    80007fc2:	e42a                	sd	a0,8(sp)
	const TickType_t xDelay1000ms = pdMS_TO_TICKS( 10 );
    80007fc4:	4795                	li	a5,5
    80007fc6:	ec3e                	sd	a5,24(sp)

	uint32_t tempReadValue = 0;
    80007fc8:	c802                	sw	zero,16(sp)
	uint32_t delay = 100;
    80007fca:	06400793          	li	a5,100
    80007fce:	ca3e                	sw	a5,20(sp)

	i2c_init();
    80007fd0:	e04fd0ef          	jal	ra,800055d4 <i2c_init>

	//Initialises I2C Controller
	if(config_i2c(I2C, PRESCALER_COUNT,SCLK_COUNT))
    80007fd4:	000ff797          	auipc	a5,0xff
    80007fd8:	eac78793          	addi	a5,a5,-340 # 80106e80 <i2c_instance>
    80007fdc:	679c                	ld	a5,8(a5)
    80007fde:	09100613          	li	a2,145
    80007fe2:	45fd                	li	a1,31
    80007fe4:	853e                	mv	a0,a5
    80007fe6:	e3afd0ef          	jal	ra,80005620 <config_i2c>
    80007fea:	87aa                	mv	a5,a0
    80007fec:	cb81                	beqz	a5,80007ffc <vTaskbmp280+0x3e>
	{
		log_error("\tSomething Wrong In Initialization\n");
    80007fee:	00003517          	auipc	a0,0x3
    80007ff2:	94a50513          	addi	a0,a0,-1718 # 8000a938 <__rodata_start+0x15e0>
    80007ff6:	be6ff0ef          	jal	ra,800073dc <log_error>
		return;
    80007ffa:	ae29                	j	80008314 <vTaskbmp280+0x356>
	}
	else
		log_info("\tIntilization BMP280_STATUS_REGISTER Happened Fine\n");
    80007ffc:	00003517          	auipc	a0,0x3
    80008000:	96450513          	addi	a0,a0,-1692 # 8000a960 <__rodata_start+0x1608>
    80008004:	b5cff0ef          	jal	ra,80007360 <log_info>

	write_bmp280_register(I2C, BMP280_CONFIG_REGISTER, 0xC0, delay);
    80008008:	000ff797          	auipc	a5,0xff
    8000800c:	e7878793          	addi	a5,a5,-392 # 80106e80 <i2c_instance>
    80008010:	679c                	ld	a5,8(a5)
    80008012:	4752                	lw	a4,20(sp)
    80008014:	86ba                	mv	a3,a4
    80008016:	0c000613          	li	a2,192
    8000801a:	0f500593          	li	a1,245
    8000801e:	853e                	mv	a0,a5
    80008020:	eb7ff0ef          	jal	ra,80007ed6 <write_bmp280_register>
	write_bmp280_register(I2C, BMP280_CTRL_MEANS, 0x27, delay);
    80008024:	000ff797          	auipc	a5,0xff
    80008028:	e5c78793          	addi	a5,a5,-420 # 80106e80 <i2c_instance>
    8000802c:	679c                	ld	a5,8(a5)
    8000802e:	4752                	lw	a4,20(sp)
    80008030:	86ba                	mv	a3,a4
    80008032:	02700613          	li	a2,39
    80008036:	0f400593          	li	a1,244
    8000803a:	853e                	mv	a0,a5
    8000803c:	e9bff0ef          	jal	ra,80007ed6 <write_bmp280_register>

	if(0 == read_bmp280_register(I2C, 0xD0, &tempReadValue, delay))
    80008040:	000ff797          	auipc	a5,0xff
    80008044:	e4078793          	addi	a5,a5,-448 # 80106e80 <i2c_instance>
    80008048:	679c                	ld	a5,8(a5)
    8000804a:	46d2                	lw	a3,20(sp)
    8000804c:	0818                	addi	a4,sp,16
    8000804e:	863a                	mv	a2,a4
    80008050:	0d000593          	li	a1,208
    80008054:	853e                	mv	a0,a5
    80008056:	fa0ff0ef          	jal	ra,800077f6 <read_bmp280_register>
    8000805a:	87aa                	mv	a5,a0
    8000805c:	ef91                	bnez	a5,80008078 <vTaskbmp280+0xba>
	{
		if (0x58 != tempReadValue)
    8000805e:	47c2                	lw	a5,16(sp)
    80008060:	873e                	mv	a4,a5
    80008062:	05800793          	li	a5,88
    80008066:	00f70963          	beq	a4,a5,80008078 <vTaskbmp280+0xba>
		{
			printf("\n Device Not detected");
    8000806a:	00003517          	auipc	a0,0x3
    8000806e:	92e50513          	addi	a0,a0,-1746 # 8000a998 <__rodata_start+0x1640>
    80008072:	aa2ff0ef          	jal	ra,80007314 <printf>
			return;
    80008076:	ac79                	j	80008314 <vTaskbmp280+0x356>
		}
	}

	write_bmp280_register(I2C, BMP280_RESET_REGISTER, 0xB6, delay);
    80008078:	000ff797          	auipc	a5,0xff
    8000807c:	e0878793          	addi	a5,a5,-504 # 80106e80 <i2c_instance>
    80008080:	679c                	ld	a5,8(a5)
    80008082:	4752                	lw	a4,20(sp)
    80008084:	86ba                	mv	a3,a4
    80008086:	0b600613          	li	a2,182
    8000808a:	0e000593          	li	a1,224
    8000808e:	853e                	mv	a0,a5
    80008090:	e47ff0ef          	jal	ra,80007ed6 <write_bmp280_register>
	read_bmp280_register(I2C, BMP280_RESET_REGISTER, &tempReadValue, delay);
    80008094:	000ff797          	auipc	a5,0xff
    80008098:	dec78793          	addi	a5,a5,-532 # 80106e80 <i2c_instance>
    8000809c:	679c                	ld	a5,8(a5)
    8000809e:	46d2                	lw	a3,20(sp)
    800080a0:	0818                	addi	a4,sp,16
    800080a2:	863a                	mv	a2,a4
    800080a4:	0e000593          	li	a1,224
    800080a8:	853e                	mv	a0,a5
    800080aa:	f4cff0ef          	jal	ra,800077f6 <read_bmp280_register>

	bmp280_calib_dig_T1 = read_bmp280_values16(I2C, BMP280_REG_DIG_T1, delay);
    800080ae:	000ff797          	auipc	a5,0xff
    800080b2:	dd278793          	addi	a5,a5,-558 # 80106e80 <i2c_instance>
    800080b6:	679c                	ld	a5,8(a5)
    800080b8:	4752                	lw	a4,20(sp)
    800080ba:	863a                	mv	a2,a4
    800080bc:	08800593          	li	a1,136
    800080c0:	853e                	mv	a0,a5
    800080c2:	d43ff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    800080c6:	87aa                	mv	a5,a0
    800080c8:	03079713          	slli	a4,a5,0x30
    800080cc:	9341                	srli	a4,a4,0x30
    800080ce:	000ff797          	auipc	a5,0xff
    800080d2:	16e78793          	addi	a5,a5,366 # 8010723c <bmp280_calib_dig_T1>
    800080d6:	00e79023          	sh	a4,0(a5)
	bmp280_calib_dig_T2 = read_bmp280_values16(I2C, BMP280_REG_DIG_T2, delay);
    800080da:	000ff797          	auipc	a5,0xff
    800080de:	da678793          	addi	a5,a5,-602 # 80106e80 <i2c_instance>
    800080e2:	679c                	ld	a5,8(a5)
    800080e4:	4752                	lw	a4,20(sp)
    800080e6:	863a                	mv	a2,a4
    800080e8:	08a00593          	li	a1,138
    800080ec:	853e                	mv	a0,a5
    800080ee:	d17ff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    800080f2:	87aa                	mv	a5,a0
    800080f4:	873e                	mv	a4,a5
    800080f6:	000ff797          	auipc	a5,0xff
    800080fa:	15878793          	addi	a5,a5,344 # 8010724e <bmp280_calib_dig_T2>
    800080fe:	00e79023          	sh	a4,0(a5)
	bmp280_calib_dig_T3 = read_bmp280_values16(I2C, BMP280_REG_DIG_T3, delay);
    80008102:	000ff797          	auipc	a5,0xff
    80008106:	d7e78793          	addi	a5,a5,-642 # 80106e80 <i2c_instance>
    8000810a:	679c                	ld	a5,8(a5)
    8000810c:	4752                	lw	a4,20(sp)
    8000810e:	863a                	mv	a2,a4
    80008110:	08c00593          	li	a1,140
    80008114:	853e                	mv	a0,a5
    80008116:	cefff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    8000811a:	87aa                	mv	a5,a0
    8000811c:	873e                	mv	a4,a5
    8000811e:	000ff797          	auipc	a5,0xff
    80008122:	12078793          	addi	a5,a5,288 # 8010723e <bmp280_calib_dig_T3>
    80008126:	00e79023          	sh	a4,0(a5)

	bmp280_calib_dig_P1 = read_bmp280_values16(I2C, BMP280_REG_DIG_P1, delay);
    8000812a:	000ff797          	auipc	a5,0xff
    8000812e:	d5678793          	addi	a5,a5,-682 # 80106e80 <i2c_instance>
    80008132:	679c                	ld	a5,8(a5)
    80008134:	4752                	lw	a4,20(sp)
    80008136:	863a                	mv	a2,a4
    80008138:	08e00593          	li	a1,142
    8000813c:	853e                	mv	a0,a5
    8000813e:	cc7ff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    80008142:	87aa                	mv	a5,a0
    80008144:	03079713          	slli	a4,a5,0x30
    80008148:	9341                	srli	a4,a4,0x30
    8000814a:	000ff797          	auipc	a5,0xff
    8000814e:	0f878793          	addi	a5,a5,248 # 80107242 <bmp280_calib_dig_P1>
    80008152:	00e79023          	sh	a4,0(a5)
	bmp280_calib_dig_P2 = read_bmp280_values16(I2C, BMP280_REG_DIG_P2, delay);
    80008156:	000ff797          	auipc	a5,0xff
    8000815a:	d2a78793          	addi	a5,a5,-726 # 80106e80 <i2c_instance>
    8000815e:	679c                	ld	a5,8(a5)
    80008160:	4752                	lw	a4,20(sp)
    80008162:	863a                	mv	a2,a4
    80008164:	09000593          	li	a1,144
    80008168:	853e                	mv	a0,a5
    8000816a:	c9bff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    8000816e:	87aa                	mv	a5,a0
    80008170:	873e                	mv	a4,a5
    80008172:	000ff797          	auipc	a5,0xff
    80008176:	0da78793          	addi	a5,a5,218 # 8010724c <bmp280_calib_dig_P2>
    8000817a:	00e79023          	sh	a4,0(a5)
	bmp280_calib_dig_P3 = read_bmp280_values16(I2C, BMP280_REG_DIG_P3, delay);
    8000817e:	000ff797          	auipc	a5,0xff
    80008182:	d0278793          	addi	a5,a5,-766 # 80106e80 <i2c_instance>
    80008186:	679c                	ld	a5,8(a5)
    80008188:	4752                	lw	a4,20(sp)
    8000818a:	863a                	mv	a2,a4
    8000818c:	09200593          	li	a1,146
    80008190:	853e                	mv	a0,a5
    80008192:	c73ff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    80008196:	87aa                	mv	a5,a0
    80008198:	873e                	mv	a4,a5
    8000819a:	000ff797          	auipc	a5,0xff
    8000819e:	0ae78793          	addi	a5,a5,174 # 80107248 <bmp280_calib_dig_P3>
    800081a2:	00e79023          	sh	a4,0(a5)
	bmp280_calib_dig_P4 = read_bmp280_values16(I2C, BMP280_REG_DIG_P4, delay);
    800081a6:	000ff797          	auipc	a5,0xff
    800081aa:	cda78793          	addi	a5,a5,-806 # 80106e80 <i2c_instance>
    800081ae:	679c                	ld	a5,8(a5)
    800081b0:	4752                	lw	a4,20(sp)
    800081b2:	863a                	mv	a2,a4
    800081b4:	09400593          	li	a1,148
    800081b8:	853e                	mv	a0,a5
    800081ba:	c4bff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    800081be:	87aa                	mv	a5,a0
    800081c0:	873e                	mv	a4,a5
    800081c2:	000ff797          	auipc	a5,0xff
    800081c6:	07e78793          	addi	a5,a5,126 # 80107240 <bmp280_calib_dig_P4>
    800081ca:	00e79023          	sh	a4,0(a5)
	bmp280_calib_dig_P5 = read_bmp280_values16(I2C, BMP280_REG_DIG_P5, delay);
    800081ce:	000ff797          	auipc	a5,0xff
    800081d2:	cb278793          	addi	a5,a5,-846 # 80106e80 <i2c_instance>
    800081d6:	679c                	ld	a5,8(a5)
    800081d8:	4752                	lw	a4,20(sp)
    800081da:	863a                	mv	a2,a4
    800081dc:	09600593          	li	a1,150
    800081e0:	853e                	mv	a0,a5
    800081e2:	c23ff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    800081e6:	87aa                	mv	a5,a0
    800081e8:	873e                	mv	a4,a5
    800081ea:	000ff797          	auipc	a5,0xff
    800081ee:	05a78793          	addi	a5,a5,90 # 80107244 <bmp280_calib_dig_P5>
    800081f2:	00e79023          	sh	a4,0(a5)
	bmp280_calib_dig_P6 = read_bmp280_values16(I2C, BMP280_REG_DIG_P6, delay);
    800081f6:	000ff797          	auipc	a5,0xff
    800081fa:	c8a78793          	addi	a5,a5,-886 # 80106e80 <i2c_instance>
    800081fe:	679c                	ld	a5,8(a5)
    80008200:	4752                	lw	a4,20(sp)
    80008202:	863a                	mv	a2,a4
    80008204:	09800593          	li	a1,152
    80008208:	853e                	mv	a0,a5
    8000820a:	bfbff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    8000820e:	87aa                	mv	a5,a0
    80008210:	873e                	mv	a4,a5
    80008212:	000ff797          	auipc	a5,0xff
    80008216:	03478793          	addi	a5,a5,52 # 80107246 <bmp280_calib_dig_P6>
    8000821a:	00e79023          	sh	a4,0(a5)
	bmp280_calib_dig_P7 = read_bmp280_values16(I2C, BMP280_REG_DIG_P7, delay);
    8000821e:	000ff797          	auipc	a5,0xff
    80008222:	c6278793          	addi	a5,a5,-926 # 80106e80 <i2c_instance>
    80008226:	679c                	ld	a5,8(a5)
    80008228:	4752                	lw	a4,20(sp)
    8000822a:	863a                	mv	a2,a4
    8000822c:	09a00593          	li	a1,154
    80008230:	853e                	mv	a0,a5
    80008232:	bd3ff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    80008236:	87aa                	mv	a5,a0
    80008238:	873e                	mv	a4,a5
    8000823a:	000ff797          	auipc	a5,0xff
    8000823e:	00078793          	mv	a5,a5
    80008242:	00e79023          	sh	a4,0(a5) # 8010723a <bmp280_calib_dig_P7>
	bmp280_calib_dig_P8 = read_bmp280_values16(I2C, BMP280_REG_DIG_P8, delay);
    80008246:	000ff797          	auipc	a5,0xff
    8000824a:	c3a78793          	addi	a5,a5,-966 # 80106e80 <i2c_instance>
    8000824e:	679c                	ld	a5,8(a5)
    80008250:	4752                	lw	a4,20(sp)
    80008252:	863a                	mv	a2,a4
    80008254:	09c00593          	li	a1,156
    80008258:	853e                	mv	a0,a5
    8000825a:	babff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    8000825e:	87aa                	mv	a5,a0
    80008260:	873e                	mv	a4,a5
    80008262:	000ff797          	auipc	a5,0xff
    80008266:	fe878793          	addi	a5,a5,-24 # 8010724a <bmp280_calib_dig_P8>
    8000826a:	00e79023          	sh	a4,0(a5)
	bmp280_calib_dig_P9 = read_bmp280_values16(I2C, BMP280_REG_DIG_P9, delay);
    8000826e:	000ff797          	auipc	a5,0xff
    80008272:	c1278793          	addi	a5,a5,-1006 # 80106e80 <i2c_instance>
    80008276:	679c                	ld	a5,8(a5)
    80008278:	4752                	lw	a4,20(sp)
    8000827a:	863a                	mv	a2,a4
    8000827c:	09e00593          	li	a1,158
    80008280:	853e                	mv	a0,a5
    80008282:	b83ff0ef          	jal	ra,80007e04 <read_bmp280_values16>
    80008286:	87aa                	mv	a5,a0
    80008288:	873e                	mv	a4,a5
    8000828a:	000ff797          	auipc	a5,0xff
    8000828e:	fae78793          	addi	a5,a5,-82 # 80107238 <bmp280_calib_dig_P9>
    80008292:	00e79023          	sh	a4,0(a5)

	/* As per most tasks, this task is implemented in an infinite loop. */
	for( ;; )
	{
		write_bmp280_register(I2C, BMP280_CTRL_MEANS, BMP280_NORMAL_MODE,
    80008296:	000ff797          	auipc	a5,0xff
    8000829a:	bea78793          	addi	a5,a5,-1046 # 80106e80 <i2c_instance>
    8000829e:	679c                	ld	a5,8(a5)
    800082a0:	4752                	lw	a4,20(sp)
    800082a2:	86ba                	mv	a3,a4
    800082a4:	02600613          	li	a2,38
    800082a8:	0f400593          	li	a1,244
    800082ac:	853e                	mv	a0,a5
    800082ae:	c29ff0ef          	jal	ra,80007ed6 <write_bmp280_register>
				      delay);

		if(0 == read_bmp280_register(I2C, BMP280_STATUS_REGISTER,
    800082b2:	000ff797          	auipc	a5,0xff
    800082b6:	bce78793          	addi	a5,a5,-1074 # 80106e80 <i2c_instance>
    800082ba:	679c                	ld	a5,8(a5)
    800082bc:	46d2                	lw	a3,20(sp)
    800082be:	0818                	addi	a4,sp,16
    800082c0:	863a                	mv	a2,a4
    800082c2:	0f300593          	li	a1,243
    800082c6:	853e                	mv	a0,a5
    800082c8:	d2eff0ef          	jal	ra,800077f6 <read_bmp280_register>
    800082cc:	87aa                	mv	a5,a0
    800082ce:	eb8d                	bnez	a5,80008300 <vTaskbmp280+0x342>
					     &tempReadValue, delay))
		{
			if(!(tempReadValue & 0x9))
    800082d0:	47c2                	lw	a5,16(sp)
    800082d2:	8ba5                	andi	a5,a5,9
    800082d4:	2781                	sext.w	a5,a5
    800082d6:	eb9d                	bnez	a5,8000830c <vTaskbmp280+0x34e>
			{
				//Read pressure and temperature values.
				read_bmp280_values(I2C, 0xF7, &gpress,
    800082d8:	000ff797          	auipc	a5,0xff
    800082dc:	ba878793          	addi	a5,a5,-1112 # 80106e80 <i2c_instance>
    800082e0:	679c                	ld	a5,8(a5)
    800082e2:	4752                	lw	a4,20(sp)
    800082e4:	00003697          	auipc	a3,0x3
    800082e8:	91468693          	addi	a3,a3,-1772 # 8000abf8 <gtemp>
    800082ec:	00003617          	auipc	a2,0x3
    800082f0:	90860613          	addi	a2,a2,-1784 # 8000abf4 <gpress>
    800082f4:	0f700593          	li	a1,247
    800082f8:	853e                	mv	a0,a5
    800082fa:	d9eff0ef          	jal	ra,80007898 <read_bmp280_values>
    800082fe:	a039                	j	8000830c <vTaskbmp280+0x34e>
						   &gtemp, delay);
			}
		}
		else
		{
			log_error("\nTemperature read failed.");
    80008300:	00002517          	auipc	a0,0x2
    80008304:	6b050513          	addi	a0,a0,1712 # 8000a9b0 <__rodata_start+0x1658>
    80008308:	8d4ff0ef          	jal	ra,800073dc <log_error>
		}

		vTaskDelay( xDelay1000ms );
    8000830c:	6562                	ld	a0,24(sp)
    8000830e:	9cff90ef          	jal	ra,80001cdc <vTaskDelay>
		write_bmp280_register(I2C, BMP280_CTRL_MEANS, BMP280_NORMAL_MODE,
    80008312:	b751                	j	80008296 <vTaskbmp280+0x2d8>
		/* Delay for a period. */
	}
}
    80008314:	70a2                	ld	ra,40(sp)
    80008316:	6145                	addi	sp,sp,48
    80008318:	8082                	ret

000000008000831a <spi_write>:

static void spi_write(void)
{
    8000831a:	1101                	addi	sp,sp,-32
    8000831c:	ec06                	sd	ra,24(sp)
	uint32_t write_address = 0x0b00000;
    8000831e:	00b007b7          	lui	a5,0xb00
    80008322:	c63e                	sw	a5,12(sp)

	flash_device_id();
    80008324:	a14fd0ef          	jal	ra,80005538 <flash_device_id>
	waitfor(200);
    80008328:	0c800513          	li	a0,200
    8000832c:	8e7fe0ef          	jal	ra,80006c12 <waitfor>

	flash_write_enable();
    80008330:	e7ffc0ef          	jal	ra,800051ae <flash_write_enable>
	flash_erase(0x00b00000); //erases an entire sector
    80008334:	00b00537          	lui	a0,0xb00
    80008338:	9acfd0ef          	jal	ra,800054e4 <flash_erase>
	flash_status_register_read();
    8000833c:	9c4fd0ef          	jal	ra,80005500 <flash_status_register_read>

	//flash write
	flash_write_enable();
    80008340:	e6ffc0ef          	jal	ra,800051ae <flash_write_enable>
	flash_write(write_address, gtemp);
    80008344:	4732                	lw	a4,12(sp)
    80008346:	00003797          	auipc	a5,0x3
    8000834a:	8b278793          	addi	a5,a5,-1870 # 8000abf8 <gtemp>
    8000834e:	439c                	lw	a5,0(a5)
    80008350:	2781                	sext.w	a5,a5
    80008352:	85be                	mv	a1,a5
    80008354:	853a                	mv	a0,a4
    80008356:	83cfd0ef          	jal	ra,80005392 <flash_write>
	flash_status_register_read();
    8000835a:	9a6fd0ef          	jal	ra,80005500 <flash_status_register_read>

	flash_write(write_address + 0x4, gpress);
    8000835e:	47b2                	lw	a5,12(sp)
    80008360:	2791                	addiw	a5,a5,4
    80008362:	2781                	sext.w	a5,a5
    80008364:	0007871b          	sext.w	a4,a5
    80008368:	00003797          	auipc	a5,0x3
    8000836c:	88c78793          	addi	a5,a5,-1908 # 8000abf4 <gpress>
    80008370:	439c                	lw	a5,0(a5)
    80008372:	2781                	sext.w	a5,a5
    80008374:	85be                	mv	a1,a5
    80008376:	853a                	mv	a0,a4
    80008378:	81afd0ef          	jal	ra,80005392 <flash_write>
	flash_status_register_read();
    8000837c:	984fd0ef          	jal	ra,80005500 <flash_status_register_read>
}
    80008380:	0001                	nop
    80008382:	60e2                	ld	ra,24(sp)
    80008384:	6105                	addi	sp,sp,32
    80008386:	8082                	ret

0000000080008388 <vTaskspiwrite>:

void vTaskspiwrite(__attribute__((unused)) void *pvParameters )
{
    80008388:	7179                	addi	sp,sp,-48
    8000838a:	f406                	sd	ra,40(sp)
    8000838c:	e42a                	sd	a0,8(sp)
	const TickType_t xDelay1000ms = pdMS_TO_TICKS(10);
    8000838e:	4795                	li	a5,5
    80008390:	ec3e                	sd	a5,24(sp)

	configure_spi(SPI1_OFFSET);
    80008392:	10000513          	li	a0,256
    80008396:	c19fc0ef          	jal	ra,80004fae <configure_spi>
	spi_init();
    8000839a:	d23fc0ef          	jal	ra,800050bc <spi_init>

	/* As per most tasks, this task is implemented in an infinite loop. */
	for( ;; )
	{
		spi_write();
    8000839e:	f7dff0ef          	jal	ra,8000831a <spi_write>

		vTaskDelay( xDelay1000ms );
    800083a2:	6562                	ld	a0,24(sp)
    800083a4:	939f90ef          	jal	ra,80001cdc <vTaskDelay>
		spi_write();
    800083a8:	bfdd                	j	8000839e <vTaskspiwrite+0x16>

00000000800083aa <vTaskgpio>:
		/* Delay for a period. */
	}
}

void vTaskgpio(__attribute__((unused)) void *pvParameters)
{
    800083aa:	7179                	addi	sp,sp,-48
    800083ac:	f406                	sd	ra,40(sp)
    800083ae:	e42a                	sd	a0,8(sp)
	const TickType_t xDelay1000ms = pdMS_TO_TICKS(10);
    800083b0:	4795                	li	a5,5
    800083b2:	ec3e                	sd	a5,24(sp)

	write_word(GPIO_DIRECTION_CNTRL_REG, 0xffffffff);
    800083b4:	57fd                	li	a5,-1
    800083b6:	0207d593          	srli	a1,a5,0x20
    800083ba:	000407b7          	lui	a5,0x40
    800083be:	10078513          	addi	a0,a5,256 # 40100 <_STACK_SIZE+0x2c100>
    800083c2:	b87fe0ef          	jal	ra,80006f48 <write_word>

	/* As per most tasks, this task is implemented in an infinite loop. */
	for( ;; )
	{
		if(gtemp > 3000)
    800083c6:	00003797          	auipc	a5,0x3
    800083ca:	83278793          	addi	a5,a5,-1998 # 8000abf8 <gtemp>
    800083ce:	439c                	lw	a5,0(a5)
    800083d0:	873e                	mv	a4,a5
    800083d2:	6785                	lui	a5,0x1
    800083d4:	bb878793          	addi	a5,a5,-1096 # bb8 <_tbss_end+0xbb8>
    800083d8:	00e7fb63          	bgeu	a5,a4,800083ee <vTaskgpio+0x44>
		{
			// switch on air cooler
			write_word(GPIO_DATA_REG, 0xff);
    800083dc:	0ff00593          	li	a1,255
    800083e0:	000407b7          	lui	a5,0x40
    800083e4:	10878513          	addi	a0,a5,264 # 40108 <_STACK_SIZE+0x2c108>
    800083e8:	b61fe0ef          	jal	ra,80006f48 <write_word>
    800083ec:	a0b9                	j	8000843a <vTaskgpio+0x90>
		}
		else if(gtemp > 2600)
    800083ee:	00003797          	auipc	a5,0x3
    800083f2:	80a78793          	addi	a5,a5,-2038 # 8000abf8 <gtemp>
    800083f6:	439c                	lw	a5,0(a5)
    800083f8:	873e                	mv	a4,a5
    800083fa:	6785                	lui	a5,0x1
    800083fc:	a2878793          	addi	a5,a5,-1496 # a28 <_tbss_end+0xa28>
    80008400:	00e7fc63          	bgeu	a5,a4,80008418 <vTaskgpio+0x6e>
		{
			//Full speed fan rotation
			write_word(GPIO_DATA_REG, 0xff00);
    80008404:	67c1                	lui	a5,0x10
    80008406:	f0078593          	addi	a1,a5,-256 # ff00 <_tbss_end+0xff00>
    8000840a:	000407b7          	lui	a5,0x40
    8000840e:	10878513          	addi	a0,a5,264 # 40108 <_STACK_SIZE+0x2c108>
    80008412:	b37fe0ef          	jal	ra,80006f48 <write_word>
    80008416:	a015                	j	8000843a <vTaskgpio+0x90>
		}
		else if(gtemp < 26)
    80008418:	00002797          	auipc	a5,0x2
    8000841c:	7e078793          	addi	a5,a5,2016 # 8000abf8 <gtemp>
    80008420:	439c                	lw	a5,0(a5)
    80008422:	873e                	mv	a4,a5
    80008424:	47e5                	li	a5,25
    80008426:	00e7ea63          	bltu	a5,a4,8000843a <vTaskgpio+0x90>
		{
			//mild speed fan rotation
			write_word(GPIO_DATA_REG, 0x0ff0000);
    8000842a:	00ff05b7          	lui	a1,0xff0
    8000842e:	000407b7          	lui	a5,0x40
    80008432:	10878513          	addi	a0,a5,264 # 40108 <_STACK_SIZE+0x2c108>
    80008436:	b13fe0ef          	jal	ra,80006f48 <write_word>
		}

		vTaskDelay( xDelay1000ms );
    8000843a:	6562                	ld	a0,24(sp)
    8000843c:	8a1f90ef          	jal	ra,80001cdc <vTaskDelay>
		if(gtemp > 3000)
    80008440:	b759                	j	800083c6 <vTaskgpio+0x1c>

0000000080008442 <vApplicationMallocFailedHook>:
	   demo application.  If heap_1.c or heap_2.c are used, then the size of the
	   heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	   FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	   to query the size of free heap space that remains (although it does not
	   provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
    80008442:	30047073          	csrci	mstatus,8
	for( ;; );
    80008446:	a001                	j	80008446 <vApplicationMallocFailedHook+0x4>

0000000080008448 <vApplicationIdleHook>:
	   specified, or call vTaskDelay()).  If the application makes use of the
	   vTaskDelete() API function (as this demo application does) then it is also
	   important that vApplicationIdleHook() is permitted to return to its calling
	   function, because it is the responsibility of the idle task to clean up
	   memory allocated by the kernel to any task that has since been deleted. */
}
    80008448:	0001                	nop
    8000844a:	8082                	ret

000000008000844c <vApplicationStackOverflowHook>:
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
    8000844c:	1141                	addi	sp,sp,-16
    8000844e:	e42a                	sd	a0,8(sp)
    80008450:	e02e                	sd	a1,0(sp)
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	   configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	   function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
    80008452:	30047073          	csrci	mstatus,8
	for( ;; );
    80008456:	a001                	j	80008456 <vApplicationStackOverflowHook+0xa>

0000000080008458 <memcpy>:
    80008458:	00a5c7b3          	xor	a5,a1,a0
    8000845c:	8b9d                	andi	a5,a5,7
    8000845e:	00c508b3          	add	a7,a0,a2
    80008462:	e7a1                	bnez	a5,800084aa <memcpy+0x52>
    80008464:	479d                	li	a5,7
    80008466:	04c7f263          	bgeu	a5,a2,800084aa <memcpy+0x52>
    8000846a:	00757793          	andi	a5,a0,7
    8000846e:	872a                	mv	a4,a0
    80008470:	eba9                	bnez	a5,800084c2 <memcpy+0x6a>
    80008472:	ff88f613          	andi	a2,a7,-8
    80008476:	fc060793          	addi	a5,a2,-64
    8000847a:	06f76763          	bltu	a4,a5,800084e8 <memcpy+0x90>
    8000847e:	02c77363          	bgeu	a4,a2,800084a4 <memcpy+0x4c>
    80008482:	86ae                	mv	a3,a1
    80008484:	87ba                	mv	a5,a4
    80008486:	0006b803          	ld	a6,0(a3)
    8000848a:	07a1                	addi	a5,a5,8
    8000848c:	06a1                	addi	a3,a3,8
    8000848e:	ff07bc23          	sd	a6,-8(a5)
    80008492:	fec7eae3          	bltu	a5,a2,80008486 <memcpy+0x2e>
    80008496:	fff60793          	addi	a5,a2,-1
    8000849a:	8f99                	sub	a5,a5,a4
    8000849c:	9be1                	andi	a5,a5,-8
    8000849e:	07a1                	addi	a5,a5,8
    800084a0:	973e                	add	a4,a4,a5
    800084a2:	95be                	add	a1,a1,a5
    800084a4:	01176663          	bltu	a4,a7,800084b0 <memcpy+0x58>
    800084a8:	8082                	ret
    800084aa:	872a                	mv	a4,a0
    800084ac:	ff157ee3          	bgeu	a0,a7,800084a8 <memcpy+0x50>
    800084b0:	0005c783          	lbu	a5,0(a1) # ff0000 <_STACK_SIZE+0xfdc000>
    800084b4:	0705                	addi	a4,a4,1
    800084b6:	0585                	addi	a1,a1,1
    800084b8:	fef70fa3          	sb	a5,-1(a4)
    800084bc:	ff176ae3          	bltu	a4,a7,800084b0 <memcpy+0x58>
    800084c0:	8082                	ret
    800084c2:	0005c683          	lbu	a3,0(a1)
    800084c6:	0705                	addi	a4,a4,1
    800084c8:	00777793          	andi	a5,a4,7
    800084cc:	fed70fa3          	sb	a3,-1(a4)
    800084d0:	0585                	addi	a1,a1,1
    800084d2:	d3c5                	beqz	a5,80008472 <memcpy+0x1a>
    800084d4:	0005c683          	lbu	a3,0(a1)
    800084d8:	0705                	addi	a4,a4,1
    800084da:	00777793          	andi	a5,a4,7
    800084de:	fed70fa3          	sb	a3,-1(a4)
    800084e2:	0585                	addi	a1,a1,1
    800084e4:	fff9                	bnez	a5,800084c2 <memcpy+0x6a>
    800084e6:	b771                	j	80008472 <memcpy+0x1a>
    800084e8:	6594                	ld	a3,8(a1)
    800084ea:	0005b283          	ld	t0,0(a1)
    800084ee:	0105bf83          	ld	t6,16(a1)
    800084f2:	0185bf03          	ld	t5,24(a1)
    800084f6:	0205be83          	ld	t4,32(a1)
    800084fa:	0285be03          	ld	t3,40(a1)
    800084fe:	0305b303          	ld	t1,48(a1)
    80008502:	0385b803          	ld	a6,56(a1)
    80008506:	e714                	sd	a3,8(a4)
    80008508:	61b4                	ld	a3,64(a1)
    8000850a:	00573023          	sd	t0,0(a4)
    8000850e:	01f73823          	sd	t6,16(a4)
    80008512:	01e73c23          	sd	t5,24(a4)
    80008516:	03d73023          	sd	t4,32(a4)
    8000851a:	03c73423          	sd	t3,40(a4)
    8000851e:	02673823          	sd	t1,48(a4)
    80008522:	03073c23          	sd	a6,56(a4)
    80008526:	e334                	sd	a3,64(a4)
    80008528:	04870713          	addi	a4,a4,72
    8000852c:	04858593          	addi	a1,a1,72
    80008530:	faf76ce3          	bltu	a4,a5,800084e8 <memcpy+0x90>
    80008534:	b7a9                	j	8000847e <memcpy+0x26>

0000000080008536 <memset>:
    80008536:	433d                	li	t1,15
    80008538:	872a                	mv	a4,a0
    8000853a:	02c37163          	bgeu	t1,a2,8000855c <memset+0x26>
    8000853e:	00f77793          	andi	a5,a4,15
    80008542:	e3c1                	bnez	a5,800085c2 <memset+0x8c>
    80008544:	e1bd                	bnez	a1,800085aa <memset+0x74>
    80008546:	ff067693          	andi	a3,a2,-16
    8000854a:	8a3d                	andi	a2,a2,15
    8000854c:	96ba                	add	a3,a3,a4
    8000854e:	e30c                	sd	a1,0(a4)
    80008550:	e70c                	sd	a1,8(a4)
    80008552:	0741                	addi	a4,a4,16
    80008554:	fed76de3          	bltu	a4,a3,8000854e <memset+0x18>
    80008558:	e211                	bnez	a2,8000855c <memset+0x26>
    8000855a:	8082                	ret
    8000855c:	40c306b3          	sub	a3,t1,a2
    80008560:	068a                	slli	a3,a3,0x2
    80008562:	00000297          	auipc	t0,0x0
    80008566:	9696                	add	a3,a3,t0
    80008568:	00a68067          	jr	10(a3)
    8000856c:	00b70723          	sb	a1,14(a4)
    80008570:	00b706a3          	sb	a1,13(a4)
    80008574:	00b70623          	sb	a1,12(a4)
    80008578:	00b705a3          	sb	a1,11(a4)
    8000857c:	00b70523          	sb	a1,10(a4)
    80008580:	00b704a3          	sb	a1,9(a4)
    80008584:	00b70423          	sb	a1,8(a4)
    80008588:	00b703a3          	sb	a1,7(a4)
    8000858c:	00b70323          	sb	a1,6(a4)
    80008590:	00b702a3          	sb	a1,5(a4)
    80008594:	00b70223          	sb	a1,4(a4)
    80008598:	00b701a3          	sb	a1,3(a4)
    8000859c:	00b70123          	sb	a1,2(a4)
    800085a0:	00b700a3          	sb	a1,1(a4)
    800085a4:	00b70023          	sb	a1,0(a4)
    800085a8:	8082                	ret
    800085aa:	0ff5f593          	andi	a1,a1,255
    800085ae:	00859693          	slli	a3,a1,0x8
    800085b2:	8dd5                	or	a1,a1,a3
    800085b4:	01059693          	slli	a3,a1,0x10
    800085b8:	8dd5                	or	a1,a1,a3
    800085ba:	02059693          	slli	a3,a1,0x20
    800085be:	8dd5                	or	a1,a1,a3
    800085c0:	b759                	j	80008546 <memset+0x10>
    800085c2:	00279693          	slli	a3,a5,0x2
    800085c6:	00000297          	auipc	t0,0x0
    800085ca:	9696                	add	a3,a3,t0
    800085cc:	8286                	mv	t0,ra
    800085ce:	fa2680e7          	jalr	-94(a3)
    800085d2:	8096                	mv	ra,t0
    800085d4:	17c1                	addi	a5,a5,-16
    800085d6:	8f1d                	sub	a4,a4,a5
    800085d8:	963e                	add	a2,a2,a5
    800085da:	f8c371e3          	bgeu	t1,a2,8000855c <memset+0x26>
    800085de:	b79d                	j	80008544 <memset+0xe>

00000000800085e0 <strcpy>:
    800085e0:	00b567b3          	or	a5,a0,a1
    800085e4:	8b9d                	andi	a5,a5,7
    800085e6:	efbd                	bnez	a5,80008664 <strcpy+0x84>
    800085e8:	6198                	ld	a4,0(a1)
    800085ea:	00002697          	auipc	a3,0x2
    800085ee:	51e6b683          	ld	a3,1310(a3) # 8000ab08 <__rodata_end>
    800085f2:	567d                	li	a2,-1
    800085f4:	00d777b3          	and	a5,a4,a3
    800085f8:	97b6                	add	a5,a5,a3
    800085fa:	8fd9                	or	a5,a5,a4
    800085fc:	8fd5                	or	a5,a5,a3
    800085fe:	06c79c63          	bne	a5,a2,80008676 <strcpy+0x96>
    80008602:	862a                	mv	a2,a0
    80008604:	587d                	li	a6,-1
    80008606:	e218                	sd	a4,0(a2)
    80008608:	6598                	ld	a4,8(a1)
    8000860a:	05a1                	addi	a1,a1,8
    8000860c:	0621                	addi	a2,a2,8
    8000860e:	00d777b3          	and	a5,a4,a3
    80008612:	97b6                	add	a5,a5,a3
    80008614:	8fd9                	or	a5,a5,a4
    80008616:	8fd5                	or	a5,a5,a3
    80008618:	ff0787e3          	beq	a5,a6,80008606 <strcpy+0x26>
    8000861c:	0005c783          	lbu	a5,0(a1)
    80008620:	0015c703          	lbu	a4,1(a1)
    80008624:	0025c683          	lbu	a3,2(a1)
    80008628:	00f60023          	sb	a5,0(a2)
    8000862c:	cb9d                	beqz	a5,80008662 <strcpy+0x82>
    8000862e:	00e600a3          	sb	a4,1(a2)
    80008632:	cb05                	beqz	a4,80008662 <strcpy+0x82>
    80008634:	0035c783          	lbu	a5,3(a1)
    80008638:	00d60123          	sb	a3,2(a2)
    8000863c:	c29d                	beqz	a3,80008662 <strcpy+0x82>
    8000863e:	0045c703          	lbu	a4,4(a1)
    80008642:	00f601a3          	sb	a5,3(a2)
    80008646:	cf91                	beqz	a5,80008662 <strcpy+0x82>
    80008648:	0055c783          	lbu	a5,5(a1)
    8000864c:	00e60223          	sb	a4,4(a2)
    80008650:	cb09                	beqz	a4,80008662 <strcpy+0x82>
    80008652:	0065c703          	lbu	a4,6(a1)
    80008656:	00f602a3          	sb	a5,5(a2)
    8000865a:	c781                	beqz	a5,80008662 <strcpy+0x82>
    8000865c:	00e60323          	sb	a4,6(a2)
    80008660:	ef09                	bnez	a4,8000867a <strcpy+0x9a>
    80008662:	8082                	ret
    80008664:	87aa                	mv	a5,a0
    80008666:	0005c703          	lbu	a4,0(a1)
    8000866a:	0785                	addi	a5,a5,1
    8000866c:	0585                	addi	a1,a1,1
    8000866e:	fee78fa3          	sb	a4,-1(a5)
    80008672:	fb75                	bnez	a4,80008666 <strcpy+0x86>
    80008674:	8082                	ret
    80008676:	862a                	mv	a2,a0
    80008678:	b755                	j	8000861c <strcpy+0x3c>
    8000867a:	000603a3          	sb	zero,7(a2)
    8000867e:	8082                	ret

0000000080008680 <__clzdi2>:
    80008680:	03800793          	li	a5,56
    80008684:	00f55733          	srl	a4,a0,a5
    80008688:	0ff77713          	andi	a4,a4,255
    8000868c:	e319                	bnez	a4,80008692 <__clzdi2+0x12>
    8000868e:	17e1                	addi	a5,a5,-8
    80008690:	fbf5                	bnez	a5,80008684 <__clzdi2+0x4>
    80008692:	04000713          	li	a4,64
    80008696:	8f1d                	sub	a4,a4,a5
    80008698:	00f55533          	srl	a0,a0,a5
    8000869c:	00002797          	auipc	a5,0x2
    800086a0:	36c78793          	addi	a5,a5,876 # 8000aa08 <__clz_tab>
    800086a4:	953e                	add	a0,a0,a5
    800086a6:	00054503          	lbu	a0,0(a0) # b00000 <_STACK_SIZE+0xaec000>
    800086aa:	40a7053b          	subw	a0,a4,a0
    800086ae:	8082                	ret

00000000800086b0 <__adddf3>:
    800086b0:	1101                	addi	sp,sp,-32
    800086b2:	587d                	li	a6,-1
    800086b4:	00c85713          	srli	a4,a6,0xc
    800086b8:	0345d613          	srli	a2,a1,0x34
    800086bc:	e822                	sd	s0,16(sp)
    800086be:	03455413          	srli	s0,a0,0x34
    800086c2:	00a777b3          	and	a5,a4,a0
    800086c6:	e426                	sd	s1,8(sp)
    800086c8:	8f6d                	and	a4,a4,a1
    800086ca:	7ff47413          	andi	s0,s0,2047
    800086ce:	7ff67613          	andi	a2,a2,2047
    800086d2:	ec06                	sd	ra,24(sp)
    800086d4:	e04a                	sd	s2,0(sp)
    800086d6:	03f55493          	srli	s1,a0,0x3f
    800086da:	91fd                	srli	a1,a1,0x3f
    800086dc:	078e                	slli	a5,a5,0x3
    800086de:	070e                	slli	a4,a4,0x3
    800086e0:	40c406bb          	subw	a3,s0,a2
    800086e4:	12b49c63          	bne	s1,a1,8000881c <__adddf3+0x16c>
    800086e8:	0006859b          	sext.w	a1,a3
    800086ec:	08b05463          	blez	a1,80008774 <__adddf3+0xc4>
    800086f0:	ea21                	bnez	a2,80008740 <__adddf3+0x90>
    800086f2:	cf05                	beqz	a4,8000872a <__adddf3+0x7a>
    800086f4:	fff6859b          	addiw	a1,a3,-1
    800086f8:	e58d                	bnez	a1,80008722 <__adddf3+0x72>
    800086fa:	97ba                	add	a5,a5,a4
    800086fc:	00879713          	slli	a4,a5,0x8
    80008700:	02075563          	bgez	a4,8000872a <__adddf3+0x7a>
    80008704:	0405                	addi	s0,s0,1
    80008706:	7ff00713          	li	a4,2047
    8000870a:	28e40463          	beq	s0,a4,80008992 <__adddf3+0x2e2>
    8000870e:	1ff00713          	li	a4,511
    80008712:	175a                	slli	a4,a4,0x36
    80008714:	0017f693          	andi	a3,a5,1
    80008718:	177d                	addi	a4,a4,-1
    8000871a:	8385                	srli	a5,a5,0x1
    8000871c:	8ff9                	and	a5,a5,a4
    8000871e:	8fd5                	or	a5,a5,a3
    80008720:	a029                	j	8000872a <__adddf3+0x7a>
    80008722:	7ff00693          	li	a3,2047
    80008726:	02d41463          	bne	s0,a3,8000874e <__adddf3+0x9e>
    8000872a:	0077f713          	andi	a4,a5,7
    8000872e:	26070363          	beqz	a4,80008994 <__adddf3+0x2e4>
    80008732:	00f7f713          	andi	a4,a5,15
    80008736:	4691                	li	a3,4
    80008738:	24d70e63          	beq	a4,a3,80008994 <__adddf3+0x2e4>
    8000873c:	0791                	addi	a5,a5,4
    8000873e:	ac99                	j	80008994 <__adddf3+0x2e4>
    80008740:	7ff00693          	li	a3,2047
    80008744:	fed403e3          	beq	s0,a3,8000872a <__adddf3+0x7a>
    80008748:	4685                	li	a3,1
    8000874a:	16de                	slli	a3,a3,0x37
    8000874c:	8f55                	or	a4,a4,a3
    8000874e:	03800613          	li	a2,56
    80008752:	4685                	li	a3,1
    80008754:	00b64e63          	blt	a2,a1,80008770 <__adddf3+0xc0>
    80008758:	04000693          	li	a3,64
    8000875c:	00b75633          	srl	a2,a4,a1
    80008760:	40b685bb          	subw	a1,a3,a1
    80008764:	00b71733          	sll	a4,a4,a1
    80008768:	00e03733          	snez	a4,a4
    8000876c:	00e666b3          	or	a3,a2,a4
    80008770:	97b6                	add	a5,a5,a3
    80008772:	b769                	j	800086fc <__adddf3+0x4c>
    80008774:	cdb1                	beqz	a1,800087d0 <__adddf3+0x120>
    80008776:	e039                	bnez	s0,800087bc <__adddf3+0x10c>
    80008778:	20078463          	beqz	a5,80008980 <__adddf3+0x2d0>
    8000877c:	01059563          	bne	a1,a6,80008786 <__adddf3+0xd6>
    80008780:	97ba                	add	a5,a5,a4
    80008782:	8432                	mv	s0,a2
    80008784:	bfa5                	j	800086fc <__adddf3+0x4c>
    80008786:	7ff00593          	li	a1,2047
    8000878a:	20b60063          	beq	a2,a1,8000898a <__adddf3+0x2da>
    8000878e:	fff6c693          	not	a3,a3
    80008792:	2681                	sext.w	a3,a3
    80008794:	03800513          	li	a0,56
    80008798:	4585                	li	a1,1
    8000879a:	00d54e63          	blt	a0,a3,800087b6 <__adddf3+0x106>
    8000879e:	04000593          	li	a1,64
    800087a2:	00d7d533          	srl	a0,a5,a3
    800087a6:	40d586bb          	subw	a3,a1,a3
    800087aa:	00d797b3          	sll	a5,a5,a3
    800087ae:	00f037b3          	snez	a5,a5
    800087b2:	00f565b3          	or	a1,a0,a5
    800087b6:	00e587b3          	add	a5,a1,a4
    800087ba:	b7e1                	j	80008782 <__adddf3+0xd2>
    800087bc:	7ff00593          	li	a1,2047
    800087c0:	1cb60563          	beq	a2,a1,8000898a <__adddf3+0x2da>
    800087c4:	4585                	li	a1,1
    800087c6:	15de                	slli	a1,a1,0x37
    800087c8:	40d006bb          	negw	a3,a3
    800087cc:	8fcd                	or	a5,a5,a1
    800087ce:	b7d9                	j	80008794 <__adddf3+0xe4>
    800087d0:	00140693          	addi	a3,s0,1
    800087d4:	7fe6f613          	andi	a2,a3,2046
    800087d8:	ea15                	bnez	a2,8000880c <__adddf3+0x15c>
    800087da:	ec19                	bnez	s0,800087f8 <__adddf3+0x148>
    800087dc:	1a078563          	beqz	a5,80008986 <__adddf3+0x2d6>
    800087e0:	d729                	beqz	a4,8000872a <__adddf3+0x7a>
    800087e2:	97ba                	add	a5,a5,a4
    800087e4:	00879713          	slli	a4,a5,0x8
    800087e8:	f40751e3          	bgez	a4,8000872a <__adddf3+0x7a>
    800087ec:	185e                	slli	a6,a6,0x37
    800087ee:	187d                	addi	a6,a6,-1
    800087f0:	0107f7b3          	and	a5,a5,a6
    800087f4:	4405                	li	s0,1
    800087f6:	bf15                	j	8000872a <__adddf3+0x7a>
    800087f8:	18078963          	beqz	a5,8000898a <__adddf3+0x2da>
    800087fc:	12070063          	beqz	a4,8000891c <__adddf3+0x26c>
    80008800:	4785                	li	a5,1
    80008802:	4481                	li	s1,0
    80008804:	17da                	slli	a5,a5,0x36
    80008806:	7ff00413          	li	s0,2047
    8000880a:	a269                	j	80008994 <__adddf3+0x2e4>
    8000880c:	7ff00613          	li	a2,2047
    80008810:	16c68f63          	beq	a3,a2,8000898e <__adddf3+0x2de>
    80008814:	97ba                	add	a5,a5,a4
    80008816:	8385                	srli	a5,a5,0x1
    80008818:	8436                	mv	s0,a3
    8000881a:	bf01                	j	8000872a <__adddf3+0x7a>
    8000881c:	0006851b          	sext.w	a0,a3
    80008820:	04a05f63          	blez	a0,8000887e <__adddf3+0x1ce>
    80008824:	e629                	bnez	a2,8000886e <__adddf3+0x1be>
    80008826:	d311                	beqz	a4,8000872a <__adddf3+0x7a>
    80008828:	fff6851b          	addiw	a0,a3,-1
    8000882c:	e911                	bnez	a0,80008840 <__adddf3+0x190>
    8000882e:	8f99                	sub	a5,a5,a4
    80008830:	00879713          	slli	a4,a5,0x8
    80008834:	ee075be3          	bgez	a4,8000872a <__adddf3+0x7a>
    80008838:	07a6                	slli	a5,a5,0x9
    8000883a:	0097d913          	srli	s2,a5,0x9
    8000883e:	a8dd                	j	80008934 <__adddf3+0x284>
    80008840:	7ff00693          	li	a3,2047
    80008844:	eed403e3          	beq	s0,a3,8000872a <__adddf3+0x7a>
    80008848:	03800613          	li	a2,56
    8000884c:	4685                	li	a3,1
    8000884e:	00a64e63          	blt	a2,a0,8000886a <__adddf3+0x1ba>
    80008852:	04000693          	li	a3,64
    80008856:	00a75633          	srl	a2,a4,a0
    8000885a:	40a6853b          	subw	a0,a3,a0
    8000885e:	00a71733          	sll	a4,a4,a0
    80008862:	00e03733          	snez	a4,a4
    80008866:	00e666b3          	or	a3,a2,a4
    8000886a:	8f95                	sub	a5,a5,a3
    8000886c:	b7d1                	j	80008830 <__adddf3+0x180>
    8000886e:	7ff00693          	li	a3,2047
    80008872:	ead40ce3          	beq	s0,a3,8000872a <__adddf3+0x7a>
    80008876:	4685                	li	a3,1
    80008878:	16de                	slli	a3,a3,0x37
    8000887a:	8f55                	or	a4,a4,a3
    8000887c:	b7f1                	j	80008848 <__adddf3+0x198>
    8000887e:	c125                	beqz	a0,800088de <__adddf3+0x22e>
    80008880:	e429                	bnez	s0,800088ca <__adddf3+0x21a>
    80008882:	14078e63          	beqz	a5,800089de <__adddf3+0x32e>
    80008886:	01051763          	bne	a0,a6,80008894 <__adddf3+0x1e4>
    8000888a:	40f707b3          	sub	a5,a4,a5
    8000888e:	8432                	mv	s0,a2
    80008890:	84ae                	mv	s1,a1
    80008892:	bf79                	j	80008830 <__adddf3+0x180>
    80008894:	7ff00513          	li	a0,2047
    80008898:	14a60763          	beq	a2,a0,800089e6 <__adddf3+0x336>
    8000889c:	fff6c693          	not	a3,a3
    800088a0:	2681                	sext.w	a3,a3
    800088a2:	03800813          	li	a6,56
    800088a6:	4505                	li	a0,1
    800088a8:	00d84e63          	blt	a6,a3,800088c4 <__adddf3+0x214>
    800088ac:	04000513          	li	a0,64
    800088b0:	00d7d833          	srl	a6,a5,a3
    800088b4:	40d506bb          	subw	a3,a0,a3
    800088b8:	00d797b3          	sll	a5,a5,a3
    800088bc:	00f037b3          	snez	a5,a5
    800088c0:	00f86533          	or	a0,a6,a5
    800088c4:	40a707b3          	sub	a5,a4,a0
    800088c8:	b7d9                	j	8000888e <__adddf3+0x1de>
    800088ca:	7ff00513          	li	a0,2047
    800088ce:	10a60c63          	beq	a2,a0,800089e6 <__adddf3+0x336>
    800088d2:	4505                	li	a0,1
    800088d4:	155e                	slli	a0,a0,0x37
    800088d6:	40d006bb          	negw	a3,a3
    800088da:	8fc9                	or	a5,a5,a0
    800088dc:	b7d9                	j	800088a2 <__adddf3+0x1f2>
    800088de:	00140693          	addi	a3,s0,1
    800088e2:	7fe6f693          	andi	a3,a3,2046
    800088e6:	ee95                	bnez	a3,80008922 <__adddf3+0x272>
    800088e8:	e405                	bnez	s0,80008910 <__adddf3+0x260>
    800088ea:	e791                	bnez	a5,800088f6 <__adddf3+0x246>
    800088ec:	87ba                	mv	a5,a4
    800088ee:	eb75                	bnez	a4,800089e2 <__adddf3+0x332>
    800088f0:	4781                	li	a5,0
    800088f2:	4481                	li	s1,0
    800088f4:	a045                	j	80008994 <__adddf3+0x2e4>
    800088f6:	e2070ae3          	beqz	a4,8000872a <__adddf3+0x7a>
    800088fa:	40e786b3          	sub	a3,a5,a4
    800088fe:	00869613          	slli	a2,a3,0x8
    80008902:	40f707b3          	sub	a5,a4,a5
    80008906:	0c064e63          	bltz	a2,800089e2 <__adddf3+0x332>
    8000890a:	d2fd                	beqz	a3,800088f0 <__adddf3+0x240>
    8000890c:	87b6                	mv	a5,a3
    8000890e:	bd31                	j	8000872a <__adddf3+0x7a>
    80008910:	ee0796e3          	bnez	a5,800087fc <__adddf3+0x14c>
    80008914:	ee0706e3          	beqz	a4,80008800 <__adddf3+0x150>
    80008918:	87ba                	mv	a5,a4
    8000891a:	84ae                	mv	s1,a1
    8000891c:	7ff00413          	li	s0,2047
    80008920:	b529                	j	8000872a <__adddf3+0x7a>
    80008922:	40e78933          	sub	s2,a5,a4
    80008926:	00891693          	slli	a3,s2,0x8
    8000892a:	0206df63          	bgez	a3,80008968 <__adddf3+0x2b8>
    8000892e:	40f70933          	sub	s2,a4,a5
    80008932:	84ae                	mv	s1,a1
    80008934:	854a                	mv	a0,s2
    80008936:	d4bff0ef          	jal	ra,80008680 <__clzdi2>
    8000893a:	ff85079b          	addiw	a5,a0,-8
    8000893e:	00f91933          	sll	s2,s2,a5
    80008942:	0287c863          	blt	a5,s0,80008972 <__adddf3+0x2c2>
    80008946:	4087853b          	subw	a0,a5,s0
    8000894a:	2505                	addiw	a0,a0,1
    8000894c:	04000413          	li	s0,64
    80008950:	00a957b3          	srl	a5,s2,a0
    80008954:	40a4053b          	subw	a0,s0,a0
    80008958:	00a91933          	sll	s2,s2,a0
    8000895c:	01203933          	snez	s2,s2
    80008960:	0127e7b3          	or	a5,a5,s2
    80008964:	4401                	li	s0,0
    80008966:	b3d1                	j	8000872a <__adddf3+0x7a>
    80008968:	fc0916e3          	bnez	s2,80008934 <__adddf3+0x284>
    8000896c:	4781                	li	a5,0
    8000896e:	4401                	li	s0,0
    80008970:	b749                	j	800088f2 <__adddf3+0x242>
    80008972:	8c1d                	sub	s0,s0,a5
    80008974:	57fd                	li	a5,-1
    80008976:	17de                	slli	a5,a5,0x37
    80008978:	17fd                	addi	a5,a5,-1
    8000897a:	00f977b3          	and	a5,s2,a5
    8000897e:	b375                	j	8000872a <__adddf3+0x7a>
    80008980:	87ba                	mv	a5,a4
    80008982:	8432                	mv	s0,a2
    80008984:	b35d                	j	8000872a <__adddf3+0x7a>
    80008986:	87ba                	mv	a5,a4
    80008988:	b34d                	j	8000872a <__adddf3+0x7a>
    8000898a:	87ba                	mv	a5,a4
    8000898c:	bf41                	j	8000891c <__adddf3+0x26c>
    8000898e:	7ff00413          	li	s0,2047
    80008992:	4781                	li	a5,0
    80008994:	00879713          	slli	a4,a5,0x8
    80008998:	00075b63          	bgez	a4,800089ae <__adddf3+0x2fe>
    8000899c:	0405                	addi	s0,s0,1
    8000899e:	7ff00713          	li	a4,2047
    800089a2:	04e40663          	beq	s0,a4,800089ee <__adddf3+0x33e>
    800089a6:	577d                	li	a4,-1
    800089a8:	175e                	slli	a4,a4,0x37
    800089aa:	177d                	addi	a4,a4,-1
    800089ac:	8ff9                	and	a5,a5,a4
    800089ae:	7ff00713          	li	a4,2047
    800089b2:	838d                	srli	a5,a5,0x3
    800089b4:	00e41663          	bne	s0,a4,800089c0 <__adddf3+0x310>
    800089b8:	c781                	beqz	a5,800089c0 <__adddf3+0x310>
    800089ba:	4785                	li	a5,1
    800089bc:	17ce                	slli	a5,a5,0x33
    800089be:	4481                	li	s1,0
    800089c0:	7ff47413          	andi	s0,s0,2047
    800089c4:	07b2                	slli	a5,a5,0xc
    800089c6:	1452                	slli	s0,s0,0x34
    800089c8:	83b1                	srli	a5,a5,0xc
    800089ca:	60e2                	ld	ra,24(sp)
    800089cc:	8fc1                	or	a5,a5,s0
    800089ce:	6442                	ld	s0,16(sp)
    800089d0:	03f49513          	slli	a0,s1,0x3f
    800089d4:	6902                	ld	s2,0(sp)
    800089d6:	64a2                	ld	s1,8(sp)
    800089d8:	8d5d                	or	a0,a0,a5
    800089da:	6105                	addi	sp,sp,32
    800089dc:	8082                	ret
    800089de:	87ba                	mv	a5,a4
    800089e0:	8432                	mv	s0,a2
    800089e2:	84ae                	mv	s1,a1
    800089e4:	b399                	j	8000872a <__adddf3+0x7a>
    800089e6:	87ba                	mv	a5,a4
    800089e8:	7ff00413          	li	s0,2047
    800089ec:	bfdd                	j	800089e2 <__adddf3+0x332>
    800089ee:	4781                	li	a5,0
    800089f0:	bf7d                	j	800089ae <__adddf3+0x2fe>

00000000800089f2 <__eqsf2>:
    800089f2:	008007b7          	lui	a5,0x800
    800089f6:	17fd                	addi	a5,a5,-1
    800089f8:	00a7f6b3          	and	a3,a5,a0
    800089fc:	0175561b          	srliw	a2,a0,0x17
    80008a00:	8fed                	and	a5,a5,a1
    80008a02:	0175d81b          	srliw	a6,a1,0x17
    80008a06:	1682                	slli	a3,a3,0x20
    80008a08:	01f5571b          	srliw	a4,a0,0x1f
    80008a0c:	1782                	slli	a5,a5,0x20
    80008a0e:	0ff67613          	andi	a2,a2,255
    80008a12:	0ff00513          	li	a0,255
    80008a16:	9281                	srli	a3,a3,0x20
    80008a18:	9381                	srli	a5,a5,0x20
    80008a1a:	0ff87813          	andi	a6,a6,255
    80008a1e:	01f5d59b          	srliw	a1,a1,0x1f
    80008a22:	00a61463          	bne	a2,a0,80008a2a <__eqsf2+0x38>
    80008a26:	4505                	li	a0,1
    80008a28:	e29d                	bnez	a3,80008a4e <__eqsf2+0x5c>
    80008a2a:	0ff00513          	li	a0,255
    80008a2e:	00a81463          	bne	a6,a0,80008a36 <__eqsf2+0x44>
    80008a32:	4505                	li	a0,1
    80008a34:	ef89                	bnez	a5,80008a4e <__eqsf2+0x5c>
    80008a36:	4505                	li	a0,1
    80008a38:	01061b63          	bne	a2,a6,80008a4e <__eqsf2+0x5c>
    80008a3c:	00f69963          	bne	a3,a5,80008a4e <__eqsf2+0x5c>
    80008a40:	00b70663          	beq	a4,a1,80008a4c <__eqsf2+0x5a>
    80008a44:	e609                	bnez	a2,80008a4e <__eqsf2+0x5c>
    80008a46:	00d03533          	snez	a0,a3
    80008a4a:	8082                	ret
    80008a4c:	4501                	li	a0,0
    80008a4e:	8082                	ret

0000000080008a50 <__lesf2>:
    80008a50:	008007b7          	lui	a5,0x800
    80008a54:	17fd                	addi	a5,a5,-1
    80008a56:	00a7f6b3          	and	a3,a5,a0
    80008a5a:	0175561b          	srliw	a2,a0,0x17
    80008a5e:	8fed                	and	a5,a5,a1
    80008a60:	0175d71b          	srliw	a4,a1,0x17
    80008a64:	1682                	slli	a3,a3,0x20
    80008a66:	1782                	slli	a5,a5,0x20
    80008a68:	0ff67613          	andi	a2,a2,255
    80008a6c:	0ff00813          	li	a6,255
    80008a70:	9281                	srli	a3,a3,0x20
    80008a72:	01f5551b          	srliw	a0,a0,0x1f
    80008a76:	9381                	srli	a5,a5,0x20
    80008a78:	0ff77713          	andi	a4,a4,255
    80008a7c:	01f5d59b          	srliw	a1,a1,0x1f
    80008a80:	01061563          	bne	a2,a6,80008a8a <__lesf2+0x3a>
    80008a84:	c2b9                	beqz	a3,80008aca <__lesf2+0x7a>
    80008a86:	4509                	li	a0,2
    80008a88:	8082                	ret
    80008a8a:	01071363          	bne	a4,a6,80008a90 <__lesf2+0x40>
    80008a8e:	ffe5                	bnez	a5,80008a86 <__lesf2+0x36>
    80008a90:	ee1d                	bnez	a2,80008ace <__lesf2+0x7e>
    80008a92:	e311                	bnez	a4,80008a96 <__lesf2+0x46>
    80008a94:	cb8d                	beqz	a5,80008ac6 <__lesf2+0x76>
    80008a96:	ca81                	beqz	a3,80008aa6 <__lesf2+0x56>
    80008a98:	00b51463          	bne	a0,a1,80008aa0 <__lesf2+0x50>
    80008a9c:	00c75963          	bge	a4,a2,80008aae <__lesf2+0x5e>
    80008aa0:	c10d                	beqz	a0,80008ac2 <__lesf2+0x72>
    80008aa2:	557d                	li	a0,-1
    80008aa4:	8082                	ret
    80008aa6:	557d                	li	a0,-1
    80008aa8:	c591                	beqz	a1,80008ab4 <__lesf2+0x64>
    80008aaa:	852e                	mv	a0,a1
    80008aac:	8082                	ret
    80008aae:	00e65463          	bge	a2,a4,80008ab6 <__lesf2+0x66>
    80008ab2:	d965                	beqz	a0,80008aa2 <__lesf2+0x52>
    80008ab4:	8082                	ret
    80008ab6:	fed7e5e3          	bltu	a5,a3,80008aa0 <__lesf2+0x50>
    80008aba:	fef6ece3          	bltu	a3,a5,80008ab2 <__lesf2+0x62>
    80008abe:	4501                	li	a0,0
    80008ac0:	8082                	ret
    80008ac2:	4505                	li	a0,1
    80008ac4:	8082                	ret
    80008ac6:	dee5                	beqz	a3,80008abe <__lesf2+0x6e>
    80008ac8:	bfe1                	j	80008aa0 <__lesf2+0x50>
    80008aca:	fcc702e3          	beq	a4,a2,80008a8e <__lesf2+0x3e>
    80008ace:	f769                	bnez	a4,80008a98 <__lesf2+0x48>
    80008ad0:	dbe1                	beqz	a5,80008aa0 <__lesf2+0x50>
    80008ad2:	b7d9                	j	80008a98 <__lesf2+0x48>

0000000080008ad4 <__mulsf3>:
    80008ad4:	7139                	addi	sp,sp,-64
    80008ad6:	f426                	sd	s1,40(sp)
    80008ad8:	0175549b          	srliw	s1,a0,0x17
    80008adc:	f822                	sd	s0,48(sp)
    80008ade:	f04a                	sd	s2,32(sp)
    80008ae0:	ec4e                	sd	s3,24(sp)
    80008ae2:	e852                	sd	s4,16(sp)
    80008ae4:	02951413          	slli	s0,a0,0x29
    80008ae8:	fc06                	sd	ra,56(sp)
    80008aea:	e456                	sd	s5,8(sp)
    80008aec:	0ff4f493          	andi	s1,s1,255
    80008af0:	8a2e                	mv	s4,a1
    80008af2:	02945993          	srli	s3,s0,0x29
    80008af6:	01f5591b          	srliw	s2,a0,0x1f
    80008afa:	c8a5                	beqz	s1,80008b6a <__mulsf3+0x96>
    80008afc:	0ff00793          	li	a5,255
    80008b00:	08f48463          	beq	s1,a5,80008b88 <__mulsf3+0xb4>
    80008b04:	00399413          	slli	s0,s3,0x3
    80008b08:	040007b7          	lui	a5,0x4000
    80008b0c:	00f469b3          	or	s3,s0,a5
    80008b10:	f8148493          	addi	s1,s1,-127
    80008b14:	4a81                	li	s5,0
    80008b16:	017a579b          	srliw	a5,s4,0x17
    80008b1a:	029a1413          	slli	s0,s4,0x29
    80008b1e:	0ff7f793          	andi	a5,a5,255
    80008b22:	9025                	srli	s0,s0,0x29
    80008b24:	01fa5a1b          	srliw	s4,s4,0x1f
    80008b28:	cbb5                	beqz	a5,80008b9c <__mulsf3+0xc8>
    80008b2a:	0ff00713          	li	a4,255
    80008b2e:	08e78563          	beq	a5,a4,80008bb8 <__mulsf3+0xe4>
    80008b32:	040e                	slli	s0,s0,0x3
    80008b34:	04000737          	lui	a4,0x4000
    80008b38:	8c59                	or	s0,s0,a4
    80008b3a:	f8178793          	addi	a5,a5,-127 # 3ffff81 <_STACK_SIZE+0x3febf81>
    80008b3e:	4701                	li	a4,0
    80008b40:	94be                	add	s1,s1,a5
    80008b42:	002a9793          	slli	a5,s5,0x2
    80008b46:	8fd9                	or	a5,a5,a4
    80008b48:	17fd                	addi	a5,a5,-1
    80008b4a:	4639                	li	a2,14
    80008b4c:	01494533          	xor	a0,s2,s4
    80008b50:	00148693          	addi	a3,s1,1
    80008b54:	06f66b63          	bltu	a2,a5,80008bca <__mulsf3+0xf6>
    80008b58:	00002617          	auipc	a2,0x2
    80008b5c:	e7460613          	addi	a2,a2,-396 # 8000a9cc <__rodata_start+0x1674>
    80008b60:	078a                	slli	a5,a5,0x2
    80008b62:	97b2                	add	a5,a5,a2
    80008b64:	439c                	lw	a5,0(a5)
    80008b66:	97b2                	add	a5,a5,a2
    80008b68:	8782                	jr	a5
    80008b6a:	02098663          	beqz	s3,80008b96 <__mulsf3+0xc2>
    80008b6e:	854e                	mv	a0,s3
    80008b70:	b11ff0ef          	jal	ra,80008680 <__clzdi2>
    80008b74:	0005079b          	sext.w	a5,a0
    80008b78:	faa00493          	li	s1,-86
    80008b7c:	fdb5051b          	addiw	a0,a0,-37
    80008b80:	00a999b3          	sll	s3,s3,a0
    80008b84:	8c9d                	sub	s1,s1,a5
    80008b86:	b779                	j	80008b14 <__mulsf3+0x40>
    80008b88:	0ff00493          	li	s1,255
    80008b8c:	4a89                	li	s5,2
    80008b8e:	f80984e3          	beqz	s3,80008b16 <__mulsf3+0x42>
    80008b92:	4a8d                	li	s5,3
    80008b94:	b749                	j	80008b16 <__mulsf3+0x42>
    80008b96:	4481                	li	s1,0
    80008b98:	4a85                	li	s5,1
    80008b9a:	bfb5                	j	80008b16 <__mulsf3+0x42>
    80008b9c:	c405                	beqz	s0,80008bc4 <__mulsf3+0xf0>
    80008b9e:	8522                	mv	a0,s0
    80008ba0:	ae1ff0ef          	jal	ra,80008680 <__clzdi2>
    80008ba4:	0005071b          	sext.w	a4,a0
    80008ba8:	faa00793          	li	a5,-86
    80008bac:	fdb5051b          	addiw	a0,a0,-37
    80008bb0:	00a41433          	sll	s0,s0,a0
    80008bb4:	8f99                	sub	a5,a5,a4
    80008bb6:	b761                	j	80008b3e <__mulsf3+0x6a>
    80008bb8:	0ff00793          	li	a5,255
    80008bbc:	4709                	li	a4,2
    80008bbe:	d049                	beqz	s0,80008b40 <__mulsf3+0x6c>
    80008bc0:	470d                	li	a4,3
    80008bc2:	bfbd                	j	80008b40 <__mulsf3+0x6c>
    80008bc4:	4781                	li	a5,0
    80008bc6:	4705                	li	a4,1
    80008bc8:	bfa5                	j	80008b40 <__mulsf3+0x6c>
    80008bca:	02898433          	mul	s0,s3,s0
    80008bce:	01a45793          	srli	a5,s0,0x1a
    80008bd2:	141a                	slli	s0,s0,0x26
    80008bd4:	00803433          	snez	s0,s0
    80008bd8:	02479713          	slli	a4,a5,0x24
    80008bdc:	8c5d                	or	s0,s0,a5
    80008bde:	06075763          	bgez	a4,80008c4c <__mulsf3+0x178>
    80008be2:	00145793          	srli	a5,s0,0x1
    80008be6:	8805                	andi	s0,s0,1
    80008be8:	8c5d                	or	s0,s0,a5
    80008bea:	07f68793          	addi	a5,a3,127
    80008bee:	06f05163          	blez	a5,80008c50 <__mulsf3+0x17c>
    80008bf2:	00747713          	andi	a4,s0,7
    80008bf6:	c719                	beqz	a4,80008c04 <__mulsf3+0x130>
    80008bf8:	00f47713          	andi	a4,s0,15
    80008bfc:	4611                	li	a2,4
    80008bfe:	00c70363          	beq	a4,a2,80008c04 <__mulsf3+0x130>
    80008c02:	0411                	addi	s0,s0,4
    80008c04:	02441713          	slli	a4,s0,0x24
    80008c08:	00075863          	bgez	a4,80008c18 <__mulsf3+0x144>
    80008c0c:	f80007b7          	lui	a5,0xf8000
    80008c10:	17fd                	addi	a5,a5,-1
    80008c12:	8c7d                	and	s0,s0,a5
    80008c14:	08068793          	addi	a5,a3,128
    80008c18:	0fe00713          	li	a4,254
    80008c1c:	800d                	srli	s0,s0,0x3
    80008c1e:	06f75f63          	bge	a4,a5,80008c9c <__mulsf3+0x1c8>
    80008c22:	4401                	li	s0,0
    80008c24:	0ff00793          	li	a5,255
    80008c28:	a895                	j	80008c9c <__mulsf3+0x1c8>
    80008c2a:	854a                	mv	a0,s2
    80008c2c:	844e                	mv	s0,s3
    80008c2e:	8756                	mv	a4,s5
    80008c30:	4789                	li	a5,2
    80008c32:	fef708e3          	beq	a4,a5,80008c22 <__mulsf3+0x14e>
    80008c36:	478d                	li	a5,3
    80008c38:	04f70d63          	beq	a4,a5,80008c92 <__mulsf3+0x1be>
    80008c3c:	4785                	li	a5,1
    80008c3e:	faf716e3          	bne	a4,a5,80008bea <__mulsf3+0x116>
    80008c42:	4401                	li	s0,0
    80008c44:	4781                	li	a5,0
    80008c46:	a899                	j	80008c9c <__mulsf3+0x1c8>
    80008c48:	8552                	mv	a0,s4
    80008c4a:	b7dd                	j	80008c30 <__mulsf3+0x15c>
    80008c4c:	86a6                	mv	a3,s1
    80008c4e:	bf71                	j	80008bea <__mulsf3+0x116>
    80008c50:	4705                	li	a4,1
    80008c52:	8f1d                	sub	a4,a4,a5
    80008c54:	47ed                	li	a5,27
    80008c56:	fee7c6e3          	blt	a5,a4,80008c42 <__mulsf3+0x16e>
    80008c5a:	04000693          	li	a3,64
    80008c5e:	00e457b3          	srl	a5,s0,a4
    80008c62:	40e6873b          	subw	a4,a3,a4
    80008c66:	00e41433          	sll	s0,s0,a4
    80008c6a:	00803433          	snez	s0,s0
    80008c6e:	8c5d                	or	s0,s0,a5
    80008c70:	00747793          	andi	a5,s0,7
    80008c74:	c799                	beqz	a5,80008c82 <__mulsf3+0x1ae>
    80008c76:	00f47793          	andi	a5,s0,15
    80008c7a:	4711                	li	a4,4
    80008c7c:	00e78363          	beq	a5,a4,80008c82 <__mulsf3+0x1ae>
    80008c80:	0411                	addi	s0,s0,4
    80008c82:	02541793          	slli	a5,s0,0x25
    80008c86:	800d                	srli	s0,s0,0x3
    80008c88:	fa07dee3          	bgez	a5,80008c44 <__mulsf3+0x170>
    80008c8c:	4401                	li	s0,0
    80008c8e:	4785                	li	a5,1
    80008c90:	a031                	j	80008c9c <__mulsf3+0x1c8>
    80008c92:	00400437          	lui	s0,0x400
    80008c96:	0ff00793          	li	a5,255
    80008c9a:	4501                	li	a0,0
    80008c9c:	0ff7f793          	andi	a5,a5,255
    80008ca0:	1426                	slli	s0,s0,0x29
    80008ca2:	0177979b          	slliw	a5,a5,0x17
    80008ca6:	9025                	srli	s0,s0,0x29
    80008ca8:	8c5d                	or	s0,s0,a5
    80008caa:	01f5151b          	slliw	a0,a0,0x1f
    80008cae:	70e2                	ld	ra,56(sp)
    80008cb0:	8d41                	or	a0,a0,s0
    80008cb2:	7442                	ld	s0,48(sp)
    80008cb4:	74a2                	ld	s1,40(sp)
    80008cb6:	7902                	ld	s2,32(sp)
    80008cb8:	69e2                	ld	s3,24(sp)
    80008cba:	6a42                	ld	s4,16(sp)
    80008cbc:	6aa2                	ld	s5,8(sp)
    80008cbe:	6121                	addi	sp,sp,64
    80008cc0:	8082                	ret

0000000080008cc2 <__subsf3>:
    80008cc2:	008006b7          	lui	a3,0x800
    80008cc6:	16fd                	addi	a3,a3,-1
    80008cc8:	00a6f7b3          	and	a5,a3,a0
    80008ccc:	8eed                	and	a3,a3,a1
    80008cce:	1101                	addi	sp,sp,-32
    80008cd0:	0175d89b          	srliw	a7,a1,0x17
    80008cd4:	1782                	slli	a5,a5,0x20
    80008cd6:	0175581b          	srliw	a6,a0,0x17
    80008cda:	1682                	slli	a3,a3,0x20
    80008cdc:	e822                	sd	s0,16(sp)
    80008cde:	e04a                	sd	s2,0(sp)
    80008ce0:	9381                	srli	a5,a5,0x20
    80008ce2:	0ff87813          	andi	a6,a6,255
    80008ce6:	9281                	srli	a3,a3,0x20
    80008ce8:	0ff8f893          	andi	a7,a7,255
    80008cec:	ec06                	sd	ra,24(sp)
    80008cee:	e426                	sd	s1,8(sp)
    80008cf0:	0ff00613          	li	a2,255
    80008cf4:	8942                	mv	s2,a6
    80008cf6:	01f5541b          	srliw	s0,a0,0x1f
    80008cfa:	078e                	slli	a5,a5,0x3
    80008cfc:	8746                	mv	a4,a7
    80008cfe:	01f5d59b          	srliw	a1,a1,0x1f
    80008d02:	068e                	slli	a3,a3,0x3
    80008d04:	00c89363          	bne	a7,a2,80008d0a <__subsf3+0x48>
    80008d08:	e299                	bnez	a3,80008d0e <__subsf3+0x4c>
    80008d0a:	0015c593          	xori	a1,a1,1
    80008d0e:	4118063b          	subw	a2,a6,a7
    80008d12:	0006051b          	sext.w	a0,a2
    80008d16:	12859d63          	bne	a1,s0,80008e50 <__subsf3+0x18e>
    80008d1a:	06a05d63          	blez	a0,80008d94 <__subsf3+0xd2>
    80008d1e:	04089263          	bnez	a7,80008d62 <__subsf3+0xa0>
    80008d22:	28068c63          	beqz	a3,80008fba <__subsf3+0x2f8>
    80008d26:	fff6051b          	addiw	a0,a2,-1
    80008d2a:	e50d                	bnez	a0,80008d54 <__subsf3+0x92>
    80008d2c:	97b6                	add	a5,a5,a3
    80008d2e:	8742                	mv	a4,a6
    80008d30:	02579693          	slli	a3,a5,0x25
    80008d34:	0e06d263          	bgez	a3,80008e18 <__subsf3+0x156>
    80008d38:	0705                	addi	a4,a4,1
    80008d3a:	0ff00693          	li	a3,255
    80008d3e:	28d70663          	beq	a4,a3,80008fca <__subsf3+0x308>
    80008d42:	fc0006b7          	lui	a3,0xfc000
    80008d46:	16fd                	addi	a3,a3,-1
    80008d48:	0017f613          	andi	a2,a5,1
    80008d4c:	8ff5                	and	a5,a5,a3
    80008d4e:	8385                	srli	a5,a5,0x1
    80008d50:	8fd1                	or	a5,a5,a2
    80008d52:	a0d9                	j	80008e18 <__subsf3+0x156>
    80008d54:	0ff00713          	li	a4,255
    80008d58:	00e81c63          	bne	a6,a4,80008d70 <__subsf3+0xae>
    80008d5c:	0ff00713          	li	a4,255
    80008d60:	a865                	j	80008e18 <__subsf3+0x156>
    80008d62:	0ff00713          	li	a4,255
    80008d66:	fee80be3          	beq	a6,a4,80008d5c <__subsf3+0x9a>
    80008d6a:	04000737          	lui	a4,0x4000
    80008d6e:	8ed9                	or	a3,a3,a4
    80008d70:	466d                	li	a2,27
    80008d72:	4705                	li	a4,1
    80008d74:	00a64e63          	blt	a2,a0,80008d90 <__subsf3+0xce>
    80008d78:	04000713          	li	a4,64
    80008d7c:	00a6d633          	srl	a2,a3,a0
    80008d80:	40a7053b          	subw	a0,a4,a0
    80008d84:	00a696b3          	sll	a3,a3,a0
    80008d88:	00d036b3          	snez	a3,a3
    80008d8c:	00d66733          	or	a4,a2,a3
    80008d90:	97ba                	add	a5,a5,a4
    80008d92:	bf71                	j	80008d2e <__subsf3+0x6c>
    80008d94:	cd31                	beqz	a0,80008df0 <__subsf3+0x12e>
    80008d96:	04081363          	bnez	a6,80008ddc <__subsf3+0x11a>
    80008d9a:	22078263          	beqz	a5,80008fbe <__subsf3+0x2fc>
    80008d9e:	55fd                	li	a1,-1
    80008da0:	00b51463          	bne	a0,a1,80008da8 <__subsf3+0xe6>
    80008da4:	97b6                	add	a5,a5,a3
    80008da6:	b769                	j	80008d30 <__subsf3+0x6e>
    80008da8:	0ff00593          	li	a1,255
    80008dac:	20b88b63          	beq	a7,a1,80008fc2 <__subsf3+0x300>
    80008db0:	fff64613          	not	a2,a2
    80008db4:	2601                	sext.w	a2,a2
    80008db6:	456d                	li	a0,27
    80008db8:	4585                	li	a1,1
    80008dba:	00c54e63          	blt	a0,a2,80008dd6 <__subsf3+0x114>
    80008dbe:	04000593          	li	a1,64
    80008dc2:	00c7d533          	srl	a0,a5,a2
    80008dc6:	40c5863b          	subw	a2,a1,a2
    80008dca:	00c797b3          	sll	a5,a5,a2
    80008dce:	00f037b3          	snez	a5,a5
    80008dd2:	00f565b3          	or	a1,a0,a5
    80008dd6:	00d587b3          	add	a5,a1,a3
    80008dda:	bf99                	j	80008d30 <__subsf3+0x6e>
    80008ddc:	0ff00593          	li	a1,255
    80008de0:	1eb88163          	beq	a7,a1,80008fc2 <__subsf3+0x300>
    80008de4:	040005b7          	lui	a1,0x4000
    80008de8:	40c0063b          	negw	a2,a2
    80008dec:	8fcd                	or	a5,a5,a1
    80008dee:	b7e1                	j	80008db6 <__subsf3+0xf4>
    80008df0:	00180613          	addi	a2,a6,1
    80008df4:	0fe67713          	andi	a4,a2,254
    80008df8:	e721                	bnez	a4,80008e40 <__subsf3+0x17e>
    80008dfa:	02081a63          	bnez	a6,80008e2e <__subsf3+0x16c>
    80008dfe:	1c078063          	beqz	a5,80008fbe <__subsf3+0x2fc>
    80008e02:	ca99                	beqz	a3,80008e18 <__subsf3+0x156>
    80008e04:	97b6                	add	a5,a5,a3
    80008e06:	02579693          	slli	a3,a5,0x25
    80008e0a:	0006d763          	bgez	a3,80008e18 <__subsf3+0x156>
    80008e0e:	fc000737          	lui	a4,0xfc000
    80008e12:	177d                	addi	a4,a4,-1
    80008e14:	8ff9                	and	a5,a5,a4
    80008e16:	4705                	li	a4,1
    80008e18:	0077f693          	andi	a3,a5,7
    80008e1c:	1a068863          	beqz	a3,80008fcc <__subsf3+0x30a>
    80008e20:	00f7f693          	andi	a3,a5,15
    80008e24:	4611                	li	a2,4
    80008e26:	1ac68363          	beq	a3,a2,80008fcc <__subsf3+0x30a>
    80008e2a:	0791                	addi	a5,a5,4
    80008e2c:	a245                	j	80008fcc <__subsf3+0x30a>
    80008e2e:	18078a63          	beqz	a5,80008fc2 <__subsf3+0x300>
    80008e32:	d68d                	beqz	a3,80008d5c <__subsf3+0x9a>
    80008e34:	4401                	li	s0,0
    80008e36:	020007b7          	lui	a5,0x2000
    80008e3a:	0ff00713          	li	a4,255
    80008e3e:	a279                	j	80008fcc <__subsf3+0x30a>
    80008e40:	0ff00713          	li	a4,255
    80008e44:	18e60163          	beq	a2,a4,80008fc6 <__subsf3+0x304>
    80008e48:	97b6                	add	a5,a5,a3
    80008e4a:	8385                	srli	a5,a5,0x1
    80008e4c:	8732                	mv	a4,a2
    80008e4e:	b7e9                	j	80008e18 <__subsf3+0x156>
    80008e50:	06a05763          	blez	a0,80008ebe <__subsf3+0x1fc>
    80008e54:	04089b63          	bnez	a7,80008eaa <__subsf3+0x1e8>
    80008e58:	8742                	mv	a4,a6
    80008e5a:	dedd                	beqz	a3,80008e18 <__subsf3+0x156>
    80008e5c:	fff6051b          	addiw	a0,a2,-1
    80008e60:	ed01                	bnez	a0,80008e78 <__subsf3+0x1b6>
    80008e62:	8f95                	sub	a5,a5,a3
    80008e64:	02579693          	slli	a3,a5,0x25
    80008e68:	fa06d8e3          	bgez	a3,80008e18 <__subsf3+0x156>
    80008e6c:	040004b7          	lui	s1,0x4000
    80008e70:	14fd                	addi	s1,s1,-1
    80008e72:	8cfd                	and	s1,s1,a5
    80008e74:	893a                	mv	s2,a4
    80008e76:	a8f5                	j	80008f72 <__subsf3+0x2b0>
    80008e78:	0ff00613          	li	a2,255
    80008e7c:	0ff00713          	li	a4,255
    80008e80:	f8c80ce3          	beq	a6,a2,80008e18 <__subsf3+0x156>
    80008e84:	466d                	li	a2,27
    80008e86:	4705                	li	a4,1
    80008e88:	00a64e63          	blt	a2,a0,80008ea4 <__subsf3+0x1e2>
    80008e8c:	04000713          	li	a4,64
    80008e90:	00a6d633          	srl	a2,a3,a0
    80008e94:	40a7053b          	subw	a0,a4,a0
    80008e98:	00a696b3          	sll	a3,a3,a0
    80008e9c:	00d036b3          	snez	a3,a3
    80008ea0:	00d66733          	or	a4,a2,a3
    80008ea4:	8f99                	sub	a5,a5,a4
    80008ea6:	8742                	mv	a4,a6
    80008ea8:	bf75                	j	80008e64 <__subsf3+0x1a2>
    80008eaa:	0ff00613          	li	a2,255
    80008eae:	0ff00713          	li	a4,255
    80008eb2:	f6c803e3          	beq	a6,a2,80008e18 <__subsf3+0x156>
    80008eb6:	04000737          	lui	a4,0x4000
    80008eba:	8ed9                	or	a3,a3,a4
    80008ebc:	b7e1                	j	80008e84 <__subsf3+0x1c2>
    80008ebe:	cd39                	beqz	a0,80008f1c <__subsf3+0x25a>
    80008ec0:	04081463          	bnez	a6,80008f08 <__subsf3+0x246>
    80008ec4:	c7ad                	beqz	a5,80008f2e <__subsf3+0x26c>
    80008ec6:	587d                	li	a6,-1
    80008ec8:	01051663          	bne	a0,a6,80008ed4 <__subsf3+0x212>
    80008ecc:	40f687b3          	sub	a5,a3,a5
    80008ed0:	842e                	mv	s0,a1
    80008ed2:	bf49                	j	80008e64 <__subsf3+0x1a2>
    80008ed4:	0ff00513          	li	a0,255
    80008ed8:	08a88163          	beq	a7,a0,80008f5a <__subsf3+0x298>
    80008edc:	fff64613          	not	a2,a2
    80008ee0:	2601                	sext.w	a2,a2
    80008ee2:	486d                	li	a6,27
    80008ee4:	4505                	li	a0,1
    80008ee6:	00c84e63          	blt	a6,a2,80008f02 <__subsf3+0x240>
    80008eea:	04000513          	li	a0,64
    80008eee:	00c7d833          	srl	a6,a5,a2
    80008ef2:	40c5063b          	subw	a2,a0,a2
    80008ef6:	00c797b3          	sll	a5,a5,a2
    80008efa:	00f037b3          	snez	a5,a5
    80008efe:	00f86533          	or	a0,a6,a5
    80008f02:	40a687b3          	sub	a5,a3,a0
    80008f06:	b7e9                	j	80008ed0 <__subsf3+0x20e>
    80008f08:	0ff00513          	li	a0,255
    80008f0c:	04a88763          	beq	a7,a0,80008f5a <__subsf3+0x298>
    80008f10:	04000537          	lui	a0,0x4000
    80008f14:	40c0063b          	negw	a2,a2
    80008f18:	8fc9                	or	a5,a5,a0
    80008f1a:	b7e1                	j	80008ee2 <__subsf3+0x220>
    80008f1c:	00180713          	addi	a4,a6,1
    80008f20:	0fe77713          	andi	a4,a4,254
    80008f24:	ef15                	bnez	a4,80008f60 <__subsf3+0x29e>
    80008f26:	02081663          	bnez	a6,80008f52 <__subsf3+0x290>
    80008f2a:	e781                	bnez	a5,80008f32 <__subsf3+0x270>
    80008f2c:	c285                	beqz	a3,80008f4c <__subsf3+0x28a>
    80008f2e:	87b6                	mv	a5,a3
    80008f30:	a819                	j	80008f46 <__subsf3+0x284>
    80008f32:	ee0683e3          	beqz	a3,80008e18 <__subsf3+0x156>
    80008f36:	40d78633          	sub	a2,a5,a3
    80008f3a:	02561513          	slli	a0,a2,0x25
    80008f3e:	00055663          	bgez	a0,80008f4a <__subsf3+0x288>
    80008f42:	40f687b3          	sub	a5,a3,a5
    80008f46:	842e                	mv	s0,a1
    80008f48:	bdc1                	j	80008e18 <__subsf3+0x156>
    80008f4a:	e679                	bnez	a2,80009018 <__subsf3+0x356>
    80008f4c:	4781                	li	a5,0
    80008f4e:	4401                	li	s0,0
    80008f50:	a8b5                	j	80008fcc <__subsf3+0x30a>
    80008f52:	ee0790e3          	bnez	a5,80008e32 <__subsf3+0x170>
    80008f56:	ec068fe3          	beqz	a3,80008e34 <__subsf3+0x172>
    80008f5a:	87b6                	mv	a5,a3
    80008f5c:	842e                	mv	s0,a1
    80008f5e:	bbfd                	j	80008d5c <__subsf3+0x9a>
    80008f60:	40d784b3          	sub	s1,a5,a3
    80008f64:	02549713          	slli	a4,s1,0x25
    80008f68:	02075e63          	bgez	a4,80008fa4 <__subsf3+0x2e2>
    80008f6c:	40f684b3          	sub	s1,a3,a5
    80008f70:	842e                	mv	s0,a1
    80008f72:	8526                	mv	a0,s1
    80008f74:	f0cff0ef          	jal	ra,80008680 <__clzdi2>
    80008f78:	fdb5071b          	addiw	a4,a0,-37
    80008f7c:	00e494b3          	sll	s1,s1,a4
    80008f80:	03274663          	blt	a4,s2,80008fac <__subsf3+0x2ea>
    80008f84:	4127053b          	subw	a0,a4,s2
    80008f88:	2505                	addiw	a0,a0,1
    80008f8a:	04000713          	li	a4,64
    80008f8e:	00a4d7b3          	srl	a5,s1,a0
    80008f92:	40a7053b          	subw	a0,a4,a0
    80008f96:	00a494b3          	sll	s1,s1,a0
    80008f9a:	009034b3          	snez	s1,s1
    80008f9e:	8fc5                	or	a5,a5,s1
    80008fa0:	4701                	li	a4,0
    80008fa2:	bd9d                	j	80008e18 <__subsf3+0x156>
    80008fa4:	f4f9                	bnez	s1,80008f72 <__subsf3+0x2b0>
    80008fa6:	4781                	li	a5,0
    80008fa8:	4701                	li	a4,0
    80008faa:	b755                	j	80008f4e <__subsf3+0x28c>
    80008fac:	fc0007b7          	lui	a5,0xfc000
    80008fb0:	17fd                	addi	a5,a5,-1
    80008fb2:	40e90733          	sub	a4,s2,a4
    80008fb6:	8fe5                	and	a5,a5,s1
    80008fb8:	b585                	j	80008e18 <__subsf3+0x156>
    80008fba:	8742                	mv	a4,a6
    80008fbc:	bdb1                	j	80008e18 <__subsf3+0x156>
    80008fbe:	87b6                	mv	a5,a3
    80008fc0:	bda1                	j	80008e18 <__subsf3+0x156>
    80008fc2:	87b6                	mv	a5,a3
    80008fc4:	bb61                	j	80008d5c <__subsf3+0x9a>
    80008fc6:	0ff00713          	li	a4,255
    80008fca:	4781                	li	a5,0
    80008fcc:	02579693          	slli	a3,a5,0x25
    80008fd0:	0006db63          	bgez	a3,80008fe6 <__subsf3+0x324>
    80008fd4:	0705                	addi	a4,a4,1
    80008fd6:	0ff00693          	li	a3,255
    80008fda:	04d70163          	beq	a4,a3,8000901c <__subsf3+0x35a>
    80008fde:	fc0006b7          	lui	a3,0xfc000
    80008fe2:	16fd                	addi	a3,a3,-1
    80008fe4:	8ff5                	and	a5,a5,a3
    80008fe6:	0ff00693          	li	a3,255
    80008fea:	838d                	srli	a5,a5,0x3
    80008fec:	00d71663          	bne	a4,a3,80008ff8 <__subsf3+0x336>
    80008ff0:	c781                	beqz	a5,80008ff8 <__subsf3+0x336>
    80008ff2:	004007b7          	lui	a5,0x400
    80008ff6:	4401                	li	s0,0
    80008ff8:	60e2                	ld	ra,24(sp)
    80008ffa:	01f4151b          	slliw	a0,s0,0x1f
    80008ffe:	0ff77713          	andi	a4,a4,255
    80009002:	6442                	ld	s0,16(sp)
    80009004:	17a6                	slli	a5,a5,0x29
    80009006:	0177171b          	slliw	a4,a4,0x17
    8000900a:	93a5                	srli	a5,a5,0x29
    8000900c:	8fd9                	or	a5,a5,a4
    8000900e:	64a2                	ld	s1,8(sp)
    80009010:	6902                	ld	s2,0(sp)
    80009012:	8d5d                	or	a0,a0,a5
    80009014:	6105                	addi	sp,sp,32
    80009016:	8082                	ret
    80009018:	87b2                	mv	a5,a2
    8000901a:	bbfd                	j	80008e18 <__subsf3+0x156>
    8000901c:	4781                	li	a5,0
    8000901e:	b7e1                	j	80008fe6 <__subsf3+0x324>

0000000080009020 <__fixsfsi>:
    80009020:	00800637          	lui	a2,0x800
    80009024:	fff60793          	addi	a5,a2,-1 # 7fffff <_STACK_SIZE+0x7ebfff>
    80009028:	0175569b          	srliw	a3,a0,0x17
    8000902c:	8fe9                	and	a5,a5,a0
    8000902e:	0ff6f693          	andi	a3,a3,255
    80009032:	07e00593          	li	a1,126
    80009036:	2781                	sext.w	a5,a5
    80009038:	01f5571b          	srliw	a4,a0,0x1f
    8000903c:	04d5f663          	bgeu	a1,a3,80009088 <__fixsfsi+0x68>
    80009040:	09d00593          	li	a1,157
    80009044:	00d5f863          	bgeu	a1,a3,80009054 <__fixsfsi+0x34>
    80009048:	80000537          	lui	a0,0x80000
    8000904c:	fff54513          	not	a0,a0
    80009050:	9d39                	addw	a0,a0,a4
    80009052:	8082                	ret
    80009054:	02079513          	slli	a0,a5,0x20
    80009058:	9101                	srli	a0,a0,0x20
    8000905a:	8d51                	or	a0,a0,a2
    8000905c:	09500613          	li	a2,149
    80009060:	0006879b          	sext.w	a5,a3
    80009064:	00d67a63          	bgeu	a2,a3,80009078 <__fixsfsi+0x58>
    80009068:	f6a7879b          	addiw	a5,a5,-150
    8000906c:	00f5153b          	sllw	a0,a0,a5
    80009070:	cf09                	beqz	a4,8000908a <__fixsfsi+0x6a>
    80009072:	40a0053b          	negw	a0,a0
    80009076:	8082                	ret
    80009078:	09600693          	li	a3,150
    8000907c:	40f687bb          	subw	a5,a3,a5
    80009080:	00f55533          	srl	a0,a0,a5
    80009084:	2501                	sext.w	a0,a0
    80009086:	b7ed                	j	80009070 <__fixsfsi+0x50>
    80009088:	4501                	li	a0,0
    8000908a:	8082                	ret

000000008000908c <__floatsisf>:
    8000908c:	1101                	addi	sp,sp,-32
    8000908e:	ec06                	sd	ra,24(sp)
    80009090:	e822                	sd	s0,16(sp)
    80009092:	e426                	sd	s1,8(sp)
    80009094:	e04a                	sd	s2,0(sp)
    80009096:	cd55                	beqz	a0,80009152 <__floatsisf+0xc6>
    80009098:	0005049b          	sext.w	s1,a0
    8000909c:	03f55913          	srli	s2,a0,0x3f
    800090a0:	00055463          	bgez	a0,800090a8 <__floatsisf+0x1c>
    800090a4:	409004bb          	negw	s1,s1
    800090a8:	02049413          	slli	s0,s1,0x20
    800090ac:	9001                	srli	s0,s0,0x20
    800090ae:	8522                	mv	a0,s0
    800090b0:	dd0ff0ef          	jal	ra,80008680 <__clzdi2>
    800090b4:	0be00793          	li	a5,190
    800090b8:	9f89                	subw	a5,a5,a0
    800090ba:	09600713          	li	a4,150
    800090be:	02f74663          	blt	a4,a5,800090ea <__floatsisf+0x5e>
    800090c2:	00e78663          	beq	a5,a4,800090ce <__floatsisf+0x42>
    800090c6:	40f7053b          	subw	a0,a4,a5
    800090ca:	00a41433          	sll	s0,s0,a0
    800090ce:	1426                	slli	s0,s0,0x29
    800090d0:	0177979b          	slliw	a5,a5,0x17
    800090d4:	9025                	srli	s0,s0,0x29
    800090d6:	8c5d                	or	s0,s0,a5
    800090d8:	01f9151b          	slliw	a0,s2,0x1f
    800090dc:	60e2                	ld	ra,24(sp)
    800090de:	8d41                	or	a0,a0,s0
    800090e0:	6442                	ld	s0,16(sp)
    800090e2:	64a2                	ld	s1,8(sp)
    800090e4:	6902                	ld	s2,0(sp)
    800090e6:	6105                	addi	sp,sp,32
    800090e8:	8082                	ret
    800090ea:	09900713          	li	a4,153
    800090ee:	00f75f63          	bge	a4,a5,8000910c <__floatsisf+0x80>
    800090f2:	0b900693          	li	a3,185
    800090f6:	f677871b          	addiw	a4,a5,-153
    800090fa:	9e9d                	subw	a3,a3,a5
    800090fc:	00e4d73b          	srlw	a4,s1,a4
    80009100:	00d494bb          	sllw	s1,s1,a3
    80009104:	009034b3          	snez	s1,s1
    80009108:	8cd9                	or	s1,s1,a4
    8000910a:	2481                	sext.w	s1,s1
    8000910c:	09900713          	li	a4,153
    80009110:	1482                	slli	s1,s1,0x20
    80009112:	8f1d                	sub	a4,a4,a5
    80009114:	9081                	srli	s1,s1,0x20
    80009116:	00e05763          	blez	a4,80009124 <__floatsisf+0x98>
    8000911a:	09900713          	li	a4,153
    8000911e:	9f1d                	subw	a4,a4,a5
    80009120:	00e494b3          	sll	s1,s1,a4
    80009124:	fc000437          	lui	s0,0xfc000
    80009128:	147d                	addi	s0,s0,-1
    8000912a:	0074f713          	andi	a4,s1,7
    8000912e:	8c65                	and	s0,s0,s1
    80009130:	c711                	beqz	a4,8000913c <__floatsisf+0xb0>
    80009132:	88bd                	andi	s1,s1,15
    80009134:	4711                	li	a4,4
    80009136:	00e48363          	beq	s1,a4,8000913c <__floatsisf+0xb0>
    8000913a:	0411                	addi	s0,s0,4
    8000913c:	02541713          	slli	a4,s0,0x25
    80009140:	00075763          	bgez	a4,8000914e <__floatsisf+0xc2>
    80009144:	fc000737          	lui	a4,0xfc000
    80009148:	177d                	addi	a4,a4,-1
    8000914a:	8c79                	and	s0,s0,a4
    8000914c:	0785                	addi	a5,a5,1
    8000914e:	800d                	srli	s0,s0,0x3
    80009150:	bfbd                	j	800090ce <__floatsisf+0x42>
    80009152:	4401                	li	s0,0
    80009154:	4781                	li	a5,0
    80009156:	4901                	li	s2,0
    80009158:	bf9d                	j	800090ce <__floatsisf+0x42>

000000008000915a <__floatunsisf>:
    8000915a:	1101                	addi	sp,sp,-32
    8000915c:	ec06                	sd	ra,24(sp)
    8000915e:	e822                	sd	s0,16(sp)
    80009160:	e426                	sd	s1,8(sp)
    80009162:	c15d                	beqz	a0,80009208 <__floatunsisf+0xae>
    80009164:	02051413          	slli	s0,a0,0x20
    80009168:	9001                	srli	s0,s0,0x20
    8000916a:	84aa                	mv	s1,a0
    8000916c:	8522                	mv	a0,s0
    8000916e:	d12ff0ef          	jal	ra,80008680 <__clzdi2>
    80009172:	0be00793          	li	a5,190
    80009176:	9f89                	subw	a5,a5,a0
    80009178:	09600713          	li	a4,150
    8000917c:	02f74263          	blt	a4,a5,800091a0 <__floatunsisf+0x46>
    80009180:	00e78663          	beq	a5,a4,8000918c <__floatunsisf+0x32>
    80009184:	40f7053b          	subw	a0,a4,a5
    80009188:	00a41433          	sll	s0,s0,a0
    8000918c:	1426                	slli	s0,s0,0x29
    8000918e:	9025                	srli	s0,s0,0x29
    80009190:	0177951b          	slliw	a0,a5,0x17
    80009194:	60e2                	ld	ra,24(sp)
    80009196:	8d41                	or	a0,a0,s0
    80009198:	6442                	ld	s0,16(sp)
    8000919a:	64a2                	ld	s1,8(sp)
    8000919c:	6105                	addi	sp,sp,32
    8000919e:	8082                	ret
    800091a0:	09900713          	li	a4,153
    800091a4:	00f75f63          	bge	a4,a5,800091c2 <__floatunsisf+0x68>
    800091a8:	0b900513          	li	a0,185
    800091ac:	9d1d                	subw	a0,a0,a5
    800091ae:	00a4953b          	sllw	a0,s1,a0
    800091b2:	f677871b          	addiw	a4,a5,-153
    800091b6:	00a03533          	snez	a0,a0
    800091ba:	00e4d4bb          	srlw	s1,s1,a4
    800091be:	8cc9                	or	s1,s1,a0
    800091c0:	2481                	sext.w	s1,s1
    800091c2:	09900713          	li	a4,153
    800091c6:	1482                	slli	s1,s1,0x20
    800091c8:	8f1d                	sub	a4,a4,a5
    800091ca:	9081                	srli	s1,s1,0x20
    800091cc:	00e05763          	blez	a4,800091da <__floatunsisf+0x80>
    800091d0:	09900713          	li	a4,153
    800091d4:	9f1d                	subw	a4,a4,a5
    800091d6:	00e494b3          	sll	s1,s1,a4
    800091da:	fc000437          	lui	s0,0xfc000
    800091de:	147d                	addi	s0,s0,-1
    800091e0:	0074f713          	andi	a4,s1,7
    800091e4:	8c65                	and	s0,s0,s1
    800091e6:	c711                	beqz	a4,800091f2 <__floatunsisf+0x98>
    800091e8:	88bd                	andi	s1,s1,15
    800091ea:	4711                	li	a4,4
    800091ec:	00e48363          	beq	s1,a4,800091f2 <__floatunsisf+0x98>
    800091f0:	0411                	addi	s0,s0,4
    800091f2:	02541713          	slli	a4,s0,0x25
    800091f6:	00075763          	bgez	a4,80009204 <__floatunsisf+0xaa>
    800091fa:	fc000737          	lui	a4,0xfc000
    800091fe:	177d                	addi	a4,a4,-1
    80009200:	8c79                	and	s0,s0,a4
    80009202:	0785                	addi	a5,a5,1
    80009204:	800d                	srli	s0,s0,0x3
    80009206:	b759                	j	8000918c <__floatunsisf+0x32>
    80009208:	4401                	li	s0,0
    8000920a:	4781                	li	a5,0
    8000920c:	b741                	j	8000918c <__floatunsisf+0x32>

000000008000920e <__extendsfdf2>:
    8000920e:	0175579b          	srliw	a5,a0,0x17
    80009212:	1101                	addi	sp,sp,-32
    80009214:	0ff7f793          	andi	a5,a5,255
    80009218:	e822                	sd	s0,16(sp)
    8000921a:	e426                	sd	s1,8(sp)
    8000921c:	02951413          	slli	s0,a0,0x29
    80009220:	01f5549b          	srliw	s1,a0,0x1f
    80009224:	00178513          	addi	a0,a5,1 # 400001 <_STACK_SIZE+0x3ec001>
    80009228:	ec06                	sd	ra,24(sp)
    8000922a:	0fe57513          	andi	a0,a0,254
    8000922e:	9025                	srli	s0,s0,0x29
    80009230:	c105                	beqz	a0,80009250 <__extendsfdf2+0x42>
    80009232:	38078513          	addi	a0,a5,896
    80009236:	0476                	slli	s0,s0,0x1d
    80009238:	0432                	slli	s0,s0,0xc
    8000923a:	1552                	slli	a0,a0,0x34
    8000923c:	8031                	srli	s0,s0,0xc
    8000923e:	8c49                	or	s0,s0,a0
    80009240:	03f49513          	slli	a0,s1,0x3f
    80009244:	60e2                	ld	ra,24(sp)
    80009246:	8d41                	or	a0,a0,s0
    80009248:	6442                	ld	s0,16(sp)
    8000924a:	64a2                	ld	s1,8(sp)
    8000924c:	6105                	addi	sp,sp,32
    8000924e:	8082                	ret
    80009250:	ef91                	bnez	a5,8000926c <__extendsfdf2+0x5e>
    80009252:	d07d                	beqz	s0,80009238 <__extendsfdf2+0x2a>
    80009254:	8522                	mv	a0,s0
    80009256:	c2aff0ef          	jal	ra,80008680 <__clzdi2>
    8000925a:	ff55079b          	addiw	a5,a0,-11
    8000925e:	00f41433          	sll	s0,s0,a5
    80009262:	3a900793          	li	a5,937
    80009266:	40a7853b          	subw	a0,a5,a0
    8000926a:	b7f9                	j	80009238 <__extendsfdf2+0x2a>
    8000926c:	7ff00513          	li	a0,2047
    80009270:	d461                	beqz	s0,80009238 <__extendsfdf2+0x2a>
    80009272:	4785                	li	a5,1
    80009274:	0476                	slli	s0,s0,0x1d
    80009276:	17ce                	slli	a5,a5,0x33
    80009278:	8c5d                	or	s0,s0,a5
    8000927a:	bf7d                	j	80009238 <__extendsfdf2+0x2a>

000000008000927c <__truncdfsf2>:
    8000927c:	03455713          	srli	a4,a0,0x34
    80009280:	7ff77713          	andi	a4,a4,2047
    80009284:	00170613          	addi	a2,a4,1 # fffffffffc000001 <__stack+0xffffffff7bee4db1>
    80009288:	00c51793          	slli	a5,a0,0xc
    8000928c:	7fe67613          	andi	a2,a2,2046
    80009290:	00c7d693          	srli	a3,a5,0xc
    80009294:	917d                	srli	a0,a0,0x3f
    80009296:	83a5                	srli	a5,a5,0x9
    80009298:	c629                	beqz	a2,800092e2 <__truncdfsf2+0x66>
    8000929a:	c8070713          	addi	a4,a4,-896
    8000929e:	0fe00613          	li	a2,254
    800092a2:	04e64c63          	blt	a2,a4,800092fa <__truncdfsf2+0x7e>
    800092a6:	02e04863          	bgtz	a4,800092d6 <__truncdfsf2+0x5a>
    800092aa:	56a5                	li	a3,-23
    800092ac:	08d74b63          	blt	a4,a3,80009342 <__truncdfsf2+0xc6>
    800092b0:	4685                	li	a3,1
    800092b2:	16de                	slli	a3,a3,0x37
    800092b4:	8fd5                	or	a5,a5,a3
    800092b6:	46f9                	li	a3,30
    800092b8:	9e99                	subw	a3,a3,a4
    800092ba:	0227071b          	addiw	a4,a4,34
    800092be:	00d7d6b3          	srl	a3,a5,a3
    800092c2:	00e797b3          	sll	a5,a5,a4
    800092c6:	00f037b3          	snez	a5,a5
    800092ca:	8fd5                	or	a5,a5,a3
    800092cc:	4701                	li	a4,0
    800092ce:	0077f693          	andi	a3,a5,7
    800092d2:	c69d                	beqz	a3,80009300 <__truncdfsf2+0x84>
    800092d4:	a88d                	j	80009346 <__truncdfsf2+0xca>
    800092d6:	169a                	slli	a3,a3,0x26
    800092d8:	83f5                	srli	a5,a5,0x1d
    800092da:	00d036b3          	snez	a3,a3
    800092de:	8fd5                	or	a5,a5,a3
    800092e0:	b7fd                	j	800092ce <__truncdfsf2+0x52>
    800092e2:	e701                	bnez	a4,800092ea <__truncdfsf2+0x6e>
    800092e4:	00f037b3          	snez	a5,a5
    800092e8:	b7dd                	j	800092ce <__truncdfsf2+0x52>
    800092ea:	0ff00713          	li	a4,255
    800092ee:	cb89                	beqz	a5,80009300 <__truncdfsf2+0x84>
    800092f0:	83f5                	srli	a5,a5,0x1d
    800092f2:	9be1                	andi	a5,a5,-8
    800092f4:	020006b7          	lui	a3,0x2000
    800092f8:	b7dd                	j	800092de <__truncdfsf2+0x62>
    800092fa:	4781                	li	a5,0
    800092fc:	0ff00713          	li	a4,255
    80009300:	02579693          	slli	a3,a5,0x25
    80009304:	0006db63          	bgez	a3,8000931a <__truncdfsf2+0x9e>
    80009308:	0705                	addi	a4,a4,1
    8000930a:	0ff00693          	li	a3,255
    8000930e:	04d70363          	beq	a4,a3,80009354 <__truncdfsf2+0xd8>
    80009312:	fc0006b7          	lui	a3,0xfc000
    80009316:	16fd                	addi	a3,a3,-1
    80009318:	8ff5                	and	a5,a5,a3
    8000931a:	0ff00693          	li	a3,255
    8000931e:	838d                	srli	a5,a5,0x3
    80009320:	00d71663          	bne	a4,a3,8000932c <__truncdfsf2+0xb0>
    80009324:	c781                	beqz	a5,8000932c <__truncdfsf2+0xb0>
    80009326:	004007b7          	lui	a5,0x400
    8000932a:	4501                	li	a0,0
    8000932c:	0ff77713          	andi	a4,a4,255
    80009330:	17a6                	slli	a5,a5,0x29
    80009332:	0177171b          	slliw	a4,a4,0x17
    80009336:	93a5                	srli	a5,a5,0x29
    80009338:	8fd9                	or	a5,a5,a4
    8000933a:	01f5151b          	slliw	a0,a0,0x1f
    8000933e:	8d5d                	or	a0,a0,a5
    80009340:	8082                	ret
    80009342:	4785                	li	a5,1
    80009344:	4701                	li	a4,0
    80009346:	00f7f693          	andi	a3,a5,15
    8000934a:	4611                	li	a2,4
    8000934c:	fac68ae3          	beq	a3,a2,80009300 <__truncdfsf2+0x84>
    80009350:	0791                	addi	a5,a5,4
    80009352:	b77d                	j	80009300 <__truncdfsf2+0x84>
    80009354:	4781                	li	a5,0
    80009356:	b7d1                	j	8000931a <__truncdfsf2+0x9e>
