/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_FreeRTOSConfig.h"

static const char* CMockString_pcFileName = "pcFileName";
static const char* CMockString_ulGetRunTimeCounterValue = "ulGetRunTimeCounterValue";
static const char* CMockString_ulLine = "ulLine";
static const char* CMockString_vAssertCalled = "vAssertCalled";
static const char* CMockString_vConfigureTimerForRunTimeStats = "vConfigureTimerForRunTimeStats";
static const char* CMockString_vGenerateCoreBInterrupt = "vGenerateCoreBInterrupt";
static const char* CMockString_xUpdatedMessageBuffer = "xUpdatedMessageBuffer";

typedef struct _CMOCK_ulGetRunTimeCounterValue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  unsigned long ReturnVal;
  int CallOrder;

} CMOCK_ulGetRunTimeCounterValue_CALL_INSTANCE;

typedef struct _CMOCK_vConfigureTimerForRunTimeStats_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vConfigureTimerForRunTimeStats_CALL_INSTANCE;

typedef struct _CMOCK_vAssertCalled_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  unsigned long Expected_ulLine;
  const char* Expected_pcFileName;
  char IgnoreArg_ulLine;
  char IgnoreArg_pcFileName;

} CMOCK_vAssertCalled_CALL_INSTANCE;

typedef struct _CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  void* Expected_xUpdatedMessageBuffer;
  int Expected_xUpdatedMessageBuffer_Depth;
  char ReturnThruPtr_xUpdatedMessageBuffer_Used;
  void* ReturnThruPtr_xUpdatedMessageBuffer_Val;
  int ReturnThruPtr_xUpdatedMessageBuffer_Size;
  char IgnoreArg_xUpdatedMessageBuffer;

} CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE;

static struct mock_FreeRTOSConfigInstance
{
  char ulGetRunTimeCounterValue_IgnoreBool;
  unsigned long ulGetRunTimeCounterValue_FinalReturn;
  char ulGetRunTimeCounterValue_CallbackBool;
  CMOCK_ulGetRunTimeCounterValue_CALLBACK ulGetRunTimeCounterValue_CallbackFunctionPointer;
  int ulGetRunTimeCounterValue_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ulGetRunTimeCounterValue_CallInstance;
  char vConfigureTimerForRunTimeStats_IgnoreBool;
  char vConfigureTimerForRunTimeStats_CallbackBool;
  CMOCK_vConfigureTimerForRunTimeStats_CALLBACK vConfigureTimerForRunTimeStats_CallbackFunctionPointer;
  int vConfigureTimerForRunTimeStats_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vConfigureTimerForRunTimeStats_CallInstance;
  char vAssertCalled_IgnoreBool;
  char vAssertCalled_CallbackBool;
  CMOCK_vAssertCalled_CALLBACK vAssertCalled_CallbackFunctionPointer;
  int vAssertCalled_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vAssertCalled_CallInstance;
  char vGenerateCoreBInterrupt_IgnoreBool;
  char vGenerateCoreBInterrupt_CallbackBool;
  CMOCK_vGenerateCoreBInterrupt_CALLBACK vGenerateCoreBInterrupt_CallbackFunctionPointer;
  int vGenerateCoreBInterrupt_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vGenerateCoreBInterrupt_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_FreeRTOSConfig_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.ulGetRunTimeCounterValue_CallInstance;
  if (Mock.ulGetRunTimeCounterValue_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ulGetRunTimeCounterValue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ulGetRunTimeCounterValue_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vConfigureTimerForRunTimeStats_CallInstance;
  if (Mock.vConfigureTimerForRunTimeStats_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vConfigureTimerForRunTimeStats);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vConfigureTimerForRunTimeStats_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vAssertCalled_CallInstance;
  if (Mock.vAssertCalled_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vAssertCalled);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vAssertCalled_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vGenerateCoreBInterrupt_CallInstance;
  if (Mock.vGenerateCoreBInterrupt_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vGenerateCoreBInterrupt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vGenerateCoreBInterrupt_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_FreeRTOSConfig_Init(void)
{
  mock_FreeRTOSConfig_Destroy();
}

void mock_FreeRTOSConfig_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak ulGetRunTimeCounterValue
#else
unsigned long ulGetRunTimeCounterValue(void) __attribute__((weak));
#endif

unsigned long ulGetRunTimeCounterValue(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ulGetRunTimeCounterValue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ulGetRunTimeCounterValue);
  cmock_call_instance = (CMOCK_ulGetRunTimeCounterValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ulGetRunTimeCounterValue_CallInstance);
  Mock.ulGetRunTimeCounterValue_CallInstance = CMock_Guts_MemNext(Mock.ulGetRunTimeCounterValue_CallInstance);
  if (Mock.ulGetRunTimeCounterValue_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ulGetRunTimeCounterValue_FinalReturn;
    Mock.ulGetRunTimeCounterValue_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ulGetRunTimeCounterValue_CallbackBool &&
      Mock.ulGetRunTimeCounterValue_CallbackFunctionPointer != NULL)
  {
    unsigned long cmock_cb_ret = Mock.ulGetRunTimeCounterValue_CallbackFunctionPointer(Mock.ulGetRunTimeCounterValue_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.ulGetRunTimeCounterValue_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ulGetRunTimeCounterValue_CallbackFunctionPointer(Mock.ulGetRunTimeCounterValue_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void ulGetRunTimeCounterValue_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, unsigned long cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulGetRunTimeCounterValue_CALL_INSTANCE));
  CMOCK_ulGetRunTimeCounterValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulGetRunTimeCounterValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulGetRunTimeCounterValue_CallInstance = CMock_Guts_MemChain(Mock.ulGetRunTimeCounterValue_CallInstance, cmock_guts_index);
  Mock.ulGetRunTimeCounterValue_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ulGetRunTimeCounterValue_IgnoreBool = (char)1;
}

void ulGetRunTimeCounterValue_CMockStopIgnore(void)
{
  if(Mock.ulGetRunTimeCounterValue_IgnoreBool)
    Mock.ulGetRunTimeCounterValue_CallInstance = CMock_Guts_MemNext(Mock.ulGetRunTimeCounterValue_CallInstance);
  Mock.ulGetRunTimeCounterValue_IgnoreBool = (char)0;
}

void ulGetRunTimeCounterValue_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, unsigned long cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulGetRunTimeCounterValue_CALL_INSTANCE));
  CMOCK_ulGetRunTimeCounterValue_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulGetRunTimeCounterValue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulGetRunTimeCounterValue_CallInstance = CMock_Guts_MemChain(Mock.ulGetRunTimeCounterValue_CallInstance, cmock_guts_index);
  Mock.ulGetRunTimeCounterValue_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ulGetRunTimeCounterValue_AddCallback(CMOCK_ulGetRunTimeCounterValue_CALLBACK Callback)
{
  Mock.ulGetRunTimeCounterValue_IgnoreBool = (char)0;
  Mock.ulGetRunTimeCounterValue_CallbackBool = (char)1;
  Mock.ulGetRunTimeCounterValue_CallbackFunctionPointer = Callback;
}

void ulGetRunTimeCounterValue_Stub(CMOCK_ulGetRunTimeCounterValue_CALLBACK Callback)
{
  Mock.ulGetRunTimeCounterValue_IgnoreBool = (char)0;
  Mock.ulGetRunTimeCounterValue_CallbackBool = (char)0;
  Mock.ulGetRunTimeCounterValue_CallbackFunctionPointer = Callback;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vConfigureTimerForRunTimeStats
#else
void vConfigureTimerForRunTimeStats(void) __attribute__((weak));
#endif

void vConfigureTimerForRunTimeStats(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vConfigureTimerForRunTimeStats_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vConfigureTimerForRunTimeStats);
  cmock_call_instance = (CMOCK_vConfigureTimerForRunTimeStats_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vConfigureTimerForRunTimeStats_CallInstance);
  Mock.vConfigureTimerForRunTimeStats_CallInstance = CMock_Guts_MemNext(Mock.vConfigureTimerForRunTimeStats_CallInstance);
  if (Mock.vConfigureTimerForRunTimeStats_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vConfigureTimerForRunTimeStats_CallbackBool &&
      Mock.vConfigureTimerForRunTimeStats_CallbackFunctionPointer != NULL)
  {
    Mock.vConfigureTimerForRunTimeStats_CallbackFunctionPointer(Mock.vConfigureTimerForRunTimeStats_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vConfigureTimerForRunTimeStats_CallbackFunctionPointer != NULL)
  {
    Mock.vConfigureTimerForRunTimeStats_CallbackFunctionPointer(Mock.vConfigureTimerForRunTimeStats_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vConfigureTimerForRunTimeStats_CMockIgnore(void)
{
  Mock.vConfigureTimerForRunTimeStats_IgnoreBool = (char)1;
}

void vConfigureTimerForRunTimeStats_CMockStopIgnore(void)
{
  Mock.vConfigureTimerForRunTimeStats_IgnoreBool = (char)0;
}

void vConfigureTimerForRunTimeStats_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vConfigureTimerForRunTimeStats_CALL_INSTANCE));
  CMOCK_vConfigureTimerForRunTimeStats_CALL_INSTANCE* cmock_call_instance = (CMOCK_vConfigureTimerForRunTimeStats_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vConfigureTimerForRunTimeStats_CallInstance = CMock_Guts_MemChain(Mock.vConfigureTimerForRunTimeStats_CallInstance, cmock_guts_index);
  Mock.vConfigureTimerForRunTimeStats_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vConfigureTimerForRunTimeStats_AddCallback(CMOCK_vConfigureTimerForRunTimeStats_CALLBACK Callback)
{
  Mock.vConfigureTimerForRunTimeStats_IgnoreBool = (char)0;
  Mock.vConfigureTimerForRunTimeStats_CallbackBool = (char)1;
  Mock.vConfigureTimerForRunTimeStats_CallbackFunctionPointer = Callback;
}

void vConfigureTimerForRunTimeStats_Stub(CMOCK_vConfigureTimerForRunTimeStats_CALLBACK Callback)
{
  Mock.vConfigureTimerForRunTimeStats_IgnoreBool = (char)0;
  Mock.vConfigureTimerForRunTimeStats_CallbackBool = (char)0;
  Mock.vConfigureTimerForRunTimeStats_CallbackFunctionPointer = Callback;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vAssertCalled
#else
void vAssertCalled(unsigned long ulLine, const char* const pcFileName) __attribute__((weak));
#endif

void vAssertCalled(unsigned long ulLine, const char* const pcFileName)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vAssertCalled_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vAssertCalled);
  cmock_call_instance = (CMOCK_vAssertCalled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vAssertCalled_CallInstance);
  Mock.vAssertCalled_CallInstance = CMock_Guts_MemNext(Mock.vAssertCalled_CallInstance);
  if (Mock.vAssertCalled_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vAssertCalled_CallbackBool &&
      Mock.vAssertCalled_CallbackFunctionPointer != NULL)
  {
    Mock.vAssertCalled_CallbackFunctionPointer(ulLine, pcFileName, Mock.vAssertCalled_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ulLine)
  {
    UNITY_SET_DETAILS(CMockString_vAssertCalled,CMockString_ulLine);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulLine, ulLine, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pcFileName)
  {
    UNITY_SET_DETAILS(CMockString_vAssertCalled,CMockString_pcFileName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcFileName, pcFileName, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vAssertCalled_CallbackFunctionPointer != NULL)
  {
    Mock.vAssertCalled_CallbackFunctionPointer(ulLine, pcFileName, Mock.vAssertCalled_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vAssertCalled(CMOCK_vAssertCalled_CALL_INSTANCE* cmock_call_instance, unsigned long ulLine, const char* const pcFileName)
{
  cmock_call_instance->Expected_ulLine = ulLine;
  cmock_call_instance->IgnoreArg_ulLine = 0;
  cmock_call_instance->Expected_pcFileName = pcFileName;
  cmock_call_instance->IgnoreArg_pcFileName = 0;
}

void vAssertCalled_CMockIgnore(void)
{
  Mock.vAssertCalled_IgnoreBool = (char)1;
}

void vAssertCalled_CMockStopIgnore(void)
{
  Mock.vAssertCalled_IgnoreBool = (char)0;
}

void vAssertCalled_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vAssertCalled_CALL_INSTANCE));
  CMOCK_vAssertCalled_CALL_INSTANCE* cmock_call_instance = (CMOCK_vAssertCalled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vAssertCalled_CallInstance = CMock_Guts_MemChain(Mock.vAssertCalled_CallInstance, cmock_guts_index);
  Mock.vAssertCalled_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vAssertCalled_CMockExpect(UNITY_LINE_TYPE cmock_line, unsigned long ulLine, const char* const pcFileName)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vAssertCalled_CALL_INSTANCE));
  CMOCK_vAssertCalled_CALL_INSTANCE* cmock_call_instance = (CMOCK_vAssertCalled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vAssertCalled_CallInstance = CMock_Guts_MemChain(Mock.vAssertCalled_CallInstance, cmock_guts_index);
  Mock.vAssertCalled_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vAssertCalled(cmock_call_instance, ulLine, pcFileName);
}

void vAssertCalled_AddCallback(CMOCK_vAssertCalled_CALLBACK Callback)
{
  Mock.vAssertCalled_IgnoreBool = (char)0;
  Mock.vAssertCalled_CallbackBool = (char)1;
  Mock.vAssertCalled_CallbackFunctionPointer = Callback;
}

void vAssertCalled_Stub(CMOCK_vAssertCalled_CALLBACK Callback)
{
  Mock.vAssertCalled_IgnoreBool = (char)0;
  Mock.vAssertCalled_CallbackBool = (char)0;
  Mock.vAssertCalled_CallbackFunctionPointer = Callback;
}

void vAssertCalled_CMockIgnoreArg_ulLine(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vAssertCalled_CALL_INSTANCE* cmock_call_instance = (CMOCK_vAssertCalled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vAssertCalled_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulLine = 1;
}

void vAssertCalled_CMockIgnoreArg_pcFileName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vAssertCalled_CALL_INSTANCE* cmock_call_instance = (CMOCK_vAssertCalled_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vAssertCalled_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcFileName = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vGenerateCoreBInterrupt
#else
void vGenerateCoreBInterrupt(void* xUpdatedMessageBuffer) __attribute__((weak));
#endif

void vGenerateCoreBInterrupt(void* xUpdatedMessageBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vGenerateCoreBInterrupt);
  cmock_call_instance = (CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vGenerateCoreBInterrupt_CallInstance);
  Mock.vGenerateCoreBInterrupt_CallInstance = CMock_Guts_MemNext(Mock.vGenerateCoreBInterrupt_CallInstance);
  if (Mock.vGenerateCoreBInterrupt_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vGenerateCoreBInterrupt_CallbackBool &&
      Mock.vGenerateCoreBInterrupt_CallbackFunctionPointer != NULL)
  {
    Mock.vGenerateCoreBInterrupt_CallbackFunctionPointer(xUpdatedMessageBuffer, Mock.vGenerateCoreBInterrupt_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xUpdatedMessageBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vGenerateCoreBInterrupt,CMockString_xUpdatedMessageBuffer);
    if (cmock_call_instance->Expected_xUpdatedMessageBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(xUpdatedMessageBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_xUpdatedMessageBuffer, xUpdatedMessageBuffer, cmock_call_instance->Expected_xUpdatedMessageBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vGenerateCoreBInterrupt_CallbackFunctionPointer != NULL)
  {
    Mock.vGenerateCoreBInterrupt_CallbackFunctionPointer(xUpdatedMessageBuffer, Mock.vGenerateCoreBInterrupt_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_xUpdatedMessageBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(xUpdatedMessageBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)xUpdatedMessageBuffer, (void*)cmock_call_instance->ReturnThruPtr_xUpdatedMessageBuffer_Val,
      cmock_call_instance->ReturnThruPtr_xUpdatedMessageBuffer_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vGenerateCoreBInterrupt(CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE* cmock_call_instance, void* xUpdatedMessageBuffer, int xUpdatedMessageBuffer_Depth)
{
  cmock_call_instance->Expected_xUpdatedMessageBuffer = xUpdatedMessageBuffer;
  cmock_call_instance->Expected_xUpdatedMessageBuffer_Depth = xUpdatedMessageBuffer_Depth;
  cmock_call_instance->IgnoreArg_xUpdatedMessageBuffer = 0;
  cmock_call_instance->ReturnThruPtr_xUpdatedMessageBuffer_Used = 0;
}

void vGenerateCoreBInterrupt_CMockIgnore(void)
{
  Mock.vGenerateCoreBInterrupt_IgnoreBool = (char)1;
}

void vGenerateCoreBInterrupt_CMockStopIgnore(void)
{
  Mock.vGenerateCoreBInterrupt_IgnoreBool = (char)0;
}

void vGenerateCoreBInterrupt_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE));
  CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGenerateCoreBInterrupt_CallInstance = CMock_Guts_MemChain(Mock.vGenerateCoreBInterrupt_CallInstance, cmock_guts_index);
  Mock.vGenerateCoreBInterrupt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vGenerateCoreBInterrupt_CMockExpect(UNITY_LINE_TYPE cmock_line, void* xUpdatedMessageBuffer)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE));
  CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGenerateCoreBInterrupt_CallInstance = CMock_Guts_MemChain(Mock.vGenerateCoreBInterrupt_CallInstance, cmock_guts_index);
  Mock.vGenerateCoreBInterrupt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vGenerateCoreBInterrupt(cmock_call_instance, xUpdatedMessageBuffer, 1);
}

void vGenerateCoreBInterrupt_AddCallback(CMOCK_vGenerateCoreBInterrupt_CALLBACK Callback)
{
  Mock.vGenerateCoreBInterrupt_IgnoreBool = (char)0;
  Mock.vGenerateCoreBInterrupt_CallbackBool = (char)1;
  Mock.vGenerateCoreBInterrupt_CallbackFunctionPointer = Callback;
}

void vGenerateCoreBInterrupt_Stub(CMOCK_vGenerateCoreBInterrupt_CALLBACK Callback)
{
  Mock.vGenerateCoreBInterrupt_IgnoreBool = (char)0;
  Mock.vGenerateCoreBInterrupt_CallbackBool = (char)0;
  Mock.vGenerateCoreBInterrupt_CallbackFunctionPointer = Callback;
}

void vGenerateCoreBInterrupt_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, void* xUpdatedMessageBuffer, int xUpdatedMessageBuffer_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE));
  CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vGenerateCoreBInterrupt_CallInstance = CMock_Guts_MemChain(Mock.vGenerateCoreBInterrupt_CallInstance, cmock_guts_index);
  Mock.vGenerateCoreBInterrupt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vGenerateCoreBInterrupt(cmock_call_instance, xUpdatedMessageBuffer, xUpdatedMessageBuffer_Depth);
}

void vGenerateCoreBInterrupt_CMockReturnMemThruPtr_xUpdatedMessageBuffer(UNITY_LINE_TYPE cmock_line, void* xUpdatedMessageBuffer, int cmock_size)
{
  CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGenerateCoreBInterrupt_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_xUpdatedMessageBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_xUpdatedMessageBuffer_Val = xUpdatedMessageBuffer;
  cmock_call_instance->ReturnThruPtr_xUpdatedMessageBuffer_Size = cmock_size;
}

void vGenerateCoreBInterrupt_CMockIgnoreArg_xUpdatedMessageBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE* cmock_call_instance = (CMOCK_vGenerateCoreBInterrupt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vGenerateCoreBInterrupt_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xUpdatedMessageBuffer = 1;
}

