// ---------------------------------------------------------
//   ATMEL Microcontroller Software Support
// ---------------------------------------------------------
// The software is delivered "AS IS" without warranty or
// condition of any  kind, either express, implied or
// statutory. This includes without limitation any warranty
// or condition with respect to merchantability or fitness
// for any particular purpose, or against the infringements of
// intellectual property rights of others.
// ---------------------------------------------------------
//  File: sama5d4-ek-ddram.mac
//  User setup file for CSPY debugger.
//  
// ---------------------------------------------------------

__var __tempo_var;
__var __dummy_read;
__var __data_test;
__var __mac_i;

__var REG_CKGR_MOR;
__var CKGR_MOR_MOSCXTEN;
__var CKGR_MOR_MOSCXTBY;
__var CKGR_MOR_MOSCRCEN;
__var CKGR_MOR_MOSCSEL;
__var REG_CKGR_MCFR;
__var CKGR_MCFR_MAINFRDY;
__var REG_PMC_SR;
__var PMC_SR_MCKRDY;
__var PMC_SR_LOCKA;
__var PMC_PCK_CSS_MAIN_CLK;
__var REG_CKGR_PLLAR;
__var REG_PMC_PLLICPR;
__var REG_PMC_MCKR;
__var PMC_MCKR_PLLADIV2_DIV2;
__var PMC_MCKR_PRES_Msk;
__var PMC_MCKR_PRES_CLOCK;
__var PMC_MCKR_MDIV_Msk;
__var PMC_MCKR_MDIV_PCK_DIV3;
__var PMC_MCKR_CSS_PLLA_CLK;
__var PMC_SR_MOSCSELS;

/*********************************************************************
*
*       execUserReset() : JTAG set initially to Full Speed
*/
execUserReset()
{
    __message "------------------------------ execUserReset ---------------------------------";
    ini();
    __message "-------------------------------Set PC Reset ----------------------------------";
    __writeMemory32(0x1D3,0x98,"Register");        //*  Set CPSR
}

/*********************************************************************
*
*       execUserPreload() : JTAG set initially to 32kHz
*/
execUserPreload()
{
    __message "------------------------------ execUserPreload ---------------------------------";
    //__hwReset(0);                     //* Hardware Reset: CPU is automatically halted after the reset (JTAG is already configured to 32kHz)

    __writeMemory32(0xD3,0x98,"Register"); //*  Set CPSR

 __tempo_var = __readMemory32(0xF0018028,"Memory");   // PLL A reg addr is 0xF0018028

    if (__tempo_var == 0x215C3F01)
    {
        __message " ----------- PLL A is already set to 1056 MHz - Skip DDR2 init -----------";

        __tempo_var = __readMemory32(0xF001000C,"Memory");

        if (__tempo_var == 0x2223A338)
        {
             __message " ----------- DDR2 is already Up - skip initialization -----------";
        }
        else
          {
              __initDDR2();                     //* Init DDR2 memory
              __message "------------ DDR2 is initialized ------------";
          }
    }
    else
    {
       __writeMemory32(0x00FFFFFF,0xF001C210,"Memory");   // SLAVE 4
       __writeMemory32(0x0000000F,0xF001C290,"Memory");
       __writeMemory32(0x0000FFFF,0xF001C250,"Memory");
      
       __writeMemory32(0x00FFFFFF,0xF001C214,"Memory");   // SLAVE 5
       __writeMemory32(0x0000000F,0xF001C294,"Memory");
       __writeMemory32(0x0000FFFF,0xF001C254,"Memory");
      
       __writeMemory32(0x00FFFFFF,0xF001C218,"Memory");   // SLAVE 6
       __writeMemory32(0x0000000F,0xF001C298,"Memory");
       __writeMemory32(0x0000FFFF,0xF001C258,"Memory");
      
       __writeMemory32(0x00FFFFFF,0xF001C21C,"Memory");   // SLAVE 7
       __writeMemory32(0x0000000F,0xF001C29C,"Memory");
       __writeMemory32(0x0000FFFF,0xF001C25C,"Memory");
      
       __writeMemory32(0x00FFFFFF,0xF001C220,"Memory");   // SLAVE 8
       __writeMemory32(0x0000000F,0xF001C2A0,"Memory");
       __writeMemory32(0x0000FFFF,0xF001C260,"Memory");
      
       __writeMemory32(0x00FFFFFF,0xF001C224,"Memory");   // SLAVE 9
       __writeMemory32(0x0000000F,0xF001C2A4,"Memory");
       __writeMemory32(0x0000FFFF,0xF001C264,"Memory");
      
       __writeMemory32(0x00FFFFFF,0xF001C228,"Memory");   // SLAVE 10
       __writeMemory32(0x0000000F,0xF001C2A8,"Memory");
       __writeMemory32(0x0000FFFF,0xF001C268,"Memory");
      
      PMC_SelectExt12M_Osc();
      PMC_SwitchMck2Main();
      PMC_SetPllA(87);
      PMC_SetMckPllaDiv();
      PMC_SetMckPrescaler();
      PMC_SetMckDivider();
      PMC_SwitchMck2Pll();
       __message "------------ PLL set to 1056 MHz, MCK set to 176 MHz ------------";

       __initDDR2(1);                     //* Init DDR2 memory

       __message "------------ DDR2 is initialized ------------";
    }
    Watchdog();                        //* Watchdog Disable

    //*  Get the Chip ID  (AT91C_DBGU_C1R & AT91C_DBGU_C2R
    __mac_i=__readMemory32(0xFC069040,"Memory");
    __message " ---------------------------------------- Chip ID   0x",__mac_i:%X;
}


/*********************************************************************
*
*       ini() :
* Function description
* Write ARM9 core regsiter to Reset value
*/
ini()
{
__writeMemory32(0x0,0x00,"Register");
__writeMemory32(0x0,0x04,"Register");
__writeMemory32(0x0,0x08,"Register");
__writeMemory32(0x0,0x0C,"Register");
__writeMemory32(0x0,0x10,"Register");
__writeMemory32(0x0,0x14,"Register");
__writeMemory32(0x0,0x18,"Register");
__writeMemory32(0x0,0x1C,"Register");
__writeMemory32(0x0,0x20,"Register");
__writeMemory32(0x0,0x24,"Register");
__writeMemory32(0x0,0x28,"Register");
__writeMemory32(0x0,0x2C,"Register");
__writeMemory32(0x0,0x30,"Register");
__writeMemory32(0x0,0x34,"Register");
__writeMemory32(0x0,0x38,"Register");

// Set CPSR
__writeMemory32(0x0D3,0x98,"Register");

}


/*********************************************************************
*
*       _Watchdog()
*
* Function description
*   Clear Watchdog
*/

Watchdog()
{
   // Watchdog Disable
   __writeMemory32(0x00008000,0xFC068644,"Memory");
   __message " ------------------------ Watchdog Disable ------------------------";
}

/*********************************************************************
*
*       PMC_SelectExt12M_Osc()
*
* Function description
*   Select external 12MHz oscillator
*/
PMC_SelectExt12M_Osc()
{ 

// ---------  Select_ext_Crystal_32k  ---------------
  
    REG_CKGR_MOR = 0xF0018020;
    CKGR_MOR_MOSCXTEN = (0x1 << 0);     /*(CKGR_MOR) Main Crystal Oscillator Enable */
    CKGR_MOR_MOSCXTBY = (0x1 << 1);     /*(CKGR_MOR) Main Crystal Oscillator Bypass */
    CKGR_MOR_MOSCRCEN = (0x1 << 3);     /*(CKGR_MOR) Main On-Chip RC Oscillator Enable */
    CKGR_MOR_MOSCSEL = (0x1 << 24);     /*(CKGR_MOR) Main Oscillator Selection */
    REG_CKGR_MCFR = 0xF0018024;         /*(PMC) Main Clock Frequency Register */
    CKGR_MCFR_MAINFRDY = (0x1 << 16);   /*(CKGR_MCFR) Main Clock Ready */
    REG_PMC_SR = 0xF0018068;            /*(PMC) Status Register */
    PMC_SR_MOSCSELS = (0x1 << 16);      /*(PMC_SR) Main Oscillator Selection Status */
    PMC_SR_MCKRDY = (0x1 << 3);         /*(PMC_SR) Master Clock Status */

    /* enable external OSC 12 MHz  */
    __tempo_var = __readMemory32(REG_CKGR_MOR,"Memory");
    __tempo_var |= CKGR_MOR_MOSCXTEN | (0x37 << 16);
    __writeMemory32(__tempo_var,REG_CKGR_MOR,"Memory");

    /* wait Main CLK Ready */
    while(!((__readMemory32(REG_CKGR_MCFR,"Memory")) & CKGR_MCFR_MAINFRDY));

    /* disable external OSC 12 MHz bypass */
    __tempo_var = __readMemory32(REG_CKGR_MOR,"Memory");
    __tempo_var = (__tempo_var & ~CKGR_MOR_MOSCXTBY) | (0x37 << 16); 
    __writeMemory32(__tempo_var,REG_CKGR_MOR,"Memory");

    /* switch MAIN clock to external OSC 12 MHz*/
    __tempo_var = __readMemory32(REG_CKGR_MOR,"Memory");
    __tempo_var |= CKGR_MOR_MOSCSEL | (0x37 << 16); 
    __writeMemory32(__tempo_var,REG_CKGR_MOR,"Memory");

    /* wait MAIN clock status change for external OSC 12 MHz selection*/
    while(!((__readMemory32(REG_PMC_SR,"Memory")) & PMC_SR_MOSCSELS));

    /* in case when MCK is running on MAIN CLK */
    while(!((__readMemory32(REG_PMC_SR,"Memory")) & PMC_SR_MCKRDY));

     __message " -------- PMC_SelectExt12M_Osc ---------- REG_CKGR_MOR  0x",__mac_i:%X;
}

/*********************************************************************
*
*       PMC_SwitchMck2Main()
*
* Function description
*   Switch PMC from MCK to main clock.
*/
PMC_SwitchMck2Main()
{
    REG_PMC_MCKR = 0xF0018030;          /*(PMC) Master Clock Register */
    PMC_PCK_CSS_MAIN_CLK = (0x1 << 0);  /*(PMC_PCK[3]) Main Clock is selected */
    PMC_SR_MCKRDY = (0x1 << 3);         /*(PMC_SR) Master Clock Status */
    REG_PMC_SR = 0xF0018068;            /*(PMC) Status Register */

    /* Select Main Oscillator as input clock for PCK and MCK */
    __tempo_var = __readMemory32(REG_PMC_MCKR,"Memory");
    __tempo_var = (__tempo_var & ~0x03)| PMC_PCK_CSS_MAIN_CLK ;
    __writeMemory32(__tempo_var, REG_PMC_MCKR,"Memory");
    while(!((__readMemory32(REG_PMC_SR,"Memory")) & PMC_SR_MCKRDY));
    __mac_i=__readMemory32(REG_PMC_MCKR,"Memory");
    __message " --------- PMC_SwitchMck2Main ----------- REG_PMC_MCKR  0x",__mac_i:%X;
}

/*********************************************************************
*
*       PMC_SetPllA()
*
* Function description
*   Configure PLLA Registe.
*/

PMC_SetPllA(pllmul)
{
    REG_CKGR_PLLAR = 0xF0018028;        /*(PMC) PLLA Register */
    REG_PMC_PLLICPR = 0xF0018080;       /*(PMC) PLL Charge Pump Current Register */
    REG_PMC_SR = 0xF0018068;            /*(PMC) Status Register */
    PMC_SR_LOCKA = (0x1 << 1);          /*(PMC_SR) PLLA Lock Status */

    __writeMemory32(((0x1 << 29) | (0x3F << 8) | ( 0 << 14) | ((pllmul) << 18) | 1 ), REG_CKGR_PLLAR,"Memory");
    //__writeMemory32((0x03<<8), REG_PMC_PLLICPR,"Memory");
    while(!((__readMemory32(REG_PMC_SR,"Memory")) & PMC_SR_LOCKA));
    __mac_i=__readMemory32(REG_CKGR_PLLAR,"Memory");
    __message " --------- PMC_SetPllA ---------------- REG_CKGR_PLLAR  0x",__mac_i:%X;
}

/*********************************************************************
*
*       PMC_SetMckPllaDiv()
*
* Function description
*   Configure MCK PLLA divider.
*/
PMC_SetMckPllaDiv()
{
    REG_PMC_MCKR = 0xF0018030;             /*(PMC) Master Clock Register */
    PMC_MCKR_PLLADIV2_DIV2 = (0x1 << 12);  /*(PMC_MCKR) PLLA clock frequency is divided by 2. */
    __tempo_var = __readMemory32(REG_PMC_MCKR,"Memory");
    if ((__tempo_var & PMC_MCKR_PLLADIV2_DIV2) != PMC_MCKR_PLLADIV2_DIV2)
    {
        __tempo_var |= PMC_MCKR_PLLADIV2_DIV2;
        __writeMemory32(__tempo_var, REG_PMC_MCKR,"Memory");
        while(!((__readMemory32(REG_PMC_SR,"Memory")) & PMC_SR_MCKRDY));
    }
}

/*********************************************************************
*
*       PMC_SetMckPrescaler()
*
* Function description
*   Configure MCK Prescaler.
*/
PMC_SetMckPrescaler()
{
    REG_PMC_MCKR = 0xF0018030;             /*(PMC) Master Clock Register */
    PMC_MCKR_PRES_Msk = (0x7 << 4);        /*(PMC_MCKR) Master/Processor Clock Prescaler */
    PMC_MCKR_PRES_CLOCK = (0x0 << 4);      /*(PMC_MCKR) Selected clock */

    /* Change MCK Prescaler divider in PMC_MCKR register */
    __tempo_var = __readMemory32(REG_PMC_MCKR,"Memory");
    __tempo_var = (__tempo_var & ~PMC_MCKR_PRES_Msk) | PMC_MCKR_PRES_CLOCK;
    __writeMemory32(__tempo_var, REG_PMC_MCKR,"Memory");
    while(!((__readMemory32(REG_PMC_SR,"Memory")) & PMC_SR_MCKRDY));
    __mac_i=__readMemory32(REG_PMC_MCKR,"Memory");
    __message " --------- PMC_SetMckPrescaler -------------- REG_PMC_MCKR  0x",__mac_i:%X;
}

/*********************************************************************
*
*       PMC_SetMckDivider()
*
* Function description
*   Configure MCK Divider.
*/
PMC_SetMckDivider()
{
    REG_PMC_MCKR = 0xF0018030;             /*(PMC) Master Clock Register */
    PMC_MCKR_MDIV_Msk = (0x3 << 8);        /*(PMC_MCKR) Master Clock Division */
    PMC_MCKR_MDIV_PCK_DIV3 = (0x3 << 8);   /*(PMC_MCKR) Master Clock is Prescaler Output Clock divided by 3.SysClk DDR is equal to 2 x MCK. DDRCK is equal to MCK. */

    /* change MCK Prescaler divider in PMC_MCKR register */
    __tempo_var = __readMemory32(REG_PMC_MCKR,"Memory");
    __tempo_var = (__tempo_var & ~PMC_MCKR_MDIV_Msk) | PMC_MCKR_MDIV_PCK_DIV3;
    __writeMemory32(__tempo_var, REG_PMC_MCKR,"Memory");
    while(!((__readMemory32(REG_PMC_SR,"Memory")) & PMC_SR_MCKRDY));
    __mac_i=__readMemory32(REG_PMC_MCKR,"Memory");
    __message " --------- PMC_SetMckDivider -------------- REG_PMC_MCKR  0x",__mac_i:%X;
}

/*********************************************************************
*
*       PMC_SwitchMck2Pll()
*
* Function description
*   Switch PMC from MCK to PLL clock.
*/
PMC_SwitchMck2Pll()
{
    REG_PMC_MCKR = 0xF0018030;             /*(PMC) Master Clock Register */
    PMC_MCKR_CSS_PLLA_CLK = (0x2 << 0);    /*(PMC_MCKR) PLLACK/PLLADIV2 is selected */

    /* Select PLL as input clock for PCK and MCK */
    __tempo_var = __readMemory32(REG_PMC_MCKR,"Memory");
    __tempo_var = (__tempo_var & ~0x03) | PMC_MCKR_CSS_PLLA_CLK;
    __writeMemory32(__tempo_var, REG_PMC_MCKR,"Memory");
    while(!((__readMemory32(REG_PMC_SR,"Memory")) & PMC_SR_MCKRDY));
    __mac_i=__readMemory32(REG_PMC_MCKR,"Memory");
    __message " --------- PMC_SwitchMck2Pll -------------- REG_PMC_MCKR  0x",__mac_i:%X;
}



// ---------------------------------------------------------------------------
//  Function Name       : __initDDR2
//  Object              : Set DDR2 memory for working at 176 Mhz
// ---------------------------------------------------------------------------

__initDDR2(type)
{
    
// ------------------ DDR Controller Registers --------------

//  #define REG_MPDDRC_MR                              (0xF0010000U) /**< \brief (MPDDRC) MPDDRC Mode Register */
//  #define REG_MPDDRC_RTR                             (0xF0010004U) /**< \brief (MPDDRC) MPDDRC Refresh Timer Register */
//  #define REG_MPDDRC_CR                              (0xF0010008U) /**< \brief (MPDDRC) MPDDRC Configuration Register */
//  #define REG_MPDDRC_TPR0                            (0xF001000CU) /**< \brief (MPDDRC) MPDDRC Timing Parameter 0 Register */
//  #define REG_MPDDRC_TPR1                            (0xF0010010U) /**< \brief (MPDDRC) MPDDRC Timing Parameter 1 Register */
//  #define REG_MPDDRC_TPR2                            (0xF0010014U) /**< \brief (MPDDRC) MPDDRC Timing Parameter 2 Register */
//  #define REG_MPDDRC_LPR                             (0xF001001CU) /**< \brief (MPDDRC) MPDDRC Low-power Register */
//  #define REG_MPDDRC_MD                              (0xF0010020U) /**< \brief (MPDDRC) MPDDRC Memory Device Register */
//  #define REG_MPDDRC_LPDDR2_LPR                      (0xF0010028U) /**< \brief (MPDDRC) MPDDRC LPDDR2 Low-power Register */
//  #define REG_MPDDRC_LPDDR2_CAL_MR4                  (0xF001002CU) /**< \brief (MPDDRC) MPDDRC LPDDR2 Calibration and MR4 Register */
//  #define REG_MPDDRC_LPDDR2_TIM_CAL                  (0xF0010030U) /**< \brief (MPDDRC) MPDDRC LPDDR2 Timing Calibration Register */
//  #define REG_MPDDRC_IO_CALIBR                       (0xF0010034U) /**< \brief (MPDDRC) MPDDRC IO Calibration */
//  #define REG_MPDDRC_OCMS                            (0xF0010038U) /**< \brief (MPDDRC) MPDDRC OCMS Register */
//  #define REG_MPDDRC_OCMS_KEY1                       (0xF001003CU) /**< \brief (MPDDRC) MPDDRC OCMS KEY1 Register */
//  #define REG_MPDDRC_OCMS_KEY2                       (0xF0010040U) /**< \brief (MPDDRC) MPDDRC OCMS KEY2 Register */
//  #define REG_MPDDRC_CONF_ARBITER                    (0xF0010044U) /**< \brief (MPDDRC) MPDDRC Configuration Arbiter */
//  #define REG_MPDDRC_TIMEOUT                         (0xF0010048U) /**< \brief (MPDDRC) MPDDRC Time-out Port 0/1/2/3 */
//  #define REG_MPDDRC_REQ_PORT_0123                   (0xF001004CU) /**< \brief (MPDDRC) MPDDRC Time-out Request Port 0/1/2/3 */
//  #define REG_MPDDRC_REQ_PORT_4567                   (0xF0010050U) /**< \brief (MPDDRC) MPDDRC Time-out Request Port 4/5/6/7 */
//  #define REG_MPDDRC_BDW_PORT_0123                   (0xF0010054U) /**< \brief (MPDDRC) MPDDRC Bandwidth Port 0/1/2/3 */
//  #define REG_MPDDRC_BDW_PORT_4567                   (0xF0010058U) /**< \brief (MPDDRC) MPDDRC Bandwidth Port 4/5/6/7 */
//  #define REG_MPDDRC_RD_DATA_PATH                    (0xF001005CU) /**< \brief (MPDDRC) MPDDRC_READ_DATA_PATH */
//  #define REG_MPDDRC_SAW                             (0xF0010060U) /**< \brief (MPDDRC) MPDDRC Smart Adaptation Wrapper 0 Register */
//  #define REG_MPDDRC_WPMR                            (0xF00100E4U) /**< \brief (MPDDRC) MPDDRC Write Protect Control Register */
//  #define REG_MPDDRC_WPSR                            (0xF00100E8U) /**< \brief (MPDDRC) MPDDRC Write Protect Status Register */
//  #define REG_MPDDRC_DLL_OS                          (0xF0010100U) /**< \brief (MPDDRC) MPDDRC DLL Offset Selection Register */
//  #define REG_MPDDRC_DLL_MO                          (0xF0010104U) /**< \brief (MPDDRC) MPDDRC DLL MASTER Offset Register */
//  #define REG_MPDDRC_DLL_SO0                         (0xF0010108U) /**< \brief (MPDDRC) MPDDRC DLL SLAVE Offset 0 Register */
//  #define REG_MPDDRC_DLL_SO1                         (0xF001010CU) /**< \brief (MPDDRC) MPDDRC DLL SLAVE Offset 1 Register */
//  #define REG_MPDDRC_DLL_WRO                         (0xF0010110U) /**< \brief (MPDDRC) MPDDRC DLL CLKWR Offset Register */
//  #define REG_MPDDRC_DLL_ADO                         (0xF0010114U) /**< \brief (MPDDRC) MPDDRC DLL CLKAD Offset Register */
//  #define REG_MPDDRC_DLL_SM                          (0xF0010118U) /**< \brief (MPDDRC) MPDDRC DLL Status MASTER0 Register */
//  #define REG_MPDDRC_DLL_SSL                         (0xF0010128U) /**< \brief (MPDDRC) MPDDRC DLL Status SLAVE0 Register */
//  #define REG_MPDDRC_DLL_SWR                         (0xF0010148U) /**< \brief (MPDDRC) MPDDRC DLL Status CLKWR0 Register */
//  #define REG_MPDDRC_DLL_SAD                         (0xF0010158U) /**< \brief (MPDDRC) MPDDRC DLL Status CLKAD Register */
// -----------------------------------------------
   
    __delay(2);
    __writeMemory32(0x00008000,0xFC068644,"Memory");   // Disable Watchdog
    __writeMemory32(0x00010000,0xF0018010,"Memory");   // Enable MPDDR controller clock
    __writeMemory32(0x00000004,0xF0018000,"Memory");   // System Clock Enable Register : Enable DDR clock

    __writeMemory32(0x00000001,0xF001005C,"Memory");   // Read Data Path register  :  Sampling point is shifted of one cycle

    __writeMemory32(0x00870514,0xF0010034,"Memory");   // MPDDRC I/O Calibration Register : RZQ_60_RZQ_50 + enable permanent calibration + TZQIO = 5

    __writeMemory32(0x00000006,0xF0010020,"Memory");   // Memory Device Register  :  32bit mode - DDR2 mode

    __writeMemory32(0x2223A338,0xF001000C,"Memory");   // Timing 0 Register : tras  | trcd  | twr   | trc  | trp | trrd | twtr | tmrd
    __writeMemory32(0x0b206417,0xF0010010,"Memory");   // Timing 1 Register : trfc  | txsnr | txsrd | txp
    __writeMemory32(0x00072328,0xF0010014,"Memory");   // Timing 2 Register : txard | tards | trpa  | trtp | tfaw

    __writeMemory32(0x00B0003D,0xF0010008,"Memory");   // Configuration Register  :  row = 14, column(DDR) = 10, CAS 3, DLL reset disable, phase error correction is enabled / normal driver strength

    __writeMemory32(0x00000001,0xF0010000,"Memory");   // Mode register : command  NOP --> ENABLE CLOCK output
    __writeMemory32(0x00000000,0x20000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);   // wait 1 ms
    __writeMemory32(0x00000001,0xF0010000,"Memory");   // Mode register : command  NOP --> ENABLE CLOCK output
    __writeMemory32(0x00000000,0x20000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);
    __writeMemory32(0x00000002,0xF0010000,"Memory");   // Mode register : command  All Banks Precharge
    __writeMemory32(0x00000000,0x20000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);
    __writeMemory32(0x00000005,0xF0010000,"Memory");   // Mode register : command  Extended Load Mode Register : Set EMR Ext Mode Reg EMSR2 BA0=0 BA1=1
    __writeMemory32(0x00000000,0x28000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);
    __writeMemory32(0x00000005,0xF0010000,"Memory");   // Mode register : command  Extended Load Mode Register : Set EMR Ext Mode Reg EMSR3 BA0=1 BA1=1
    __writeMemory32(0x00000000,0x2C000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);
    __writeMemory32(0x00000005,0xF0010000,"Memory");   // Mode register : command  Extended Load Mode Register : Set EMR Ext Mode Reg EMSR1 BA0=1 BA1=0 ENABLE DLL
    __writeMemory32(0x00000000,0x24000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);

    __writeMemory32(0x00B000BD,0xF0010008,"Memory");   // Configuration Register : Enable DLL reset

    __writeMemory32(0x00000003,0xF0010000,"Memory");   // Mode register : command  RESET DLL
    __writeMemory32(0x00000000,0x20000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);
    __writeMemory32(0x00000002,0xF0010000,"Memory");   // Mode register : command  All Banks Precharge
    __writeMemory32(0x00000000,0x20000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);
    __writeMemory32(0x00000004,0xF0010000,"Memory");   // Mode register : 2 * command  Auto-Refresh
    __writeMemory32(0x00000000,0x20000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);
    __writeMemory32(0x00000004,0xF0010000,"Memory");   // Mode register :
    __writeMemory32(0x00000000,0x20000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);

    __writeMemory32(0x00B0003D,0xF0010008,"Memory");   // Configuration Register : disable DLL reset

    __writeMemory32(0x00000003,0xF0010000,"Memory");   // Mode register :  MRS  initialize device operation (CAS latency, burst length and disable DLL reset)
    __writeMemory32(0x00000000,0x20000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);

    __writeMemory32(0x00B0703D,0xF0010008,"Memory");   // Configuration Register : OCD default value

    __writeMemory32(0x00000005,0xF0010000,"Memory");   // Mode register : EMRS1   OCD Default values
    __writeMemory32(0x00000000,0x24000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);

    __writeMemory32(0x00B0003D,0xF0010008,"Memory");   // Configuration Register : OCD exit

    __writeMemory32(0x00000005,0xF0010000,"Memory");   // Mode register : EMRS1   OCD exit
    __writeMemory32(0x00000000,0x24000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);
    __writeMemory32(0x00000000,0xF0010000,"Memory");   // Mode register : command  Normal mode
    __writeMemory32(0x00000000,0x20000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);
    __writeMemory32(0x00000000,0x20000000,"Memory");   // DDR2 memory : access memory to validate preeceeding command
    __delay(1);

    __writeMemory32(0x000002B0,0xF0010004,"Memory");   // Refresh Timer register

    __message "------------------------------- DDR2 memory init for 176 MHz ----------------------------------";
}


