;/*
;    FreeRTOS V6.0.4 - Copyright (C) 2010 Real Time Engineers Ltd.
;
;    ***************************************************************************
;    *                                                                         *
;    * If you are:                                                             *
;    *                                                                         *
;    *    + New to FreeRTOS,                                                   *
;    *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
;    *    + Looking for basic training,                                        *
;    *    + Wanting to improve your FreeRTOS skills and productivity           *
;    *                                                                         *
;    * then take a look at the FreeRTOS eBook                                  *
;    *                                                                         *
;    *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
;    *                  http://www.FreeRTOS.org/Documentation                  *
;    *                                                                         *
;    * A pdf reference manual is also available.  Both are usually delivered   *
;    * to your inbox within 20 minutes to two hours when purchased between 8am *
;    * and 8pm GMT (although please allow up to 24 hours in case of            *
;    * exceptional circumstances).  Thank you for your support!                *
;    *                                                                         *
;    ***************************************************************************
;
;    This file is part of the FreeRTOS distribution.
;
;    FreeRTOS is free software; you can redistribute it and/or modify it under
;    the terms of the GNU General Public License (version 2) as published by the
;    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
;    ***NOTE*** The exception to the GPL is included to allow you to distribute
;    a combined work that includes FreeRTOS without being obliged to provide the
;    source code for proprietary components outside of the FreeRTOS kernel.
;    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
;    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
;    more details. You should have received a copy of the GNU General Public 
;    License and the FreeRTOS license exception along with FreeRTOS; if not it 
;    can be viewed here: http://www.freertos.org/a00114.html and also obtained 
;    by writing to Richard Barry, contact details for whom are available on the
;    FreeRTOS WEB site.
;
;    1 tab == 4 spaces!
;
;    http://www.FreeRTOS.org - Documentation, latest information, license and
;    contact details.
;
;    http://www.SafeRTOS.com - A version that is certified for use in safety
;    critical systems.
;
;    http://www.OpenRTOS.com - Commercial support, development, porting,
;    licensing and training services.
;*/

	.import _ulRegTest1CycleCount
	.import _ulRegTest2CycleCount
	.import _vPortYield

	.export _vRegTest1Task
	.export _vRegTest2Task

    .section    P, code, align=4
	
	
	
_vRegTest1Task:

	; Fill the registers with known values.
	mov		#2, r1
	mov		#3, r2
	mov		#4, r3
	mov		#5, r4
	mov		#6, r5
	mov		#7, r6
	mov		#8, r7
	mov		#9, r8
	mov		#10, r9
	mov		#11, r10
	mov		#12, r11
	mov		#13, r12
	mov		#14, r13
	mov		#15, r14

	mov		#16, r0
	lds		r0, macl
	mov		#17, r0
	lds		r0, mach
	mov		#18, r0
	ldc		r0, gbr

	; Also fill the flop registers with known values.
	lds		r1, fpul
	fsts	fpul, fr1
	lds		r2, fpul
	fsts	fpul, fr2
	lds		r3, fpul
	fsts	fpul, fr3
	lds		r4, fpul
	fsts	fpul, fr4
	lds		r5, fpul
	fsts	fpul, fr5
	lds		r6, fpul
	fsts	fpul, fr6
	lds		r7, fpul
	fsts	fpul, fr7
	lds		r8, fpul
	fsts	fpul, fr8
	lds		r9, fpul
	fsts	fpul, fr9
	lds		r10, fpul
	fsts	fpul, fr10
	lds		r11, fpul
	fsts	fpul, fr11
	lds		r12, fpul
	fsts	fpul, fr12
	lds		r13, fpul
	fsts	fpul, fr13
	lds		r14, fpul
	fsts	fpul, fr14
	
_vRegTest1Loop:

	; Reset r1 which was used in the tests.
	mov		#2, r1

	; Test that the registers still contain the expected values.  If not, jump to
	; vRegTestError, which will stop this function looping and so cause it to stop
	; incrementing its loop counter.  Both the standard and flop registers are 
	; checked.	
	mov		#2, r0
	cmp/eq	r0, r1
	bf		_vRegTest1Error
	flds	fr1, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error
	
	mov		#3, r0
	cmp/eq	r0, r2
	bf		_vRegTest1Error
	flds	fr2, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#4, r0
	cmp/eq	r0, r3
	bf		_vRegTest1Error
	flds	fr3, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#5, r0
	cmp/eq	r0, r4
	bf		_vRegTest1Error
	flds	fr4, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#6, r0
	cmp/eq	r0, r5
	bf		_vRegTest1Error
	flds	fr5, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#7, r0
	cmp/eq	r0, r6
	bf		_vRegTest1Error
	flds	fr6, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#8, r0
	cmp/eq	r0, r7
	bf		_vRegTest1Error
	flds	fr7, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#9, r0
	cmp/eq	r0, r8
	bf		_vRegTest1Error
	flds	fr8, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#10, r0
	cmp/eq	r0, r9
	bf		_vRegTest1Error
	flds	fr9, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#11, r0
	cmp/eq	r0, r10
	bf		_vRegTest1Error
	flds	fr10, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#12, r0
	cmp/eq	r0, r11
	bf		_vRegTest1Error
	flds	fr11, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#13, r0
	cmp/eq	r0, r12
	bf		_vRegTest1Error
	flds	fr12, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#14, r0
	cmp/eq	r0, r13
	bf		_vRegTest1Error
	flds	fr13, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	mov		#15, r0
	cmp/eq	r0, r14
	bf		_vRegTest1Error
	flds	fr14, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	sts		macl, r0
	mov		#16, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	sts		mach, r0
	mov		#17, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	stc		gbr, r0
	mov		#18, r1
	cmp/eq	r0, r1
	bf		_vRegTest1Error

	; Increment the loop counter to indicate that this task is still running and
	; still healthy.
	mov.l	#_ulRegTest1CycleCount, r0
	mov.l	@r0, r1
	add		#1, r1
	mov.l	r1, @r0

	; Jump back to test all the registers again.
	bra		_vRegTest1Loop
	nop

;-----------------------------------------------------------

_vRegTest1Error:
	bra		_vRegTest1Error	
	nop

;-----------------------------------------------------------

_vRegTest2Task:

	; Fill the standard registers with known values.
	mov		#12, r1
	mov		#13, r2
	mov		#14, r3
	mov		#15, r4
	mov		#16, r5
	mov		#17, r6
	mov		#18, r7
	mov		#19, r8
	mov		#110, r9
	mov		#111, r10
	mov		#112, r11
	mov		#113, r12
	mov		#114, r13

	mov		#115, r0
	lds		r0, macl
	mov		#116, r0
	lds		r0, mach
	mov		#117, r0
	ldc		r0, gbr
	
	; Also fill the flop registers with known values.
	lds		r1, fpul
	fsts	fpul, fr1
	lds		r2, fpul
	fsts	fpul, fr2
	lds		r3, fpul
	fsts	fpul, fr3
	lds		r4, fpul
	fsts	fpul, fr4
	lds		r5, fpul
	fsts	fpul, fr5
	lds		r6, fpul
	fsts	fpul, fr6
	lds		r7, fpul
	fsts	fpul, fr7
	lds		r8, fpul
	fsts	fpul, fr8
	lds		r9, fpul
	fsts	fpul, fr9
	lds		r10, fpul
	fsts	fpul, fr10
	lds		r11, fpul
	fsts	fpul, fr11
	lds		r12, fpul
	fsts	fpul, fr12
	lds		r13, fpul
	fsts	fpul, fr13
	lds		r14, fpul
	fsts	fpul, fr14

_vRegTest2Loop:

	; Reset r1 which was used in the tests.
	mov		#12, r1

	; Test that the registers still contain the expected values.  If not, jump to
	; vRegTestError, which will stop this function looping and so cause it to stop
	; incrementing its loop counter.  Both the standard and flop registers are 
	; checked.	
	mov		#12, r0
	cmp/eq	r0, r1
	bf		_vRegTest2Error
	flds	fr1, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error
	
	mov		#13, r0
	cmp/eq	r0, r2
	bf		_vRegTest2Error
	flds	fr2, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#14, r0
	cmp/eq	r0, r3
	bf		_vRegTest2Error
	flds	fr3, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#15, r0
	cmp/eq	r0, r4
	bf		_vRegTest2Error
	flds	fr4, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#16, r0
	cmp/eq	r0, r5
	bf		_vRegTest2Error
	flds	fr5, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#17, r0
	cmp/eq	r0, r6
	bf		_vRegTest2Error
	flds	fr6, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#18, r0
	cmp/eq	r0, r7
	bf		_vRegTest2Error
	flds	fr7, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#19, r0
	cmp/eq	r0, r8
	bf		_vRegTest2Error
	flds	fr8, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#110, r0
	cmp/eq	r0, r9
	bf		_vRegTest2Error
	flds	fr9, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#111, r0
	cmp/eq	r0, r10
	bf		_vRegTest2Error
	flds	fr10, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#112, r0
	cmp/eq	r0, r11
	bf		_vRegTest2Error
	flds	fr11, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#113, r0
	cmp/eq	r0, r12
	bf		_vRegTest2Error
	flds	fr12, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	mov		#114, r0
	cmp/eq	r0, r13
	bf		_vRegTest2Error
	flds	fr13, fpul
	sts		fpul, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	sts		macl, r0
	mov		#115, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	sts		mach, r0
	mov		#116, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	stc		gbr, r0
	mov		#117, r1
	cmp/eq	r0, r1
	bf		_vRegTest2Error

	; Increment the loop counter to indicate that this task is still running and
	; still healthy.
	mov.l	#_ulRegTest2CycleCount, r0
	mov.l	@r0, r1
	add		#1, r1
	mov.l	r1, @r0

	; Jump back to test all the registers again.
	bra		_vRegTest2Loop
	nop

;-----------------------------------------------------------

_vRegTest2Error:

	bra		_vRegTest2Error
	nop	


	.end
		
