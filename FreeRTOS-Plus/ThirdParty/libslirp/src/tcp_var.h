/* SPDX-License-Identifier: BSD-3-Clause */
/*
 * Copyright (c) 1982, 1986, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp_var.h	8.3 (Berkeley) 4/10/94
 * tcp_var.h,v 1.3 1994/08/21 05:27:39 paul Exp
 */

#ifndef TCP_VAR_H
#define TCP_VAR_H

#include "tcpip.h"
#include "tcp_timer.h"

/*
 * Tcp control block, one per tcp; fields:
 */
struct tcpcb {
    struct tcpiphdr *seg_next; /* sequencing queue */
    struct tcpiphdr *seg_prev;
    short t_state; /* state of this connection */
    short t_timer[TCPT_NTIMERS]; /* tcp timers */
    short t_rxtshift; /* log(2) of rexmt exp. backoff */
    short t_rxtcur; /* current retransmit value */
    short t_dupacks; /* consecutive dup acks recd */
    uint16_t t_maxseg; /* maximum segment size */
    uint8_t t_force; /* 1 if forcing out a byte */
    uint16_t t_flags;
#define TF_ACKNOW 0x0001 /* ack peer immediately */
#define TF_DELACK 0x0002 /* ack, but try to delay it */
#define TF_NODELAY 0x0004 /* don't delay packets to coalesce */
#define TF_NOOPT 0x0008 /* don't use tcp options */
#define TF_SENTFIN 0x0010 /* have sent FIN */
#define TF_REQ_SCALE 0x0020 /* have/will request window scaling */
#define TF_RCVD_SCALE 0x0040 /* other side has requested scaling */
#define TF_REQ_TSTMP 0x0080 /* have/will request timestamps */
#define TF_RCVD_TSTMP 0x0100 /* a timestamp was received in SYN */
#define TF_SACK_PERMIT 0x0200 /* other side said I could SACK */

    struct tcpiphdr t_template; /* static skeletal packet for xmit */

    struct socket *t_socket; /* back pointer to socket */
    /*
     * The following fields are used as in the protocol specification.
     * See RFC783, Dec. 1981, page 21.
     */
    /* send sequence variables */
    tcp_seq snd_una; /* send unacknowledged */
    tcp_seq snd_nxt; /* send next */
    tcp_seq snd_up; /* send urgent pointer */
    tcp_seq snd_wl1; /* window update seg seq number */
    tcp_seq snd_wl2; /* window update seg ack number */
    tcp_seq iss; /* initial send sequence number */
    uint32_t snd_wnd; /* send window */
    /* receive sequence variables */
    uint32_t rcv_wnd; /* receive window */
    tcp_seq rcv_nxt; /* receive next */
    tcp_seq rcv_up; /* receive urgent pointer */
    tcp_seq irs; /* initial receive sequence number */
    /*
     * Additional variables for this implementation.
     */
    /* receive variables */
    tcp_seq rcv_adv; /* advertised window */
    /* retransmit variables */
    tcp_seq snd_max; /* highest sequence number sent;
                      * used to recognize retransmits
                      */
    /* congestion control (for slow start, source quench, retransmit after loss)
     */
    uint32_t snd_cwnd; /* congestion-controlled window */
    uint32_t snd_ssthresh; /* snd_cwnd size threshold for
                            * for slow start exponential to
                            * linear switch
                            */
    /*
     * transmit timing stuff.  See below for scale of srtt and rttvar.
     * "Variance" is actually smoothed difference.
     */
    short t_idle; /* inactivity time */
    short t_rtt; /* round trip time */
    tcp_seq t_rtseq; /* sequence number being timed */
    short t_srtt; /* smoothed round-trip time */
    short t_rttvar; /* variance in round-trip time */
    uint16_t t_rttmin; /* minimum rtt allowed */
    uint32_t max_sndwnd; /* largest window peer has offered */

    /* out-of-band data */
    uint8_t t_oobflags; /* have some */
    uint8_t t_iobc; /* input character */
#define TCPOOB_HAVEDATA 0x01
#define TCPOOB_HADDATA 0x02
    short t_softerror; /* possible error not yet reported */

    /* RFC 1323 variables */
    uint8_t snd_scale; /* window scaling for send window */
    uint8_t rcv_scale; /* window scaling for recv window */
    uint8_t request_r_scale; /* pending window scaling */
    uint8_t requested_s_scale;
    uint32_t ts_recent; /* timestamp echo data */
    uint32_t ts_recent_age; /* when last updated */
    tcp_seq last_ack_sent;
};

#define sototcpcb(so) ((so)->so_tcpcb)

/*
 * The smoothed round-trip time and estimated variance
 * are stored as fixed point numbers scaled by the values below.
 * For convenience, these scales are also used in smoothing the average
 * (smoothed = (1/scale)sample + ((scale-1)/scale)smoothed).
 * With these scales, srtt has 3 bits to the right of the binary point,
 * and thus an "ALPHA" of 0.875.  rttvar has 2 bits to the right of the
 * binary point, and is smoothed with an ALPHA of 0.75.
 */
#define TCP_RTT_SCALE 8 /* multiplier for srtt; 3 bits frac. */
#define TCP_RTT_SHIFT 3 /* shift for srtt; 3 bits frac. */
#define TCP_RTTVAR_SCALE 4 /* multiplier for rttvar; 2 bits */
#define TCP_RTTVAR_SHIFT 2 /* multiplier for rttvar; 2 bits */

/*
 * The initial retransmission should happen at rtt + 4 * rttvar.
 * Because of the way we do the smoothing, srtt and rttvar
 * will each average +1/2 tick of bias.  When we compute
 * the retransmit timer, we want 1/2 tick of rounding and
 * 1 extra tick because of +-1/2 tick uncertainty in the
 * firing of the timer.  The bias will give us exactly the
 * 1.5 tick we need.  But, because the bias is
 * statistical, we have to test that we don't drop below
 * the minimum feasible timer (which is 2 ticks).
 * This macro assumes that the value of TCP_RTTVAR_SCALE
 * is the same as the multiplier for rttvar.
 */
#define TCP_REXMTVAL(tp) (((tp)->t_srtt >> TCP_RTT_SHIFT) + (tp)->t_rttvar)

#endif
